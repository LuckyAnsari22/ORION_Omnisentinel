function bX(n,t){for(var e=0;e<t.length;e++){const s=t[e];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const i=Object.getOwnPropertyDescriptor(s,r);i&&Object.defineProperty(n,r,i.get?i:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function e(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=e(r);fetch(r.href,i)}})();var BB=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function xX(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function wX(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var t=n.default;if(typeof t=="function"){var e=function s(){var r=!1;try{r=this instanceof s}catch{}return r?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};e.prototype=t.prototype}else e={};return Object.defineProperty(e,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(e,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}),e}var _T={exports:{}},Hm={};var cF;function vX(){if(cF)return Hm;cF=1;var n=Symbol.for("react.transitional.element"),t=Symbol.for("react.fragment");function e(s,r,i){var o=null;if(i!==void 0&&(o=""+i),r.key!==void 0&&(o=""+r.key),"key"in r){i={};for(var a in r)a!=="key"&&(i[a]=r[a])}else i=r;return r=i.ref,{$$typeof:n,type:s,key:o,ref:r!==void 0?r:null,props:i}}return Hm.Fragment=t,Hm.jsx=e,Hm.jsxs=e,Hm}var hF;function SX(){return hF||(hF=1,_T.exports=vX()),_T.exports}var Pt=SX(),NT={exports:{}};function IX(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var PB={exports:{}},_s=PB.exports={},Va,Ua;function kE(){throw new Error("setTimeout has not been defined")}function _E(){throw new Error("clearTimeout has not been defined")}(function(){try{typeof setTimeout=="function"?Va=setTimeout:Va=kE}catch{Va=kE}try{typeof clearTimeout=="function"?Ua=clearTimeout:Ua=_E}catch{Ua=_E}})();function VB(n){if(Va===setTimeout)return setTimeout(n,0);if((Va===kE||!Va)&&setTimeout)return Va=setTimeout,setTimeout(n,0);try{return Va(n,0)}catch{try{return Va.call(null,n,0)}catch{return Va.call(this,n,0)}}}function TX(n){if(Ua===clearTimeout)return clearTimeout(n);if((Ua===_E||!Ua)&&clearTimeout)return Ua=clearTimeout,clearTimeout(n);try{return Ua(n)}catch{try{return Ua.call(null,n)}catch{return Ua.call(this,n)}}}var Wl=[],Rd=!1,Sh,O1=-1;function CX(){!Rd||!Sh||(Rd=!1,Sh.length?Wl=Sh.concat(Wl):O1=-1,Wl.length&&UB())}function UB(){if(!Rd){var n=VB(CX);Rd=!0;for(var t=Wl.length;t;){for(Sh=Wl,Wl=[];++O1<t;)Sh&&Sh[O1].run();O1=-1,t=Wl.length}Sh=null,Rd=!1,TX(n)}}_s.nextTick=function(n){var t=new Array(arguments.length-1);if(arguments.length>1)for(var e=1;e<arguments.length;e++)t[e-1]=arguments[e];Wl.push(new GB(n,t)),Wl.length===1&&!Rd&&VB(UB)};function GB(n,t){this.fun=n,this.array=t}GB.prototype.run=function(){this.fun.apply(null,this.array)};_s.title="browser";_s.browser=!0;_s.env={};_s.argv=[];_s.version="";_s.versions={};function ru(){}_s.on=ru;_s.addListener=ru;_s.once=ru;_s.off=ru;_s.removeListener=ru;_s.removeAllListeners=ru;_s.emit=ru;_s.prependListener=ru;_s.prependOnceListener=ru;_s.listeners=function(n){return[]};_s.binding=function(n){throw new Error("process.binding is not supported")};_s.cwd=function(){return"/"};_s.chdir=function(n){throw new Error("process.chdir is not supported")};_s.umask=function(){return 0};var EX=PB.exports;const Un=IX(EX);var _e={},fF;function $X(){if(fF)return _e;fF=1;var n=Symbol.for("react.transitional.element"),t=Symbol.for("react.portal"),e=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),i=Symbol.for("react.consumer"),o=Symbol.for("react.context"),a=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),c=Symbol.for("react.memo"),f=Symbol.for("react.lazy"),d=Symbol.for("react.activity"),m=Symbol.iterator;function y(q){return q===null||typeof q!="object"?null:(q=m&&q[m]||q["@@iterator"],typeof q=="function"?q:null)}var b={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},w=Object.assign,x={};function S(q,et,U){this.props=q,this.context=et,this.refs=x,this.updater=U||b}S.prototype.isReactComponent={},S.prototype.setState=function(q,et){if(typeof q!="object"&&typeof q!="function"&&q!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,q,et,"setState")},S.prototype.forceUpdate=function(q){this.updater.enqueueForceUpdate(this,q,"forceUpdate")};function T(){}T.prototype=S.prototype;function $(q,et,U){this.props=q,this.context=et,this.refs=x,this.updater=U||b}var E=$.prototype=new T;E.constructor=$,w(E,S.prototype),E.isPureReactComponent=!0;var R=Array.isArray;function B(){}var N={H:null,A:null,T:null,S:null},k=Object.prototype.hasOwnProperty;function _(q,et,U){var X=U.ref;return{$$typeof:n,type:q,key:et,ref:X!==void 0?X:null,props:U}}function F(q,et){return _(q.type,et,q.props)}function A(q){return typeof q=="object"&&q!==null&&q.$$typeof===n}function P(q){var et={"=":"=0",":":"=2"};return"$"+q.replace(/[=:]/g,function(U){return et[U]})}var L=/\/+/g;function tt(q,et){return typeof q=="object"&&q!==null&&q.key!=null?P(""+q.key):et.toString(36)}function st(q){switch(q.status){case"fulfilled":return q.value;case"rejected":throw q.reason;default:switch(typeof q.status=="string"?q.then(B,B):(q.status="pending",q.then(function(et){q.status==="pending"&&(q.status="fulfilled",q.value=et)},function(et){q.status==="pending"&&(q.status="rejected",q.reason=et)})),q.status){case"fulfilled":return q.value;case"rejected":throw q.reason}}throw q}function j(q,et,U,X,nt){var xt=typeof q;(xt==="undefined"||xt==="boolean")&&(q=null);var Ot=!1;if(q===null)Ot=!0;else switch(xt){case"bigint":case"string":case"number":Ot=!0;break;case"object":switch(q.$$typeof){case n:case t:Ot=!0;break;case f:return Ot=q._init,j(Ot(q._payload),et,U,X,nt)}}if(Ot)return nt=nt(q),Ot=X===""?"."+tt(q,0):X,R(nt)?(U="",Ot!=null&&(U=Ot.replace(L,"$&/")+"/"),j(nt,et,U,"",function(Wt){return Wt})):nt!=null&&(A(nt)&&(nt=F(nt,U+(nt.key==null||q&&q.key===nt.key?"":(""+nt.key).replace(L,"$&/")+"/")+Ot)),et.push(nt)),1;Ot=0;var qt=X===""?".":X+":";if(R(q))for(var zt=0;zt<q.length;zt++)X=q[zt],xt=qt+tt(X,zt),Ot+=j(X,et,U,xt,nt);else if(zt=y(q),typeof zt=="function")for(q=zt.call(q),zt=0;!(X=q.next()).done;)X=X.value,xt=qt+tt(X,zt++),Ot+=j(X,et,U,xt,nt);else if(xt==="object"){if(typeof q.then=="function")return j(st(q),et,U,X,nt);throw et=String(q),Error("Objects are not valid as a React child (found: "+(et==="[object Object]"?"object with keys {"+Object.keys(q).join(", ")+"}":et)+"). If you meant to render a collection of children, use an array instead.")}return Ot}function Z(q,et,U){if(q==null)return q;var X=[],nt=0;return j(q,X,"","",function(xt){return et.call(U,xt,nt++)}),X}function J(q){if(q._status===-1){var et=q._result;et=et(),et.then(function(U){(q._status===0||q._status===-1)&&(q._status=1,q._result=U)},function(U){(q._status===0||q._status===-1)&&(q._status=2,q._result=U)}),q._status===-1&&(q._status=0,q._result=et)}if(q._status===1)return q._result.default;throw q._result}var ot=typeof reportError=="function"?reportError:function(q){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var et=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof q=="object"&&q!==null&&typeof q.message=="string"?String(q.message):String(q),error:q});if(!window.dispatchEvent(et))return}else if(typeof Un=="object"&&typeof Un.emit=="function"){Un.emit("uncaughtException",q);return}console.error(q)},pt={map:Z,forEach:function(q,et,U){Z(q,function(){et.apply(this,arguments)},U)},count:function(q){var et=0;return Z(q,function(){et++}),et},toArray:function(q){return Z(q,function(et){return et})||[]},only:function(q){if(!A(q))throw Error("React.Children.only expected to receive a single React element child.");return q}};return _e.Activity=d,_e.Children=pt,_e.Component=S,_e.Fragment=e,_e.Profiler=r,_e.PureComponent=$,_e.StrictMode=s,_e.Suspense=l,_e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=N,_e.__COMPILER_RUNTIME={__proto__:null,c:function(q){return N.H.useMemoCache(q)}},_e.cache=function(q){return function(){return q.apply(null,arguments)}},_e.cacheSignal=function(){return null},_e.cloneElement=function(q,et,U){if(q==null)throw Error("The argument must be a React element, but you passed "+q+".");var X=w({},q.props),nt=q.key;if(et!=null)for(xt in et.key!==void 0&&(nt=""+et.key),et)!k.call(et,xt)||xt==="key"||xt==="__self"||xt==="__source"||xt==="ref"&&et.ref===void 0||(X[xt]=et[xt]);var xt=arguments.length-2;if(xt===1)X.children=U;else if(1<xt){for(var Ot=Array(xt),qt=0;qt<xt;qt++)Ot[qt]=arguments[qt+2];X.children=Ot}return _(q.type,nt,X)},_e.createContext=function(q){return q={$$typeof:o,_currentValue:q,_currentValue2:q,_threadCount:0,Provider:null,Consumer:null},q.Provider=q,q.Consumer={$$typeof:i,_context:q},q},_e.createElement=function(q,et,U){var X,nt={},xt=null;if(et!=null)for(X in et.key!==void 0&&(xt=""+et.key),et)k.call(et,X)&&X!=="key"&&X!=="__self"&&X!=="__source"&&(nt[X]=et[X]);var Ot=arguments.length-2;if(Ot===1)nt.children=U;else if(1<Ot){for(var qt=Array(Ot),zt=0;zt<Ot;zt++)qt[zt]=arguments[zt+2];nt.children=qt}if(q&&q.defaultProps)for(X in Ot=q.defaultProps,Ot)nt[X]===void 0&&(nt[X]=Ot[X]);return _(q,xt,nt)},_e.createRef=function(){return{current:null}},_e.forwardRef=function(q){return{$$typeof:a,render:q}},_e.isValidElement=A,_e.lazy=function(q){return{$$typeof:f,_payload:{_status:-1,_result:q},_init:J}},_e.memo=function(q,et){return{$$typeof:c,type:q,compare:et===void 0?null:et}},_e.startTransition=function(q){var et=N.T,U={};N.T=U;try{var X=q(),nt=N.S;nt!==null&&nt(U,X),typeof X=="object"&&X!==null&&typeof X.then=="function"&&X.then(B,ot)}catch(xt){ot(xt)}finally{et!==null&&U.types!==null&&(et.types=U.types),N.T=et}},_e.unstable_useCacheRefresh=function(){return N.H.useCacheRefresh()},_e.use=function(q){return N.H.use(q)},_e.useActionState=function(q,et,U){return N.H.useActionState(q,et,U)},_e.useCallback=function(q,et){return N.H.useCallback(q,et)},_e.useContext=function(q){return N.H.useContext(q)},_e.useDebugValue=function(){},_e.useDeferredValue=function(q,et){return N.H.useDeferredValue(q,et)},_e.useEffect=function(q,et){return N.H.useEffect(q,et)},_e.useEffectEvent=function(q){return N.H.useEffectEvent(q)},_e.useId=function(){return N.H.useId()},_e.useImperativeHandle=function(q,et,U){return N.H.useImperativeHandle(q,et,U)},_e.useInsertionEffect=function(q,et){return N.H.useInsertionEffect(q,et)},_e.useLayoutEffect=function(q,et){return N.H.useLayoutEffect(q,et)},_e.useMemo=function(q,et){return N.H.useMemo(q,et)},_e.useOptimistic=function(q,et){return N.H.useOptimistic(q,et)},_e.useReducer=function(q,et,U){return N.H.useReducer(q,et,U)},_e.useRef=function(q){return N.H.useRef(q)},_e.useState=function(q){return N.H.useState(q)},_e.useSyncExternalStore=function(q,et,U){return N.H.useSyncExternalStore(q,et,U)},_e.useTransition=function(){return N.H.useTransition()},_e.version="19.2.3",_e}var dF;function f2(){return dF||(dF=1,NT.exports=$X()),NT.exports}var Vr=f2(),RT={exports:{}},Km={},DT={exports:{}},OT={};var pF;function AX(){return pF||(pF=1,(function(n){function t(j,Z){var J=j.length;j.push(Z);t:for(;0<J;){var ot=J-1>>>1,pt=j[ot];if(0<r(pt,Z))j[ot]=Z,j[J]=pt,J=ot;else break t}}function e(j){return j.length===0?null:j[0]}function s(j){if(j.length===0)return null;var Z=j[0],J=j.pop();if(J!==Z){j[0]=J;t:for(var ot=0,pt=j.length,q=pt>>>1;ot<q;){var et=2*(ot+1)-1,U=j[et],X=et+1,nt=j[X];if(0>r(U,J))X<pt&&0>r(nt,U)?(j[ot]=nt,j[X]=J,ot=X):(j[ot]=U,j[et]=J,ot=et);else if(X<pt&&0>r(nt,J))j[ot]=nt,j[X]=J,ot=X;else break t}}return Z}function r(j,Z){var J=j.sortIndex-Z.sortIndex;return J!==0?J:j.id-Z.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var i=performance;n.unstable_now=function(){return i.now()}}else{var o=Date,a=o.now();n.unstable_now=function(){return o.now()-a}}var l=[],c=[],f=1,d=null,m=3,y=!1,b=!1,w=!1,x=!1,S=typeof setTimeout=="function"?setTimeout:null,T=typeof clearTimeout=="function"?clearTimeout:null,$=typeof setImmediate<"u"?setImmediate:null;function E(j){for(var Z=e(c);Z!==null;){if(Z.callback===null)s(c);else if(Z.startTime<=j)s(c),Z.sortIndex=Z.expirationTime,t(l,Z);else break;Z=e(c)}}function R(j){if(w=!1,E(j),!b)if(e(l)!==null)b=!0,B||(B=!0,P());else{var Z=e(c);Z!==null&&st(R,Z.startTime-j)}}var B=!1,N=-1,k=5,_=-1;function F(){return x?!0:!(n.unstable_now()-_<k)}function A(){if(x=!1,B){var j=n.unstable_now();_=j;var Z=!0;try{t:{b=!1,w&&(w=!1,T(N),N=-1),y=!0;var J=m;try{e:{for(E(j),d=e(l);d!==null&&!(d.expirationTime>j&&F());){var ot=d.callback;if(typeof ot=="function"){d.callback=null,m=d.priorityLevel;var pt=ot(d.expirationTime<=j);if(j=n.unstable_now(),typeof pt=="function"){d.callback=pt,E(j),Z=!0;break e}d===e(l)&&s(l),E(j)}else s(l);d=e(l)}if(d!==null)Z=!0;else{var q=e(c);q!==null&&st(R,q.startTime-j),Z=!1}}break t}finally{d=null,m=J,y=!1}Z=void 0}}finally{Z?P():B=!1}}}var P;if(typeof $=="function")P=function(){$(A)};else if(typeof MessageChannel<"u"){var L=new MessageChannel,tt=L.port2;L.port1.onmessage=A,P=function(){tt.postMessage(null)}}else P=function(){S(A,0)};function st(j,Z){N=S(function(){j(n.unstable_now())},Z)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(j){j.callback=null},n.unstable_forceFrameRate=function(j){0>j||125<j?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):k=0<j?Math.floor(1e3/j):5},n.unstable_getCurrentPriorityLevel=function(){return m},n.unstable_next=function(j){switch(m){case 1:case 2:case 3:var Z=3;break;default:Z=m}var J=m;m=Z;try{return j()}finally{m=J}},n.unstable_requestPaint=function(){x=!0},n.unstable_runWithPriority=function(j,Z){switch(j){case 1:case 2:case 3:case 4:case 5:break;default:j=3}var J=m;m=j;try{return Z()}finally{m=J}},n.unstable_scheduleCallback=function(j,Z,J){var ot=n.unstable_now();switch(typeof J=="object"&&J!==null?(J=J.delay,J=typeof J=="number"&&0<J?ot+J:ot):J=ot,j){case 1:var pt=-1;break;case 2:pt=250;break;case 5:pt=1073741823;break;case 4:pt=1e4;break;default:pt=5e3}return pt=J+pt,j={id:f++,callback:Z,priorityLevel:j,startTime:J,expirationTime:pt,sortIndex:-1},J>ot?(j.sortIndex=J,t(c,j),e(l)===null&&j===e(c)&&(w?(T(N),N=-1):w=!0,st(R,J-ot))):(j.sortIndex=pt,t(l,j),b||y||(b=!0,B||(B=!0,P()))),j},n.unstable_shouldYield=F,n.unstable_wrapCallback=function(j){var Z=m;return function(){var J=m;m=Z;try{return j.apply(this,arguments)}finally{m=J}}}})(OT)),OT}var mF;function kX(){return mF||(mF=1,DT.exports=AX()),DT.exports}var FT={exports:{}},Br={};var gF;function _X(){if(gF)return Br;gF=1;var n=f2();function t(l){var c="https://react.dev/errors/"+l;if(1<arguments.length){c+="?args[]="+encodeURIComponent(arguments[1]);for(var f=2;f<arguments.length;f++)c+="&args[]="+encodeURIComponent(arguments[f])}return"Minified React error #"+l+"; visit "+c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function e(){}var s={d:{f:e,r:function(){throw Error(t(522))},D:e,C:e,L:e,m:e,X:e,S:e,M:e},p:0,findDOMNode:null},r=Symbol.for("react.portal");function i(l,c,f){var d=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:r,key:d==null?null:""+d,children:l,containerInfo:c,implementation:f}}var o=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function a(l,c){if(l==="font")return"";if(typeof c=="string")return c==="use-credentials"?c:""}return Br.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,Br.createPortal=function(l,c){var f=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!c||c.nodeType!==1&&c.nodeType!==9&&c.nodeType!==11)throw Error(t(299));return i(l,c,null,f)},Br.flushSync=function(l){var c=o.T,f=s.p;try{if(o.T=null,s.p=2,l)return l()}finally{o.T=c,s.p=f,s.d.f()}},Br.preconnect=function(l,c){typeof l=="string"&&(c?(c=c.crossOrigin,c=typeof c=="string"?c==="use-credentials"?c:"":void 0):c=null,s.d.C(l,c))},Br.prefetchDNS=function(l){typeof l=="string"&&s.d.D(l)},Br.preinit=function(l,c){if(typeof l=="string"&&c&&typeof c.as=="string"){var f=c.as,d=a(f,c.crossOrigin),m=typeof c.integrity=="string"?c.integrity:void 0,y=typeof c.fetchPriority=="string"?c.fetchPriority:void 0;f==="style"?s.d.S(l,typeof c.precedence=="string"?c.precedence:void 0,{crossOrigin:d,integrity:m,fetchPriority:y}):f==="script"&&s.d.X(l,{crossOrigin:d,integrity:m,fetchPriority:y,nonce:typeof c.nonce=="string"?c.nonce:void 0})}},Br.preinitModule=function(l,c){if(typeof l=="string")if(typeof c=="object"&&c!==null){if(c.as==null||c.as==="script"){var f=a(c.as,c.crossOrigin);s.d.M(l,{crossOrigin:f,integrity:typeof c.integrity=="string"?c.integrity:void 0,nonce:typeof c.nonce=="string"?c.nonce:void 0})}}else c==null&&s.d.M(l)},Br.preload=function(l,c){if(typeof l=="string"&&typeof c=="object"&&c!==null&&typeof c.as=="string"){var f=c.as,d=a(f,c.crossOrigin);s.d.L(l,f,{crossOrigin:d,integrity:typeof c.integrity=="string"?c.integrity:void 0,nonce:typeof c.nonce=="string"?c.nonce:void 0,type:typeof c.type=="string"?c.type:void 0,fetchPriority:typeof c.fetchPriority=="string"?c.fetchPriority:void 0,referrerPolicy:typeof c.referrerPolicy=="string"?c.referrerPolicy:void 0,imageSrcSet:typeof c.imageSrcSet=="string"?c.imageSrcSet:void 0,imageSizes:typeof c.imageSizes=="string"?c.imageSizes:void 0,media:typeof c.media=="string"?c.media:void 0})}},Br.preloadModule=function(l,c){if(typeof l=="string")if(c){var f=a(c.as,c.crossOrigin);s.d.m(l,{as:typeof c.as=="string"&&c.as!=="script"?c.as:void 0,crossOrigin:f,integrity:typeof c.integrity=="string"?c.integrity:void 0})}else s.d.m(l)},Br.requestFormReset=function(l){s.d.r(l)},Br.unstable_batchedUpdates=function(l,c){return l(c)},Br.useFormState=function(l,c,f){return o.H.useFormState(l,c,f)},Br.useFormStatus=function(){return o.H.useHostTransitionStatus()},Br.version="19.2.3",Br}var yF;function NX(){if(yF)return FT.exports;yF=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(t){console.error(t)}}return n(),FT.exports=_X(),FT.exports}var bF;function RX(){if(bF)return Km;bF=1;var n=kX(),t=f2(),e=NX();function s(u){var h="https://react.dev/errors/"+u;if(1<arguments.length){h+="?args[]="+encodeURIComponent(arguments[1]);for(var p=2;p<arguments.length;p++)h+="&args[]="+encodeURIComponent(arguments[p])}return"Minified React error #"+u+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(u){return!(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11)}function i(u){var h=u,p=u;if(u.alternate)for(;h.return;)h=h.return;else{u=h;do h=u,(h.flags&4098)!==0&&(p=h.return),u=h.return;while(u)}return h.tag===3?p:null}function o(u){if(u.tag===13){var h=u.memoizedState;if(h===null&&(u=u.alternate,u!==null&&(h=u.memoizedState)),h!==null)return h.dehydrated}return null}function a(u){if(u.tag===31){var h=u.memoizedState;if(h===null&&(u=u.alternate,u!==null&&(h=u.memoizedState)),h!==null)return h.dehydrated}return null}function l(u){if(i(u)!==u)throw Error(s(188))}function c(u){var h=u.alternate;if(!h){if(h=i(u),h===null)throw Error(s(188));return h!==u?null:u}for(var p=u,g=h;;){var I=p.return;if(I===null)break;var C=I.alternate;if(C===null){if(g=I.return,g!==null){p=g;continue}break}if(I.child===C.child){for(C=I.child;C;){if(C===p)return l(I),u;if(C===g)return l(I),h;C=C.sibling}throw Error(s(188))}if(p.return!==g.return)p=I,g=C;else{for(var z=!1,W=I.child;W;){if(W===p){z=!0,p=I,g=C;break}if(W===g){z=!0,g=I,p=C;break}W=W.sibling}if(!z){for(W=C.child;W;){if(W===p){z=!0,p=C,g=I;break}if(W===g){z=!0,g=C,p=I;break}W=W.sibling}if(!z)throw Error(s(189))}}if(p.alternate!==g)throw Error(s(190))}if(p.tag!==3)throw Error(s(188));return p.stateNode.current===p?u:h}function f(u){var h=u.tag;if(h===5||h===26||h===27||h===6)return u;for(u=u.child;u!==null;){if(h=f(u),h!==null)return h;u=u.sibling}return null}var d=Object.assign,m=Symbol.for("react.element"),y=Symbol.for("react.transitional.element"),b=Symbol.for("react.portal"),w=Symbol.for("react.fragment"),x=Symbol.for("react.strict_mode"),S=Symbol.for("react.profiler"),T=Symbol.for("react.consumer"),$=Symbol.for("react.context"),E=Symbol.for("react.forward_ref"),R=Symbol.for("react.suspense"),B=Symbol.for("react.suspense_list"),N=Symbol.for("react.memo"),k=Symbol.for("react.lazy"),_=Symbol.for("react.activity"),F=Symbol.for("react.memo_cache_sentinel"),A=Symbol.iterator;function P(u){return u===null||typeof u!="object"?null:(u=A&&u[A]||u["@@iterator"],typeof u=="function"?u:null)}var L=Symbol.for("react.client.reference");function tt(u){if(u==null)return null;if(typeof u=="function")return u.$$typeof===L?null:u.displayName||u.name||null;if(typeof u=="string")return u;switch(u){case w:return"Fragment";case S:return"Profiler";case x:return"StrictMode";case R:return"Suspense";case B:return"SuspenseList";case _:return"Activity"}if(typeof u=="object")switch(u.$$typeof){case b:return"Portal";case $:return u.displayName||"Context";case T:return(u._context.displayName||"Context")+".Consumer";case E:var h=u.render;return u=u.displayName,u||(u=h.displayName||h.name||"",u=u!==""?"ForwardRef("+u+")":"ForwardRef"),u;case N:return h=u.displayName||null,h!==null?h:tt(u.type)||"Memo";case k:h=u._payload,u=u._init;try{return tt(u(h))}catch{}}return null}var st=Array.isArray,j=t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,Z=e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,J={pending:!1,data:null,method:null,action:null},ot=[],pt=-1;function q(u){return{current:u}}function et(u){0>pt||(u.current=ot[pt],ot[pt]=null,pt--)}function U(u,h){pt++,ot[pt]=u.current,u.current=h}var X=q(null),nt=q(null),xt=q(null),Ot=q(null);function qt(u,h){switch(U(xt,h),U(nt,u),U(X,null),h.nodeType){case 9:case 11:u=(u=h.documentElement)&&(u=u.namespaceURI)?DO(u):0;break;default:if(u=h.tagName,h=h.namespaceURI)h=DO(h),u=OO(h,u);else switch(u){case"svg":u=1;break;case"math":u=2;break;default:u=0}}et(X),U(X,u)}function zt(){et(X),et(nt),et(xt)}function Wt(u){u.memoizedState!==null&&U(Ot,u);var h=X.current,p=OO(h,u.type);h!==p&&(U(nt,u),U(X,p))}function Xt(u){nt.current===u&&(et(X),et(nt)),Ot.current===u&&(et(Ot),Gm._currentValue=J)}var te,oe;function fe(u){if(te===void 0)try{throw Error()}catch(p){var h=p.stack.trim().match(/\n( *(at )?)/);te=h&&h[1]||"",oe=-1<p.stack.indexOf(`
    at`)?" (<anonymous>)":-1<p.stack.indexOf("@")?"@unknown:0:0":""}return`
`+te+u+oe}var pe=!1;function ie(u,h){if(!u||pe)return"";pe=!0;var p=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var g={DetermineComponentFrameRoot:function(){try{if(h){var Ut=function(){throw Error()};if(Object.defineProperty(Ut.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Ut,[])}catch(Rt){var $t=Rt}Reflect.construct(u,[],Ut)}else{try{Ut.call()}catch(Rt){$t=Rt}u.call(Ut.prototype)}}else{try{throw Error()}catch(Rt){$t=Rt}(Ut=u())&&typeof Ut.catch=="function"&&Ut.catch(function(){})}}catch(Rt){if(Rt&&$t&&typeof Rt.stack=="string")return[Rt.stack,$t.stack]}return[null,null]}};g.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var I=Object.getOwnPropertyDescriptor(g.DetermineComponentFrameRoot,"name");I&&I.configurable&&Object.defineProperty(g.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var C=g.DetermineComponentFrameRoot(),z=C[0],W=C[1];if(z&&W){var it=z.split(`
`),Tt=W.split(`
`);for(I=g=0;g<it.length&&!it[g].includes("DetermineComponentFrameRoot");)g++;for(;I<Tt.length&&!Tt[I].includes("DetermineComponentFrameRoot");)I++;if(g===it.length||I===Tt.length)for(g=it.length-1,I=Tt.length-1;1<=g&&0<=I&&it[g]!==Tt[I];)I--;for(;1<=g&&0<=I;g--,I--)if(it[g]!==Tt[I]){if(g!==1||I!==1)do if(g--,I--,0>I||it[g]!==Tt[I]){var Bt=`
`+it[g].replace(" at new "," at ");return u.displayName&&Bt.includes("<anonymous>")&&(Bt=Bt.replace("<anonymous>",u.displayName)),Bt}while(1<=g&&0<=I);break}}}finally{pe=!1,Error.prepareStackTrace=p}return(p=u?u.displayName||u.name:"")?fe(p):""}function Ae(u,h){switch(u.tag){case 26:case 27:case 5:return fe(u.type);case 16:return fe("Lazy");case 13:return u.child!==h&&h!==null?fe("Suspense Fallback"):fe("Suspense");case 19:return fe("SuspenseList");case 0:case 15:return ie(u.type,!1);case 11:return ie(u.type.render,!1);case 1:return ie(u.type,!0);case 31:return fe("Activity");default:return""}}function Ge(u){try{var h="",p=null;do h+=Ae(u,p),p=u,u=u.return;while(u);return h}catch(g){return`
Error generating stack: `+g.message+`
`+g.stack}}var Nt=Object.prototype.hasOwnProperty,Ie=n.unstable_scheduleCallback,wn=n.unstable_cancelCallback,rs=n.unstable_shouldYield,Ns=n.unstable_requestPaint,je=n.unstable_now,Nn=n.unstable_getCurrentPriorityLevel,cr=n.unstable_ImmediatePriority,zr=n.unstable_UserBlockingPriority,Wn=n.unstable_NormalPriority,No=n.unstable_LowPriority,G=n.unstable_IdlePriority,O=n.log,M=n.unstable_setDisableYieldValue,Y=null,at=null;function Ct(u){if(typeof O=="function"&&M(u),at&&typeof at.setStrictMode=="function")try{at.setStrictMode(Y,u)}catch{}}var Mt=Math.clz32?Math.clz32:En,Oe=Math.log,Cn=Math.LN2;function En(u){return u>>>=0,u===0?32:31-(Oe(u)/Cn|0)|0}var un=256,Je=262144,Rs=4194304;function ba(u){var h=u&42;if(h!==0)return h;switch(u&-u){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return u&261888;case 262144:case 524288:case 1048576:case 2097152:return u&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return u&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return u}}function xa(u,h,p){var g=u.pendingLanes;if(g===0)return 0;var I=0,C=u.suspendedLanes,z=u.pingedLanes;u=u.warmLanes;var W=g&134217727;return W!==0?(g=W&~C,g!==0?I=ba(g):(z&=W,z!==0?I=ba(z):p||(p=W&~u,p!==0&&(I=ba(p))))):(W=g&~C,W!==0?I=ba(W):z!==0?I=ba(z):p||(p=g&~u,p!==0&&(I=ba(p)))),I===0?0:h!==0&&h!==I&&(h&C)===0&&(C=I&-I,p=h&-h,C>=p||C===32&&(p&4194048)!==0)?h:I}function Ro(u,h){return(u.pendingLanes&~(u.suspendedLanes&~u.pingedLanes)&h)===0}function OS(u,h){switch(u){case 1:case 2:case 4:case 8:case 64:return h+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return h+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Bb(){var u=Rs;return Rs<<=1,(Rs&62914560)===0&&(Rs=4194304),u}function wa(u){for(var h=[],p=0;31>p;p++)h.push(u);return h}function Bc(u,h){u.pendingLanes|=h,h!==268435456&&(u.suspendedLanes=0,u.pingedLanes=0,u.warmLanes=0)}function FS(u,h,p,g,I,C){var z=u.pendingLanes;u.pendingLanes=p,u.suspendedLanes=0,u.pingedLanes=0,u.warmLanes=0,u.expiredLanes&=p,u.entangledLanes&=p,u.errorRecoveryDisabledLanes&=p,u.shellSuspendCounter=0;var W=u.entanglements,it=u.expirationTimes,Tt=u.hiddenUpdates;for(p=z&~p;0<p;){var Bt=31-Mt(p),Ut=1<<Bt;W[Bt]=0,it[Bt]=-1;var $t=Tt[Bt];if($t!==null)for(Tt[Bt]=null,Bt=0;Bt<$t.length;Bt++){var Rt=$t[Bt];Rt!==null&&(Rt.lane&=-536870913)}p&=~Ut}g!==0&&Pc(u,g,0),C!==0&&I===0&&u.tag!==0&&(u.suspendedLanes|=C&~(z&~h))}function Pc(u,h,p){u.pendingLanes|=h,u.suspendedLanes&=~h;var g=31-Mt(h);u.entangledLanes|=h,u.entanglements[g]=u.entanglements[g]|1073741824|p&261930}function Kp(u,h){var p=u.entangledLanes|=h;for(u=u.entanglements;p;){var g=31-Mt(p),I=1<<g;I&h|u[g]&h&&(u[g]|=h),p&=~I}}function Xp(u,h){var p=h&-h;return p=(p&42)!==0?1:Vc(p),(p&(u.suspendedLanes|h))!==0?0:p}function Vc(u){switch(u){case 2:u=1;break;case 8:u=4;break;case 32:u=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:u=128;break;case 268435456:u=134217728;break;default:u=0}return u}function vl(u){return u&=-u,2<u?8<u?(u&134217727)!==0?32:268435456:8:2}function Pb(){var u=Z.p;return u!==0?u:(u=window.event,u===void 0?32:sF(u.type))}function Do(u,h){var p=Z.p;try{return Z.p=u,h()}finally{Z.p=p}}var Oo=Math.random().toString(36).slice(2),Ds="__reactFiber$"+Oo,hr="__reactProps$"+Oo,va="__reactContainer$"+Oo,$f="__reactEvents$"+Oo,MS="__reactListeners$"+Oo,Vb="__reactHandles$"+Oo,Ub="__reactResources$"+Oo,Sa="__reactMarker$"+Oo;function Af(u){delete u[Ds],delete u[hr],delete u[$f],delete u[MS],delete u[Vb]}function Ia(u){var h=u[Ds];if(h)return h;for(var p=u.parentNode;p;){if(h=p[va]||p[Ds]){if(p=h.alternate,h.child!==null||p!==null&&p.child!==null)for(u=VO(u);u!==null;){if(p=u[Ds])return p;u=VO(u)}return h}u=p,p=u.parentNode}return null}function Qi(u){if(u=u[Ds]||u[va]){var h=u.tag;if(h===5||h===6||h===13||h===31||h===26||h===27||h===3)return u}return null}function Ri(u){var h=u.tag;if(h===5||h===26||h===27||h===6)return u.stateNode;throw Error(s(33))}function Ta(u){var h=u[Ub];return h||(h=u[Ub]={hoistableStyles:new Map,hoistableScripts:new Map}),h}function Os(u){u[Sa]=!0}var Yp=new Set,Qp={};function Ca(u,h){Ea(u,h),Ea(u+"Capture",h)}function Ea(u,h){for(Qp[u]=h,u=0;u<h.length;u++)Yp.add(h[u])}var Zp=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),Jp={},tm={};function Gb(u){return Nt.call(tm,u)?!0:Nt.call(Jp,u)?!1:Zp.test(u)?tm[u]=!0:(Jp[u]=!0,!1)}function kf(u,h,p){if(Gb(h))if(p===null)u.removeAttribute(h);else{switch(typeof p){case"undefined":case"function":case"symbol":u.removeAttribute(h);return;case"boolean":var g=h.toLowerCase().slice(0,5);if(g!=="data-"&&g!=="aria-"){u.removeAttribute(h);return}}u.setAttribute(h,""+p)}}function Di(u,h,p){if(p===null)u.removeAttribute(h);else{switch(typeof p){case"undefined":case"function":case"symbol":case"boolean":u.removeAttribute(h);return}u.setAttribute(h,""+p)}}function Fs(u,h,p,g){if(g===null)u.removeAttribute(p);else{switch(typeof g){case"undefined":case"function":case"symbol":case"boolean":u.removeAttribute(p);return}u.setAttributeNS(h,p,""+g)}}function fr(u){switch(typeof u){case"bigint":case"boolean":case"number":case"string":case"undefined":return u;case"object":return u;default:return""}}function fu(u){var h=u.type;return(u=u.nodeName)&&u.toLowerCase()==="input"&&(h==="checkbox"||h==="radio")}function em(u,h,p){var g=Object.getOwnPropertyDescriptor(u.constructor.prototype,h);if(!u.hasOwnProperty(h)&&typeof g<"u"&&typeof g.get=="function"&&typeof g.set=="function"){var I=g.get,C=g.set;return Object.defineProperty(u,h,{configurable:!0,get:function(){return I.call(this)},set:function(z){p=""+z,C.call(this,z)}}),Object.defineProperty(u,h,{enumerable:g.enumerable}),{getValue:function(){return p},setValue:function(z){p=""+z},stopTracking:function(){u._valueTracker=null,delete u[h]}}}}function $n(u){if(!u._valueTracker){var h=fu(u)?"checked":"value";u._valueTracker=em(u,h,""+u[h])}}function Uc(u){if(!u)return!1;var h=u._valueTracker;if(!h)return!0;var p=h.getValue(),g="";return u&&(g=fu(u)?u.checked?"true":"false":u.value),u=g,u!==p?(h.setValue(u),!0):!1}function $a(u){if(u=u||(typeof document<"u"?document:void 0),typeof u>"u")return null;try{return u.activeElement||u.body}catch{return u.body}}var Gc=/[\n"\\]/g;function pi(u){return u.replace(Gc,function(h){return"\\"+h.charCodeAt(0).toString(16)+" "})}function _f(u,h,p,g,I,C,z,W){u.name="",z!=null&&typeof z!="function"&&typeof z!="symbol"&&typeof z!="boolean"?u.type=z:u.removeAttribute("type"),h!=null?z==="number"?(h===0&&u.value===""||u.value!=h)&&(u.value=""+fr(h)):u.value!==""+fr(h)&&(u.value=""+fr(h)):z!=="submit"&&z!=="reset"||u.removeAttribute("value"),h!=null?nm(u,z,fr(h)):p!=null?nm(u,z,fr(p)):g!=null&&u.removeAttribute("value"),I==null&&C!=null&&(u.defaultChecked=!!C),I!=null&&(u.checked=I&&typeof I!="function"&&typeof I!="symbol"),W!=null&&typeof W!="function"&&typeof W!="symbol"&&typeof W!="boolean"?u.name=""+fr(W):u.removeAttribute("name")}function Wb(u,h,p,g,I,C,z,W){if(C!=null&&typeof C!="function"&&typeof C!="symbol"&&typeof C!="boolean"&&(u.type=C),h!=null||p!=null){if(!(C!=="submit"&&C!=="reset"||h!=null)){$n(u);return}p=p!=null?""+fr(p):"",h=h!=null?""+fr(h):p,W||h===u.value||(u.value=h),u.defaultValue=h}g=g??I,g=typeof g!="function"&&typeof g!="symbol"&&!!g,u.checked=W?u.checked:!!g,u.defaultChecked=!!g,z!=null&&typeof z!="function"&&typeof z!="symbol"&&typeof z!="boolean"&&(u.name=z),$n(u)}function nm(u,h,p){h==="number"&&$a(u.ownerDocument)===u||u.defaultValue===""+p||(u.defaultValue=""+p)}function du(u,h,p,g){if(u=u.options,h){h={};for(var I=0;I<p.length;I++)h["$"+p[I]]=!0;for(p=0;p<u.length;p++)I=h.hasOwnProperty("$"+u[p].value),u[p].selected!==I&&(u[p].selected=I),I&&g&&(u[p].defaultSelected=!0)}else{for(p=""+fr(p),h=null,I=0;I<u.length;I++){if(u[I].value===p){u[I].selected=!0,g&&(u[I].defaultSelected=!0);return}h!==null||u[I].disabled||(h=u[I])}h!==null&&(h.selected=!0)}}function jb(u,h,p){if(h!=null&&(h=""+fr(h),h!==u.value&&(u.value=h),p==null)){u.defaultValue!==h&&(u.defaultValue=h);return}u.defaultValue=p!=null?""+fr(p):""}function pu(u,h,p,g){if(h==null){if(g!=null){if(p!=null)throw Error(s(92));if(st(g)){if(1<g.length)throw Error(s(93));g=g[0]}p=g}p==null&&(p=""),h=p}p=fr(h),u.defaultValue=p,g=u.textContent,g===p&&g!==""&&g!==null&&(u.value=g),$n(u)}function mi(u,h){if(h){var p=u.firstChild;if(p&&p===u.lastChild&&p.nodeType===3){p.nodeValue=h;return}}u.textContent=h}var qb=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function sm(u,h,p){var g=h.indexOf("--")===0;p==null||typeof p=="boolean"||p===""?g?u.setProperty(h,""):h==="float"?u.cssFloat="":u[h]="":g?u.setProperty(h,p):typeof p!="number"||p===0||qb.has(h)?h==="float"?u.cssFloat=p:u[h]=(""+p).trim():u[h]=p+"px"}function rm(u,h,p){if(h!=null&&typeof h!="object")throw Error(s(62));if(u=u.style,p!=null){for(var g in p)!p.hasOwnProperty(g)||h!=null&&h.hasOwnProperty(g)||(g.indexOf("--")===0?u.setProperty(g,""):g==="float"?u.cssFloat="":u[g]="");for(var I in h)g=h[I],h.hasOwnProperty(I)&&p[I]!==g&&sm(u,I,g)}else for(var C in h)h.hasOwnProperty(C)&&sm(u,C,h[C])}function Nf(u){if(u.indexOf("-")===-1)return!1;switch(u){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Hb=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),mu=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Rf(u){return mu.test(""+u)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":u}function Fo(){}var im=null;function Zi(u){return u=u.target||u.srcElement||window,u.correspondingUseElement&&(u=u.correspondingUseElement),u.nodeType===3?u.parentNode:u}var gu=null,Aa=null;function Wc(u){var h=Qi(u);if(h&&(u=h.stateNode)){var p=u[hr]||null;t:switch(u=h.stateNode,h.type){case"input":if(_f(u,p.value,p.defaultValue,p.defaultValue,p.checked,p.defaultChecked,p.type,p.name),h=p.name,p.type==="radio"&&h!=null){for(p=u;p.parentNode;)p=p.parentNode;for(p=p.querySelectorAll('input[name="'+pi(""+h)+'"][type="radio"]'),h=0;h<p.length;h++){var g=p[h];if(g!==u&&g.form===u.form){var I=g[hr]||null;if(!I)throw Error(s(90));_f(g,I.value,I.defaultValue,I.defaultValue,I.checked,I.defaultChecked,I.type,I.name)}}for(h=0;h<p.length;h++)g=p[h],g.form===u.form&&Uc(g)}break t;case"textarea":jb(u,p.value,p.defaultValue);break t;case"select":h=p.value,h!=null&&du(u,!!p.multiple,h,!1)}}}var Df=!1;function yu(u,h,p){if(Df)return u(h,p);Df=!0;try{var g=u(h);return g}finally{if(Df=!1,(gu!==null||Aa!==null)&&(P0(),gu&&(h=gu,u=Aa,Aa=gu=null,Wc(h),u)))for(h=0;h<u.length;h++)Wc(u[h])}}function Mo(u,h){var p=u.stateNode;if(p===null)return null;var g=p[hr]||null;if(g===null)return null;p=g[h];t:switch(h){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(g=!g.disabled)||(u=u.type,g=!(u==="button"||u==="input"||u==="select"||u==="textarea")),u=!g;break t;default:u=!1}if(u)return null;if(p&&typeof p!="function")throw Error(s(231,h,typeof p));return p}var Ji=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),jc=!1;if(Ji)try{var Rn={};Object.defineProperty(Rn,"passive",{get:function(){jc=!0}}),window.addEventListener("test",Rn,Rn),window.removeEventListener("test",Rn,Rn)}catch{jc=!1}var ka=null,om=null,qc=null;function am(){if(qc)return qc;var u,h=om,p=h.length,g,I="value"in ka?ka.value:ka.textContent,C=I.length;for(u=0;u<p&&h[u]===I[u];u++);var z=p-u;for(g=1;g<=z&&h[p-g]===I[C-g];g++);return qc=I.slice(u,1<g?1-g:void 0)}function Hc(u){var h=u.keyCode;return"charCode"in u?(u=u.charCode,u===0&&h===13&&(u=13)):u=h,u===10&&(u=13),32<=u||u===13?u:0}function Sl(){return!0}function Lo(){return!1}function Tr(u){function h(p,g,I,C,z){this._reactName=p,this._targetInst=I,this.type=g,this.nativeEvent=C,this.target=z,this.currentTarget=null;for(var W in u)u.hasOwnProperty(W)&&(p=u[W],this[W]=p?p(C):C[W]);return this.isDefaultPrevented=(C.defaultPrevented!=null?C.defaultPrevented:C.returnValue===!1)?Sl:Lo,this.isPropagationStopped=Lo,this}return d(h.prototype,{preventDefault:function(){this.defaultPrevented=!0;var p=this.nativeEvent;p&&(p.preventDefault?p.preventDefault():typeof p.returnValue!="unknown"&&(p.returnValue=!1),this.isDefaultPrevented=Sl)},stopPropagation:function(){var p=this.nativeEvent;p&&(p.stopPropagation?p.stopPropagation():typeof p.cancelBubble!="unknown"&&(p.cancelBubble=!0),this.isPropagationStopped=Sl)},persist:function(){},isPersistent:Sl}),h}var Il={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(u){return u.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},_a=Tr(Il),bu=d({},Il,{view:0,detail:0}),lm=Tr(bu),xu,Of,Na,Ff=d({},bu,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:wu,button:0,buttons:0,relatedTarget:function(u){return u.relatedTarget===void 0?u.fromElement===u.srcElement?u.toElement:u.fromElement:u.relatedTarget},movementX:function(u){return"movementX"in u?u.movementX:(u!==Na&&(Na&&u.type==="mousemove"?(xu=u.screenX-Na.screenX,Of=u.screenY-Na.screenY):Of=xu=0,Na=u),xu)},movementY:function(u){return"movementY"in u?u.movementY:Of}}),um=Tr(Ff),Kc=d({},Ff,{dataTransfer:0}),Kb=Tr(Kc),Xb=d({},bu,{relatedTarget:0}),Xc=Tr(Xb),cm=d({},Il,{animationName:0,elapsedTime:0,pseudoElement:0}),Yb=Tr(cm),Mf=d({},Il,{clipboardData:function(u){return"clipboardData"in u?u.clipboardData:window.clipboardData}}),Qb=Tr(Mf),Zb=d({},Il,{data:0}),Ra=Tr(Zb),Jb={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},t0={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},e0={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function n0(u){var h=this.nativeEvent;return h.getModifierState?h.getModifierState(u):(u=e0[u])?!!h[u]:!1}function wu(){return n0}var Qr=d({},bu,{key:function(u){if(u.key){var h=Jb[u.key]||u.key;if(h!=="Unidentified")return h}return u.type==="keypress"?(u=Hc(u),u===13?"Enter":String.fromCharCode(u)):u.type==="keydown"||u.type==="keyup"?t0[u.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:wu,charCode:function(u){return u.type==="keypress"?Hc(u):0},keyCode:function(u){return u.type==="keydown"||u.type==="keyup"?u.keyCode:0},which:function(u){return u.type==="keypress"?Hc(u):u.type==="keydown"||u.type==="keyup"?u.keyCode:0}}),s0=Tr(Qr),r0=d({},Ff,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Tl=Tr(r0),v=d({},bu,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:wu}),D=Tr(v),V=d({},Il,{propertyName:0,elapsedTime:0,pseudoElement:0}),K=Tr(V),wt=d({},Ff,{deltaX:function(u){return"deltaX"in u?u.deltaX:"wheelDeltaX"in u?-u.wheelDeltaX:0},deltaY:function(u){return"deltaY"in u?u.deltaY:"wheelDeltaY"in u?-u.wheelDeltaY:"wheelDelta"in u?-u.wheelDelta:0},deltaZ:0,deltaMode:0}),_t=Tr(wt),Zt=d({},Il,{newState:0,oldState:0}),Fe=Tr(Zt),Is=[9,13,27,32],gn=Ji&&"CompositionEvent"in window,is=null;Ji&&"documentMode"in document&&(is=document.documentMode);var to=Ji&&"TextEvent"in window&&!is,Da=Ji&&(!gn||is&&8<is&&11>=is),zo=" ",Bo=!1;function Yc(u,h){switch(u){case"keyup":return Is.indexOf(h.keyCode)!==-1;case"keydown":return h.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Lf(u){return u=u.detail,typeof u=="object"&&"data"in u?u.data:null}var zf=!1;function UK(u,h){switch(u){case"compositionend":return Lf(h);case"keypress":return h.which!==32?null:(Bo=!0,zo);case"textInput":return u=h.data,u===zo&&Bo?null:u;default:return null}}function GK(u,h){if(zf)return u==="compositionend"||!gn&&Yc(u,h)?(u=am(),qc=om=ka=null,zf=!1,u):null;switch(u){case"paste":return null;case"keypress":if(!(h.ctrlKey||h.altKey||h.metaKey)||h.ctrlKey&&h.altKey){if(h.char&&1<h.char.length)return h.char;if(h.which)return String.fromCharCode(h.which)}return null;case"compositionend":return Da&&h.locale!=="ko"?null:h.data;default:return null}}var WK={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function WN(u){var h=u&&u.nodeName&&u.nodeName.toLowerCase();return h==="input"?!!WK[u.type]:h==="textarea"}function jN(u,h,p,g){gu?Aa?Aa.push(g):Aa=[g]:gu=g,h=H0(h,"onChange"),0<h.length&&(p=new _a("onChange","change",null,p,g),u.push({event:p,listeners:h}))}var hm=null,fm=null;function jK(u){$O(u,0)}function i0(u){var h=Ri(u);if(Uc(h))return u}function qN(u,h){if(u==="change")return h}var HN=!1;if(Ji){var LS;if(Ji){var zS="oninput"in document;if(!zS){var KN=document.createElement("div");KN.setAttribute("oninput","return;"),zS=typeof KN.oninput=="function"}LS=zS}else LS=!1;HN=LS&&(!document.documentMode||9<document.documentMode)}function XN(){hm&&(hm.detachEvent("onpropertychange",YN),fm=hm=null)}function YN(u){if(u.propertyName==="value"&&i0(fm)){var h=[];jN(h,fm,u,Zi(u)),yu(jK,h)}}function qK(u,h,p){u==="focusin"?(XN(),hm=h,fm=p,hm.attachEvent("onpropertychange",YN)):u==="focusout"&&XN()}function HK(u){if(u==="selectionchange"||u==="keyup"||u==="keydown")return i0(fm)}function KK(u,h){if(u==="click")return i0(h)}function XK(u,h){if(u==="input"||u==="change")return i0(h)}function YK(u,h){return u===h&&(u!==0||1/u===1/h)||u!==u&&h!==h}var Oi=typeof Object.is=="function"?Object.is:YK;function dm(u,h){if(Oi(u,h))return!0;if(typeof u!="object"||u===null||typeof h!="object"||h===null)return!1;var p=Object.keys(u),g=Object.keys(h);if(p.length!==g.length)return!1;for(g=0;g<p.length;g++){var I=p[g];if(!Nt.call(h,I)||!Oi(u[I],h[I]))return!1}return!0}function QN(u){for(;u&&u.firstChild;)u=u.firstChild;return u}function ZN(u,h){var p=QN(u);u=0;for(var g;p;){if(p.nodeType===3){if(g=u+p.textContent.length,u<=h&&g>=h)return{node:p,offset:h-u};u=g}t:{for(;p;){if(p.nextSibling){p=p.nextSibling;break t}p=p.parentNode}p=void 0}p=QN(p)}}function JN(u,h){return u&&h?u===h?!0:u&&u.nodeType===3?!1:h&&h.nodeType===3?JN(u,h.parentNode):"contains"in u?u.contains(h):u.compareDocumentPosition?!!(u.compareDocumentPosition(h)&16):!1:!1}function tR(u){u=u!=null&&u.ownerDocument!=null&&u.ownerDocument.defaultView!=null?u.ownerDocument.defaultView:window;for(var h=$a(u.document);h instanceof u.HTMLIFrameElement;){try{var p=typeof h.contentWindow.location.href=="string"}catch{p=!1}if(p)u=h.contentWindow;else break;h=$a(u.document)}return h}function BS(u){var h=u&&u.nodeName&&u.nodeName.toLowerCase();return h&&(h==="input"&&(u.type==="text"||u.type==="search"||u.type==="tel"||u.type==="url"||u.type==="password")||h==="textarea"||u.contentEditable==="true")}var QK=Ji&&"documentMode"in document&&11>=document.documentMode,Bf=null,PS=null,pm=null,VS=!1;function eR(u,h,p){var g=p.window===p?p.document:p.nodeType===9?p:p.ownerDocument;VS||Bf==null||Bf!==$a(g)||(g=Bf,"selectionStart"in g&&BS(g)?g={start:g.selectionStart,end:g.selectionEnd}:(g=(g.ownerDocument&&g.ownerDocument.defaultView||window).getSelection(),g={anchorNode:g.anchorNode,anchorOffset:g.anchorOffset,focusNode:g.focusNode,focusOffset:g.focusOffset}),pm&&dm(pm,g)||(pm=g,g=H0(PS,"onSelect"),0<g.length&&(h=new _a("onSelect","select",null,h,p),u.push({event:h,listeners:g}),h.target=Bf)))}function Qc(u,h){var p={};return p[u.toLowerCase()]=h.toLowerCase(),p["Webkit"+u]="webkit"+h,p["Moz"+u]="moz"+h,p}var Pf={animationend:Qc("Animation","AnimationEnd"),animationiteration:Qc("Animation","AnimationIteration"),animationstart:Qc("Animation","AnimationStart"),transitionrun:Qc("Transition","TransitionRun"),transitionstart:Qc("Transition","TransitionStart"),transitioncancel:Qc("Transition","TransitionCancel"),transitionend:Qc("Transition","TransitionEnd")},US={},nR={};Ji&&(nR=document.createElement("div").style,"AnimationEvent"in window||(delete Pf.animationend.animation,delete Pf.animationiteration.animation,delete Pf.animationstart.animation),"TransitionEvent"in window||delete Pf.transitionend.transition);function Zc(u){if(US[u])return US[u];if(!Pf[u])return u;var h=Pf[u],p;for(p in h)if(h.hasOwnProperty(p)&&p in nR)return US[u]=h[p];return u}var sR=Zc("animationend"),rR=Zc("animationiteration"),iR=Zc("animationstart"),ZK=Zc("transitionrun"),JK=Zc("transitionstart"),t7=Zc("transitioncancel"),oR=Zc("transitionend"),aR=new Map,GS="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");GS.push("scrollEnd");function Po(u,h){aR.set(u,h),Ca(h,[u])}var o0=typeof reportError=="function"?reportError:function(u){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var h=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof u=="object"&&u!==null&&typeof u.message=="string"?String(u.message):String(u),error:u});if(!window.dispatchEvent(h))return}else if(typeof Un=="object"&&typeof Un.emit=="function"){Un.emit("uncaughtException",u);return}console.error(u)},eo=[],Vf=0,WS=0;function a0(){for(var u=Vf,h=WS=Vf=0;h<u;){var p=eo[h];eo[h++]=null;var g=eo[h];eo[h++]=null;var I=eo[h];eo[h++]=null;var C=eo[h];if(eo[h++]=null,g!==null&&I!==null){var z=g.pending;z===null?I.next=I:(I.next=z.next,z.next=I),g.pending=I}C!==0&&lR(p,I,C)}}function l0(u,h,p,g){eo[Vf++]=u,eo[Vf++]=h,eo[Vf++]=p,eo[Vf++]=g,WS|=g,u.lanes|=g,u=u.alternate,u!==null&&(u.lanes|=g)}function jS(u,h,p,g){return l0(u,h,p,g),u0(u)}function Jc(u,h){return l0(u,null,null,h),u0(u)}function lR(u,h,p){u.lanes|=p;var g=u.alternate;g!==null&&(g.lanes|=p);for(var I=!1,C=u.return;C!==null;)C.childLanes|=p,g=C.alternate,g!==null&&(g.childLanes|=p),C.tag===22&&(u=C.stateNode,u===null||u._visibility&1||(I=!0)),u=C,C=C.return;return u.tag===3?(C=u.stateNode,I&&h!==null&&(I=31-Mt(p),u=C.hiddenUpdates,g=u[I],g===null?u[I]=[h]:g.push(h),h.lane=p|536870912),C):null}function u0(u){if(50<Mm)throw Mm=0,tT=null,Error(s(185));for(var h=u.return;h!==null;)u=h,h=u.return;return u.tag===3?u.stateNode:null}var Uf={};function e7(u,h,p,g){this.tag=u,this.key=p,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=h,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=g,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Fi(u,h,p,g){return new e7(u,h,p,g)}function qS(u){return u=u.prototype,!(!u||!u.isReactComponent)}function Cl(u,h){var p=u.alternate;return p===null?(p=Fi(u.tag,h,u.key,u.mode),p.elementType=u.elementType,p.type=u.type,p.stateNode=u.stateNode,p.alternate=u,u.alternate=p):(p.pendingProps=h,p.type=u.type,p.flags=0,p.subtreeFlags=0,p.deletions=null),p.flags=u.flags&65011712,p.childLanes=u.childLanes,p.lanes=u.lanes,p.child=u.child,p.memoizedProps=u.memoizedProps,p.memoizedState=u.memoizedState,p.updateQueue=u.updateQueue,h=u.dependencies,p.dependencies=h===null?null:{lanes:h.lanes,firstContext:h.firstContext},p.sibling=u.sibling,p.index=u.index,p.ref=u.ref,p.refCleanup=u.refCleanup,p}function uR(u,h){u.flags&=65011714;var p=u.alternate;return p===null?(u.childLanes=0,u.lanes=h,u.child=null,u.subtreeFlags=0,u.memoizedProps=null,u.memoizedState=null,u.updateQueue=null,u.dependencies=null,u.stateNode=null):(u.childLanes=p.childLanes,u.lanes=p.lanes,u.child=p.child,u.subtreeFlags=0,u.deletions=null,u.memoizedProps=p.memoizedProps,u.memoizedState=p.memoizedState,u.updateQueue=p.updateQueue,u.type=p.type,h=p.dependencies,u.dependencies=h===null?null:{lanes:h.lanes,firstContext:h.firstContext}),u}function c0(u,h,p,g,I,C){var z=0;if(g=u,typeof u=="function")qS(u)&&(z=1);else if(typeof u=="string")z=oX(u,p,X.current)?26:u==="html"||u==="head"||u==="body"?27:5;else t:switch(u){case _:return u=Fi(31,p,h,I),u.elementType=_,u.lanes=C,u;case w:return th(p.children,I,C,h);case x:z=8,I|=24;break;case S:return u=Fi(12,p,h,I|2),u.elementType=S,u.lanes=C,u;case R:return u=Fi(13,p,h,I),u.elementType=R,u.lanes=C,u;case B:return u=Fi(19,p,h,I),u.elementType=B,u.lanes=C,u;default:if(typeof u=="object"&&u!==null)switch(u.$$typeof){case $:z=10;break t;case T:z=9;break t;case E:z=11;break t;case N:z=14;break t;case k:z=16,g=null;break t}z=29,p=Error(s(130,u===null?"null":typeof u,"")),g=null}return h=Fi(z,p,h,I),h.elementType=u,h.type=g,h.lanes=C,h}function th(u,h,p,g){return u=Fi(7,u,g,h),u.lanes=p,u}function HS(u,h,p){return u=Fi(6,u,null,h),u.lanes=p,u}function cR(u){var h=Fi(18,null,null,0);return h.stateNode=u,h}function KS(u,h,p){return h=Fi(4,u.children!==null?u.children:[],u.key,h),h.lanes=p,h.stateNode={containerInfo:u.containerInfo,pendingChildren:null,implementation:u.implementation},h}var hR=new WeakMap;function no(u,h){if(typeof u=="object"&&u!==null){var p=hR.get(u);return p!==void 0?p:(h={value:u,source:h,stack:Ge(h)},hR.set(u,h),h)}return{value:u,source:h,stack:Ge(h)}}var Gf=[],Wf=0,h0=null,mm=0,so=[],ro=0,vu=null,Oa=1,Fa="";function El(u,h){Gf[Wf++]=mm,Gf[Wf++]=h0,h0=u,mm=h}function fR(u,h,p){so[ro++]=Oa,so[ro++]=Fa,so[ro++]=vu,vu=u;var g=Oa;u=Fa;var I=32-Mt(g)-1;g&=~(1<<I),p+=1;var C=32-Mt(h)+I;if(30<C){var z=I-I%5;C=(g&(1<<z)-1).toString(32),g>>=z,I-=z,Oa=1<<32-Mt(h)+I|p<<I|g,Fa=C+u}else Oa=1<<C|p<<I|g,Fa=u}function XS(u){u.return!==null&&(El(u,1),fR(u,1,0))}function YS(u){for(;u===h0;)h0=Gf[--Wf],Gf[Wf]=null,mm=Gf[--Wf],Gf[Wf]=null;for(;u===vu;)vu=so[--ro],so[ro]=null,Fa=so[--ro],so[ro]=null,Oa=so[--ro],so[ro]=null}function dR(u,h){so[ro++]=Oa,so[ro++]=Fa,so[ro++]=vu,Oa=h.id,Fa=h.overflow,vu=u}var Cr=null,Xn=null,tn=!1,Su=null,io=!1,QS=Error(s(519));function Iu(u){var h=Error(s(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw gm(no(h,u)),QS}function pR(u){var h=u.stateNode,p=u.type,g=u.memoizedProps;switch(h[Ds]=u,h[hr]=g,p){case"dialog":He("cancel",h),He("close",h);break;case"iframe":case"object":case"embed":He("load",h);break;case"video":case"audio":for(p=0;p<zm.length;p++)He(zm[p],h);break;case"source":He("error",h);break;case"img":case"image":case"link":He("error",h),He("load",h);break;case"details":He("toggle",h);break;case"input":He("invalid",h),Wb(h,g.value,g.defaultValue,g.checked,g.defaultChecked,g.type,g.name,!0);break;case"select":He("invalid",h);break;case"textarea":He("invalid",h),pu(h,g.value,g.defaultValue,g.children)}p=g.children,typeof p!="string"&&typeof p!="number"&&typeof p!="bigint"||h.textContent===""+p||g.suppressHydrationWarning===!0||NO(h.textContent,p)?(g.popover!=null&&(He("beforetoggle",h),He("toggle",h)),g.onScroll!=null&&He("scroll",h),g.onScrollEnd!=null&&He("scrollend",h),g.onClick!=null&&(h.onclick=Fo),h=!0):h=!1,h||Iu(u,!0)}function mR(u){for(Cr=u.return;Cr;)switch(Cr.tag){case 5:case 31:case 13:io=!1;return;case 27:case 3:io=!0;return;default:Cr=Cr.return}}function jf(u){if(u!==Cr)return!1;if(!tn)return mR(u),tn=!0,!1;var h=u.tag,p;if((p=h!==3&&h!==27)&&((p=h===5)&&(p=u.type,p=!(p!=="form"&&p!=="button")||mT(u.type,u.memoizedProps)),p=!p),p&&Xn&&Iu(u),mR(u),h===13){if(u=u.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(s(317));Xn=PO(u)}else if(h===31){if(u=u.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(s(317));Xn=PO(u)}else h===27?(h=Xn,Lu(u.type)?(u=wT,wT=null,Xn=u):Xn=h):Xn=Cr?ao(u.stateNode.nextSibling):null;return!0}function eh(){Xn=Cr=null,tn=!1}function ZS(){var u=Su;return u!==null&&(xi===null?xi=u:xi.push.apply(xi,u),Su=null),u}function gm(u){Su===null?Su=[u]:Su.push(u)}var JS=q(null),nh=null,$l=null;function Tu(u,h,p){U(JS,h._currentValue),h._currentValue=p}function Al(u){u._currentValue=JS.current,et(JS)}function tI(u,h,p){for(;u!==null;){var g=u.alternate;if((u.childLanes&h)!==h?(u.childLanes|=h,g!==null&&(g.childLanes|=h)):g!==null&&(g.childLanes&h)!==h&&(g.childLanes|=h),u===p)break;u=u.return}}function eI(u,h,p,g){var I=u.child;for(I!==null&&(I.return=u);I!==null;){var C=I.dependencies;if(C!==null){var z=I.child;C=C.firstContext;t:for(;C!==null;){var W=C;C=I;for(var it=0;it<h.length;it++)if(W.context===h[it]){C.lanes|=p,W=C.alternate,W!==null&&(W.lanes|=p),tI(C.return,p,u),g||(z=null);break t}C=W.next}}else if(I.tag===18){if(z=I.return,z===null)throw Error(s(341));z.lanes|=p,C=z.alternate,C!==null&&(C.lanes|=p),tI(z,p,u),z=null}else z=I.child;if(z!==null)z.return=I;else for(z=I;z!==null;){if(z===u){z=null;break}if(I=z.sibling,I!==null){I.return=z.return,z=I;break}z=z.return}I=z}}function qf(u,h,p,g){u=null;for(var I=h,C=!1;I!==null;){if(!C){if((I.flags&524288)!==0)C=!0;else if((I.flags&262144)!==0)break}if(I.tag===10){var z=I.alternate;if(z===null)throw Error(s(387));if(z=z.memoizedProps,z!==null){var W=I.type;Oi(I.pendingProps.value,z.value)||(u!==null?u.push(W):u=[W])}}else if(I===Ot.current){if(z=I.alternate,z===null)throw Error(s(387));z.memoizedState.memoizedState!==I.memoizedState.memoizedState&&(u!==null?u.push(Gm):u=[Gm])}I=I.return}u!==null&&eI(h,u,p,g),h.flags|=262144}function f0(u){for(u=u.firstContext;u!==null;){if(!Oi(u.context._currentValue,u.memoizedValue))return!0;u=u.next}return!1}function sh(u){nh=u,$l=null,u=u.dependencies,u!==null&&(u.firstContext=null)}function Er(u){return gR(nh,u)}function d0(u,h){return nh===null&&sh(u),gR(u,h)}function gR(u,h){var p=h._currentValue;if(h={context:h,memoizedValue:p,next:null},$l===null){if(u===null)throw Error(s(308));$l=h,u.dependencies={lanes:0,firstContext:h},u.flags|=524288}else $l=$l.next=h;return p}var n7=typeof AbortController<"u"?AbortController:function(){var u=[],h=this.signal={aborted:!1,addEventListener:function(p,g){u.push(g)}};this.abort=function(){h.aborted=!0,u.forEach(function(p){return p()})}},s7=n.unstable_scheduleCallback,r7=n.unstable_NormalPriority,Ms={$$typeof:$,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function nI(){return{controller:new n7,data:new Map,refCount:0}}function ym(u){u.refCount--,u.refCount===0&&s7(r7,function(){u.controller.abort()})}var bm=null,sI=0,Hf=0,Kf=null;function i7(u,h){if(bm===null){var p=bm=[];sI=0,Hf=oT(),Kf={status:"pending",value:void 0,then:function(g){p.push(g)}}}return sI++,h.then(yR,yR),h}function yR(){if(--sI===0&&bm!==null){Kf!==null&&(Kf.status="fulfilled");var u=bm;bm=null,Hf=0,Kf=null;for(var h=0;h<u.length;h++)(0,u[h])()}}function o7(u,h){var p=[],g={status:"pending",value:null,reason:null,then:function(I){p.push(I)}};return u.then(function(){g.status="fulfilled",g.value=h;for(var I=0;I<p.length;I++)(0,p[I])(h)},function(I){for(g.status="rejected",g.reason=I,I=0;I<p.length;I++)(0,p[I])(void 0)}),g}var bR=j.S;j.S=function(u,h){eO=je(),typeof h=="object"&&h!==null&&typeof h.then=="function"&&i7(u,h),bR!==null&&bR(u,h)};var rh=q(null);function rI(){var u=rh.current;return u!==null?u:zn.pooledCache}function p0(u,h){h===null?U(rh,rh.current):U(rh,h.pool)}function xR(){var u=rI();return u===null?null:{parent:Ms._currentValue,pool:u}}var Xf=Error(s(460)),iI=Error(s(474)),m0=Error(s(542)),g0={then:function(){}};function wR(u){return u=u.status,u==="fulfilled"||u==="rejected"}function vR(u,h,p){switch(p=u[p],p===void 0?u.push(h):p!==h&&(h.then(Fo,Fo),h=p),h.status){case"fulfilled":return h.value;case"rejected":throw u=h.reason,IR(u),u;default:if(typeof h.status=="string")h.then(Fo,Fo);else{if(u=zn,u!==null&&100<u.shellSuspendCounter)throw Error(s(482));u=h,u.status="pending",u.then(function(g){if(h.status==="pending"){var I=h;I.status="fulfilled",I.value=g}},function(g){if(h.status==="pending"){var I=h;I.status="rejected",I.reason=g}})}switch(h.status){case"fulfilled":return h.value;case"rejected":throw u=h.reason,IR(u),u}throw oh=h,Xf}}function ih(u){try{var h=u._init;return h(u._payload)}catch(p){throw p!==null&&typeof p=="object"&&typeof p.then=="function"?(oh=p,Xf):p}}var oh=null;function SR(){if(oh===null)throw Error(s(459));var u=oh;return oh=null,u}function IR(u){if(u===Xf||u===m0)throw Error(s(483))}var Yf=null,xm=0;function y0(u){var h=xm;return xm+=1,Yf===null&&(Yf=[]),vR(Yf,u,h)}function wm(u,h){h=h.props.ref,u.ref=h!==void 0?h:null}function b0(u,h){throw h.$$typeof===m?Error(s(525)):(u=Object.prototype.toString.call(h),Error(s(31,u==="[object Object]"?"object with keys {"+Object.keys(h).join(", ")+"}":u)))}function TR(u){function h(bt,ut){if(u){var It=bt.deletions;It===null?(bt.deletions=[ut],bt.flags|=16):It.push(ut)}}function p(bt,ut){if(!u)return null;for(;ut!==null;)h(bt,ut),ut=ut.sibling;return null}function g(bt){for(var ut=new Map;bt!==null;)bt.key!==null?ut.set(bt.key,bt):ut.set(bt.index,bt),bt=bt.sibling;return ut}function I(bt,ut){return bt=Cl(bt,ut),bt.index=0,bt.sibling=null,bt}function C(bt,ut,It){return bt.index=It,u?(It=bt.alternate,It!==null?(It=It.index,It<ut?(bt.flags|=67108866,ut):It):(bt.flags|=67108866,ut)):(bt.flags|=1048576,ut)}function z(bt){return u&&bt.alternate===null&&(bt.flags|=67108866),bt}function W(bt,ut,It,Vt){return ut===null||ut.tag!==6?(ut=HS(It,bt.mode,Vt),ut.return=bt,ut):(ut=I(ut,It),ut.return=bt,ut)}function it(bt,ut,It,Vt){var ye=It.type;return ye===w?Bt(bt,ut,It.props.children,Vt,It.key):ut!==null&&(ut.elementType===ye||typeof ye=="object"&&ye!==null&&ye.$$typeof===k&&ih(ye)===ut.type)?(ut=I(ut,It.props),wm(ut,It),ut.return=bt,ut):(ut=c0(It.type,It.key,It.props,null,bt.mode,Vt),wm(ut,It),ut.return=bt,ut)}function Tt(bt,ut,It,Vt){return ut===null||ut.tag!==4||ut.stateNode.containerInfo!==It.containerInfo||ut.stateNode.implementation!==It.implementation?(ut=KS(It,bt.mode,Vt),ut.return=bt,ut):(ut=I(ut,It.children||[]),ut.return=bt,ut)}function Bt(bt,ut,It,Vt,ye){return ut===null||ut.tag!==7?(ut=th(It,bt.mode,Vt,ye),ut.return=bt,ut):(ut=I(ut,It),ut.return=bt,ut)}function Ut(bt,ut,It){if(typeof ut=="string"&&ut!==""||typeof ut=="number"||typeof ut=="bigint")return ut=HS(""+ut,bt.mode,It),ut.return=bt,ut;if(typeof ut=="object"&&ut!==null){switch(ut.$$typeof){case y:return It=c0(ut.type,ut.key,ut.props,null,bt.mode,It),wm(It,ut),It.return=bt,It;case b:return ut=KS(ut,bt.mode,It),ut.return=bt,ut;case k:return ut=ih(ut),Ut(bt,ut,It)}if(st(ut)||P(ut))return ut=th(ut,bt.mode,It,null),ut.return=bt,ut;if(typeof ut.then=="function")return Ut(bt,y0(ut),It);if(ut.$$typeof===$)return Ut(bt,d0(bt,ut),It);b0(bt,ut)}return null}function $t(bt,ut,It,Vt){var ye=ut!==null?ut.key:null;if(typeof It=="string"&&It!==""||typeof It=="number"||typeof It=="bigint")return ye!==null?null:W(bt,ut,""+It,Vt);if(typeof It=="object"&&It!==null){switch(It.$$typeof){case y:return It.key===ye?it(bt,ut,It,Vt):null;case b:return It.key===ye?Tt(bt,ut,It,Vt):null;case k:return It=ih(It),$t(bt,ut,It,Vt)}if(st(It)||P(It))return ye!==null?null:Bt(bt,ut,It,Vt,null);if(typeof It.then=="function")return $t(bt,ut,y0(It),Vt);if(It.$$typeof===$)return $t(bt,ut,d0(bt,It),Vt);b0(bt,It)}return null}function Rt(bt,ut,It,Vt,ye){if(typeof Vt=="string"&&Vt!==""||typeof Vt=="number"||typeof Vt=="bigint")return bt=bt.get(It)||null,W(ut,bt,""+Vt,ye);if(typeof Vt=="object"&&Vt!==null){switch(Vt.$$typeof){case y:return bt=bt.get(Vt.key===null?It:Vt.key)||null,it(ut,bt,Vt,ye);case b:return bt=bt.get(Vt.key===null?It:Vt.key)||null,Tt(ut,bt,Vt,ye);case k:return Vt=ih(Vt),Rt(bt,ut,It,Vt,ye)}if(st(Vt)||P(Vt))return bt=bt.get(It)||null,Bt(ut,bt,Vt,ye,null);if(typeof Vt.then=="function")return Rt(bt,ut,It,y0(Vt),ye);if(Vt.$$typeof===$)return Rt(bt,ut,It,d0(ut,Vt),ye);b0(ut,Vt)}return null}function ae(bt,ut,It,Vt){for(var ye=null,cn=null,he=ut,ze=ut=0,Xe=null;he!==null&&ze<It.length;ze++){he.index>ze?(Xe=he,he=null):Xe=he.sibling;var hn=$t(bt,he,It[ze],Vt);if(hn===null){he===null&&(he=Xe);break}u&&he&&hn.alternate===null&&h(bt,he),ut=C(hn,ut,ze),cn===null?ye=hn:cn.sibling=hn,cn=hn,he=Xe}if(ze===It.length)return p(bt,he),tn&&El(bt,ze),ye;if(he===null){for(;ze<It.length;ze++)he=Ut(bt,It[ze],Vt),he!==null&&(ut=C(he,ut,ze),cn===null?ye=he:cn.sibling=he,cn=he);return tn&&El(bt,ze),ye}for(he=g(he);ze<It.length;ze++)Xe=Rt(he,bt,ze,It[ze],Vt),Xe!==null&&(u&&Xe.alternate!==null&&he.delete(Xe.key===null?ze:Xe.key),ut=C(Xe,ut,ze),cn===null?ye=Xe:cn.sibling=Xe,cn=Xe);return u&&he.forEach(function(Uu){return h(bt,Uu)}),tn&&El(bt,ze),ye}function ve(bt,ut,It,Vt){if(It==null)throw Error(s(151));for(var ye=null,cn=null,he=ut,ze=ut=0,Xe=null,hn=It.next();he!==null&&!hn.done;ze++,hn=It.next()){he.index>ze?(Xe=he,he=null):Xe=he.sibling;var Uu=$t(bt,he,hn.value,Vt);if(Uu===null){he===null&&(he=Xe);break}u&&he&&Uu.alternate===null&&h(bt,he),ut=C(Uu,ut,ze),cn===null?ye=Uu:cn.sibling=Uu,cn=Uu,he=Xe}if(hn.done)return p(bt,he),tn&&El(bt,ze),ye;if(he===null){for(;!hn.done;ze++,hn=It.next())hn=Ut(bt,hn.value,Vt),hn!==null&&(ut=C(hn,ut,ze),cn===null?ye=hn:cn.sibling=hn,cn=hn);return tn&&El(bt,ze),ye}for(he=g(he);!hn.done;ze++,hn=It.next())hn=Rt(he,bt,ze,hn.value,Vt),hn!==null&&(u&&hn.alternate!==null&&he.delete(hn.key===null?ze:hn.key),ut=C(hn,ut,ze),cn===null?ye=hn:cn.sibling=hn,cn=hn);return u&&he.forEach(function(yX){return h(bt,yX)}),tn&&El(bt,ze),ye}function Fn(bt,ut,It,Vt){if(typeof It=="object"&&It!==null&&It.type===w&&It.key===null&&(It=It.props.children),typeof It=="object"&&It!==null){switch(It.$$typeof){case y:t:{for(var ye=It.key;ut!==null;){if(ut.key===ye){if(ye=It.type,ye===w){if(ut.tag===7){p(bt,ut.sibling),Vt=I(ut,It.props.children),Vt.return=bt,bt=Vt;break t}}else if(ut.elementType===ye||typeof ye=="object"&&ye!==null&&ye.$$typeof===k&&ih(ye)===ut.type){p(bt,ut.sibling),Vt=I(ut,It.props),wm(Vt,It),Vt.return=bt,bt=Vt;break t}p(bt,ut);break}else h(bt,ut);ut=ut.sibling}It.type===w?(Vt=th(It.props.children,bt.mode,Vt,It.key),Vt.return=bt,bt=Vt):(Vt=c0(It.type,It.key,It.props,null,bt.mode,Vt),wm(Vt,It),Vt.return=bt,bt=Vt)}return z(bt);case b:t:{for(ye=It.key;ut!==null;){if(ut.key===ye)if(ut.tag===4&&ut.stateNode.containerInfo===It.containerInfo&&ut.stateNode.implementation===It.implementation){p(bt,ut.sibling),Vt=I(ut,It.children||[]),Vt.return=bt,bt=Vt;break t}else{p(bt,ut);break}else h(bt,ut);ut=ut.sibling}Vt=KS(It,bt.mode,Vt),Vt.return=bt,bt=Vt}return z(bt);case k:return It=ih(It),Fn(bt,ut,It,Vt)}if(st(It))return ae(bt,ut,It,Vt);if(P(It)){if(ye=P(It),typeof ye!="function")throw Error(s(150));return It=ye.call(It),ve(bt,ut,It,Vt)}if(typeof It.then=="function")return Fn(bt,ut,y0(It),Vt);if(It.$$typeof===$)return Fn(bt,ut,d0(bt,It),Vt);b0(bt,It)}return typeof It=="string"&&It!==""||typeof It=="number"||typeof It=="bigint"?(It=""+It,ut!==null&&ut.tag===6?(p(bt,ut.sibling),Vt=I(ut,It),Vt.return=bt,bt=Vt):(p(bt,ut),Vt=HS(It,bt.mode,Vt),Vt.return=bt,bt=Vt),z(bt)):p(bt,ut)}return function(bt,ut,It,Vt){try{xm=0;var ye=Fn(bt,ut,It,Vt);return Yf=null,ye}catch(he){if(he===Xf||he===m0)throw he;var cn=Fi(29,he,null,bt.mode);return cn.lanes=Vt,cn.return=bt,cn}}}var ah=TR(!0),CR=TR(!1),Cu=!1;function oI(u){u.updateQueue={baseState:u.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function aI(u,h){u=u.updateQueue,h.updateQueue===u&&(h.updateQueue={baseState:u.baseState,firstBaseUpdate:u.firstBaseUpdate,lastBaseUpdate:u.lastBaseUpdate,shared:u.shared,callbacks:null})}function Eu(u){return{lane:u,tag:0,payload:null,callback:null,next:null}}function $u(u,h,p){var g=u.updateQueue;if(g===null)return null;if(g=g.shared,(yn&2)!==0){var I=g.pending;return I===null?h.next=h:(h.next=I.next,I.next=h),g.pending=h,h=u0(u),lR(u,null,p),h}return l0(u,g,h,p),u0(u)}function vm(u,h,p){if(h=h.updateQueue,h!==null&&(h=h.shared,(p&4194048)!==0)){var g=h.lanes;g&=u.pendingLanes,p|=g,h.lanes=p,Kp(u,p)}}function lI(u,h){var p=u.updateQueue,g=u.alternate;if(g!==null&&(g=g.updateQueue,p===g)){var I=null,C=null;if(p=p.firstBaseUpdate,p!==null){do{var z={lane:p.lane,tag:p.tag,payload:p.payload,callback:null,next:null};C===null?I=C=z:C=C.next=z,p=p.next}while(p!==null);C===null?I=C=h:C=C.next=h}else I=C=h;p={baseState:g.baseState,firstBaseUpdate:I,lastBaseUpdate:C,shared:g.shared,callbacks:g.callbacks},u.updateQueue=p;return}u=p.lastBaseUpdate,u===null?p.firstBaseUpdate=h:u.next=h,p.lastBaseUpdate=h}var uI=!1;function Sm(){if(uI){var u=Kf;if(u!==null)throw u}}function Im(u,h,p,g){uI=!1;var I=u.updateQueue;Cu=!1;var C=I.firstBaseUpdate,z=I.lastBaseUpdate,W=I.shared.pending;if(W!==null){I.shared.pending=null;var it=W,Tt=it.next;it.next=null,z===null?C=Tt:z.next=Tt,z=it;var Bt=u.alternate;Bt!==null&&(Bt=Bt.updateQueue,W=Bt.lastBaseUpdate,W!==z&&(W===null?Bt.firstBaseUpdate=Tt:W.next=Tt,Bt.lastBaseUpdate=it))}if(C!==null){var Ut=I.baseState;z=0,Bt=Tt=it=null,W=C;do{var $t=W.lane&-536870913,Rt=$t!==W.lane;if(Rt?(Ke&$t)===$t:(g&$t)===$t){$t!==0&&$t===Hf&&(uI=!0),Bt!==null&&(Bt=Bt.next={lane:0,tag:W.tag,payload:W.payload,callback:null,next:null});t:{var ae=u,ve=W;$t=h;var Fn=p;switch(ve.tag){case 1:if(ae=ve.payload,typeof ae=="function"){Ut=ae.call(Fn,Ut,$t);break t}Ut=ae;break t;case 3:ae.flags=ae.flags&-65537|128;case 0:if(ae=ve.payload,$t=typeof ae=="function"?ae.call(Fn,Ut,$t):ae,$t==null)break t;Ut=d({},Ut,$t);break t;case 2:Cu=!0}}$t=W.callback,$t!==null&&(u.flags|=64,Rt&&(u.flags|=8192),Rt=I.callbacks,Rt===null?I.callbacks=[$t]:Rt.push($t))}else Rt={lane:$t,tag:W.tag,payload:W.payload,callback:W.callback,next:null},Bt===null?(Tt=Bt=Rt,it=Ut):Bt=Bt.next=Rt,z|=$t;if(W=W.next,W===null){if(W=I.shared.pending,W===null)break;Rt=W,W=Rt.next,Rt.next=null,I.lastBaseUpdate=Rt,I.shared.pending=null}}while(!0);Bt===null&&(it=Ut),I.baseState=it,I.firstBaseUpdate=Tt,I.lastBaseUpdate=Bt,C===null&&(I.shared.lanes=0),Ru|=z,u.lanes=z,u.memoizedState=Ut}}function ER(u,h){if(typeof u!="function")throw Error(s(191,u));u.call(h)}function $R(u,h){var p=u.callbacks;if(p!==null)for(u.callbacks=null,u=0;u<p.length;u++)ER(p[u],h)}var Qf=q(null),x0=q(0);function AR(u,h){u=Ll,U(x0,u),U(Qf,h),Ll=u|h.baseLanes}function cI(){U(x0,Ll),U(Qf,Qf.current)}function hI(){Ll=x0.current,et(Qf),et(x0)}var Mi=q(null),oo=null;function Au(u){var h=u.alternate;U(Ts,Ts.current&1),U(Mi,u),oo===null&&(h===null||Qf.current!==null||h.memoizedState!==null)&&(oo=u)}function fI(u){U(Ts,Ts.current),U(Mi,u),oo===null&&(oo=u)}function kR(u){u.tag===22?(U(Ts,Ts.current),U(Mi,u),oo===null&&(oo=u)):ku()}function ku(){U(Ts,Ts.current),U(Mi,Mi.current)}function Li(u){et(Mi),oo===u&&(oo=null),et(Ts)}var Ts=q(0);function w0(u){for(var h=u;h!==null;){if(h.tag===13){var p=h.memoizedState;if(p!==null&&(p=p.dehydrated,p===null||bT(p)||xT(p)))return h}else if(h.tag===19&&(h.memoizedProps.revealOrder==="forwards"||h.memoizedProps.revealOrder==="backwards"||h.memoizedProps.revealOrder==="unstable_legacy-backwards"||h.memoizedProps.revealOrder==="together")){if((h.flags&128)!==0)return h}else if(h.child!==null){h.child.return=h,h=h.child;continue}if(h===u)break;for(;h.sibling===null;){if(h.return===null||h.return===u)return null;h=h.return}h.sibling.return=h.return,h=h.sibling}return null}var kl=0,Me=null,Dn=null,Ls=null,v0=!1,Zf=!1,lh=!1,S0=0,Tm=0,Jf=null,a7=0;function ps(){throw Error(s(321))}function dI(u,h){if(h===null)return!1;for(var p=0;p<h.length&&p<u.length;p++)if(!Oi(u[p],h[p]))return!1;return!0}function pI(u,h,p,g,I,C){return kl=C,Me=h,h.memoizedState=null,h.updateQueue=null,h.lanes=0,j.H=u===null||u.memoizedState===null?fD:kI,lh=!1,C=p(g,I),lh=!1,Zf&&(C=NR(h,p,g,I)),_R(u),C}function _R(u){j.H=$m;var h=Dn!==null&&Dn.next!==null;if(kl=0,Ls=Dn=Me=null,v0=!1,Tm=0,Jf=null,h)throw Error(s(300));u===null||zs||(u=u.dependencies,u!==null&&f0(u)&&(zs=!0))}function NR(u,h,p,g){Me=u;var I=0;do{if(Zf&&(Jf=null),Tm=0,Zf=!1,25<=I)throw Error(s(301));if(I+=1,Ls=Dn=null,u.updateQueue!=null){var C=u.updateQueue;C.lastEffect=null,C.events=null,C.stores=null,C.memoCache!=null&&(C.memoCache.index=0)}j.H=dD,C=h(p,g)}while(Zf);return C}function l7(){var u=j.H,h=u.useState()[0];return h=typeof h.then=="function"?Cm(h):h,u=u.useState()[0],(Dn!==null?Dn.memoizedState:null)!==u&&(Me.flags|=1024),h}function mI(){var u=S0!==0;return S0=0,u}function gI(u,h,p){h.updateQueue=u.updateQueue,h.flags&=-2053,u.lanes&=~p}function yI(u){if(v0){for(u=u.memoizedState;u!==null;){var h=u.queue;h!==null&&(h.pending=null),u=u.next}v0=!1}kl=0,Ls=Dn=Me=null,Zf=!1,Tm=S0=0,Jf=null}function Zr(){var u={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Ls===null?Me.memoizedState=Ls=u:Ls=Ls.next=u,Ls}function Cs(){if(Dn===null){var u=Me.alternate;u=u!==null?u.memoizedState:null}else u=Dn.next;var h=Ls===null?Me.memoizedState:Ls.next;if(h!==null)Ls=h,Dn=u;else{if(u===null)throw Me.alternate===null?Error(s(467)):Error(s(310));Dn=u,u={memoizedState:Dn.memoizedState,baseState:Dn.baseState,baseQueue:Dn.baseQueue,queue:Dn.queue,next:null},Ls===null?Me.memoizedState=Ls=u:Ls=Ls.next=u}return Ls}function I0(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Cm(u){var h=Tm;return Tm+=1,Jf===null&&(Jf=[]),u=vR(Jf,u,h),h=Me,(Ls===null?h.memoizedState:Ls.next)===null&&(h=h.alternate,j.H=h===null||h.memoizedState===null?fD:kI),u}function T0(u){if(u!==null&&typeof u=="object"){if(typeof u.then=="function")return Cm(u);if(u.$$typeof===$)return Er(u)}throw Error(s(438,String(u)))}function bI(u){var h=null,p=Me.updateQueue;if(p!==null&&(h=p.memoCache),h==null){var g=Me.alternate;g!==null&&(g=g.updateQueue,g!==null&&(g=g.memoCache,g!=null&&(h={data:g.data.map(function(I){return I.slice()}),index:0})))}if(h==null&&(h={data:[],index:0}),p===null&&(p=I0(),Me.updateQueue=p),p.memoCache=h,p=h.data[h.index],p===void 0)for(p=h.data[h.index]=Array(u),g=0;g<u;g++)p[g]=F;return h.index++,p}function _l(u,h){return typeof h=="function"?h(u):h}function C0(u){var h=Cs();return xI(h,Dn,u)}function xI(u,h,p){var g=u.queue;if(g===null)throw Error(s(311));g.lastRenderedReducer=p;var I=u.baseQueue,C=g.pending;if(C!==null){if(I!==null){var z=I.next;I.next=C.next,C.next=z}h.baseQueue=I=C,g.pending=null}if(C=u.baseState,I===null)u.memoizedState=C;else{h=I.next;var W=z=null,it=null,Tt=h,Bt=!1;do{var Ut=Tt.lane&-536870913;if(Ut!==Tt.lane?(Ke&Ut)===Ut:(kl&Ut)===Ut){var $t=Tt.revertLane;if($t===0)it!==null&&(it=it.next={lane:0,revertLane:0,gesture:null,action:Tt.action,hasEagerState:Tt.hasEagerState,eagerState:Tt.eagerState,next:null}),Ut===Hf&&(Bt=!0);else if((kl&$t)===$t){Tt=Tt.next,$t===Hf&&(Bt=!0);continue}else Ut={lane:0,revertLane:Tt.revertLane,gesture:null,action:Tt.action,hasEagerState:Tt.hasEagerState,eagerState:Tt.eagerState,next:null},it===null?(W=it=Ut,z=C):it=it.next=Ut,Me.lanes|=$t,Ru|=$t;Ut=Tt.action,lh&&p(C,Ut),C=Tt.hasEagerState?Tt.eagerState:p(C,Ut)}else $t={lane:Ut,revertLane:Tt.revertLane,gesture:Tt.gesture,action:Tt.action,hasEagerState:Tt.hasEagerState,eagerState:Tt.eagerState,next:null},it===null?(W=it=$t,z=C):it=it.next=$t,Me.lanes|=Ut,Ru|=Ut;Tt=Tt.next}while(Tt!==null&&Tt!==h);if(it===null?z=C:it.next=W,!Oi(C,u.memoizedState)&&(zs=!0,Bt&&(p=Kf,p!==null)))throw p;u.memoizedState=C,u.baseState=z,u.baseQueue=it,g.lastRenderedState=C}return I===null&&(g.lanes=0),[u.memoizedState,g.dispatch]}function wI(u){var h=Cs(),p=h.queue;if(p===null)throw Error(s(311));p.lastRenderedReducer=u;var g=p.dispatch,I=p.pending,C=h.memoizedState;if(I!==null){p.pending=null;var z=I=I.next;do C=u(C,z.action),z=z.next;while(z!==I);Oi(C,h.memoizedState)||(zs=!0),h.memoizedState=C,h.baseQueue===null&&(h.baseState=C),p.lastRenderedState=C}return[C,g]}function RR(u,h,p){var g=Me,I=Cs(),C=tn;if(C){if(p===void 0)throw Error(s(407));p=p()}else p=h();var z=!Oi((Dn||I).memoizedState,p);if(z&&(I.memoizedState=p,zs=!0),I=I.queue,II(FR.bind(null,g,I,u),[u]),I.getSnapshot!==h||z||Ls!==null&&Ls.memoizedState.tag&1){if(g.flags|=2048,td(9,{destroy:void 0},OR.bind(null,g,I,p,h),null),zn===null)throw Error(s(349));C||(kl&127)!==0||DR(g,h,p)}return p}function DR(u,h,p){u.flags|=16384,u={getSnapshot:h,value:p},h=Me.updateQueue,h===null?(h=I0(),Me.updateQueue=h,h.stores=[u]):(p=h.stores,p===null?h.stores=[u]:p.push(u))}function OR(u,h,p,g){h.value=p,h.getSnapshot=g,MR(h)&&LR(u)}function FR(u,h,p){return p(function(){MR(h)&&LR(u)})}function MR(u){var h=u.getSnapshot;u=u.value;try{var p=h();return!Oi(u,p)}catch{return!0}}function LR(u){var h=Jc(u,2);h!==null&&wi(h,u,2)}function vI(u){var h=Zr();if(typeof u=="function"){var p=u;if(u=p(),lh){Ct(!0);try{p()}finally{Ct(!1)}}}return h.memoizedState=h.baseState=u,h.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:_l,lastRenderedState:u},h}function zR(u,h,p,g){return u.baseState=p,xI(u,Dn,typeof g=="function"?g:_l)}function u7(u,h,p,g,I){if(A0(u))throw Error(s(485));if(u=h.action,u!==null){var C={payload:I,action:u,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(z){C.listeners.push(z)}};j.T!==null?p(!0):C.isTransition=!1,g(C),p=h.pending,p===null?(C.next=h.pending=C,BR(h,C)):(C.next=p.next,h.pending=p.next=C)}}function BR(u,h){var p=h.action,g=h.payload,I=u.state;if(h.isTransition){var C=j.T,z={};j.T=z;try{var W=p(I,g),it=j.S;it!==null&&it(z,W),PR(u,h,W)}catch(Tt){SI(u,h,Tt)}finally{C!==null&&z.types!==null&&(C.types=z.types),j.T=C}}else try{C=p(I,g),PR(u,h,C)}catch(Tt){SI(u,h,Tt)}}function PR(u,h,p){p!==null&&typeof p=="object"&&typeof p.then=="function"?p.then(function(g){VR(u,h,g)},function(g){return SI(u,h,g)}):VR(u,h,p)}function VR(u,h,p){h.status="fulfilled",h.value=p,UR(h),u.state=p,h=u.pending,h!==null&&(p=h.next,p===h?u.pending=null:(p=p.next,h.next=p,BR(u,p)))}function SI(u,h,p){var g=u.pending;if(u.pending=null,g!==null){g=g.next;do h.status="rejected",h.reason=p,UR(h),h=h.next;while(h!==g)}u.action=null}function UR(u){u=u.listeners;for(var h=0;h<u.length;h++)(0,u[h])()}function GR(u,h){return h}function WR(u,h){if(tn){var p=zn.formState;if(p!==null){t:{var g=Me;if(tn){if(Xn){e:{for(var I=Xn,C=io;I.nodeType!==8;){if(!C){I=null;break e}if(I=ao(I.nextSibling),I===null){I=null;break e}}C=I.data,I=C==="F!"||C==="F"?I:null}if(I){Xn=ao(I.nextSibling),g=I.data==="F!";break t}}Iu(g)}g=!1}g&&(h=p[0])}}return p=Zr(),p.memoizedState=p.baseState=h,g={pending:null,lanes:0,dispatch:null,lastRenderedReducer:GR,lastRenderedState:h},p.queue=g,p=uD.bind(null,Me,g),g.dispatch=p,g=vI(!1),C=AI.bind(null,Me,!1,g.queue),g=Zr(),I={state:h,dispatch:null,action:u,pending:null},g.queue=I,p=u7.bind(null,Me,I,C,p),I.dispatch=p,g.memoizedState=u,[h,p,!1]}function jR(u){var h=Cs();return qR(h,Dn,u)}function qR(u,h,p){if(h=xI(u,h,GR)[0],u=C0(_l)[0],typeof h=="object"&&h!==null&&typeof h.then=="function")try{var g=Cm(h)}catch(z){throw z===Xf?m0:z}else g=h;h=Cs();var I=h.queue,C=I.dispatch;return p!==h.memoizedState&&(Me.flags|=2048,td(9,{destroy:void 0},c7.bind(null,I,p),null)),[g,C,u]}function c7(u,h){u.action=h}function HR(u){var h=Cs(),p=Dn;if(p!==null)return qR(h,p,u);Cs(),h=h.memoizedState,p=Cs();var g=p.queue.dispatch;return p.memoizedState=u,[h,g,!1]}function td(u,h,p,g){return u={tag:u,create:p,deps:g,inst:h,next:null},h=Me.updateQueue,h===null&&(h=I0(),Me.updateQueue=h),p=h.lastEffect,p===null?h.lastEffect=u.next=u:(g=p.next,p.next=u,u.next=g,h.lastEffect=u),u}function KR(){return Cs().memoizedState}function E0(u,h,p,g){var I=Zr();Me.flags|=u,I.memoizedState=td(1|h,{destroy:void 0},p,g===void 0?null:g)}function $0(u,h,p,g){var I=Cs();g=g===void 0?null:g;var C=I.memoizedState.inst;Dn!==null&&g!==null&&dI(g,Dn.memoizedState.deps)?I.memoizedState=td(h,C,p,g):(Me.flags|=u,I.memoizedState=td(1|h,C,p,g))}function XR(u,h){E0(8390656,8,u,h)}function II(u,h){$0(2048,8,u,h)}function h7(u){Me.flags|=4;var h=Me.updateQueue;if(h===null)h=I0(),Me.updateQueue=h,h.events=[u];else{var p=h.events;p===null?h.events=[u]:p.push(u)}}function YR(u){var h=Cs().memoizedState;return h7({ref:h,nextImpl:u}),function(){if((yn&2)!==0)throw Error(s(440));return h.impl.apply(void 0,arguments)}}function QR(u,h){return $0(4,2,u,h)}function ZR(u,h){return $0(4,4,u,h)}function JR(u,h){if(typeof h=="function"){u=u();var p=h(u);return function(){typeof p=="function"?p():h(null)}}if(h!=null)return u=u(),h.current=u,function(){h.current=null}}function tD(u,h,p){p=p!=null?p.concat([u]):null,$0(4,4,JR.bind(null,h,u),p)}function TI(){}function eD(u,h){var p=Cs();h=h===void 0?null:h;var g=p.memoizedState;return h!==null&&dI(h,g[1])?g[0]:(p.memoizedState=[u,h],u)}function nD(u,h){var p=Cs();h=h===void 0?null:h;var g=p.memoizedState;if(h!==null&&dI(h,g[1]))return g[0];if(g=u(),lh){Ct(!0);try{u()}finally{Ct(!1)}}return p.memoizedState=[g,h],g}function CI(u,h,p){return p===void 0||(kl&1073741824)!==0&&(Ke&261930)===0?u.memoizedState=h:(u.memoizedState=p,u=sO(),Me.lanes|=u,Ru|=u,p)}function sD(u,h,p,g){return Oi(p,h)?p:Qf.current!==null?(u=CI(u,p,g),Oi(u,h)||(zs=!0),u):(kl&42)===0||(kl&1073741824)!==0&&(Ke&261930)===0?(zs=!0,u.memoizedState=p):(u=sO(),Me.lanes|=u,Ru|=u,h)}function rD(u,h,p,g,I){var C=Z.p;Z.p=C!==0&&8>C?C:8;var z=j.T,W={};j.T=W,AI(u,!1,h,p);try{var it=I(),Tt=j.S;if(Tt!==null&&Tt(W,it),it!==null&&typeof it=="object"&&typeof it.then=="function"){var Bt=o7(it,g);Em(u,h,Bt,Pi(u))}else Em(u,h,g,Pi(u))}catch(Ut){Em(u,h,{then:function(){},status:"rejected",reason:Ut},Pi())}finally{Z.p=C,z!==null&&W.types!==null&&(z.types=W.types),j.T=z}}function f7(){}function EI(u,h,p,g){if(u.tag!==5)throw Error(s(476));var I=iD(u).queue;rD(u,I,h,J,p===null?f7:function(){return oD(u),p(g)})}function iD(u){var h=u.memoizedState;if(h!==null)return h;h={memoizedState:J,baseState:J,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:_l,lastRenderedState:J},next:null};var p={};return h.next={memoizedState:p,baseState:p,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:_l,lastRenderedState:p},next:null},u.memoizedState=h,u=u.alternate,u!==null&&(u.memoizedState=h),h}function oD(u){var h=iD(u);h.next===null&&(h=u.alternate.memoizedState),Em(u,h.next.queue,{},Pi())}function $I(){return Er(Gm)}function aD(){return Cs().memoizedState}function lD(){return Cs().memoizedState}function d7(u){for(var h=u.return;h!==null;){switch(h.tag){case 24:case 3:var p=Pi();u=Eu(p);var g=$u(h,u,p);g!==null&&(wi(g,h,p),vm(g,h,p)),h={cache:nI()},u.payload=h;return}h=h.return}}function p7(u,h,p){var g=Pi();p={lane:g,revertLane:0,gesture:null,action:p,hasEagerState:!1,eagerState:null,next:null},A0(u)?cD(h,p):(p=jS(u,h,p,g),p!==null&&(wi(p,u,g),hD(p,h,g)))}function uD(u,h,p){var g=Pi();Em(u,h,p,g)}function Em(u,h,p,g){var I={lane:g,revertLane:0,gesture:null,action:p,hasEagerState:!1,eagerState:null,next:null};if(A0(u))cD(h,I);else{var C=u.alternate;if(u.lanes===0&&(C===null||C.lanes===0)&&(C=h.lastRenderedReducer,C!==null))try{var z=h.lastRenderedState,W=C(z,p);if(I.hasEagerState=!0,I.eagerState=W,Oi(W,z))return l0(u,h,I,0),zn===null&&a0(),!1}catch{}if(p=jS(u,h,I,g),p!==null)return wi(p,u,g),hD(p,h,g),!0}return!1}function AI(u,h,p,g){if(g={lane:2,revertLane:oT(),gesture:null,action:g,hasEagerState:!1,eagerState:null,next:null},A0(u)){if(h)throw Error(s(479))}else h=jS(u,p,g,2),h!==null&&wi(h,u,2)}function A0(u){var h=u.alternate;return u===Me||h!==null&&h===Me}function cD(u,h){Zf=v0=!0;var p=u.pending;p===null?h.next=h:(h.next=p.next,p.next=h),u.pending=h}function hD(u,h,p){if((p&4194048)!==0){var g=h.lanes;g&=u.pendingLanes,p|=g,h.lanes=p,Kp(u,p)}}var $m={readContext:Er,use:T0,useCallback:ps,useContext:ps,useEffect:ps,useImperativeHandle:ps,useLayoutEffect:ps,useInsertionEffect:ps,useMemo:ps,useReducer:ps,useRef:ps,useState:ps,useDebugValue:ps,useDeferredValue:ps,useTransition:ps,useSyncExternalStore:ps,useId:ps,useHostTransitionStatus:ps,useFormState:ps,useActionState:ps,useOptimistic:ps,useMemoCache:ps,useCacheRefresh:ps};$m.useEffectEvent=ps;var fD={readContext:Er,use:T0,useCallback:function(u,h){return Zr().memoizedState=[u,h===void 0?null:h],u},useContext:Er,useEffect:XR,useImperativeHandle:function(u,h,p){p=p!=null?p.concat([u]):null,E0(4194308,4,JR.bind(null,h,u),p)},useLayoutEffect:function(u,h){return E0(4194308,4,u,h)},useInsertionEffect:function(u,h){E0(4,2,u,h)},useMemo:function(u,h){var p=Zr();h=h===void 0?null:h;var g=u();if(lh){Ct(!0);try{u()}finally{Ct(!1)}}return p.memoizedState=[g,h],g},useReducer:function(u,h,p){var g=Zr();if(p!==void 0){var I=p(h);if(lh){Ct(!0);try{p(h)}finally{Ct(!1)}}}else I=h;return g.memoizedState=g.baseState=I,u={pending:null,lanes:0,dispatch:null,lastRenderedReducer:u,lastRenderedState:I},g.queue=u,u=u.dispatch=p7.bind(null,Me,u),[g.memoizedState,u]},useRef:function(u){var h=Zr();return u={current:u},h.memoizedState=u},useState:function(u){u=vI(u);var h=u.queue,p=uD.bind(null,Me,h);return h.dispatch=p,[u.memoizedState,p]},useDebugValue:TI,useDeferredValue:function(u,h){var p=Zr();return CI(p,u,h)},useTransition:function(){var u=vI(!1);return u=rD.bind(null,Me,u.queue,!0,!1),Zr().memoizedState=u,[!1,u]},useSyncExternalStore:function(u,h,p){var g=Me,I=Zr();if(tn){if(p===void 0)throw Error(s(407));p=p()}else{if(p=h(),zn===null)throw Error(s(349));(Ke&127)!==0||DR(g,h,p)}I.memoizedState=p;var C={value:p,getSnapshot:h};return I.queue=C,XR(FR.bind(null,g,C,u),[u]),g.flags|=2048,td(9,{destroy:void 0},OR.bind(null,g,C,p,h),null),p},useId:function(){var u=Zr(),h=zn.identifierPrefix;if(tn){var p=Fa,g=Oa;p=(g&~(1<<32-Mt(g)-1)).toString(32)+p,h="_"+h+"R_"+p,p=S0++,0<p&&(h+="H"+p.toString(32)),h+="_"}else p=a7++,h="_"+h+"r_"+p.toString(32)+"_";return u.memoizedState=h},useHostTransitionStatus:$I,useFormState:WR,useActionState:WR,useOptimistic:function(u){var h=Zr();h.memoizedState=h.baseState=u;var p={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return h.queue=p,h=AI.bind(null,Me,!0,p),p.dispatch=h,[u,h]},useMemoCache:bI,useCacheRefresh:function(){return Zr().memoizedState=d7.bind(null,Me)},useEffectEvent:function(u){var h=Zr(),p={impl:u};return h.memoizedState=p,function(){if((yn&2)!==0)throw Error(s(440));return p.impl.apply(void 0,arguments)}}},kI={readContext:Er,use:T0,useCallback:eD,useContext:Er,useEffect:II,useImperativeHandle:tD,useInsertionEffect:QR,useLayoutEffect:ZR,useMemo:nD,useReducer:C0,useRef:KR,useState:function(){return C0(_l)},useDebugValue:TI,useDeferredValue:function(u,h){var p=Cs();return sD(p,Dn.memoizedState,u,h)},useTransition:function(){var u=C0(_l)[0],h=Cs().memoizedState;return[typeof u=="boolean"?u:Cm(u),h]},useSyncExternalStore:RR,useId:aD,useHostTransitionStatus:$I,useFormState:jR,useActionState:jR,useOptimistic:function(u,h){var p=Cs();return zR(p,Dn,u,h)},useMemoCache:bI,useCacheRefresh:lD};kI.useEffectEvent=YR;var dD={readContext:Er,use:T0,useCallback:eD,useContext:Er,useEffect:II,useImperativeHandle:tD,useInsertionEffect:QR,useLayoutEffect:ZR,useMemo:nD,useReducer:wI,useRef:KR,useState:function(){return wI(_l)},useDebugValue:TI,useDeferredValue:function(u,h){var p=Cs();return Dn===null?CI(p,u,h):sD(p,Dn.memoizedState,u,h)},useTransition:function(){var u=wI(_l)[0],h=Cs().memoizedState;return[typeof u=="boolean"?u:Cm(u),h]},useSyncExternalStore:RR,useId:aD,useHostTransitionStatus:$I,useFormState:HR,useActionState:HR,useOptimistic:function(u,h){var p=Cs();return Dn!==null?zR(p,Dn,u,h):(p.baseState=u,[u,p.queue.dispatch])},useMemoCache:bI,useCacheRefresh:lD};dD.useEffectEvent=YR;function _I(u,h,p,g){h=u.memoizedState,p=p(g,h),p=p==null?h:d({},h,p),u.memoizedState=p,u.lanes===0&&(u.updateQueue.baseState=p)}var NI={enqueueSetState:function(u,h,p){u=u._reactInternals;var g=Pi(),I=Eu(g);I.payload=h,p!=null&&(I.callback=p),h=$u(u,I,g),h!==null&&(wi(h,u,g),vm(h,u,g))},enqueueReplaceState:function(u,h,p){u=u._reactInternals;var g=Pi(),I=Eu(g);I.tag=1,I.payload=h,p!=null&&(I.callback=p),h=$u(u,I,g),h!==null&&(wi(h,u,g),vm(h,u,g))},enqueueForceUpdate:function(u,h){u=u._reactInternals;var p=Pi(),g=Eu(p);g.tag=2,h!=null&&(g.callback=h),h=$u(u,g,p),h!==null&&(wi(h,u,p),vm(h,u,p))}};function pD(u,h,p,g,I,C,z){return u=u.stateNode,typeof u.shouldComponentUpdate=="function"?u.shouldComponentUpdate(g,C,z):h.prototype&&h.prototype.isPureReactComponent?!dm(p,g)||!dm(I,C):!0}function mD(u,h,p,g){u=h.state,typeof h.componentWillReceiveProps=="function"&&h.componentWillReceiveProps(p,g),typeof h.UNSAFE_componentWillReceiveProps=="function"&&h.UNSAFE_componentWillReceiveProps(p,g),h.state!==u&&NI.enqueueReplaceState(h,h.state,null)}function uh(u,h){var p=h;if("ref"in h){p={};for(var g in h)g!=="ref"&&(p[g]=h[g])}if(u=u.defaultProps){p===h&&(p=d({},p));for(var I in u)p[I]===void 0&&(p[I]=u[I])}return p}function gD(u){o0(u)}function yD(u){console.error(u)}function bD(u){o0(u)}function k0(u,h){try{var p=u.onUncaughtError;p(h.value,{componentStack:h.stack})}catch(g){setTimeout(function(){throw g})}}function xD(u,h,p){try{var g=u.onCaughtError;g(p.value,{componentStack:p.stack,errorBoundary:h.tag===1?h.stateNode:null})}catch(I){setTimeout(function(){throw I})}}function RI(u,h,p){return p=Eu(p),p.tag=3,p.payload={element:null},p.callback=function(){k0(u,h)},p}function wD(u){return u=Eu(u),u.tag=3,u}function vD(u,h,p,g){var I=p.type.getDerivedStateFromError;if(typeof I=="function"){var C=g.value;u.payload=function(){return I(C)},u.callback=function(){xD(h,p,g)}}var z=p.stateNode;z!==null&&typeof z.componentDidCatch=="function"&&(u.callback=function(){xD(h,p,g),typeof I!="function"&&(Du===null?Du=new Set([this]):Du.add(this));var W=g.stack;this.componentDidCatch(g.value,{componentStack:W!==null?W:""})})}function m7(u,h,p,g,I){if(p.flags|=32768,g!==null&&typeof g=="object"&&typeof g.then=="function"){if(h=p.alternate,h!==null&&qf(h,p,I,!0),p=Mi.current,p!==null){switch(p.tag){case 31:case 13:return oo===null?V0():p.alternate===null&&ms===0&&(ms=3),p.flags&=-257,p.flags|=65536,p.lanes=I,g===g0?p.flags|=16384:(h=p.updateQueue,h===null?p.updateQueue=new Set([g]):h.add(g),sT(u,g,I)),!1;case 22:return p.flags|=65536,g===g0?p.flags|=16384:(h=p.updateQueue,h===null?(h={transitions:null,markerInstances:null,retryQueue:new Set([g])},p.updateQueue=h):(p=h.retryQueue,p===null?h.retryQueue=new Set([g]):p.add(g)),sT(u,g,I)),!1}throw Error(s(435,p.tag))}return sT(u,g,I),V0(),!1}if(tn)return h=Mi.current,h!==null?((h.flags&65536)===0&&(h.flags|=256),h.flags|=65536,h.lanes=I,g!==QS&&(u=Error(s(422),{cause:g}),gm(no(u,p)))):(g!==QS&&(h=Error(s(423),{cause:g}),gm(no(h,p))),u=u.current.alternate,u.flags|=65536,I&=-I,u.lanes|=I,g=no(g,p),I=RI(u.stateNode,g,I),lI(u,I),ms!==4&&(ms=2)),!1;var C=Error(s(520),{cause:g});if(C=no(C,p),Fm===null?Fm=[C]:Fm.push(C),ms!==4&&(ms=2),h===null)return!0;g=no(g,p),p=h;do{switch(p.tag){case 3:return p.flags|=65536,u=I&-I,p.lanes|=u,u=RI(p.stateNode,g,u),lI(p,u),!1;case 1:if(h=p.type,C=p.stateNode,(p.flags&128)===0&&(typeof h.getDerivedStateFromError=="function"||C!==null&&typeof C.componentDidCatch=="function"&&(Du===null||!Du.has(C))))return p.flags|=65536,I&=-I,p.lanes|=I,I=wD(I),vD(I,u,p,g),lI(p,I),!1}p=p.return}while(p!==null);return!1}var DI=Error(s(461)),zs=!1;function $r(u,h,p,g){h.child=u===null?CR(h,null,p,g):ah(h,u.child,p,g)}function SD(u,h,p,g,I){p=p.render;var C=h.ref;if("ref"in g){var z={};for(var W in g)W!=="ref"&&(z[W]=g[W])}else z=g;return sh(h),g=pI(u,h,p,z,C,I),W=mI(),u!==null&&!zs?(gI(u,h,I),Nl(u,h,I)):(tn&&W&&XS(h),h.flags|=1,$r(u,h,g,I),h.child)}function ID(u,h,p,g,I){if(u===null){var C=p.type;return typeof C=="function"&&!qS(C)&&C.defaultProps===void 0&&p.compare===null?(h.tag=15,h.type=C,TD(u,h,C,g,I)):(u=c0(p.type,null,g,h,h.mode,I),u.ref=h.ref,u.return=h,h.child=u)}if(C=u.child,!VI(u,I)){var z=C.memoizedProps;if(p=p.compare,p=p!==null?p:dm,p(z,g)&&u.ref===h.ref)return Nl(u,h,I)}return h.flags|=1,u=Cl(C,g),u.ref=h.ref,u.return=h,h.child=u}function TD(u,h,p,g,I){if(u!==null){var C=u.memoizedProps;if(dm(C,g)&&u.ref===h.ref)if(zs=!1,h.pendingProps=g=C,VI(u,I))(u.flags&131072)!==0&&(zs=!0);else return h.lanes=u.lanes,Nl(u,h,I)}return OI(u,h,p,g,I)}function CD(u,h,p,g){var I=g.children,C=u!==null?u.memoizedState:null;if(u===null&&h.stateNode===null&&(h.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),g.mode==="hidden"){if((h.flags&128)!==0){if(C=C!==null?C.baseLanes|p:p,u!==null){for(g=h.child=u.child,I=0;g!==null;)I=I|g.lanes|g.childLanes,g=g.sibling;g=I&~C}else g=0,h.child=null;return ED(u,h,C,p,g)}if((p&536870912)!==0)h.memoizedState={baseLanes:0,cachePool:null},u!==null&&p0(h,C!==null?C.cachePool:null),C!==null?AR(h,C):cI(),kR(h);else return g=h.lanes=536870912,ED(u,h,C!==null?C.baseLanes|p:p,p,g)}else C!==null?(p0(h,C.cachePool),AR(h,C),ku(),h.memoizedState=null):(u!==null&&p0(h,null),cI(),ku());return $r(u,h,I,p),h.child}function Am(u,h){return u!==null&&u.tag===22||h.stateNode!==null||(h.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),h.sibling}function ED(u,h,p,g,I){var C=rI();return C=C===null?null:{parent:Ms._currentValue,pool:C},h.memoizedState={baseLanes:p,cachePool:C},u!==null&&p0(h,null),cI(),kR(h),u!==null&&qf(u,h,g,!0),h.childLanes=I,null}function _0(u,h){return h=R0({mode:h.mode,children:h.children},u.mode),h.ref=u.ref,u.child=h,h.return=u,h}function $D(u,h,p){return ah(h,u.child,null,p),u=_0(h,h.pendingProps),u.flags|=2,Li(h),h.memoizedState=null,u}function g7(u,h,p){var g=h.pendingProps,I=(h.flags&128)!==0;if(h.flags&=-129,u===null){if(tn){if(g.mode==="hidden")return u=_0(h,g),h.lanes=536870912,Am(null,u);if(fI(h),(u=Xn)?(u=BO(u,io),u=u!==null&&u.data==="&"?u:null,u!==null&&(h.memoizedState={dehydrated:u,treeContext:vu!==null?{id:Oa,overflow:Fa}:null,retryLane:536870912,hydrationErrors:null},p=cR(u),p.return=h,h.child=p,Cr=h,Xn=null)):u=null,u===null)throw Iu(h);return h.lanes=536870912,null}return _0(h,g)}var C=u.memoizedState;if(C!==null){var z=C.dehydrated;if(fI(h),I)if(h.flags&256)h.flags&=-257,h=$D(u,h,p);else if(h.memoizedState!==null)h.child=u.child,h.flags|=128,h=null;else throw Error(s(558));else if(zs||qf(u,h,p,!1),I=(p&u.childLanes)!==0,zs||I){if(g=zn,g!==null&&(z=Xp(g,p),z!==0&&z!==C.retryLane))throw C.retryLane=z,Jc(u,z),wi(g,u,z),DI;V0(),h=$D(u,h,p)}else u=C.treeContext,Xn=ao(z.nextSibling),Cr=h,tn=!0,Su=null,io=!1,u!==null&&dR(h,u),h=_0(h,g),h.flags|=4096;return h}return u=Cl(u.child,{mode:g.mode,children:g.children}),u.ref=h.ref,h.child=u,u.return=h,u}function N0(u,h){var p=h.ref;if(p===null)u!==null&&u.ref!==null&&(h.flags|=4194816);else{if(typeof p!="function"&&typeof p!="object")throw Error(s(284));(u===null||u.ref!==p)&&(h.flags|=4194816)}}function OI(u,h,p,g,I){return sh(h),p=pI(u,h,p,g,void 0,I),g=mI(),u!==null&&!zs?(gI(u,h,I),Nl(u,h,I)):(tn&&g&&XS(h),h.flags|=1,$r(u,h,p,I),h.child)}function AD(u,h,p,g,I,C){return sh(h),h.updateQueue=null,p=NR(h,g,p,I),_R(u),g=mI(),u!==null&&!zs?(gI(u,h,C),Nl(u,h,C)):(tn&&g&&XS(h),h.flags|=1,$r(u,h,p,C),h.child)}function kD(u,h,p,g,I){if(sh(h),h.stateNode===null){var C=Uf,z=p.contextType;typeof z=="object"&&z!==null&&(C=Er(z)),C=new p(g,C),h.memoizedState=C.state!==null&&C.state!==void 0?C.state:null,C.updater=NI,h.stateNode=C,C._reactInternals=h,C=h.stateNode,C.props=g,C.state=h.memoizedState,C.refs={},oI(h),z=p.contextType,C.context=typeof z=="object"&&z!==null?Er(z):Uf,C.state=h.memoizedState,z=p.getDerivedStateFromProps,typeof z=="function"&&(_I(h,p,z,g),C.state=h.memoizedState),typeof p.getDerivedStateFromProps=="function"||typeof C.getSnapshotBeforeUpdate=="function"||typeof C.UNSAFE_componentWillMount!="function"&&typeof C.componentWillMount!="function"||(z=C.state,typeof C.componentWillMount=="function"&&C.componentWillMount(),typeof C.UNSAFE_componentWillMount=="function"&&C.UNSAFE_componentWillMount(),z!==C.state&&NI.enqueueReplaceState(C,C.state,null),Im(h,g,C,I),Sm(),C.state=h.memoizedState),typeof C.componentDidMount=="function"&&(h.flags|=4194308),g=!0}else if(u===null){C=h.stateNode;var W=h.memoizedProps,it=uh(p,W);C.props=it;var Tt=C.context,Bt=p.contextType;z=Uf,typeof Bt=="object"&&Bt!==null&&(z=Er(Bt));var Ut=p.getDerivedStateFromProps;Bt=typeof Ut=="function"||typeof C.getSnapshotBeforeUpdate=="function",W=h.pendingProps!==W,Bt||typeof C.UNSAFE_componentWillReceiveProps!="function"&&typeof C.componentWillReceiveProps!="function"||(W||Tt!==z)&&mD(h,C,g,z),Cu=!1;var $t=h.memoizedState;C.state=$t,Im(h,g,C,I),Sm(),Tt=h.memoizedState,W||$t!==Tt||Cu?(typeof Ut=="function"&&(_I(h,p,Ut,g),Tt=h.memoizedState),(it=Cu||pD(h,p,it,g,$t,Tt,z))?(Bt||typeof C.UNSAFE_componentWillMount!="function"&&typeof C.componentWillMount!="function"||(typeof C.componentWillMount=="function"&&C.componentWillMount(),typeof C.UNSAFE_componentWillMount=="function"&&C.UNSAFE_componentWillMount()),typeof C.componentDidMount=="function"&&(h.flags|=4194308)):(typeof C.componentDidMount=="function"&&(h.flags|=4194308),h.memoizedProps=g,h.memoizedState=Tt),C.props=g,C.state=Tt,C.context=z,g=it):(typeof C.componentDidMount=="function"&&(h.flags|=4194308),g=!1)}else{C=h.stateNode,aI(u,h),z=h.memoizedProps,Bt=uh(p,z),C.props=Bt,Ut=h.pendingProps,$t=C.context,Tt=p.contextType,it=Uf,typeof Tt=="object"&&Tt!==null&&(it=Er(Tt)),W=p.getDerivedStateFromProps,(Tt=typeof W=="function"||typeof C.getSnapshotBeforeUpdate=="function")||typeof C.UNSAFE_componentWillReceiveProps!="function"&&typeof C.componentWillReceiveProps!="function"||(z!==Ut||$t!==it)&&mD(h,C,g,it),Cu=!1,$t=h.memoizedState,C.state=$t,Im(h,g,C,I),Sm();var Rt=h.memoizedState;z!==Ut||$t!==Rt||Cu||u!==null&&u.dependencies!==null&&f0(u.dependencies)?(typeof W=="function"&&(_I(h,p,W,g),Rt=h.memoizedState),(Bt=Cu||pD(h,p,Bt,g,$t,Rt,it)||u!==null&&u.dependencies!==null&&f0(u.dependencies))?(Tt||typeof C.UNSAFE_componentWillUpdate!="function"&&typeof C.componentWillUpdate!="function"||(typeof C.componentWillUpdate=="function"&&C.componentWillUpdate(g,Rt,it),typeof C.UNSAFE_componentWillUpdate=="function"&&C.UNSAFE_componentWillUpdate(g,Rt,it)),typeof C.componentDidUpdate=="function"&&(h.flags|=4),typeof C.getSnapshotBeforeUpdate=="function"&&(h.flags|=1024)):(typeof C.componentDidUpdate!="function"||z===u.memoizedProps&&$t===u.memoizedState||(h.flags|=4),typeof C.getSnapshotBeforeUpdate!="function"||z===u.memoizedProps&&$t===u.memoizedState||(h.flags|=1024),h.memoizedProps=g,h.memoizedState=Rt),C.props=g,C.state=Rt,C.context=it,g=Bt):(typeof C.componentDidUpdate!="function"||z===u.memoizedProps&&$t===u.memoizedState||(h.flags|=4),typeof C.getSnapshotBeforeUpdate!="function"||z===u.memoizedProps&&$t===u.memoizedState||(h.flags|=1024),g=!1)}return C=g,N0(u,h),g=(h.flags&128)!==0,C||g?(C=h.stateNode,p=g&&typeof p.getDerivedStateFromError!="function"?null:C.render(),h.flags|=1,u!==null&&g?(h.child=ah(h,u.child,null,I),h.child=ah(h,null,p,I)):$r(u,h,p,I),h.memoizedState=C.state,u=h.child):u=Nl(u,h,I),u}function _D(u,h,p,g){return eh(),h.flags|=256,$r(u,h,p,g),h.child}var FI={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function MI(u){return{baseLanes:u,cachePool:xR()}}function LI(u,h,p){return u=u!==null?u.childLanes&~p:0,h&&(u|=Bi),u}function ND(u,h,p){var g=h.pendingProps,I=!1,C=(h.flags&128)!==0,z;if((z=C)||(z=u!==null&&u.memoizedState===null?!1:(Ts.current&2)!==0),z&&(I=!0,h.flags&=-129),z=(h.flags&32)!==0,h.flags&=-33,u===null){if(tn){if(I?Au(h):ku(),(u=Xn)?(u=BO(u,io),u=u!==null&&u.data!=="&"?u:null,u!==null&&(h.memoizedState={dehydrated:u,treeContext:vu!==null?{id:Oa,overflow:Fa}:null,retryLane:536870912,hydrationErrors:null},p=cR(u),p.return=h,h.child=p,Cr=h,Xn=null)):u=null,u===null)throw Iu(h);return xT(u)?h.lanes=32:h.lanes=536870912,null}var W=g.children;return g=g.fallback,I?(ku(),I=h.mode,W=R0({mode:"hidden",children:W},I),g=th(g,I,p,null),W.return=h,g.return=h,W.sibling=g,h.child=W,g=h.child,g.memoizedState=MI(p),g.childLanes=LI(u,z,p),h.memoizedState=FI,Am(null,g)):(Au(h),zI(h,W))}var it=u.memoizedState;if(it!==null&&(W=it.dehydrated,W!==null)){if(C)h.flags&256?(Au(h),h.flags&=-257,h=BI(u,h,p)):h.memoizedState!==null?(ku(),h.child=u.child,h.flags|=128,h=null):(ku(),W=g.fallback,I=h.mode,g=R0({mode:"visible",children:g.children},I),W=th(W,I,p,null),W.flags|=2,g.return=h,W.return=h,g.sibling=W,h.child=g,ah(h,u.child,null,p),g=h.child,g.memoizedState=MI(p),g.childLanes=LI(u,z,p),h.memoizedState=FI,h=Am(null,g));else if(Au(h),xT(W)){if(z=W.nextSibling&&W.nextSibling.dataset,z)var Tt=z.dgst;z=Tt,g=Error(s(419)),g.stack="",g.digest=z,gm({value:g,source:null,stack:null}),h=BI(u,h,p)}else if(zs||qf(u,h,p,!1),z=(p&u.childLanes)!==0,zs||z){if(z=zn,z!==null&&(g=Xp(z,p),g!==0&&g!==it.retryLane))throw it.retryLane=g,Jc(u,g),wi(z,u,g),DI;bT(W)||V0(),h=BI(u,h,p)}else bT(W)?(h.flags|=192,h.child=u.child,h=null):(u=it.treeContext,Xn=ao(W.nextSibling),Cr=h,tn=!0,Su=null,io=!1,u!==null&&dR(h,u),h=zI(h,g.children),h.flags|=4096);return h}return I?(ku(),W=g.fallback,I=h.mode,it=u.child,Tt=it.sibling,g=Cl(it,{mode:"hidden",children:g.children}),g.subtreeFlags=it.subtreeFlags&65011712,Tt!==null?W=Cl(Tt,W):(W=th(W,I,p,null),W.flags|=2),W.return=h,g.return=h,g.sibling=W,h.child=g,Am(null,g),g=h.child,W=u.child.memoizedState,W===null?W=MI(p):(I=W.cachePool,I!==null?(it=Ms._currentValue,I=I.parent!==it?{parent:it,pool:it}:I):I=xR(),W={baseLanes:W.baseLanes|p,cachePool:I}),g.memoizedState=W,g.childLanes=LI(u,z,p),h.memoizedState=FI,Am(u.child,g)):(Au(h),p=u.child,u=p.sibling,p=Cl(p,{mode:"visible",children:g.children}),p.return=h,p.sibling=null,u!==null&&(z=h.deletions,z===null?(h.deletions=[u],h.flags|=16):z.push(u)),h.child=p,h.memoizedState=null,p)}function zI(u,h){return h=R0({mode:"visible",children:h},u.mode),h.return=u,u.child=h}function R0(u,h){return u=Fi(22,u,null,h),u.lanes=0,u}function BI(u,h,p){return ah(h,u.child,null,p),u=zI(h,h.pendingProps.children),u.flags|=2,h.memoizedState=null,u}function RD(u,h,p){u.lanes|=h;var g=u.alternate;g!==null&&(g.lanes|=h),tI(u.return,h,p)}function PI(u,h,p,g,I,C){var z=u.memoizedState;z===null?u.memoizedState={isBackwards:h,rendering:null,renderingStartTime:0,last:g,tail:p,tailMode:I,treeForkCount:C}:(z.isBackwards=h,z.rendering=null,z.renderingStartTime=0,z.last=g,z.tail=p,z.tailMode=I,z.treeForkCount=C)}function DD(u,h,p){var g=h.pendingProps,I=g.revealOrder,C=g.tail;g=g.children;var z=Ts.current,W=(z&2)!==0;if(W?(z=z&1|2,h.flags|=128):z&=1,U(Ts,z),$r(u,h,g,p),g=tn?mm:0,!W&&u!==null&&(u.flags&128)!==0)t:for(u=h.child;u!==null;){if(u.tag===13)u.memoizedState!==null&&RD(u,p,h);else if(u.tag===19)RD(u,p,h);else if(u.child!==null){u.child.return=u,u=u.child;continue}if(u===h)break t;for(;u.sibling===null;){if(u.return===null||u.return===h)break t;u=u.return}u.sibling.return=u.return,u=u.sibling}switch(I){case"forwards":for(p=h.child,I=null;p!==null;)u=p.alternate,u!==null&&w0(u)===null&&(I=p),p=p.sibling;p=I,p===null?(I=h.child,h.child=null):(I=p.sibling,p.sibling=null),PI(h,!1,I,p,C,g);break;case"backwards":case"unstable_legacy-backwards":for(p=null,I=h.child,h.child=null;I!==null;){if(u=I.alternate,u!==null&&w0(u)===null){h.child=I;break}u=I.sibling,I.sibling=p,p=I,I=u}PI(h,!0,p,null,C,g);break;case"together":PI(h,!1,null,null,void 0,g);break;default:h.memoizedState=null}return h.child}function Nl(u,h,p){if(u!==null&&(h.dependencies=u.dependencies),Ru|=h.lanes,(p&h.childLanes)===0)if(u!==null){if(qf(u,h,p,!1),(p&h.childLanes)===0)return null}else return null;if(u!==null&&h.child!==u.child)throw Error(s(153));if(h.child!==null){for(u=h.child,p=Cl(u,u.pendingProps),h.child=p,p.return=h;u.sibling!==null;)u=u.sibling,p=p.sibling=Cl(u,u.pendingProps),p.return=h;p.sibling=null}return h.child}function VI(u,h){return(u.lanes&h)!==0?!0:(u=u.dependencies,!!(u!==null&&f0(u)))}function y7(u,h,p){switch(h.tag){case 3:qt(h,h.stateNode.containerInfo),Tu(h,Ms,u.memoizedState.cache),eh();break;case 27:case 5:Wt(h);break;case 4:qt(h,h.stateNode.containerInfo);break;case 10:Tu(h,h.type,h.memoizedProps.value);break;case 31:if(h.memoizedState!==null)return h.flags|=128,fI(h),null;break;case 13:var g=h.memoizedState;if(g!==null)return g.dehydrated!==null?(Au(h),h.flags|=128,null):(p&h.child.childLanes)!==0?ND(u,h,p):(Au(h),u=Nl(u,h,p),u!==null?u.sibling:null);Au(h);break;case 19:var I=(u.flags&128)!==0;if(g=(p&h.childLanes)!==0,g||(qf(u,h,p,!1),g=(p&h.childLanes)!==0),I){if(g)return DD(u,h,p);h.flags|=128}if(I=h.memoizedState,I!==null&&(I.rendering=null,I.tail=null,I.lastEffect=null),U(Ts,Ts.current),g)break;return null;case 22:return h.lanes=0,CD(u,h,p,h.pendingProps);case 24:Tu(h,Ms,u.memoizedState.cache)}return Nl(u,h,p)}function OD(u,h,p){if(u!==null)if(u.memoizedProps!==h.pendingProps)zs=!0;else{if(!VI(u,p)&&(h.flags&128)===0)return zs=!1,y7(u,h,p);zs=(u.flags&131072)!==0}else zs=!1,tn&&(h.flags&1048576)!==0&&fR(h,mm,h.index);switch(h.lanes=0,h.tag){case 16:t:{var g=h.pendingProps;if(u=ih(h.elementType),h.type=u,typeof u=="function")qS(u)?(g=uh(u,g),h.tag=1,h=kD(null,h,u,g,p)):(h.tag=0,h=OI(null,h,u,g,p));else{if(u!=null){var I=u.$$typeof;if(I===E){h.tag=11,h=SD(null,h,u,g,p);break t}else if(I===N){h.tag=14,h=ID(null,h,u,g,p);break t}}throw h=tt(u)||u,Error(s(306,h,""))}}return h;case 0:return OI(u,h,h.type,h.pendingProps,p);case 1:return g=h.type,I=uh(g,h.pendingProps),kD(u,h,g,I,p);case 3:t:{if(qt(h,h.stateNode.containerInfo),u===null)throw Error(s(387));g=h.pendingProps;var C=h.memoizedState;I=C.element,aI(u,h),Im(h,g,null,p);var z=h.memoizedState;if(g=z.cache,Tu(h,Ms,g),g!==C.cache&&eI(h,[Ms],p,!0),Sm(),g=z.element,C.isDehydrated)if(C={element:g,isDehydrated:!1,cache:z.cache},h.updateQueue.baseState=C,h.memoizedState=C,h.flags&256){h=_D(u,h,g,p);break t}else if(g!==I){I=no(Error(s(424)),h),gm(I),h=_D(u,h,g,p);break t}else for(u=h.stateNode.containerInfo,u.nodeType===9?u=u.body:u=u.nodeName==="HTML"?u.ownerDocument.body:u,Xn=ao(u.firstChild),Cr=h,tn=!0,Su=null,io=!0,p=CR(h,null,g,p),h.child=p;p;)p.flags=p.flags&-3|4096,p=p.sibling;else{if(eh(),g===I){h=Nl(u,h,p);break t}$r(u,h,g,p)}h=h.child}return h;case 26:return N0(u,h),u===null?(p=jO(h.type,null,h.pendingProps,null))?h.memoizedState=p:tn||(p=h.type,u=h.pendingProps,g=K0(xt.current).createElement(p),g[Ds]=h,g[hr]=u,Ar(g,p,u),Os(g),h.stateNode=g):h.memoizedState=jO(h.type,u.memoizedProps,h.pendingProps,u.memoizedState),null;case 27:return Wt(h),u===null&&tn&&(g=h.stateNode=UO(h.type,h.pendingProps,xt.current),Cr=h,io=!0,I=Xn,Lu(h.type)?(wT=I,Xn=ao(g.firstChild)):Xn=I),$r(u,h,h.pendingProps.children,p),N0(u,h),u===null&&(h.flags|=4194304),h.child;case 5:return u===null&&tn&&((I=g=Xn)&&(g=H7(g,h.type,h.pendingProps,io),g!==null?(h.stateNode=g,Cr=h,Xn=ao(g.firstChild),io=!1,I=!0):I=!1),I||Iu(h)),Wt(h),I=h.type,C=h.pendingProps,z=u!==null?u.memoizedProps:null,g=C.children,mT(I,C)?g=null:z!==null&&mT(I,z)&&(h.flags|=32),h.memoizedState!==null&&(I=pI(u,h,l7,null,null,p),Gm._currentValue=I),N0(u,h),$r(u,h,g,p),h.child;case 6:return u===null&&tn&&((u=p=Xn)&&(p=K7(p,h.pendingProps,io),p!==null?(h.stateNode=p,Cr=h,Xn=null,u=!0):u=!1),u||Iu(h)),null;case 13:return ND(u,h,p);case 4:return qt(h,h.stateNode.containerInfo),g=h.pendingProps,u===null?h.child=ah(h,null,g,p):$r(u,h,g,p),h.child;case 11:return SD(u,h,h.type,h.pendingProps,p);case 7:return $r(u,h,h.pendingProps,p),h.child;case 8:return $r(u,h,h.pendingProps.children,p),h.child;case 12:return $r(u,h,h.pendingProps.children,p),h.child;case 10:return g=h.pendingProps,Tu(h,h.type,g.value),$r(u,h,g.children,p),h.child;case 9:return I=h.type._context,g=h.pendingProps.children,sh(h),I=Er(I),g=g(I),h.flags|=1,$r(u,h,g,p),h.child;case 14:return ID(u,h,h.type,h.pendingProps,p);case 15:return TD(u,h,h.type,h.pendingProps,p);case 19:return DD(u,h,p);case 31:return g7(u,h,p);case 22:return CD(u,h,p,h.pendingProps);case 24:return sh(h),g=Er(Ms),u===null?(I=rI(),I===null&&(I=zn,C=nI(),I.pooledCache=C,C.refCount++,C!==null&&(I.pooledCacheLanes|=p),I=C),h.memoizedState={parent:g,cache:I},oI(h),Tu(h,Ms,I)):((u.lanes&p)!==0&&(aI(u,h),Im(h,null,null,p),Sm()),I=u.memoizedState,C=h.memoizedState,I.parent!==g?(I={parent:g,cache:g},h.memoizedState=I,h.lanes===0&&(h.memoizedState=h.updateQueue.baseState=I),Tu(h,Ms,g)):(g=C.cache,Tu(h,Ms,g),g!==I.cache&&eI(h,[Ms],p,!0))),$r(u,h,h.pendingProps.children,p),h.child;case 29:throw h.pendingProps}throw Error(s(156,h.tag))}function Rl(u){u.flags|=4}function UI(u,h,p,g,I){if((h=(u.mode&32)!==0)&&(h=!1),h){if(u.flags|=16777216,(I&335544128)===I)if(u.stateNode.complete)u.flags|=8192;else if(aO())u.flags|=8192;else throw oh=g0,iI}else u.flags&=-16777217}function FD(u,h){if(h.type!=="stylesheet"||(h.state.loading&4)!==0)u.flags&=-16777217;else if(u.flags|=16777216,!YO(h))if(aO())u.flags|=8192;else throw oh=g0,iI}function D0(u,h){h!==null&&(u.flags|=4),u.flags&16384&&(h=u.tag!==22?Bb():536870912,u.lanes|=h,rd|=h)}function km(u,h){if(!tn)switch(u.tailMode){case"hidden":h=u.tail;for(var p=null;h!==null;)h.alternate!==null&&(p=h),h=h.sibling;p===null?u.tail=null:p.sibling=null;break;case"collapsed":p=u.tail;for(var g=null;p!==null;)p.alternate!==null&&(g=p),p=p.sibling;g===null?h||u.tail===null?u.tail=null:u.tail.sibling=null:g.sibling=null}}function Yn(u){var h=u.alternate!==null&&u.alternate.child===u.child,p=0,g=0;if(h)for(var I=u.child;I!==null;)p|=I.lanes|I.childLanes,g|=I.subtreeFlags&65011712,g|=I.flags&65011712,I.return=u,I=I.sibling;else for(I=u.child;I!==null;)p|=I.lanes|I.childLanes,g|=I.subtreeFlags,g|=I.flags,I.return=u,I=I.sibling;return u.subtreeFlags|=g,u.childLanes=p,h}function b7(u,h,p){var g=h.pendingProps;switch(YS(h),h.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Yn(h),null;case 1:return Yn(h),null;case 3:return p=h.stateNode,g=null,u!==null&&(g=u.memoizedState.cache),h.memoizedState.cache!==g&&(h.flags|=2048),Al(Ms),zt(),p.pendingContext&&(p.context=p.pendingContext,p.pendingContext=null),(u===null||u.child===null)&&(jf(h)?Rl(h):u===null||u.memoizedState.isDehydrated&&(h.flags&256)===0||(h.flags|=1024,ZS())),Yn(h),null;case 26:var I=h.type,C=h.memoizedState;return u===null?(Rl(h),C!==null?(Yn(h),FD(h,C)):(Yn(h),UI(h,I,null,g,p))):C?C!==u.memoizedState?(Rl(h),Yn(h),FD(h,C)):(Yn(h),h.flags&=-16777217):(u=u.memoizedProps,u!==g&&Rl(h),Yn(h),UI(h,I,u,g,p)),null;case 27:if(Xt(h),p=xt.current,I=h.type,u!==null&&h.stateNode!=null)u.memoizedProps!==g&&Rl(h);else{if(!g){if(h.stateNode===null)throw Error(s(166));return Yn(h),null}u=X.current,jf(h)?pR(h):(u=UO(I,g,p),h.stateNode=u,Rl(h))}return Yn(h),null;case 5:if(Xt(h),I=h.type,u!==null&&h.stateNode!=null)u.memoizedProps!==g&&Rl(h);else{if(!g){if(h.stateNode===null)throw Error(s(166));return Yn(h),null}if(C=X.current,jf(h))pR(h);else{var z=K0(xt.current);switch(C){case 1:C=z.createElementNS("http://www.w3.org/2000/svg",I);break;case 2:C=z.createElementNS("http://www.w3.org/1998/Math/MathML",I);break;default:switch(I){case"svg":C=z.createElementNS("http://www.w3.org/2000/svg",I);break;case"math":C=z.createElementNS("http://www.w3.org/1998/Math/MathML",I);break;case"script":C=z.createElement("div"),C.innerHTML="<script><\/script>",C=C.removeChild(C.firstChild);break;case"select":C=typeof g.is=="string"?z.createElement("select",{is:g.is}):z.createElement("select"),g.multiple?C.multiple=!0:g.size&&(C.size=g.size);break;default:C=typeof g.is=="string"?z.createElement(I,{is:g.is}):z.createElement(I)}}C[Ds]=h,C[hr]=g;t:for(z=h.child;z!==null;){if(z.tag===5||z.tag===6)C.appendChild(z.stateNode);else if(z.tag!==4&&z.tag!==27&&z.child!==null){z.child.return=z,z=z.child;continue}if(z===h)break t;for(;z.sibling===null;){if(z.return===null||z.return===h)break t;z=z.return}z.sibling.return=z.return,z=z.sibling}h.stateNode=C;t:switch(Ar(C,I,g),I){case"button":case"input":case"select":case"textarea":g=!!g.autoFocus;break t;case"img":g=!0;break t;default:g=!1}g&&Rl(h)}}return Yn(h),UI(h,h.type,u===null?null:u.memoizedProps,h.pendingProps,p),null;case 6:if(u&&h.stateNode!=null)u.memoizedProps!==g&&Rl(h);else{if(typeof g!="string"&&h.stateNode===null)throw Error(s(166));if(u=xt.current,jf(h)){if(u=h.stateNode,p=h.memoizedProps,g=null,I=Cr,I!==null)switch(I.tag){case 27:case 5:g=I.memoizedProps}u[Ds]=h,u=!!(u.nodeValue===p||g!==null&&g.suppressHydrationWarning===!0||NO(u.nodeValue,p)),u||Iu(h,!0)}else u=K0(u).createTextNode(g),u[Ds]=h,h.stateNode=u}return Yn(h),null;case 31:if(p=h.memoizedState,u===null||u.memoizedState!==null){if(g=jf(h),p!==null){if(u===null){if(!g)throw Error(s(318));if(u=h.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(s(557));u[Ds]=h}else eh(),(h.flags&128)===0&&(h.memoizedState=null),h.flags|=4;Yn(h),u=!1}else p=ZS(),u!==null&&u.memoizedState!==null&&(u.memoizedState.hydrationErrors=p),u=!0;if(!u)return h.flags&256?(Li(h),h):(Li(h),null);if((h.flags&128)!==0)throw Error(s(558))}return Yn(h),null;case 13:if(g=h.memoizedState,u===null||u.memoizedState!==null&&u.memoizedState.dehydrated!==null){if(I=jf(h),g!==null&&g.dehydrated!==null){if(u===null){if(!I)throw Error(s(318));if(I=h.memoizedState,I=I!==null?I.dehydrated:null,!I)throw Error(s(317));I[Ds]=h}else eh(),(h.flags&128)===0&&(h.memoizedState=null),h.flags|=4;Yn(h),I=!1}else I=ZS(),u!==null&&u.memoizedState!==null&&(u.memoizedState.hydrationErrors=I),I=!0;if(!I)return h.flags&256?(Li(h),h):(Li(h),null)}return Li(h),(h.flags&128)!==0?(h.lanes=p,h):(p=g!==null,u=u!==null&&u.memoizedState!==null,p&&(g=h.child,I=null,g.alternate!==null&&g.alternate.memoizedState!==null&&g.alternate.memoizedState.cachePool!==null&&(I=g.alternate.memoizedState.cachePool.pool),C=null,g.memoizedState!==null&&g.memoizedState.cachePool!==null&&(C=g.memoizedState.cachePool.pool),C!==I&&(g.flags|=2048)),p!==u&&p&&(h.child.flags|=8192),D0(h,h.updateQueue),Yn(h),null);case 4:return zt(),u===null&&cT(h.stateNode.containerInfo),Yn(h),null;case 10:return Al(h.type),Yn(h),null;case 19:if(et(Ts),g=h.memoizedState,g===null)return Yn(h),null;if(I=(h.flags&128)!==0,C=g.rendering,C===null)if(I)km(g,!1);else{if(ms!==0||u!==null&&(u.flags&128)!==0)for(u=h.child;u!==null;){if(C=w0(u),C!==null){for(h.flags|=128,km(g,!1),u=C.updateQueue,h.updateQueue=u,D0(h,u),h.subtreeFlags=0,u=p,p=h.child;p!==null;)uR(p,u),p=p.sibling;return U(Ts,Ts.current&1|2),tn&&El(h,g.treeForkCount),h.child}u=u.sibling}g.tail!==null&&je()>z0&&(h.flags|=128,I=!0,km(g,!1),h.lanes=4194304)}else{if(!I)if(u=w0(C),u!==null){if(h.flags|=128,I=!0,u=u.updateQueue,h.updateQueue=u,D0(h,u),km(g,!0),g.tail===null&&g.tailMode==="hidden"&&!C.alternate&&!tn)return Yn(h),null}else 2*je()-g.renderingStartTime>z0&&p!==536870912&&(h.flags|=128,I=!0,km(g,!1),h.lanes=4194304);g.isBackwards?(C.sibling=h.child,h.child=C):(u=g.last,u!==null?u.sibling=C:h.child=C,g.last=C)}return g.tail!==null?(u=g.tail,g.rendering=u,g.tail=u.sibling,g.renderingStartTime=je(),u.sibling=null,p=Ts.current,U(Ts,I?p&1|2:p&1),tn&&El(h,g.treeForkCount),u):(Yn(h),null);case 22:case 23:return Li(h),hI(),g=h.memoizedState!==null,u!==null?u.memoizedState!==null!==g&&(h.flags|=8192):g&&(h.flags|=8192),g?(p&536870912)!==0&&(h.flags&128)===0&&(Yn(h),h.subtreeFlags&6&&(h.flags|=8192)):Yn(h),p=h.updateQueue,p!==null&&D0(h,p.retryQueue),p=null,u!==null&&u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(p=u.memoizedState.cachePool.pool),g=null,h.memoizedState!==null&&h.memoizedState.cachePool!==null&&(g=h.memoizedState.cachePool.pool),g!==p&&(h.flags|=2048),u!==null&&et(rh),null;case 24:return p=null,u!==null&&(p=u.memoizedState.cache),h.memoizedState.cache!==p&&(h.flags|=2048),Al(Ms),Yn(h),null;case 25:return null;case 30:return null}throw Error(s(156,h.tag))}function x7(u,h){switch(YS(h),h.tag){case 1:return u=h.flags,u&65536?(h.flags=u&-65537|128,h):null;case 3:return Al(Ms),zt(),u=h.flags,(u&65536)!==0&&(u&128)===0?(h.flags=u&-65537|128,h):null;case 26:case 27:case 5:return Xt(h),null;case 31:if(h.memoizedState!==null){if(Li(h),h.alternate===null)throw Error(s(340));eh()}return u=h.flags,u&65536?(h.flags=u&-65537|128,h):null;case 13:if(Li(h),u=h.memoizedState,u!==null&&u.dehydrated!==null){if(h.alternate===null)throw Error(s(340));eh()}return u=h.flags,u&65536?(h.flags=u&-65537|128,h):null;case 19:return et(Ts),null;case 4:return zt(),null;case 10:return Al(h.type),null;case 22:case 23:return Li(h),hI(),u!==null&&et(rh),u=h.flags,u&65536?(h.flags=u&-65537|128,h):null;case 24:return Al(Ms),null;case 25:return null;default:return null}}function MD(u,h){switch(YS(h),h.tag){case 3:Al(Ms),zt();break;case 26:case 27:case 5:Xt(h);break;case 4:zt();break;case 31:h.memoizedState!==null&&Li(h);break;case 13:Li(h);break;case 19:et(Ts);break;case 10:Al(h.type);break;case 22:case 23:Li(h),hI(),u!==null&&et(rh);break;case 24:Al(Ms)}}function _m(u,h){try{var p=h.updateQueue,g=p!==null?p.lastEffect:null;if(g!==null){var I=g.next;p=I;do{if((p.tag&u)===u){g=void 0;var C=p.create,z=p.inst;g=C(),z.destroy=g}p=p.next}while(p!==I)}}catch(W){kn(h,h.return,W)}}function _u(u,h,p){try{var g=h.updateQueue,I=g!==null?g.lastEffect:null;if(I!==null){var C=I.next;g=C;do{if((g.tag&u)===u){var z=g.inst,W=z.destroy;if(W!==void 0){z.destroy=void 0,I=h;var it=p,Tt=W;try{Tt()}catch(Bt){kn(I,it,Bt)}}}g=g.next}while(g!==C)}}catch(Bt){kn(h,h.return,Bt)}}function LD(u){var h=u.updateQueue;if(h!==null){var p=u.stateNode;try{$R(h,p)}catch(g){kn(u,u.return,g)}}}function zD(u,h,p){p.props=uh(u.type,u.memoizedProps),p.state=u.memoizedState;try{p.componentWillUnmount()}catch(g){kn(u,h,g)}}function Nm(u,h){try{var p=u.ref;if(p!==null){switch(u.tag){case 26:case 27:case 5:var g=u.stateNode;break;case 30:g=u.stateNode;break;default:g=u.stateNode}typeof p=="function"?u.refCleanup=p(g):p.current=g}}catch(I){kn(u,h,I)}}function Ma(u,h){var p=u.ref,g=u.refCleanup;if(p!==null)if(typeof g=="function")try{g()}catch(I){kn(u,h,I)}finally{u.refCleanup=null,u=u.alternate,u!=null&&(u.refCleanup=null)}else if(typeof p=="function")try{p(null)}catch(I){kn(u,h,I)}else p.current=null}function BD(u){var h=u.type,p=u.memoizedProps,g=u.stateNode;try{t:switch(h){case"button":case"input":case"select":case"textarea":p.autoFocus&&g.focus();break t;case"img":p.src?g.src=p.src:p.srcSet&&(g.srcset=p.srcSet)}}catch(I){kn(u,u.return,I)}}function GI(u,h,p){try{var g=u.stateNode;V7(g,u.type,p,h),g[hr]=h}catch(I){kn(u,u.return,I)}}function PD(u){return u.tag===5||u.tag===3||u.tag===26||u.tag===27&&Lu(u.type)||u.tag===4}function WI(u){t:for(;;){for(;u.sibling===null;){if(u.return===null||PD(u.return))return null;u=u.return}for(u.sibling.return=u.return,u=u.sibling;u.tag!==5&&u.tag!==6&&u.tag!==18;){if(u.tag===27&&Lu(u.type)||u.flags&2||u.child===null||u.tag===4)continue t;u.child.return=u,u=u.child}if(!(u.flags&2))return u.stateNode}}function jI(u,h,p){var g=u.tag;if(g===5||g===6)u=u.stateNode,h?(p.nodeType===9?p.body:p.nodeName==="HTML"?p.ownerDocument.body:p).insertBefore(u,h):(h=p.nodeType===9?p.body:p.nodeName==="HTML"?p.ownerDocument.body:p,h.appendChild(u),p=p._reactRootContainer,p!=null||h.onclick!==null||(h.onclick=Fo));else if(g!==4&&(g===27&&Lu(u.type)&&(p=u.stateNode,h=null),u=u.child,u!==null))for(jI(u,h,p),u=u.sibling;u!==null;)jI(u,h,p),u=u.sibling}function O0(u,h,p){var g=u.tag;if(g===5||g===6)u=u.stateNode,h?p.insertBefore(u,h):p.appendChild(u);else if(g!==4&&(g===27&&Lu(u.type)&&(p=u.stateNode),u=u.child,u!==null))for(O0(u,h,p),u=u.sibling;u!==null;)O0(u,h,p),u=u.sibling}function VD(u){var h=u.stateNode,p=u.memoizedProps;try{for(var g=u.type,I=h.attributes;I.length;)h.removeAttributeNode(I[0]);Ar(h,g,p),h[Ds]=u,h[hr]=p}catch(C){kn(u,u.return,C)}}var Dl=!1,Bs=!1,qI=!1,UD=typeof WeakSet=="function"?WeakSet:Set,dr=null;function w7(u,h){if(u=u.containerInfo,dT=e1,u=tR(u),BS(u)){if("selectionStart"in u)var p={start:u.selectionStart,end:u.selectionEnd};else t:{p=(p=u.ownerDocument)&&p.defaultView||window;var g=p.getSelection&&p.getSelection();if(g&&g.rangeCount!==0){p=g.anchorNode;var I=g.anchorOffset,C=g.focusNode;g=g.focusOffset;try{p.nodeType,C.nodeType}catch{p=null;break t}var z=0,W=-1,it=-1,Tt=0,Bt=0,Ut=u,$t=null;e:for(;;){for(var Rt;Ut!==p||I!==0&&Ut.nodeType!==3||(W=z+I),Ut!==C||g!==0&&Ut.nodeType!==3||(it=z+g),Ut.nodeType===3&&(z+=Ut.nodeValue.length),(Rt=Ut.firstChild)!==null;)$t=Ut,Ut=Rt;for(;;){if(Ut===u)break e;if($t===p&&++Tt===I&&(W=z),$t===C&&++Bt===g&&(it=z),(Rt=Ut.nextSibling)!==null)break;Ut=$t,$t=Ut.parentNode}Ut=Rt}p=W===-1||it===-1?null:{start:W,end:it}}else p=null}p=p||{start:0,end:0}}else p=null;for(pT={focusedElem:u,selectionRange:p},e1=!1,dr=h;dr!==null;)if(h=dr,u=h.child,(h.subtreeFlags&1028)!==0&&u!==null)u.return=h,dr=u;else for(;dr!==null;){switch(h=dr,C=h.alternate,u=h.flags,h.tag){case 0:if((u&4)!==0&&(u=h.updateQueue,u=u!==null?u.events:null,u!==null))for(p=0;p<u.length;p++)I=u[p],I.ref.impl=I.nextImpl;break;case 11:case 15:break;case 1:if((u&1024)!==0&&C!==null){u=void 0,p=h,I=C.memoizedProps,C=C.memoizedState,g=p.stateNode;try{var ae=uh(p.type,I);u=g.getSnapshotBeforeUpdate(ae,C),g.__reactInternalSnapshotBeforeUpdate=u}catch(ve){kn(p,p.return,ve)}}break;case 3:if((u&1024)!==0){if(u=h.stateNode.containerInfo,p=u.nodeType,p===9)yT(u);else if(p===1)switch(u.nodeName){case"HEAD":case"HTML":case"BODY":yT(u);break;default:u.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((u&1024)!==0)throw Error(s(163))}if(u=h.sibling,u!==null){u.return=h.return,dr=u;break}dr=h.return}}function GD(u,h,p){var g=p.flags;switch(p.tag){case 0:case 11:case 15:Fl(u,p),g&4&&_m(5,p);break;case 1:if(Fl(u,p),g&4)if(u=p.stateNode,h===null)try{u.componentDidMount()}catch(z){kn(p,p.return,z)}else{var I=uh(p.type,h.memoizedProps);h=h.memoizedState;try{u.componentDidUpdate(I,h,u.__reactInternalSnapshotBeforeUpdate)}catch(z){kn(p,p.return,z)}}g&64&&LD(p),g&512&&Nm(p,p.return);break;case 3:if(Fl(u,p),g&64&&(u=p.updateQueue,u!==null)){if(h=null,p.child!==null)switch(p.child.tag){case 27:case 5:h=p.child.stateNode;break;case 1:h=p.child.stateNode}try{$R(u,h)}catch(z){kn(p,p.return,z)}}break;case 27:h===null&&g&4&&VD(p);case 26:case 5:Fl(u,p),h===null&&g&4&&BD(p),g&512&&Nm(p,p.return);break;case 12:Fl(u,p);break;case 31:Fl(u,p),g&4&&qD(u,p);break;case 13:Fl(u,p),g&4&&HD(u,p),g&64&&(u=p.memoizedState,u!==null&&(u=u.dehydrated,u!==null&&(p=k7.bind(null,p),X7(u,p))));break;case 22:if(g=p.memoizedState!==null||Dl,!g){h=h!==null&&h.memoizedState!==null||Bs,I=Dl;var C=Bs;Dl=g,(Bs=h)&&!C?Ml(u,p,(p.subtreeFlags&8772)!==0):Fl(u,p),Dl=I,Bs=C}break;case 30:break;default:Fl(u,p)}}function WD(u){var h=u.alternate;h!==null&&(u.alternate=null,WD(h)),u.child=null,u.deletions=null,u.sibling=null,u.tag===5&&(h=u.stateNode,h!==null&&Af(h)),u.stateNode=null,u.return=null,u.dependencies=null,u.memoizedProps=null,u.memoizedState=null,u.pendingProps=null,u.stateNode=null,u.updateQueue=null}var os=null,gi=!1;function Ol(u,h,p){for(p=p.child;p!==null;)jD(u,h,p),p=p.sibling}function jD(u,h,p){if(at&&typeof at.onCommitFiberUnmount=="function")try{at.onCommitFiberUnmount(Y,p)}catch{}switch(p.tag){case 26:Bs||Ma(p,h),Ol(u,h,p),p.memoizedState?p.memoizedState.count--:p.stateNode&&(p=p.stateNode,p.parentNode.removeChild(p));break;case 27:Bs||Ma(p,h);var g=os,I=gi;Lu(p.type)&&(os=p.stateNode,gi=!1),Ol(u,h,p),Pm(p.stateNode),os=g,gi=I;break;case 5:Bs||Ma(p,h);case 6:if(g=os,I=gi,os=null,Ol(u,h,p),os=g,gi=I,os!==null)if(gi)try{(os.nodeType===9?os.body:os.nodeName==="HTML"?os.ownerDocument.body:os).removeChild(p.stateNode)}catch(C){kn(p,h,C)}else try{os.removeChild(p.stateNode)}catch(C){kn(p,h,C)}break;case 18:os!==null&&(gi?(u=os,LO(u.nodeType===9?u.body:u.nodeName==="HTML"?u.ownerDocument.body:u,p.stateNode),fd(u)):LO(os,p.stateNode));break;case 4:g=os,I=gi,os=p.stateNode.containerInfo,gi=!0,Ol(u,h,p),os=g,gi=I;break;case 0:case 11:case 14:case 15:_u(2,p,h),Bs||_u(4,p,h),Ol(u,h,p);break;case 1:Bs||(Ma(p,h),g=p.stateNode,typeof g.componentWillUnmount=="function"&&zD(p,h,g)),Ol(u,h,p);break;case 21:Ol(u,h,p);break;case 22:Bs=(g=Bs)||p.memoizedState!==null,Ol(u,h,p),Bs=g;break;default:Ol(u,h,p)}}function qD(u,h){if(h.memoizedState===null&&(u=h.alternate,u!==null&&(u=u.memoizedState,u!==null))){u=u.dehydrated;try{fd(u)}catch(p){kn(h,h.return,p)}}}function HD(u,h){if(h.memoizedState===null&&(u=h.alternate,u!==null&&(u=u.memoizedState,u!==null&&(u=u.dehydrated,u!==null))))try{fd(u)}catch(p){kn(h,h.return,p)}}function v7(u){switch(u.tag){case 31:case 13:case 19:var h=u.stateNode;return h===null&&(h=u.stateNode=new UD),h;case 22:return u=u.stateNode,h=u._retryCache,h===null&&(h=u._retryCache=new UD),h;default:throw Error(s(435,u.tag))}}function F0(u,h){var p=v7(u);h.forEach(function(g){if(!p.has(g)){p.add(g);var I=_7.bind(null,u,g);g.then(I,I)}})}function yi(u,h){var p=h.deletions;if(p!==null)for(var g=0;g<p.length;g++){var I=p[g],C=u,z=h,W=z;t:for(;W!==null;){switch(W.tag){case 27:if(Lu(W.type)){os=W.stateNode,gi=!1;break t}break;case 5:os=W.stateNode,gi=!1;break t;case 3:case 4:os=W.stateNode.containerInfo,gi=!0;break t}W=W.return}if(os===null)throw Error(s(160));jD(C,z,I),os=null,gi=!1,C=I.alternate,C!==null&&(C.return=null),I.return=null}if(h.subtreeFlags&13886)for(h=h.child;h!==null;)KD(h,u),h=h.sibling}var Vo=null;function KD(u,h){var p=u.alternate,g=u.flags;switch(u.tag){case 0:case 11:case 14:case 15:yi(h,u),bi(u),g&4&&(_u(3,u,u.return),_m(3,u),_u(5,u,u.return));break;case 1:yi(h,u),bi(u),g&512&&(Bs||p===null||Ma(p,p.return)),g&64&&Dl&&(u=u.updateQueue,u!==null&&(g=u.callbacks,g!==null&&(p=u.shared.hiddenCallbacks,u.shared.hiddenCallbacks=p===null?g:p.concat(g))));break;case 26:var I=Vo;if(yi(h,u),bi(u),g&512&&(Bs||p===null||Ma(p,p.return)),g&4){var C=p!==null?p.memoizedState:null;if(g=u.memoizedState,p===null)if(g===null)if(u.stateNode===null){t:{g=u.type,p=u.memoizedProps,I=I.ownerDocument||I;e:switch(g){case"title":C=I.getElementsByTagName("title")[0],(!C||C[Sa]||C[Ds]||C.namespaceURI==="http://www.w3.org/2000/svg"||C.hasAttribute("itemprop"))&&(C=I.createElement(g),I.head.insertBefore(C,I.querySelector("head > title"))),Ar(C,g,p),C[Ds]=u,Os(C),g=C;break t;case"link":var z=KO("link","href",I).get(g+(p.href||""));if(z){for(var W=0;W<z.length;W++)if(C=z[W],C.getAttribute("href")===(p.href==null||p.href===""?null:p.href)&&C.getAttribute("rel")===(p.rel==null?null:p.rel)&&C.getAttribute("title")===(p.title==null?null:p.title)&&C.getAttribute("crossorigin")===(p.crossOrigin==null?null:p.crossOrigin)){z.splice(W,1);break e}}C=I.createElement(g),Ar(C,g,p),I.head.appendChild(C);break;case"meta":if(z=KO("meta","content",I).get(g+(p.content||""))){for(W=0;W<z.length;W++)if(C=z[W],C.getAttribute("content")===(p.content==null?null:""+p.content)&&C.getAttribute("name")===(p.name==null?null:p.name)&&C.getAttribute("property")===(p.property==null?null:p.property)&&C.getAttribute("http-equiv")===(p.httpEquiv==null?null:p.httpEquiv)&&C.getAttribute("charset")===(p.charSet==null?null:p.charSet)){z.splice(W,1);break e}}C=I.createElement(g),Ar(C,g,p),I.head.appendChild(C);break;default:throw Error(s(468,g))}C[Ds]=u,Os(C),g=C}u.stateNode=g}else XO(I,u.type,u.stateNode);else u.stateNode=HO(I,g,u.memoizedProps);else C!==g?(C===null?p.stateNode!==null&&(p=p.stateNode,p.parentNode.removeChild(p)):C.count--,g===null?XO(I,u.type,u.stateNode):HO(I,g,u.memoizedProps)):g===null&&u.stateNode!==null&&GI(u,u.memoizedProps,p.memoizedProps)}break;case 27:yi(h,u),bi(u),g&512&&(Bs||p===null||Ma(p,p.return)),p!==null&&g&4&&GI(u,u.memoizedProps,p.memoizedProps);break;case 5:if(yi(h,u),bi(u),g&512&&(Bs||p===null||Ma(p,p.return)),u.flags&32){I=u.stateNode;try{mi(I,"")}catch(ae){kn(u,u.return,ae)}}g&4&&u.stateNode!=null&&(I=u.memoizedProps,GI(u,I,p!==null?p.memoizedProps:I)),g&1024&&(qI=!0);break;case 6:if(yi(h,u),bi(u),g&4){if(u.stateNode===null)throw Error(s(162));g=u.memoizedProps,p=u.stateNode;try{p.nodeValue=g}catch(ae){kn(u,u.return,ae)}}break;case 3:if(Q0=null,I=Vo,Vo=X0(h.containerInfo),yi(h,u),Vo=I,bi(u),g&4&&p!==null&&p.memoizedState.isDehydrated)try{fd(h.containerInfo)}catch(ae){kn(u,u.return,ae)}qI&&(qI=!1,XD(u));break;case 4:g=Vo,Vo=X0(u.stateNode.containerInfo),yi(h,u),bi(u),Vo=g;break;case 12:yi(h,u),bi(u);break;case 31:yi(h,u),bi(u),g&4&&(g=u.updateQueue,g!==null&&(u.updateQueue=null,F0(u,g)));break;case 13:yi(h,u),bi(u),u.child.flags&8192&&u.memoizedState!==null!=(p!==null&&p.memoizedState!==null)&&(L0=je()),g&4&&(g=u.updateQueue,g!==null&&(u.updateQueue=null,F0(u,g)));break;case 22:I=u.memoizedState!==null;var it=p!==null&&p.memoizedState!==null,Tt=Dl,Bt=Bs;if(Dl=Tt||I,Bs=Bt||it,yi(h,u),Bs=Bt,Dl=Tt,bi(u),g&8192)t:for(h=u.stateNode,h._visibility=I?h._visibility&-2:h._visibility|1,I&&(p===null||it||Dl||Bs||ch(u)),p=null,h=u;;){if(h.tag===5||h.tag===26){if(p===null){it=p=h;try{if(C=it.stateNode,I)z=C.style,typeof z.setProperty=="function"?z.setProperty("display","none","important"):z.display="none";else{W=it.stateNode;var Ut=it.memoizedProps.style,$t=Ut!=null&&Ut.hasOwnProperty("display")?Ut.display:null;W.style.display=$t==null||typeof $t=="boolean"?"":(""+$t).trim()}}catch(ae){kn(it,it.return,ae)}}}else if(h.tag===6){if(p===null){it=h;try{it.stateNode.nodeValue=I?"":it.memoizedProps}catch(ae){kn(it,it.return,ae)}}}else if(h.tag===18){if(p===null){it=h;try{var Rt=it.stateNode;I?zO(Rt,!0):zO(it.stateNode,!1)}catch(ae){kn(it,it.return,ae)}}}else if((h.tag!==22&&h.tag!==23||h.memoizedState===null||h===u)&&h.child!==null){h.child.return=h,h=h.child;continue}if(h===u)break t;for(;h.sibling===null;){if(h.return===null||h.return===u)break t;p===h&&(p=null),h=h.return}p===h&&(p=null),h.sibling.return=h.return,h=h.sibling}g&4&&(g=u.updateQueue,g!==null&&(p=g.retryQueue,p!==null&&(g.retryQueue=null,F0(u,p))));break;case 19:yi(h,u),bi(u),g&4&&(g=u.updateQueue,g!==null&&(u.updateQueue=null,F0(u,g)));break;case 30:break;case 21:break;default:yi(h,u),bi(u)}}function bi(u){var h=u.flags;if(h&2){try{for(var p,g=u.return;g!==null;){if(PD(g)){p=g;break}g=g.return}if(p==null)throw Error(s(160));switch(p.tag){case 27:var I=p.stateNode,C=WI(u);O0(u,C,I);break;case 5:var z=p.stateNode;p.flags&32&&(mi(z,""),p.flags&=-33);var W=WI(u);O0(u,W,z);break;case 3:case 4:var it=p.stateNode.containerInfo,Tt=WI(u);jI(u,Tt,it);break;default:throw Error(s(161))}}catch(Bt){kn(u,u.return,Bt)}u.flags&=-3}h&4096&&(u.flags&=-4097)}function XD(u){if(u.subtreeFlags&1024)for(u=u.child;u!==null;){var h=u;XD(h),h.tag===5&&h.flags&1024&&h.stateNode.reset(),u=u.sibling}}function Fl(u,h){if(h.subtreeFlags&8772)for(h=h.child;h!==null;)GD(u,h.alternate,h),h=h.sibling}function ch(u){for(u=u.child;u!==null;){var h=u;switch(h.tag){case 0:case 11:case 14:case 15:_u(4,h,h.return),ch(h);break;case 1:Ma(h,h.return);var p=h.stateNode;typeof p.componentWillUnmount=="function"&&zD(h,h.return,p),ch(h);break;case 27:Pm(h.stateNode);case 26:case 5:Ma(h,h.return),ch(h);break;case 22:h.memoizedState===null&&ch(h);break;case 30:ch(h);break;default:ch(h)}u=u.sibling}}function Ml(u,h,p){for(p=p&&(h.subtreeFlags&8772)!==0,h=h.child;h!==null;){var g=h.alternate,I=u,C=h,z=C.flags;switch(C.tag){case 0:case 11:case 15:Ml(I,C,p),_m(4,C);break;case 1:if(Ml(I,C,p),g=C,I=g.stateNode,typeof I.componentDidMount=="function")try{I.componentDidMount()}catch(Tt){kn(g,g.return,Tt)}if(g=C,I=g.updateQueue,I!==null){var W=g.stateNode;try{var it=I.shared.hiddenCallbacks;if(it!==null)for(I.shared.hiddenCallbacks=null,I=0;I<it.length;I++)ER(it[I],W)}catch(Tt){kn(g,g.return,Tt)}}p&&z&64&&LD(C),Nm(C,C.return);break;case 27:VD(C);case 26:case 5:Ml(I,C,p),p&&g===null&&z&4&&BD(C),Nm(C,C.return);break;case 12:Ml(I,C,p);break;case 31:Ml(I,C,p),p&&z&4&&qD(I,C);break;case 13:Ml(I,C,p),p&&z&4&&HD(I,C);break;case 22:C.memoizedState===null&&Ml(I,C,p),Nm(C,C.return);break;case 30:break;default:Ml(I,C,p)}h=h.sibling}}function HI(u,h){var p=null;u!==null&&u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(p=u.memoizedState.cachePool.pool),u=null,h.memoizedState!==null&&h.memoizedState.cachePool!==null&&(u=h.memoizedState.cachePool.pool),u!==p&&(u!=null&&u.refCount++,p!=null&&ym(p))}function KI(u,h){u=null,h.alternate!==null&&(u=h.alternate.memoizedState.cache),h=h.memoizedState.cache,h!==u&&(h.refCount++,u!=null&&ym(u))}function Uo(u,h,p,g){if(h.subtreeFlags&10256)for(h=h.child;h!==null;)YD(u,h,p,g),h=h.sibling}function YD(u,h,p,g){var I=h.flags;switch(h.tag){case 0:case 11:case 15:Uo(u,h,p,g),I&2048&&_m(9,h);break;case 1:Uo(u,h,p,g);break;case 3:Uo(u,h,p,g),I&2048&&(u=null,h.alternate!==null&&(u=h.alternate.memoizedState.cache),h=h.memoizedState.cache,h!==u&&(h.refCount++,u!=null&&ym(u)));break;case 12:if(I&2048){Uo(u,h,p,g),u=h.stateNode;try{var C=h.memoizedProps,z=C.id,W=C.onPostCommit;typeof W=="function"&&W(z,h.alternate===null?"mount":"update",u.passiveEffectDuration,-0)}catch(it){kn(h,h.return,it)}}else Uo(u,h,p,g);break;case 31:Uo(u,h,p,g);break;case 13:Uo(u,h,p,g);break;case 23:break;case 22:C=h.stateNode,z=h.alternate,h.memoizedState!==null?C._visibility&2?Uo(u,h,p,g):Rm(u,h):C._visibility&2?Uo(u,h,p,g):(C._visibility|=2,ed(u,h,p,g,(h.subtreeFlags&10256)!==0||!1)),I&2048&&HI(z,h);break;case 24:Uo(u,h,p,g),I&2048&&KI(h.alternate,h);break;default:Uo(u,h,p,g)}}function ed(u,h,p,g,I){for(I=I&&((h.subtreeFlags&10256)!==0||!1),h=h.child;h!==null;){var C=u,z=h,W=p,it=g,Tt=z.flags;switch(z.tag){case 0:case 11:case 15:ed(C,z,W,it,I),_m(8,z);break;case 23:break;case 22:var Bt=z.stateNode;z.memoizedState!==null?Bt._visibility&2?ed(C,z,W,it,I):Rm(C,z):(Bt._visibility|=2,ed(C,z,W,it,I)),I&&Tt&2048&&HI(z.alternate,z);break;case 24:ed(C,z,W,it,I),I&&Tt&2048&&KI(z.alternate,z);break;default:ed(C,z,W,it,I)}h=h.sibling}}function Rm(u,h){if(h.subtreeFlags&10256)for(h=h.child;h!==null;){var p=u,g=h,I=g.flags;switch(g.tag){case 22:Rm(p,g),I&2048&&HI(g.alternate,g);break;case 24:Rm(p,g),I&2048&&KI(g.alternate,g);break;default:Rm(p,g)}h=h.sibling}}var Dm=8192;function nd(u,h,p){if(u.subtreeFlags&Dm)for(u=u.child;u!==null;)QD(u,h,p),u=u.sibling}function QD(u,h,p){switch(u.tag){case 26:nd(u,h,p),u.flags&Dm&&u.memoizedState!==null&&aX(p,Vo,u.memoizedState,u.memoizedProps);break;case 5:nd(u,h,p);break;case 3:case 4:var g=Vo;Vo=X0(u.stateNode.containerInfo),nd(u,h,p),Vo=g;break;case 22:u.memoizedState===null&&(g=u.alternate,g!==null&&g.memoizedState!==null?(g=Dm,Dm=16777216,nd(u,h,p),Dm=g):nd(u,h,p));break;default:nd(u,h,p)}}function ZD(u){var h=u.alternate;if(h!==null&&(u=h.child,u!==null)){h.child=null;do h=u.sibling,u.sibling=null,u=h;while(u!==null)}}function Om(u){var h=u.deletions;if((u.flags&16)!==0){if(h!==null)for(var p=0;p<h.length;p++){var g=h[p];dr=g,tO(g,u)}ZD(u)}if(u.subtreeFlags&10256)for(u=u.child;u!==null;)JD(u),u=u.sibling}function JD(u){switch(u.tag){case 0:case 11:case 15:Om(u),u.flags&2048&&_u(9,u,u.return);break;case 3:Om(u);break;case 12:Om(u);break;case 22:var h=u.stateNode;u.memoizedState!==null&&h._visibility&2&&(u.return===null||u.return.tag!==13)?(h._visibility&=-3,M0(u)):Om(u);break;default:Om(u)}}function M0(u){var h=u.deletions;if((u.flags&16)!==0){if(h!==null)for(var p=0;p<h.length;p++){var g=h[p];dr=g,tO(g,u)}ZD(u)}for(u=u.child;u!==null;){switch(h=u,h.tag){case 0:case 11:case 15:_u(8,h,h.return),M0(h);break;case 22:p=h.stateNode,p._visibility&2&&(p._visibility&=-3,M0(h));break;default:M0(h)}u=u.sibling}}function tO(u,h){for(;dr!==null;){var p=dr;switch(p.tag){case 0:case 11:case 15:_u(8,p,h);break;case 23:case 22:if(p.memoizedState!==null&&p.memoizedState.cachePool!==null){var g=p.memoizedState.cachePool.pool;g!=null&&g.refCount++}break;case 24:ym(p.memoizedState.cache)}if(g=p.child,g!==null)g.return=p,dr=g;else t:for(p=u;dr!==null;){g=dr;var I=g.sibling,C=g.return;if(WD(g),g===p){dr=null;break t}if(I!==null){I.return=C,dr=I;break t}dr=C}}}var S7={getCacheForType:function(u){var h=Er(Ms),p=h.data.get(u);return p===void 0&&(p=u(),h.data.set(u,p)),p},cacheSignal:function(){return Er(Ms).controller.signal}},I7=typeof WeakMap=="function"?WeakMap:Map,yn=0,zn=null,qe=null,Ke=0,An=0,zi=null,Nu=!1,sd=!1,XI=!1,Ll=0,ms=0,Ru=0,hh=0,YI=0,Bi=0,rd=0,Fm=null,xi=null,QI=!1,L0=0,eO=0,z0=1/0,B0=null,Du=null,tr=0,Ou=null,id=null,zl=0,ZI=0,JI=null,nO=null,Mm=0,tT=null;function Pi(){return(yn&2)!==0&&Ke!==0?Ke&-Ke:j.T!==null?oT():Pb()}function sO(){if(Bi===0)if((Ke&536870912)===0||tn){var u=Je;Je<<=1,(Je&3932160)===0&&(Je=262144),Bi=u}else Bi=536870912;return u=Mi.current,u!==null&&(u.flags|=32),Bi}function wi(u,h,p){(u===zn&&(An===2||An===9)||u.cancelPendingCommit!==null)&&(od(u,0),Fu(u,Ke,Bi,!1)),Bc(u,p),((yn&2)===0||u!==zn)&&(u===zn&&((yn&2)===0&&(hh|=p),ms===4&&Fu(u,Ke,Bi,!1)),La(u))}function rO(u,h,p){if((yn&6)!==0)throw Error(s(327));var g=!p&&(h&127)===0&&(h&u.expiredLanes)===0||Ro(u,h),I=g?E7(u,h):nT(u,h,!0),C=g;do{if(I===0){sd&&!g&&Fu(u,h,0,!1);break}else{if(p=u.current.alternate,C&&!T7(p)){I=nT(u,h,!1),C=!1;continue}if(I===2){if(C=h,u.errorRecoveryDisabledLanes&C)var z=0;else z=u.pendingLanes&-536870913,z=z!==0?z:z&536870912?536870912:0;if(z!==0){h=z;t:{var W=u;I=Fm;var it=W.current.memoizedState.isDehydrated;if(it&&(od(W,z).flags|=256),z=nT(W,z,!1),z!==2){if(XI&&!it){W.errorRecoveryDisabledLanes|=C,hh|=C,I=4;break t}C=xi,xi=I,C!==null&&(xi===null?xi=C:xi.push.apply(xi,C))}I=z}if(C=!1,I!==2)continue}}if(I===1){od(u,0),Fu(u,h,0,!0);break}t:{switch(g=u,C=I,C){case 0:case 1:throw Error(s(345));case 4:if((h&4194048)!==h)break;case 6:Fu(g,h,Bi,!Nu);break t;case 2:xi=null;break;case 3:case 5:break;default:throw Error(s(329))}if((h&62914560)===h&&(I=L0+300-je(),10<I)){if(Fu(g,h,Bi,!Nu),xa(g,0,!0)!==0)break t;zl=h,g.timeoutHandle=FO(iO.bind(null,g,p,xi,B0,QI,h,Bi,hh,rd,Nu,C,"Throttled",-0,0),I);break t}iO(g,p,xi,B0,QI,h,Bi,hh,rd,Nu,C,null,-0,0)}}break}while(!0);La(u)}function iO(u,h,p,g,I,C,z,W,it,Tt,Bt,Ut,$t,Rt){if(u.timeoutHandle=-1,Ut=h.subtreeFlags,Ut&8192||(Ut&16785408)===16785408){Ut={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:Fo},QD(h,C,Ut);var ae=(C&62914560)===C?L0-je():(C&4194048)===C?eO-je():0;if(ae=lX(Ut,ae),ae!==null){zl=C,u.cancelPendingCommit=ae(dO.bind(null,u,h,C,p,g,I,z,W,it,Bt,Ut,null,$t,Rt)),Fu(u,C,z,!Tt);return}}dO(u,h,C,p,g,I,z,W,it)}function T7(u){for(var h=u;;){var p=h.tag;if((p===0||p===11||p===15)&&h.flags&16384&&(p=h.updateQueue,p!==null&&(p=p.stores,p!==null)))for(var g=0;g<p.length;g++){var I=p[g],C=I.getSnapshot;I=I.value;try{if(!Oi(C(),I))return!1}catch{return!1}}if(p=h.child,h.subtreeFlags&16384&&p!==null)p.return=h,h=p;else{if(h===u)break;for(;h.sibling===null;){if(h.return===null||h.return===u)return!0;h=h.return}h.sibling.return=h.return,h=h.sibling}}return!0}function Fu(u,h,p,g){h&=~YI,h&=~hh,u.suspendedLanes|=h,u.pingedLanes&=~h,g&&(u.warmLanes|=h),g=u.expirationTimes;for(var I=h;0<I;){var C=31-Mt(I),z=1<<C;g[C]=-1,I&=~z}p!==0&&Pc(u,p,h)}function P0(){return(yn&6)===0?(Lm(0),!1):!0}function eT(){if(qe!==null){if(An===0)var u=qe.return;else u=qe,$l=nh=null,yI(u),Yf=null,xm=0,u=qe;for(;u!==null;)MD(u.alternate,u),u=u.return;qe=null}}function od(u,h){var p=u.timeoutHandle;p!==-1&&(u.timeoutHandle=-1,W7(p)),p=u.cancelPendingCommit,p!==null&&(u.cancelPendingCommit=null,p()),zl=0,eT(),zn=u,qe=p=Cl(u.current,null),Ke=h,An=0,zi=null,Nu=!1,sd=Ro(u,h),XI=!1,rd=Bi=YI=hh=Ru=ms=0,xi=Fm=null,QI=!1,(h&8)!==0&&(h|=h&32);var g=u.entangledLanes;if(g!==0)for(u=u.entanglements,g&=h;0<g;){var I=31-Mt(g),C=1<<I;h|=u[I],g&=~C}return Ll=h,a0(),p}function oO(u,h){Me=null,j.H=$m,h===Xf||h===m0?(h=SR(),An=3):h===iI?(h=SR(),An=4):An=h===DI?8:h!==null&&typeof h=="object"&&typeof h.then=="function"?6:1,zi=h,qe===null&&(ms=1,k0(u,no(h,u.current)))}function aO(){var u=Mi.current;return u===null?!0:(Ke&4194048)===Ke?oo===null:(Ke&62914560)===Ke||(Ke&536870912)!==0?u===oo:!1}function lO(){var u=j.H;return j.H=$m,u===null?$m:u}function uO(){var u=j.A;return j.A=S7,u}function V0(){ms=4,Nu||(Ke&4194048)!==Ke&&Mi.current!==null||(sd=!0),(Ru&134217727)===0&&(hh&134217727)===0||zn===null||Fu(zn,Ke,Bi,!1)}function nT(u,h,p){var g=yn;yn|=2;var I=lO(),C=uO();(zn!==u||Ke!==h)&&(B0=null,od(u,h)),h=!1;var z=ms;t:do try{if(An!==0&&qe!==null){var W=qe,it=zi;switch(An){case 8:eT(),z=6;break t;case 3:case 2:case 9:case 6:Mi.current===null&&(h=!0);var Tt=An;if(An=0,zi=null,ad(u,W,it,Tt),p&&sd){z=0;break t}break;default:Tt=An,An=0,zi=null,ad(u,W,it,Tt)}}C7(),z=ms;break}catch(Bt){oO(u,Bt)}while(!0);return h&&u.shellSuspendCounter++,$l=nh=null,yn=g,j.H=I,j.A=C,qe===null&&(zn=null,Ke=0,a0()),z}function C7(){for(;qe!==null;)cO(qe)}function E7(u,h){var p=yn;yn|=2;var g=lO(),I=uO();zn!==u||Ke!==h?(B0=null,z0=je()+500,od(u,h)):sd=Ro(u,h);t:do try{if(An!==0&&qe!==null){h=qe;var C=zi;e:switch(An){case 1:An=0,zi=null,ad(u,h,C,1);break;case 2:case 9:if(wR(C)){An=0,zi=null,hO(h);break}h=function(){An!==2&&An!==9||zn!==u||(An=7),La(u)},C.then(h,h);break t;case 3:An=7;break t;case 4:An=5;break t;case 7:wR(C)?(An=0,zi=null,hO(h)):(An=0,zi=null,ad(u,h,C,7));break;case 5:var z=null;switch(qe.tag){case 26:z=qe.memoizedState;case 5:case 27:var W=qe;if(z?YO(z):W.stateNode.complete){An=0,zi=null;var it=W.sibling;if(it!==null)qe=it;else{var Tt=W.return;Tt!==null?(qe=Tt,U0(Tt)):qe=null}break e}}An=0,zi=null,ad(u,h,C,5);break;case 6:An=0,zi=null,ad(u,h,C,6);break;case 8:eT(),ms=6;break t;default:throw Error(s(462))}}$7();break}catch(Bt){oO(u,Bt)}while(!0);return $l=nh=null,j.H=g,j.A=I,yn=p,qe!==null?0:(zn=null,Ke=0,a0(),ms)}function $7(){for(;qe!==null&&!rs();)cO(qe)}function cO(u){var h=OD(u.alternate,u,Ll);u.memoizedProps=u.pendingProps,h===null?U0(u):qe=h}function hO(u){var h=u,p=h.alternate;switch(h.tag){case 15:case 0:h=AD(p,h,h.pendingProps,h.type,void 0,Ke);break;case 11:h=AD(p,h,h.pendingProps,h.type.render,h.ref,Ke);break;case 5:yI(h);default:MD(p,h),h=qe=uR(h,Ll),h=OD(p,h,Ll)}u.memoizedProps=u.pendingProps,h===null?U0(u):qe=h}function ad(u,h,p,g){$l=nh=null,yI(h),Yf=null,xm=0;var I=h.return;try{if(m7(u,I,h,p,Ke)){ms=1,k0(u,no(p,u.current)),qe=null;return}}catch(C){if(I!==null)throw qe=I,C;ms=1,k0(u,no(p,u.current)),qe=null;return}h.flags&32768?(tn||g===1?u=!0:sd||(Ke&536870912)!==0?u=!1:(Nu=u=!0,(g===2||g===9||g===3||g===6)&&(g=Mi.current,g!==null&&g.tag===13&&(g.flags|=16384))),fO(h,u)):U0(h)}function U0(u){var h=u;do{if((h.flags&32768)!==0){fO(h,Nu);return}u=h.return;var p=b7(h.alternate,h,Ll);if(p!==null){qe=p;return}if(h=h.sibling,h!==null){qe=h;return}qe=h=u}while(h!==null);ms===0&&(ms=5)}function fO(u,h){do{var p=x7(u.alternate,u);if(p!==null){p.flags&=32767,qe=p;return}if(p=u.return,p!==null&&(p.flags|=32768,p.subtreeFlags=0,p.deletions=null),!h&&(u=u.sibling,u!==null)){qe=u;return}qe=u=p}while(u!==null);ms=6,qe=null}function dO(u,h,p,g,I,C,z,W,it){u.cancelPendingCommit=null;do G0();while(tr!==0);if((yn&6)!==0)throw Error(s(327));if(h!==null){if(h===u.current)throw Error(s(177));if(C=h.lanes|h.childLanes,C|=WS,FS(u,p,C,z,W,it),u===zn&&(qe=zn=null,Ke=0),id=h,Ou=u,zl=p,ZI=C,JI=I,nO=g,(h.subtreeFlags&10256)!==0||(h.flags&10256)!==0?(u.callbackNode=null,u.callbackPriority=0,N7(Wn,function(){return bO(),null})):(u.callbackNode=null,u.callbackPriority=0),g=(h.flags&13878)!==0,(h.subtreeFlags&13878)!==0||g){g=j.T,j.T=null,I=Z.p,Z.p=2,z=yn,yn|=4;try{w7(u,h,p)}finally{yn=z,Z.p=I,j.T=g}}tr=1,pO(),mO(),gO()}}function pO(){if(tr===1){tr=0;var u=Ou,h=id,p=(h.flags&13878)!==0;if((h.subtreeFlags&13878)!==0||p){p=j.T,j.T=null;var g=Z.p;Z.p=2;var I=yn;yn|=4;try{KD(h,u);var C=pT,z=tR(u.containerInfo),W=C.focusedElem,it=C.selectionRange;if(z!==W&&W&&W.ownerDocument&&JN(W.ownerDocument.documentElement,W)){if(it!==null&&BS(W)){var Tt=it.start,Bt=it.end;if(Bt===void 0&&(Bt=Tt),"selectionStart"in W)W.selectionStart=Tt,W.selectionEnd=Math.min(Bt,W.value.length);else{var Ut=W.ownerDocument||document,$t=Ut&&Ut.defaultView||window;if($t.getSelection){var Rt=$t.getSelection(),ae=W.textContent.length,ve=Math.min(it.start,ae),Fn=it.end===void 0?ve:Math.min(it.end,ae);!Rt.extend&&ve>Fn&&(z=Fn,Fn=ve,ve=z);var bt=ZN(W,ve),ut=ZN(W,Fn);if(bt&&ut&&(Rt.rangeCount!==1||Rt.anchorNode!==bt.node||Rt.anchorOffset!==bt.offset||Rt.focusNode!==ut.node||Rt.focusOffset!==ut.offset)){var It=Ut.createRange();It.setStart(bt.node,bt.offset),Rt.removeAllRanges(),ve>Fn?(Rt.addRange(It),Rt.extend(ut.node,ut.offset)):(It.setEnd(ut.node,ut.offset),Rt.addRange(It))}}}}for(Ut=[],Rt=W;Rt=Rt.parentNode;)Rt.nodeType===1&&Ut.push({element:Rt,left:Rt.scrollLeft,top:Rt.scrollTop});for(typeof W.focus=="function"&&W.focus(),W=0;W<Ut.length;W++){var Vt=Ut[W];Vt.element.scrollLeft=Vt.left,Vt.element.scrollTop=Vt.top}}e1=!!dT,pT=dT=null}finally{yn=I,Z.p=g,j.T=p}}u.current=h,tr=2}}function mO(){if(tr===2){tr=0;var u=Ou,h=id,p=(h.flags&8772)!==0;if((h.subtreeFlags&8772)!==0||p){p=j.T,j.T=null;var g=Z.p;Z.p=2;var I=yn;yn|=4;try{GD(u,h.alternate,h)}finally{yn=I,Z.p=g,j.T=p}}tr=3}}function gO(){if(tr===4||tr===3){tr=0,Ns();var u=Ou,h=id,p=zl,g=nO;(h.subtreeFlags&10256)!==0||(h.flags&10256)!==0?tr=5:(tr=0,id=Ou=null,yO(u,u.pendingLanes));var I=u.pendingLanes;if(I===0&&(Du=null),vl(p),h=h.stateNode,at&&typeof at.onCommitFiberRoot=="function")try{at.onCommitFiberRoot(Y,h,void 0,(h.current.flags&128)===128)}catch{}if(g!==null){h=j.T,I=Z.p,Z.p=2,j.T=null;try{for(var C=u.onRecoverableError,z=0;z<g.length;z++){var W=g[z];C(W.value,{componentStack:W.stack})}}finally{j.T=h,Z.p=I}}(zl&3)!==0&&G0(),La(u),I=u.pendingLanes,(p&261930)!==0&&(I&42)!==0?u===tT?Mm++:(Mm=0,tT=u):Mm=0,Lm(0)}}function yO(u,h){(u.pooledCacheLanes&=h)===0&&(h=u.pooledCache,h!=null&&(u.pooledCache=null,ym(h)))}function G0(){return pO(),mO(),gO(),bO()}function bO(){if(tr!==5)return!1;var u=Ou,h=ZI;ZI=0;var p=vl(zl),g=j.T,I=Z.p;try{Z.p=32>p?32:p,j.T=null,p=JI,JI=null;var C=Ou,z=zl;if(tr=0,id=Ou=null,zl=0,(yn&6)!==0)throw Error(s(331));var W=yn;if(yn|=4,JD(C.current),YD(C,C.current,z,p),yn=W,Lm(0,!1),at&&typeof at.onPostCommitFiberRoot=="function")try{at.onPostCommitFiberRoot(Y,C)}catch{}return!0}finally{Z.p=I,j.T=g,yO(u,h)}}function xO(u,h,p){h=no(p,h),h=RI(u.stateNode,h,2),u=$u(u,h,2),u!==null&&(Bc(u,2),La(u))}function kn(u,h,p){if(u.tag===3)xO(u,u,p);else for(;h!==null;){if(h.tag===3){xO(h,u,p);break}else if(h.tag===1){var g=h.stateNode;if(typeof h.type.getDerivedStateFromError=="function"||typeof g.componentDidCatch=="function"&&(Du===null||!Du.has(g))){u=no(p,u),p=wD(2),g=$u(h,p,2),g!==null&&(vD(p,g,h,u),Bc(g,2),La(g));break}}h=h.return}}function sT(u,h,p){var g=u.pingCache;if(g===null){g=u.pingCache=new I7;var I=new Set;g.set(h,I)}else I=g.get(h),I===void 0&&(I=new Set,g.set(h,I));I.has(p)||(XI=!0,I.add(p),u=A7.bind(null,u,h,p),h.then(u,u))}function A7(u,h,p){var g=u.pingCache;g!==null&&g.delete(h),u.pingedLanes|=u.suspendedLanes&p,u.warmLanes&=~p,zn===u&&(Ke&p)===p&&(ms===4||ms===3&&(Ke&62914560)===Ke&&300>je()-L0?(yn&2)===0&&od(u,0):YI|=p,rd===Ke&&(rd=0)),La(u)}function wO(u,h){h===0&&(h=Bb()),u=Jc(u,h),u!==null&&(Bc(u,h),La(u))}function k7(u){var h=u.memoizedState,p=0;h!==null&&(p=h.retryLane),wO(u,p)}function _7(u,h){var p=0;switch(u.tag){case 31:case 13:var g=u.stateNode,I=u.memoizedState;I!==null&&(p=I.retryLane);break;case 19:g=u.stateNode;break;case 22:g=u.stateNode._retryCache;break;default:throw Error(s(314))}g!==null&&g.delete(h),wO(u,p)}function N7(u,h){return Ie(u,h)}var W0=null,ld=null,rT=!1,j0=!1,iT=!1,Mu=0;function La(u){u!==ld&&u.next===null&&(ld===null?W0=ld=u:ld=ld.next=u),j0=!0,rT||(rT=!0,D7())}function Lm(u,h){if(!iT&&j0){iT=!0;do for(var p=!1,g=W0;g!==null;){if(u!==0){var I=g.pendingLanes;if(I===0)var C=0;else{var z=g.suspendedLanes,W=g.pingedLanes;C=(1<<31-Mt(42|u)+1)-1,C&=I&~(z&~W),C=C&201326741?C&201326741|1:C?C|2:0}C!==0&&(p=!0,TO(g,C))}else C=Ke,C=xa(g,g===zn?C:0,g.cancelPendingCommit!==null||g.timeoutHandle!==-1),(C&3)===0||Ro(g,C)||(p=!0,TO(g,C));g=g.next}while(p);iT=!1}}function R7(){vO()}function vO(){j0=rT=!1;var u=0;Mu!==0&&G7()&&(u=Mu);for(var h=je(),p=null,g=W0;g!==null;){var I=g.next,C=SO(g,h);C===0?(g.next=null,p===null?W0=I:p.next=I,I===null&&(ld=p)):(p=g,(u!==0||(C&3)!==0)&&(j0=!0)),g=I}tr!==0&&tr!==5||Lm(u),Mu!==0&&(Mu=0)}function SO(u,h){for(var p=u.suspendedLanes,g=u.pingedLanes,I=u.expirationTimes,C=u.pendingLanes&-62914561;0<C;){var z=31-Mt(C),W=1<<z,it=I[z];it===-1?((W&p)===0||(W&g)!==0)&&(I[z]=OS(W,h)):it<=h&&(u.expiredLanes|=W),C&=~W}if(h=zn,p=Ke,p=xa(u,u===h?p:0,u.cancelPendingCommit!==null||u.timeoutHandle!==-1),g=u.callbackNode,p===0||u===h&&(An===2||An===9)||u.cancelPendingCommit!==null)return g!==null&&g!==null&&wn(g),u.callbackNode=null,u.callbackPriority=0;if((p&3)===0||Ro(u,p)){if(h=p&-p,h===u.callbackPriority)return h;switch(g!==null&&wn(g),vl(p)){case 2:case 8:p=zr;break;case 32:p=Wn;break;case 268435456:p=G;break;default:p=Wn}return g=IO.bind(null,u),p=Ie(p,g),u.callbackPriority=h,u.callbackNode=p,h}return g!==null&&g!==null&&wn(g),u.callbackPriority=2,u.callbackNode=null,2}function IO(u,h){if(tr!==0&&tr!==5)return u.callbackNode=null,u.callbackPriority=0,null;var p=u.callbackNode;if(G0()&&u.callbackNode!==p)return null;var g=Ke;return g=xa(u,u===zn?g:0,u.cancelPendingCommit!==null||u.timeoutHandle!==-1),g===0?null:(rO(u,g,h),SO(u,je()),u.callbackNode!=null&&u.callbackNode===p?IO.bind(null,u):null)}function TO(u,h){if(G0())return null;rO(u,h,!0)}function D7(){j7(function(){(yn&6)!==0?Ie(cr,R7):vO()})}function oT(){if(Mu===0){var u=Hf;u===0&&(u=un,un<<=1,(un&261888)===0&&(un=256)),Mu=u}return Mu}function CO(u){return u==null||typeof u=="symbol"||typeof u=="boolean"?null:typeof u=="function"?u:Rf(""+u)}function EO(u,h){var p=h.ownerDocument.createElement("input");return p.name=h.name,p.value=h.value,u.id&&p.setAttribute("form",u.id),h.parentNode.insertBefore(p,h),u=new FormData(u),p.parentNode.removeChild(p),u}function O7(u,h,p,g,I){if(h==="submit"&&p&&p.stateNode===I){var C=CO((I[hr]||null).action),z=g.submitter;z&&(h=(h=z[hr]||null)?CO(h.formAction):z.getAttribute("formAction"),h!==null&&(C=h,z=null));var W=new _a("action","action",null,g,I);u.push({event:W,listeners:[{instance:null,listener:function(){if(g.defaultPrevented){if(Mu!==0){var it=z?EO(I,z):new FormData(I);EI(p,{pending:!0,data:it,method:I.method,action:C},null,it)}}else typeof C=="function"&&(W.preventDefault(),it=z?EO(I,z):new FormData(I),EI(p,{pending:!0,data:it,method:I.method,action:C},C,it))},currentTarget:I}]})}}for(var aT=0;aT<GS.length;aT++){var lT=GS[aT],F7=lT.toLowerCase(),M7=lT[0].toUpperCase()+lT.slice(1);Po(F7,"on"+M7)}Po(sR,"onAnimationEnd"),Po(rR,"onAnimationIteration"),Po(iR,"onAnimationStart"),Po("dblclick","onDoubleClick"),Po("focusin","onFocus"),Po("focusout","onBlur"),Po(ZK,"onTransitionRun"),Po(JK,"onTransitionStart"),Po(t7,"onTransitionCancel"),Po(oR,"onTransitionEnd"),Ea("onMouseEnter",["mouseout","mouseover"]),Ea("onMouseLeave",["mouseout","mouseover"]),Ea("onPointerEnter",["pointerout","pointerover"]),Ea("onPointerLeave",["pointerout","pointerover"]),Ca("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Ca("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Ca("onBeforeInput",["compositionend","keypress","textInput","paste"]),Ca("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Ca("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Ca("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var zm="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),L7=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(zm));function $O(u,h){h=(h&4)!==0;for(var p=0;p<u.length;p++){var g=u[p],I=g.event;g=g.listeners;t:{var C=void 0;if(h)for(var z=g.length-1;0<=z;z--){var W=g[z],it=W.instance,Tt=W.currentTarget;if(W=W.listener,it!==C&&I.isPropagationStopped())break t;C=W,I.currentTarget=Tt;try{C(I)}catch(Bt){o0(Bt)}I.currentTarget=null,C=it}else for(z=0;z<g.length;z++){if(W=g[z],it=W.instance,Tt=W.currentTarget,W=W.listener,it!==C&&I.isPropagationStopped())break t;C=W,I.currentTarget=Tt;try{C(I)}catch(Bt){o0(Bt)}I.currentTarget=null,C=it}}}}function He(u,h){var p=h[$f];p===void 0&&(p=h[$f]=new Set);var g=u+"__bubble";p.has(g)||(AO(h,u,2,!1),p.add(g))}function uT(u,h,p){var g=0;h&&(g|=4),AO(p,u,g,h)}var q0="_reactListening"+Math.random().toString(36).slice(2);function cT(u){if(!u[q0]){u[q0]=!0,Yp.forEach(function(p){p!=="selectionchange"&&(L7.has(p)||uT(p,!1,u),uT(p,!0,u))});var h=u.nodeType===9?u:u.ownerDocument;h===null||h[q0]||(h[q0]=!0,uT("selectionchange",!1,h))}}function AO(u,h,p,g){switch(sF(h)){case 2:var I=hX;break;case 8:I=fX;break;default:I=CT}p=I.bind(null,h,p,u),I=void 0,!jc||h!=="touchstart"&&h!=="touchmove"&&h!=="wheel"||(I=!0),g?I!==void 0?u.addEventListener(h,p,{capture:!0,passive:I}):u.addEventListener(h,p,!0):I!==void 0?u.addEventListener(h,p,{passive:I}):u.addEventListener(h,p,!1)}function hT(u,h,p,g,I){var C=g;if((h&1)===0&&(h&2)===0&&g!==null)t:for(;;){if(g===null)return;var z=g.tag;if(z===3||z===4){var W=g.stateNode.containerInfo;if(W===I)break;if(z===4)for(z=g.return;z!==null;){var it=z.tag;if((it===3||it===4)&&z.stateNode.containerInfo===I)return;z=z.return}for(;W!==null;){if(z=Ia(W),z===null)return;if(it=z.tag,it===5||it===6||it===26||it===27){g=C=z;continue t}W=W.parentNode}}g=g.return}yu(function(){var Tt=C,Bt=Zi(p),Ut=[];t:{var $t=aR.get(u);if($t!==void 0){var Rt=_a,ae=u;switch(u){case"keypress":if(Hc(p)===0)break t;case"keydown":case"keyup":Rt=s0;break;case"focusin":ae="focus",Rt=Xc;break;case"focusout":ae="blur",Rt=Xc;break;case"beforeblur":case"afterblur":Rt=Xc;break;case"click":if(p.button===2)break t;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":Rt=um;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":Rt=Kb;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":Rt=D;break;case sR:case rR:case iR:Rt=Yb;break;case oR:Rt=K;break;case"scroll":case"scrollend":Rt=lm;break;case"wheel":Rt=_t;break;case"copy":case"cut":case"paste":Rt=Qb;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":Rt=Tl;break;case"toggle":case"beforetoggle":Rt=Fe}var ve=(h&4)!==0,Fn=!ve&&(u==="scroll"||u==="scrollend"),bt=ve?$t!==null?$t+"Capture":null:$t;ve=[];for(var ut=Tt,It;ut!==null;){var Vt=ut;if(It=Vt.stateNode,Vt=Vt.tag,Vt!==5&&Vt!==26&&Vt!==27||It===null||bt===null||(Vt=Mo(ut,bt),Vt!=null&&ve.push(Bm(ut,Vt,It))),Fn)break;ut=ut.return}0<ve.length&&($t=new Rt($t,ae,null,p,Bt),Ut.push({event:$t,listeners:ve}))}}if((h&7)===0){t:{if($t=u==="mouseover"||u==="pointerover",Rt=u==="mouseout"||u==="pointerout",$t&&p!==im&&(ae=p.relatedTarget||p.fromElement)&&(Ia(ae)||ae[va]))break t;if((Rt||$t)&&($t=Bt.window===Bt?Bt:($t=Bt.ownerDocument)?$t.defaultView||$t.parentWindow:window,Rt?(ae=p.relatedTarget||p.toElement,Rt=Tt,ae=ae?Ia(ae):null,ae!==null&&(Fn=i(ae),ve=ae.tag,ae!==Fn||ve!==5&&ve!==27&&ve!==6)&&(ae=null)):(Rt=null,ae=Tt),Rt!==ae)){if(ve=um,Vt="onMouseLeave",bt="onMouseEnter",ut="mouse",(u==="pointerout"||u==="pointerover")&&(ve=Tl,Vt="onPointerLeave",bt="onPointerEnter",ut="pointer"),Fn=Rt==null?$t:Ri(Rt),It=ae==null?$t:Ri(ae),$t=new ve(Vt,ut+"leave",Rt,p,Bt),$t.target=Fn,$t.relatedTarget=It,Vt=null,Ia(Bt)===Tt&&(ve=new ve(bt,ut+"enter",ae,p,Bt),ve.target=It,ve.relatedTarget=Fn,Vt=ve),Fn=Vt,Rt&&ae)e:{for(ve=z7,bt=Rt,ut=ae,It=0,Vt=bt;Vt;Vt=ve(Vt))It++;Vt=0;for(var ye=ut;ye;ye=ve(ye))Vt++;for(;0<It-Vt;)bt=ve(bt),It--;for(;0<Vt-It;)ut=ve(ut),Vt--;for(;It--;){if(bt===ut||ut!==null&&bt===ut.alternate){ve=bt;break e}bt=ve(bt),ut=ve(ut)}ve=null}else ve=null;Rt!==null&&kO(Ut,$t,Rt,ve,!1),ae!==null&&Fn!==null&&kO(Ut,Fn,ae,ve,!0)}}t:{if($t=Tt?Ri(Tt):window,Rt=$t.nodeName&&$t.nodeName.toLowerCase(),Rt==="select"||Rt==="input"&&$t.type==="file")var cn=qN;else if(WN($t))if(HN)cn=XK;else{cn=HK;var he=qK}else Rt=$t.nodeName,!Rt||Rt.toLowerCase()!=="input"||$t.type!=="checkbox"&&$t.type!=="radio"?Tt&&Nf(Tt.elementType)&&(cn=qN):cn=KK;if(cn&&(cn=cn(u,Tt))){jN(Ut,cn,p,Bt);break t}he&&he(u,$t,Tt),u==="focusout"&&Tt&&$t.type==="number"&&Tt.memoizedProps.value!=null&&nm($t,"number",$t.value)}switch(he=Tt?Ri(Tt):window,u){case"focusin":(WN(he)||he.contentEditable==="true")&&(Bf=he,PS=Tt,pm=null);break;case"focusout":pm=PS=Bf=null;break;case"mousedown":VS=!0;break;case"contextmenu":case"mouseup":case"dragend":VS=!1,eR(Ut,p,Bt);break;case"selectionchange":if(QK)break;case"keydown":case"keyup":eR(Ut,p,Bt)}var ze;if(gn)t:{switch(u){case"compositionstart":var Xe="onCompositionStart";break t;case"compositionend":Xe="onCompositionEnd";break t;case"compositionupdate":Xe="onCompositionUpdate";break t}Xe=void 0}else zf?Yc(u,p)&&(Xe="onCompositionEnd"):u==="keydown"&&p.keyCode===229&&(Xe="onCompositionStart");Xe&&(Da&&p.locale!=="ko"&&(zf||Xe!=="onCompositionStart"?Xe==="onCompositionEnd"&&zf&&(ze=am()):(ka=Bt,om="value"in ka?ka.value:ka.textContent,zf=!0)),he=H0(Tt,Xe),0<he.length&&(Xe=new Ra(Xe,u,null,p,Bt),Ut.push({event:Xe,listeners:he}),ze?Xe.data=ze:(ze=Lf(p),ze!==null&&(Xe.data=ze)))),(ze=to?UK(u,p):GK(u,p))&&(Xe=H0(Tt,"onBeforeInput"),0<Xe.length&&(he=new Ra("onBeforeInput","beforeinput",null,p,Bt),Ut.push({event:he,listeners:Xe}),he.data=ze)),O7(Ut,u,Tt,p,Bt)}$O(Ut,h)})}function Bm(u,h,p){return{instance:u,listener:h,currentTarget:p}}function H0(u,h){for(var p=h+"Capture",g=[];u!==null;){var I=u,C=I.stateNode;if(I=I.tag,I!==5&&I!==26&&I!==27||C===null||(I=Mo(u,p),I!=null&&g.unshift(Bm(u,I,C)),I=Mo(u,h),I!=null&&g.push(Bm(u,I,C))),u.tag===3)return g;u=u.return}return[]}function z7(u){if(u===null)return null;do u=u.return;while(u&&u.tag!==5&&u.tag!==27);return u||null}function kO(u,h,p,g,I){for(var C=h._reactName,z=[];p!==null&&p!==g;){var W=p,it=W.alternate,Tt=W.stateNode;if(W=W.tag,it!==null&&it===g)break;W!==5&&W!==26&&W!==27||Tt===null||(it=Tt,I?(Tt=Mo(p,C),Tt!=null&&z.unshift(Bm(p,Tt,it))):I||(Tt=Mo(p,C),Tt!=null&&z.push(Bm(p,Tt,it)))),p=p.return}z.length!==0&&u.push({event:h,listeners:z})}var B7=/\r\n?/g,P7=/\u0000|\uFFFD/g;function _O(u){return(typeof u=="string"?u:""+u).replace(B7,`
`).replace(P7,"")}function NO(u,h){return h=_O(h),_O(u)===h}function On(u,h,p,g,I,C){switch(p){case"children":typeof g=="string"?h==="body"||h==="textarea"&&g===""||mi(u,g):(typeof g=="number"||typeof g=="bigint")&&h!=="body"&&mi(u,""+g);break;case"className":Di(u,"class",g);break;case"tabIndex":Di(u,"tabindex",g);break;case"dir":case"role":case"viewBox":case"width":case"height":Di(u,p,g);break;case"style":rm(u,g,C);break;case"data":if(h!=="object"){Di(u,"data",g);break}case"src":case"href":if(g===""&&(h!=="a"||p!=="href")){u.removeAttribute(p);break}if(g==null||typeof g=="function"||typeof g=="symbol"||typeof g=="boolean"){u.removeAttribute(p);break}g=Rf(""+g),u.setAttribute(p,g);break;case"action":case"formAction":if(typeof g=="function"){u.setAttribute(p,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof C=="function"&&(p==="formAction"?(h!=="input"&&On(u,h,"name",I.name,I,null),On(u,h,"formEncType",I.formEncType,I,null),On(u,h,"formMethod",I.formMethod,I,null),On(u,h,"formTarget",I.formTarget,I,null)):(On(u,h,"encType",I.encType,I,null),On(u,h,"method",I.method,I,null),On(u,h,"target",I.target,I,null)));if(g==null||typeof g=="symbol"||typeof g=="boolean"){u.removeAttribute(p);break}g=Rf(""+g),u.setAttribute(p,g);break;case"onClick":g!=null&&(u.onclick=Fo);break;case"onScroll":g!=null&&He("scroll",u);break;case"onScrollEnd":g!=null&&He("scrollend",u);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(p=g.__html,p!=null){if(I.children!=null)throw Error(s(60));u.innerHTML=p}}break;case"multiple":u.multiple=g&&typeof g!="function"&&typeof g!="symbol";break;case"muted":u.muted=g&&typeof g!="function"&&typeof g!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(g==null||typeof g=="function"||typeof g=="boolean"||typeof g=="symbol"){u.removeAttribute("xlink:href");break}p=Rf(""+g),u.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",p);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":g!=null&&typeof g!="function"&&typeof g!="symbol"?u.setAttribute(p,""+g):u.removeAttribute(p);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":g&&typeof g!="function"&&typeof g!="symbol"?u.setAttribute(p,""):u.removeAttribute(p);break;case"capture":case"download":g===!0?u.setAttribute(p,""):g!==!1&&g!=null&&typeof g!="function"&&typeof g!="symbol"?u.setAttribute(p,g):u.removeAttribute(p);break;case"cols":case"rows":case"size":case"span":g!=null&&typeof g!="function"&&typeof g!="symbol"&&!isNaN(g)&&1<=g?u.setAttribute(p,g):u.removeAttribute(p);break;case"rowSpan":case"start":g==null||typeof g=="function"||typeof g=="symbol"||isNaN(g)?u.removeAttribute(p):u.setAttribute(p,g);break;case"popover":He("beforetoggle",u),He("toggle",u),kf(u,"popover",g);break;case"xlinkActuate":Fs(u,"http://www.w3.org/1999/xlink","xlink:actuate",g);break;case"xlinkArcrole":Fs(u,"http://www.w3.org/1999/xlink","xlink:arcrole",g);break;case"xlinkRole":Fs(u,"http://www.w3.org/1999/xlink","xlink:role",g);break;case"xlinkShow":Fs(u,"http://www.w3.org/1999/xlink","xlink:show",g);break;case"xlinkTitle":Fs(u,"http://www.w3.org/1999/xlink","xlink:title",g);break;case"xlinkType":Fs(u,"http://www.w3.org/1999/xlink","xlink:type",g);break;case"xmlBase":Fs(u,"http://www.w3.org/XML/1998/namespace","xml:base",g);break;case"xmlLang":Fs(u,"http://www.w3.org/XML/1998/namespace","xml:lang",g);break;case"xmlSpace":Fs(u,"http://www.w3.org/XML/1998/namespace","xml:space",g);break;case"is":kf(u,"is",g);break;case"innerText":case"textContent":break;default:(!(2<p.length)||p[0]!=="o"&&p[0]!=="O"||p[1]!=="n"&&p[1]!=="N")&&(p=Hb.get(p)||p,kf(u,p,g))}}function fT(u,h,p,g,I,C){switch(p){case"style":rm(u,g,C);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(p=g.__html,p!=null){if(I.children!=null)throw Error(s(60));u.innerHTML=p}}break;case"children":typeof g=="string"?mi(u,g):(typeof g=="number"||typeof g=="bigint")&&mi(u,""+g);break;case"onScroll":g!=null&&He("scroll",u);break;case"onScrollEnd":g!=null&&He("scrollend",u);break;case"onClick":g!=null&&(u.onclick=Fo);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!Qp.hasOwnProperty(p))t:{if(p[0]==="o"&&p[1]==="n"&&(I=p.endsWith("Capture"),h=p.slice(2,I?p.length-7:void 0),C=u[hr]||null,C=C!=null?C[p]:null,typeof C=="function"&&u.removeEventListener(h,C,I),typeof g=="function")){typeof C!="function"&&C!==null&&(p in u?u[p]=null:u.hasAttribute(p)&&u.removeAttribute(p)),u.addEventListener(h,g,I);break t}p in u?u[p]=g:g===!0?u.setAttribute(p,""):kf(u,p,g)}}}function Ar(u,h,p){switch(h){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":He("error",u),He("load",u);var g=!1,I=!1,C;for(C in p)if(p.hasOwnProperty(C)){var z=p[C];if(z!=null)switch(C){case"src":g=!0;break;case"srcSet":I=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,h));default:On(u,h,C,z,p,null)}}I&&On(u,h,"srcSet",p.srcSet,p,null),g&&On(u,h,"src",p.src,p,null);return;case"input":He("invalid",u);var W=C=z=I=null,it=null,Tt=null;for(g in p)if(p.hasOwnProperty(g)){var Bt=p[g];if(Bt!=null)switch(g){case"name":I=Bt;break;case"type":z=Bt;break;case"checked":it=Bt;break;case"defaultChecked":Tt=Bt;break;case"value":C=Bt;break;case"defaultValue":W=Bt;break;case"children":case"dangerouslySetInnerHTML":if(Bt!=null)throw Error(s(137,h));break;default:On(u,h,g,Bt,p,null)}}Wb(u,C,W,it,Tt,z,I,!1);return;case"select":He("invalid",u),g=z=C=null;for(I in p)if(p.hasOwnProperty(I)&&(W=p[I],W!=null))switch(I){case"value":C=W;break;case"defaultValue":z=W;break;case"multiple":g=W;default:On(u,h,I,W,p,null)}h=C,p=z,u.multiple=!!g,h!=null?du(u,!!g,h,!1):p!=null&&du(u,!!g,p,!0);return;case"textarea":He("invalid",u),C=I=g=null;for(z in p)if(p.hasOwnProperty(z)&&(W=p[z],W!=null))switch(z){case"value":g=W;break;case"defaultValue":I=W;break;case"children":C=W;break;case"dangerouslySetInnerHTML":if(W!=null)throw Error(s(91));break;default:On(u,h,z,W,p,null)}pu(u,g,I,C);return;case"option":for(it in p)p.hasOwnProperty(it)&&(g=p[it],g!=null)&&(it==="selected"?u.selected=g&&typeof g!="function"&&typeof g!="symbol":On(u,h,it,g,p,null));return;case"dialog":He("beforetoggle",u),He("toggle",u),He("cancel",u),He("close",u);break;case"iframe":case"object":He("load",u);break;case"video":case"audio":for(g=0;g<zm.length;g++)He(zm[g],u);break;case"image":He("error",u),He("load",u);break;case"details":He("toggle",u);break;case"embed":case"source":case"link":He("error",u),He("load",u);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(Tt in p)if(p.hasOwnProperty(Tt)&&(g=p[Tt],g!=null))switch(Tt){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,h));default:On(u,h,Tt,g,p,null)}return;default:if(Nf(h)){for(Bt in p)p.hasOwnProperty(Bt)&&(g=p[Bt],g!==void 0&&fT(u,h,Bt,g,p,void 0));return}}for(W in p)p.hasOwnProperty(W)&&(g=p[W],g!=null&&On(u,h,W,g,p,null))}function V7(u,h,p,g){switch(h){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var I=null,C=null,z=null,W=null,it=null,Tt=null,Bt=null;for(Rt in p){var Ut=p[Rt];if(p.hasOwnProperty(Rt)&&Ut!=null)switch(Rt){case"checked":break;case"value":break;case"defaultValue":it=Ut;default:g.hasOwnProperty(Rt)||On(u,h,Rt,null,g,Ut)}}for(var $t in g){var Rt=g[$t];if(Ut=p[$t],g.hasOwnProperty($t)&&(Rt!=null||Ut!=null))switch($t){case"type":C=Rt;break;case"name":I=Rt;break;case"checked":Tt=Rt;break;case"defaultChecked":Bt=Rt;break;case"value":z=Rt;break;case"defaultValue":W=Rt;break;case"children":case"dangerouslySetInnerHTML":if(Rt!=null)throw Error(s(137,h));break;default:Rt!==Ut&&On(u,h,$t,Rt,g,Ut)}}_f(u,z,W,it,Tt,Bt,C,I);return;case"select":Rt=z=W=$t=null;for(C in p)if(it=p[C],p.hasOwnProperty(C)&&it!=null)switch(C){case"value":break;case"multiple":Rt=it;default:g.hasOwnProperty(C)||On(u,h,C,null,g,it)}for(I in g)if(C=g[I],it=p[I],g.hasOwnProperty(I)&&(C!=null||it!=null))switch(I){case"value":$t=C;break;case"defaultValue":W=C;break;case"multiple":z=C;default:C!==it&&On(u,h,I,C,g,it)}h=W,p=z,g=Rt,$t!=null?du(u,!!p,$t,!1):!!g!=!!p&&(h!=null?du(u,!!p,h,!0):du(u,!!p,p?[]:"",!1));return;case"textarea":Rt=$t=null;for(W in p)if(I=p[W],p.hasOwnProperty(W)&&I!=null&&!g.hasOwnProperty(W))switch(W){case"value":break;case"children":break;default:On(u,h,W,null,g,I)}for(z in g)if(I=g[z],C=p[z],g.hasOwnProperty(z)&&(I!=null||C!=null))switch(z){case"value":$t=I;break;case"defaultValue":Rt=I;break;case"children":break;case"dangerouslySetInnerHTML":if(I!=null)throw Error(s(91));break;default:I!==C&&On(u,h,z,I,g,C)}jb(u,$t,Rt);return;case"option":for(var ae in p)$t=p[ae],p.hasOwnProperty(ae)&&$t!=null&&!g.hasOwnProperty(ae)&&(ae==="selected"?u.selected=!1:On(u,h,ae,null,g,$t));for(it in g)$t=g[it],Rt=p[it],g.hasOwnProperty(it)&&$t!==Rt&&($t!=null||Rt!=null)&&(it==="selected"?u.selected=$t&&typeof $t!="function"&&typeof $t!="symbol":On(u,h,it,$t,g,Rt));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var ve in p)$t=p[ve],p.hasOwnProperty(ve)&&$t!=null&&!g.hasOwnProperty(ve)&&On(u,h,ve,null,g,$t);for(Tt in g)if($t=g[Tt],Rt=p[Tt],g.hasOwnProperty(Tt)&&$t!==Rt&&($t!=null||Rt!=null))switch(Tt){case"children":case"dangerouslySetInnerHTML":if($t!=null)throw Error(s(137,h));break;default:On(u,h,Tt,$t,g,Rt)}return;default:if(Nf(h)){for(var Fn in p)$t=p[Fn],p.hasOwnProperty(Fn)&&$t!==void 0&&!g.hasOwnProperty(Fn)&&fT(u,h,Fn,void 0,g,$t);for(Bt in g)$t=g[Bt],Rt=p[Bt],!g.hasOwnProperty(Bt)||$t===Rt||$t===void 0&&Rt===void 0||fT(u,h,Bt,$t,g,Rt);return}}for(var bt in p)$t=p[bt],p.hasOwnProperty(bt)&&$t!=null&&!g.hasOwnProperty(bt)&&On(u,h,bt,null,g,$t);for(Ut in g)$t=g[Ut],Rt=p[Ut],!g.hasOwnProperty(Ut)||$t===Rt||$t==null&&Rt==null||On(u,h,Ut,$t,g,Rt)}function RO(u){switch(u){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function U7(){if(typeof performance.getEntriesByType=="function"){for(var u=0,h=0,p=performance.getEntriesByType("resource"),g=0;g<p.length;g++){var I=p[g],C=I.transferSize,z=I.initiatorType,W=I.duration;if(C&&W&&RO(z)){for(z=0,W=I.responseEnd,g+=1;g<p.length;g++){var it=p[g],Tt=it.startTime;if(Tt>W)break;var Bt=it.transferSize,Ut=it.initiatorType;Bt&&RO(Ut)&&(it=it.responseEnd,z+=Bt*(it<W?1:(W-Tt)/(it-Tt)))}if(--g,h+=8*(C+z)/(I.duration/1e3),u++,10<u)break}}if(0<u)return h/u/1e6}return navigator.connection&&(u=navigator.connection.downlink,typeof u=="number")?u:5}var dT=null,pT=null;function K0(u){return u.nodeType===9?u:u.ownerDocument}function DO(u){switch(u){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function OO(u,h){if(u===0)switch(h){case"svg":return 1;case"math":return 2;default:return 0}return u===1&&h==="foreignObject"?0:u}function mT(u,h){return u==="textarea"||u==="noscript"||typeof h.children=="string"||typeof h.children=="number"||typeof h.children=="bigint"||typeof h.dangerouslySetInnerHTML=="object"&&h.dangerouslySetInnerHTML!==null&&h.dangerouslySetInnerHTML.__html!=null}var gT=null;function G7(){var u=window.event;return u&&u.type==="popstate"?u===gT?!1:(gT=u,!0):(gT=null,!1)}var FO=typeof setTimeout=="function"?setTimeout:void 0,W7=typeof clearTimeout=="function"?clearTimeout:void 0,MO=typeof Promise=="function"?Promise:void 0,j7=typeof queueMicrotask=="function"?queueMicrotask:typeof MO<"u"?function(u){return MO.resolve(null).then(u).catch(q7)}:FO;function q7(u){setTimeout(function(){throw u})}function Lu(u){return u==="head"}function LO(u,h){var p=h,g=0;do{var I=p.nextSibling;if(u.removeChild(p),I&&I.nodeType===8)if(p=I.data,p==="/$"||p==="/&"){if(g===0){u.removeChild(I),fd(h);return}g--}else if(p==="$"||p==="$?"||p==="$~"||p==="$!"||p==="&")g++;else if(p==="html")Pm(u.ownerDocument.documentElement);else if(p==="head"){p=u.ownerDocument.head,Pm(p);for(var C=p.firstChild;C;){var z=C.nextSibling,W=C.nodeName;C[Sa]||W==="SCRIPT"||W==="STYLE"||W==="LINK"&&C.rel.toLowerCase()==="stylesheet"||p.removeChild(C),C=z}}else p==="body"&&Pm(u.ownerDocument.body);p=I}while(p);fd(h)}function zO(u,h){var p=u;u=0;do{var g=p.nextSibling;if(p.nodeType===1?h?(p._stashedDisplay=p.style.display,p.style.display="none"):(p.style.display=p._stashedDisplay||"",p.getAttribute("style")===""&&p.removeAttribute("style")):p.nodeType===3&&(h?(p._stashedText=p.nodeValue,p.nodeValue=""):p.nodeValue=p._stashedText||""),g&&g.nodeType===8)if(p=g.data,p==="/$"){if(u===0)break;u--}else p!=="$"&&p!=="$?"&&p!=="$~"&&p!=="$!"||u++;p=g}while(p)}function yT(u){var h=u.firstChild;for(h&&h.nodeType===10&&(h=h.nextSibling);h;){var p=h;switch(h=h.nextSibling,p.nodeName){case"HTML":case"HEAD":case"BODY":yT(p),Af(p);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(p.rel.toLowerCase()==="stylesheet")continue}u.removeChild(p)}}function H7(u,h,p,g){for(;u.nodeType===1;){var I=p;if(u.nodeName.toLowerCase()!==h.toLowerCase()){if(!g&&(u.nodeName!=="INPUT"||u.type!=="hidden"))break}else if(g){if(!u[Sa])switch(h){case"meta":if(!u.hasAttribute("itemprop"))break;return u;case"link":if(C=u.getAttribute("rel"),C==="stylesheet"&&u.hasAttribute("data-precedence"))break;if(C!==I.rel||u.getAttribute("href")!==(I.href==null||I.href===""?null:I.href)||u.getAttribute("crossorigin")!==(I.crossOrigin==null?null:I.crossOrigin)||u.getAttribute("title")!==(I.title==null?null:I.title))break;return u;case"style":if(u.hasAttribute("data-precedence"))break;return u;case"script":if(C=u.getAttribute("src"),(C!==(I.src==null?null:I.src)||u.getAttribute("type")!==(I.type==null?null:I.type)||u.getAttribute("crossorigin")!==(I.crossOrigin==null?null:I.crossOrigin))&&C&&u.hasAttribute("async")&&!u.hasAttribute("itemprop"))break;return u;default:return u}}else if(h==="input"&&u.type==="hidden"){var C=I.name==null?null:""+I.name;if(I.type==="hidden"&&u.getAttribute("name")===C)return u}else return u;if(u=ao(u.nextSibling),u===null)break}return null}function K7(u,h,p){if(h==="")return null;for(;u.nodeType!==3;)if((u.nodeType!==1||u.nodeName!=="INPUT"||u.type!=="hidden")&&!p||(u=ao(u.nextSibling),u===null))return null;return u}function BO(u,h){for(;u.nodeType!==8;)if((u.nodeType!==1||u.nodeName!=="INPUT"||u.type!=="hidden")&&!h||(u=ao(u.nextSibling),u===null))return null;return u}function bT(u){return u.data==="$?"||u.data==="$~"}function xT(u){return u.data==="$!"||u.data==="$?"&&u.ownerDocument.readyState!=="loading"}function X7(u,h){var p=u.ownerDocument;if(u.data==="$~")u._reactRetry=h;else if(u.data!=="$?"||p.readyState!=="loading")h();else{var g=function(){h(),p.removeEventListener("DOMContentLoaded",g)};p.addEventListener("DOMContentLoaded",g),u._reactRetry=g}}function ao(u){for(;u!=null;u=u.nextSibling){var h=u.nodeType;if(h===1||h===3)break;if(h===8){if(h=u.data,h==="$"||h==="$!"||h==="$?"||h==="$~"||h==="&"||h==="F!"||h==="F")break;if(h==="/$"||h==="/&")return null}}return u}var wT=null;function PO(u){u=u.nextSibling;for(var h=0;u;){if(u.nodeType===8){var p=u.data;if(p==="/$"||p==="/&"){if(h===0)return ao(u.nextSibling);h--}else p!=="$"&&p!=="$!"&&p!=="$?"&&p!=="$~"&&p!=="&"||h++}u=u.nextSibling}return null}function VO(u){u=u.previousSibling;for(var h=0;u;){if(u.nodeType===8){var p=u.data;if(p==="$"||p==="$!"||p==="$?"||p==="$~"||p==="&"){if(h===0)return u;h--}else p!=="/$"&&p!=="/&"||h++}u=u.previousSibling}return null}function UO(u,h,p){switch(h=K0(p),u){case"html":if(u=h.documentElement,!u)throw Error(s(452));return u;case"head":if(u=h.head,!u)throw Error(s(453));return u;case"body":if(u=h.body,!u)throw Error(s(454));return u;default:throw Error(s(451))}}function Pm(u){for(var h=u.attributes;h.length;)u.removeAttributeNode(h[0]);Af(u)}var lo=new Map,GO=new Set;function X0(u){return typeof u.getRootNode=="function"?u.getRootNode():u.nodeType===9?u:u.ownerDocument}var Bl=Z.d;Z.d={f:Y7,r:Q7,D:Z7,C:J7,L:tX,m:eX,X:sX,S:nX,M:rX};function Y7(){var u=Bl.f(),h=P0();return u||h}function Q7(u){var h=Qi(u);h!==null&&h.tag===5&&h.type==="form"?oD(h):Bl.r(u)}var ud=typeof document>"u"?null:document;function WO(u,h,p){var g=ud;if(g&&typeof h=="string"&&h){var I=pi(h);I='link[rel="'+u+'"][href="'+I+'"]',typeof p=="string"&&(I+='[crossorigin="'+p+'"]'),GO.has(I)||(GO.add(I),u={rel:u,crossOrigin:p,href:h},g.querySelector(I)===null&&(h=g.createElement("link"),Ar(h,"link",u),Os(h),g.head.appendChild(h)))}}function Z7(u){Bl.D(u),WO("dns-prefetch",u,null)}function J7(u,h){Bl.C(u,h),WO("preconnect",u,h)}function tX(u,h,p){Bl.L(u,h,p);var g=ud;if(g&&u&&h){var I='link[rel="preload"][as="'+pi(h)+'"]';h==="image"&&p&&p.imageSrcSet?(I+='[imagesrcset="'+pi(p.imageSrcSet)+'"]',typeof p.imageSizes=="string"&&(I+='[imagesizes="'+pi(p.imageSizes)+'"]')):I+='[href="'+pi(u)+'"]';var C=I;switch(h){case"style":C=cd(u);break;case"script":C=hd(u)}lo.has(C)||(u=d({rel:"preload",href:h==="image"&&p&&p.imageSrcSet?void 0:u,as:h},p),lo.set(C,u),g.querySelector(I)!==null||h==="style"&&g.querySelector(Vm(C))||h==="script"&&g.querySelector(Um(C))||(h=g.createElement("link"),Ar(h,"link",u),Os(h),g.head.appendChild(h)))}}function eX(u,h){Bl.m(u,h);var p=ud;if(p&&u){var g=h&&typeof h.as=="string"?h.as:"script",I='link[rel="modulepreload"][as="'+pi(g)+'"][href="'+pi(u)+'"]',C=I;switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":C=hd(u)}if(!lo.has(C)&&(u=d({rel:"modulepreload",href:u},h),lo.set(C,u),p.querySelector(I)===null)){switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(p.querySelector(Um(C)))return}g=p.createElement("link"),Ar(g,"link",u),Os(g),p.head.appendChild(g)}}}function nX(u,h,p){Bl.S(u,h,p);var g=ud;if(g&&u){var I=Ta(g).hoistableStyles,C=cd(u);h=h||"default";var z=I.get(C);if(!z){var W={loading:0,preload:null};if(z=g.querySelector(Vm(C)))W.loading=5;else{u=d({rel:"stylesheet",href:u,"data-precedence":h},p),(p=lo.get(C))&&vT(u,p);var it=z=g.createElement("link");Os(it),Ar(it,"link",u),it._p=new Promise(function(Tt,Bt){it.onload=Tt,it.onerror=Bt}),it.addEventListener("load",function(){W.loading|=1}),it.addEventListener("error",function(){W.loading|=2}),W.loading|=4,Y0(z,h,g)}z={type:"stylesheet",instance:z,count:1,state:W},I.set(C,z)}}}function sX(u,h){Bl.X(u,h);var p=ud;if(p&&u){var g=Ta(p).hoistableScripts,I=hd(u),C=g.get(I);C||(C=p.querySelector(Um(I)),C||(u=d({src:u,async:!0},h),(h=lo.get(I))&&ST(u,h),C=p.createElement("script"),Os(C),Ar(C,"link",u),p.head.appendChild(C)),C={type:"script",instance:C,count:1,state:null},g.set(I,C))}}function rX(u,h){Bl.M(u,h);var p=ud;if(p&&u){var g=Ta(p).hoistableScripts,I=hd(u),C=g.get(I);C||(C=p.querySelector(Um(I)),C||(u=d({src:u,async:!0,type:"module"},h),(h=lo.get(I))&&ST(u,h),C=p.createElement("script"),Os(C),Ar(C,"link",u),p.head.appendChild(C)),C={type:"script",instance:C,count:1,state:null},g.set(I,C))}}function jO(u,h,p,g){var I=(I=xt.current)?X0(I):null;if(!I)throw Error(s(446));switch(u){case"meta":case"title":return null;case"style":return typeof p.precedence=="string"&&typeof p.href=="string"?(h=cd(p.href),p=Ta(I).hoistableStyles,g=p.get(h),g||(g={type:"style",instance:null,count:0,state:null},p.set(h,g)),g):{type:"void",instance:null,count:0,state:null};case"link":if(p.rel==="stylesheet"&&typeof p.href=="string"&&typeof p.precedence=="string"){u=cd(p.href);var C=Ta(I).hoistableStyles,z=C.get(u);if(z||(I=I.ownerDocument||I,z={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},C.set(u,z),(C=I.querySelector(Vm(u)))&&!C._p&&(z.instance=C,z.state.loading=5),lo.has(u)||(p={rel:"preload",as:"style",href:p.href,crossOrigin:p.crossOrigin,integrity:p.integrity,media:p.media,hrefLang:p.hrefLang,referrerPolicy:p.referrerPolicy},lo.set(u,p),C||iX(I,u,p,z.state))),h&&g===null)throw Error(s(528,""));return z}if(h&&g!==null)throw Error(s(529,""));return null;case"script":return h=p.async,p=p.src,typeof p=="string"&&h&&typeof h!="function"&&typeof h!="symbol"?(h=hd(p),p=Ta(I).hoistableScripts,g=p.get(h),g||(g={type:"script",instance:null,count:0,state:null},p.set(h,g)),g):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,u))}}function cd(u){return'href="'+pi(u)+'"'}function Vm(u){return'link[rel="stylesheet"]['+u+"]"}function qO(u){return d({},u,{"data-precedence":u.precedence,precedence:null})}function iX(u,h,p,g){u.querySelector('link[rel="preload"][as="style"]['+h+"]")?g.loading=1:(h=u.createElement("link"),g.preload=h,h.addEventListener("load",function(){return g.loading|=1}),h.addEventListener("error",function(){return g.loading|=2}),Ar(h,"link",p),Os(h),u.head.appendChild(h))}function hd(u){return'[src="'+pi(u)+'"]'}function Um(u){return"script[async]"+u}function HO(u,h,p){if(h.count++,h.instance===null)switch(h.type){case"style":var g=u.querySelector('style[data-href~="'+pi(p.href)+'"]');if(g)return h.instance=g,Os(g),g;var I=d({},p,{"data-href":p.href,"data-precedence":p.precedence,href:null,precedence:null});return g=(u.ownerDocument||u).createElement("style"),Os(g),Ar(g,"style",I),Y0(g,p.precedence,u),h.instance=g;case"stylesheet":I=cd(p.href);var C=u.querySelector(Vm(I));if(C)return h.state.loading|=4,h.instance=C,Os(C),C;g=qO(p),(I=lo.get(I))&&vT(g,I),C=(u.ownerDocument||u).createElement("link"),Os(C);var z=C;return z._p=new Promise(function(W,it){z.onload=W,z.onerror=it}),Ar(C,"link",g),h.state.loading|=4,Y0(C,p.precedence,u),h.instance=C;case"script":return C=hd(p.src),(I=u.querySelector(Um(C)))?(h.instance=I,Os(I),I):(g=p,(I=lo.get(C))&&(g=d({},p),ST(g,I)),u=u.ownerDocument||u,I=u.createElement("script"),Os(I),Ar(I,"link",g),u.head.appendChild(I),h.instance=I);case"void":return null;default:throw Error(s(443,h.type))}else h.type==="stylesheet"&&(h.state.loading&4)===0&&(g=h.instance,h.state.loading|=4,Y0(g,p.precedence,u));return h.instance}function Y0(u,h,p){for(var g=p.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),I=g.length?g[g.length-1]:null,C=I,z=0;z<g.length;z++){var W=g[z];if(W.dataset.precedence===h)C=W;else if(C!==I)break}C?C.parentNode.insertBefore(u,C.nextSibling):(h=p.nodeType===9?p.head:p,h.insertBefore(u,h.firstChild))}function vT(u,h){u.crossOrigin==null&&(u.crossOrigin=h.crossOrigin),u.referrerPolicy==null&&(u.referrerPolicy=h.referrerPolicy),u.title==null&&(u.title=h.title)}function ST(u,h){u.crossOrigin==null&&(u.crossOrigin=h.crossOrigin),u.referrerPolicy==null&&(u.referrerPolicy=h.referrerPolicy),u.integrity==null&&(u.integrity=h.integrity)}var Q0=null;function KO(u,h,p){if(Q0===null){var g=new Map,I=Q0=new Map;I.set(p,g)}else I=Q0,g=I.get(p),g||(g=new Map,I.set(p,g));if(g.has(u))return g;for(g.set(u,null),p=p.getElementsByTagName(u),I=0;I<p.length;I++){var C=p[I];if(!(C[Sa]||C[Ds]||u==="link"&&C.getAttribute("rel")==="stylesheet")&&C.namespaceURI!=="http://www.w3.org/2000/svg"){var z=C.getAttribute(h)||"";z=u+z;var W=g.get(z);W?W.push(C):g.set(z,[C])}}return g}function XO(u,h,p){u=u.ownerDocument||u,u.head.insertBefore(p,h==="title"?u.querySelector("head > title"):null)}function oX(u,h,p){if(p===1||h.itemProp!=null)return!1;switch(u){case"meta":case"title":return!0;case"style":if(typeof h.precedence!="string"||typeof h.href!="string"||h.href==="")break;return!0;case"link":if(typeof h.rel!="string"||typeof h.href!="string"||h.href===""||h.onLoad||h.onError)break;return h.rel==="stylesheet"?(u=h.disabled,typeof h.precedence=="string"&&u==null):!0;case"script":if(h.async&&typeof h.async!="function"&&typeof h.async!="symbol"&&!h.onLoad&&!h.onError&&h.src&&typeof h.src=="string")return!0}return!1}function YO(u){return!(u.type==="stylesheet"&&(u.state.loading&3)===0)}function aX(u,h,p,g){if(p.type==="stylesheet"&&(typeof g.media!="string"||matchMedia(g.media).matches!==!1)&&(p.state.loading&4)===0){if(p.instance===null){var I=cd(g.href),C=h.querySelector(Vm(I));if(C){h=C._p,h!==null&&typeof h=="object"&&typeof h.then=="function"&&(u.count++,u=Z0.bind(u),h.then(u,u)),p.state.loading|=4,p.instance=C,Os(C);return}C=h.ownerDocument||h,g=qO(g),(I=lo.get(I))&&vT(g,I),C=C.createElement("link"),Os(C);var z=C;z._p=new Promise(function(W,it){z.onload=W,z.onerror=it}),Ar(C,"link",g),p.instance=C}u.stylesheets===null&&(u.stylesheets=new Map),u.stylesheets.set(p,h),(h=p.state.preload)&&(p.state.loading&3)===0&&(u.count++,p=Z0.bind(u),h.addEventListener("load",p),h.addEventListener("error",p))}}var IT=0;function lX(u,h){return u.stylesheets&&u.count===0&&t1(u,u.stylesheets),0<u.count||0<u.imgCount?function(p){var g=setTimeout(function(){if(u.stylesheets&&t1(u,u.stylesheets),u.unsuspend){var C=u.unsuspend;u.unsuspend=null,C()}},6e4+h);0<u.imgBytes&&IT===0&&(IT=62500*U7());var I=setTimeout(function(){if(u.waitingForImages=!1,u.count===0&&(u.stylesheets&&t1(u,u.stylesheets),u.unsuspend)){var C=u.unsuspend;u.unsuspend=null,C()}},(u.imgBytes>IT?50:800)+h);return u.unsuspend=p,function(){u.unsuspend=null,clearTimeout(g),clearTimeout(I)}}:null}function Z0(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)t1(this,this.stylesheets);else if(this.unsuspend){var u=this.unsuspend;this.unsuspend=null,u()}}}var J0=null;function t1(u,h){u.stylesheets=null,u.unsuspend!==null&&(u.count++,J0=new Map,h.forEach(uX,u),J0=null,Z0.call(u))}function uX(u,h){if(!(h.state.loading&4)){var p=J0.get(u);if(p)var g=p.get(null);else{p=new Map,J0.set(u,p);for(var I=u.querySelectorAll("link[data-precedence],style[data-precedence]"),C=0;C<I.length;C++){var z=I[C];(z.nodeName==="LINK"||z.getAttribute("media")!=="not all")&&(p.set(z.dataset.precedence,z),g=z)}g&&p.set(null,g)}I=h.instance,z=I.getAttribute("data-precedence"),C=p.get(z)||g,C===g&&p.set(null,I),p.set(z,I),this.count++,g=Z0.bind(this),I.addEventListener("load",g),I.addEventListener("error",g),C?C.parentNode.insertBefore(I,C.nextSibling):(u=u.nodeType===9?u.head:u,u.insertBefore(I,u.firstChild)),h.state.loading|=4}}var Gm={$$typeof:$,Provider:null,Consumer:null,_currentValue:J,_currentValue2:J,_threadCount:0};function cX(u,h,p,g,I,C,z,W,it){this.tag=1,this.containerInfo=u,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=wa(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=wa(0),this.hiddenUpdates=wa(null),this.identifierPrefix=g,this.onUncaughtError=I,this.onCaughtError=C,this.onRecoverableError=z,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=it,this.incompleteTransitions=new Map}function QO(u,h,p,g,I,C,z,W,it,Tt,Bt,Ut){return u=new cX(u,h,p,z,it,Tt,Bt,Ut,W),h=1,C===!0&&(h|=24),C=Fi(3,null,null,h),u.current=C,C.stateNode=u,h=nI(),h.refCount++,u.pooledCache=h,h.refCount++,C.memoizedState={element:g,isDehydrated:p,cache:h},oI(C),u}function ZO(u){return u?(u=Uf,u):Uf}function JO(u,h,p,g,I,C){I=ZO(I),g.context===null?g.context=I:g.pendingContext=I,g=Eu(h),g.payload={element:p},C=C===void 0?null:C,C!==null&&(g.callback=C),p=$u(u,g,h),p!==null&&(wi(p,u,h),vm(p,u,h))}function tF(u,h){if(u=u.memoizedState,u!==null&&u.dehydrated!==null){var p=u.retryLane;u.retryLane=p!==0&&p<h?p:h}}function TT(u,h){tF(u,h),(u=u.alternate)&&tF(u,h)}function eF(u){if(u.tag===13||u.tag===31){var h=Jc(u,67108864);h!==null&&wi(h,u,67108864),TT(u,67108864)}}function nF(u){if(u.tag===13||u.tag===31){var h=Pi();h=Vc(h);var p=Jc(u,h);p!==null&&wi(p,u,h),TT(u,h)}}var e1=!0;function hX(u,h,p,g){var I=j.T;j.T=null;var C=Z.p;try{Z.p=2,CT(u,h,p,g)}finally{Z.p=C,j.T=I}}function fX(u,h,p,g){var I=j.T;j.T=null;var C=Z.p;try{Z.p=8,CT(u,h,p,g)}finally{Z.p=C,j.T=I}}function CT(u,h,p,g){if(e1){var I=ET(g);if(I===null)hT(u,h,g,n1,p),rF(u,g);else if(pX(I,u,h,p,g))g.stopPropagation();else if(rF(u,g),h&4&&-1<dX.indexOf(u)){for(;I!==null;){var C=Qi(I);if(C!==null)switch(C.tag){case 3:if(C=C.stateNode,C.current.memoizedState.isDehydrated){var z=ba(C.pendingLanes);if(z!==0){var W=C;for(W.pendingLanes|=2,W.entangledLanes|=2;z;){var it=1<<31-Mt(z);W.entanglements[1]|=it,z&=~it}La(C),(yn&6)===0&&(z0=je()+500,Lm(0))}}break;case 31:case 13:W=Jc(C,2),W!==null&&wi(W,C,2),P0(),TT(C,2)}if(C=ET(g),C===null&&hT(u,h,g,n1,p),C===I)break;I=C}I!==null&&g.stopPropagation()}else hT(u,h,g,null,p)}}function ET(u){return u=Zi(u),$T(u)}var n1=null;function $T(u){if(n1=null,u=Ia(u),u!==null){var h=i(u);if(h===null)u=null;else{var p=h.tag;if(p===13){if(u=o(h),u!==null)return u;u=null}else if(p===31){if(u=a(h),u!==null)return u;u=null}else if(p===3){if(h.stateNode.current.memoizedState.isDehydrated)return h.tag===3?h.stateNode.containerInfo:null;u=null}else h!==u&&(u=null)}}return n1=u,null}function sF(u){switch(u){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Nn()){case cr:return 2;case zr:return 8;case Wn:case No:return 32;case G:return 268435456;default:return 32}default:return 32}}var AT=!1,zu=null,Bu=null,Pu=null,Wm=new Map,jm=new Map,Vu=[],dX="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function rF(u,h){switch(u){case"focusin":case"focusout":zu=null;break;case"dragenter":case"dragleave":Bu=null;break;case"mouseover":case"mouseout":Pu=null;break;case"pointerover":case"pointerout":Wm.delete(h.pointerId);break;case"gotpointercapture":case"lostpointercapture":jm.delete(h.pointerId)}}function qm(u,h,p,g,I,C){return u===null||u.nativeEvent!==C?(u={blockedOn:h,domEventName:p,eventSystemFlags:g,nativeEvent:C,targetContainers:[I]},h!==null&&(h=Qi(h),h!==null&&eF(h)),u):(u.eventSystemFlags|=g,h=u.targetContainers,I!==null&&h.indexOf(I)===-1&&h.push(I),u)}function pX(u,h,p,g,I){switch(h){case"focusin":return zu=qm(zu,u,h,p,g,I),!0;case"dragenter":return Bu=qm(Bu,u,h,p,g,I),!0;case"mouseover":return Pu=qm(Pu,u,h,p,g,I),!0;case"pointerover":var C=I.pointerId;return Wm.set(C,qm(Wm.get(C)||null,u,h,p,g,I)),!0;case"gotpointercapture":return C=I.pointerId,jm.set(C,qm(jm.get(C)||null,u,h,p,g,I)),!0}return!1}function iF(u){var h=Ia(u.target);if(h!==null){var p=i(h);if(p!==null){if(h=p.tag,h===13){if(h=o(p),h!==null){u.blockedOn=h,Do(u.priority,function(){nF(p)});return}}else if(h===31){if(h=a(p),h!==null){u.blockedOn=h,Do(u.priority,function(){nF(p)});return}}else if(h===3&&p.stateNode.current.memoizedState.isDehydrated){u.blockedOn=p.tag===3?p.stateNode.containerInfo:null;return}}}u.blockedOn=null}function s1(u){if(u.blockedOn!==null)return!1;for(var h=u.targetContainers;0<h.length;){var p=ET(u.nativeEvent);if(p===null){p=u.nativeEvent;var g=new p.constructor(p.type,p);im=g,p.target.dispatchEvent(g),im=null}else return h=Qi(p),h!==null&&eF(h),u.blockedOn=p,!1;h.shift()}return!0}function oF(u,h,p){s1(u)&&p.delete(h)}function mX(){AT=!1,zu!==null&&s1(zu)&&(zu=null),Bu!==null&&s1(Bu)&&(Bu=null),Pu!==null&&s1(Pu)&&(Pu=null),Wm.forEach(oF),jm.forEach(oF)}function r1(u,h){u.blockedOn===h&&(u.blockedOn=null,AT||(AT=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,mX)))}var i1=null;function aF(u){i1!==u&&(i1=u,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){i1===u&&(i1=null);for(var h=0;h<u.length;h+=3){var p=u[h],g=u[h+1],I=u[h+2];if(typeof g!="function"){if($T(g||p)===null)continue;break}var C=Qi(p);C!==null&&(u.splice(h,3),h-=3,EI(C,{pending:!0,data:I,method:p.method,action:g},g,I))}}))}function fd(u){function h(it){return r1(it,u)}zu!==null&&r1(zu,u),Bu!==null&&r1(Bu,u),Pu!==null&&r1(Pu,u),Wm.forEach(h),jm.forEach(h);for(var p=0;p<Vu.length;p++){var g=Vu[p];g.blockedOn===u&&(g.blockedOn=null)}for(;0<Vu.length&&(p=Vu[0],p.blockedOn===null);)iF(p),p.blockedOn===null&&Vu.shift();if(p=(u.ownerDocument||u).$$reactFormReplay,p!=null)for(g=0;g<p.length;g+=3){var I=p[g],C=p[g+1],z=I[hr]||null;if(typeof C=="function")z||aF(p);else if(z){var W=null;if(C&&C.hasAttribute("formAction")){if(I=C,z=C[hr]||null)W=z.formAction;else if($T(I)!==null)continue}else W=z.action;typeof W=="function"?p[g+1]=W:(p.splice(g,3),g-=3),aF(p)}}}function lF(){function u(C){C.canIntercept&&C.info==="react-transition"&&C.intercept({handler:function(){return new Promise(function(z){return I=z})},focusReset:"manual",scroll:"manual"})}function h(){I!==null&&(I(),I=null),g||setTimeout(p,20)}function p(){if(!g&&!navigation.transition){var C=navigation.currentEntry;C&&C.url!=null&&navigation.navigate(C.url,{state:C.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var g=!1,I=null;return navigation.addEventListener("navigate",u),navigation.addEventListener("navigatesuccess",h),navigation.addEventListener("navigateerror",h),setTimeout(p,100),function(){g=!0,navigation.removeEventListener("navigate",u),navigation.removeEventListener("navigatesuccess",h),navigation.removeEventListener("navigateerror",h),I!==null&&(I(),I=null)}}}function kT(u){this._internalRoot=u}o1.prototype.render=kT.prototype.render=function(u){var h=this._internalRoot;if(h===null)throw Error(s(409));var p=h.current,g=Pi();JO(p,g,u,h,null,null)},o1.prototype.unmount=kT.prototype.unmount=function(){var u=this._internalRoot;if(u!==null){this._internalRoot=null;var h=u.containerInfo;JO(u.current,2,null,u,null,null),P0(),h[va]=null}};function o1(u){this._internalRoot=u}o1.prototype.unstable_scheduleHydration=function(u){if(u){var h=Pb();u={blockedOn:null,target:u,priority:h};for(var p=0;p<Vu.length&&h!==0&&h<Vu[p].priority;p++);Vu.splice(p,0,u),p===0&&iF(u)}};var uF=t.version;if(uF!=="19.2.3")throw Error(s(527,uF,"19.2.3"));Z.findDOMNode=function(u){var h=u._reactInternals;if(h===void 0)throw typeof u.render=="function"?Error(s(188)):(u=Object.keys(u).join(","),Error(s(268,u)));return u=c(h),u=u!==null?f(u):null,u=u===null?null:u.stateNode,u};var gX={bundleType:0,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:j,reconcilerVersion:"19.2.3"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var a1=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!a1.isDisabled&&a1.supportsFiber)try{Y=a1.inject(gX),at=a1}catch{}}return Km.createRoot=function(u,h){if(!r(u))throw Error(s(299));var p=!1,g="",I=gD,C=yD,z=bD;return h!=null&&(h.unstable_strictMode===!0&&(p=!0),h.identifierPrefix!==void 0&&(g=h.identifierPrefix),h.onUncaughtError!==void 0&&(I=h.onUncaughtError),h.onCaughtError!==void 0&&(C=h.onCaughtError),h.onRecoverableError!==void 0&&(z=h.onRecoverableError)),h=QO(u,1,!1,null,null,p,g,null,I,C,z,lF),u[va]=h.current,cT(u),new kT(h)},Km.hydrateRoot=function(u,h,p){if(!r(u))throw Error(s(299));var g=!1,I="",C=gD,z=yD,W=bD,it=null;return p!=null&&(p.unstable_strictMode===!0&&(g=!0),p.identifierPrefix!==void 0&&(I=p.identifierPrefix),p.onUncaughtError!==void 0&&(C=p.onUncaughtError),p.onCaughtError!==void 0&&(z=p.onCaughtError),p.onRecoverableError!==void 0&&(W=p.onRecoverableError),p.formState!==void 0&&(it=p.formState)),h=QO(u,1,!0,h,p??null,g,I,it,C,z,W,lF),h.context=ZO(null),p=h.current,g=Pi(),g=Vc(g),I=Eu(g),I.callback=null,$u(p,I,g),p=g,h.current.lanes=p,Bc(h,p),La(h),u[va]=h.current,cT(u),new o1(h)},Km.version="19.2.3",Km}var xF;function DX(){if(xF)return RT.exports;xF=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(t){console.error(t)}}return n(),RT.exports=RX(),RT.exports}var OX=DX();const FX=1e-7,MX=1e-4;class WB{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}let d2=class{refCount(t){return vi("refCount")}incRef(t){return vi("incRef")}timerAvailable(){return!0}time(t){return vi("time")}read(t){return vi("read")}readSync(t){return vi("readSync")}readToGPU(t,e){return vi("readToGPU")}numDataIds(){return vi("numDataIds")}disposeData(t,e){return vi("disposeData")}write(t,e,s){return vi("write")}move(t,e,s,r,i){return vi("move")}createTensorFromGPUData(t,e,s){return vi("createTensorFromGPUData")}memory(){return vi("memory")}floatPrecision(){return vi("floatPrecision")}epsilon(){return this.floatPrecision()===32?FX:MX}dispose(){return vi("dispose")}};function vi(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function LX(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,xd(n,t,e)}function Lh(n,t,e){return Math.max(n,Math.min(t,e))}function p2(n){return n%2===0?n:n+1}function xd(n,t,e){const s=n[t];n[t]=n[e],n[e]=s}function zX(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}function H(n,t){if(!n)throw new Error(typeof t=="string"?t:t())}function m2(n,t,e=""){H(mn(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function jB(n){H(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Lt(n){if(n.length===0)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function mn(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function Wd(n){return n%1===0}function NE(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function Dd(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function wF(n,t=r=>0,e,s){return new Promise((r,i)=>{let o=0;const a=()=>{if(n()){r();return}o++;const l=t(o);if(e!=null&&o>=e){i();return}s!=null?s(a,l):setTimeout(a,l)};a()})}function qB(n,t){let e=1,s=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)e*=n[i];else if(n[i]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(s===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(e===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const r=n.slice();return r[s]=t/e,r}function Ve(n,t){const e=t.length;return n=n==null?t.map((s,r)=>r):[].concat(n),H(n.every(s=>s>=-e&&s<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),H(n.every(s=>Wd(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?e+s:s)}function Ac(n,t){const e=[],s=[],r=t!=null&&Array.isArray(t)&&t.length===0,i=t==null||r?null:Ve(t,n).sort();let o=0;for(let a=0;a<n.length;++a){if(i!=null){if(i[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(i[o]==null||i[o]>a)&&n[a]===1&&(e.push(n[a]),s.push(a)),i[o]<=a&&o++}n[a]!==1&&(e.push(n[a]),s.push(a))}return{newShape:e,keptDims:s}}function Nr(n,t){return gs(n,t)}function gs(n,t){let e=null;if(n==null||n==="float32")e=new Float32Array(t);else if(n==="int32")e=new Int32Array(t);else if(n==="bool")e=new Uint8Array(t);else if(n==="string")e=new Array(t);else throw new Error(`Unknown data type ${n}`);return e}function BX(n,t){for(let e=0;e<n.length;e++){const s=n[e];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}function PX(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function HB(n,t){return!(t==="complex64"||t==="float32"&&n!=="complex64"||t==="int32"&&n!=="float32"&&n!=="complex64"||t==="bool"&&n==="bool")}function ex(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function VX(n){if(n==null)return 0;let t=0;return n.forEach(e=>t+=e.length),t}function ty(n){return typeof n=="string"||n instanceof String}function UX(n){return typeof n=="boolean"}function RE(n){return typeof n=="number"}function gp(n){return Array.isArray(n)?gp(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":RE(n)?"float32":ty(n)?"string":UX(n)?"bool":"float32"}function DE(n){return!!(n&&n.constructor&&n.call&&n.apply)}function OE(n,t){for(let e=t;e<n;++e)if(n%e===0)return e;return n}function de(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let s=t-3;s>=0;--s)e[s]=e[s+1]*n[s+1];return e}function KB(n,t,e,s=!1){const r=new Array;if(t.length===1){const i=t[0]*(s?2:1);for(let o=0;o<i;o++)r[o]=e[n+o]}else{const i=t[0],o=t.slice(1),a=o.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<i;l++)r[l]=KB(n+l*a,o,e,s)}return r}function Jo(n,t,e=!1){if(n.length===0)return t[0];const s=n.reduce((r,i)=>r*i)*(e?2:1);if(s===0)return[];if(s!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return KB(0,n,t,e)}function GX(n,t){if(Array.isArray(n))return n;if(t==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(t==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}function g2(n,t){const e=Rr(n,t);for(let s=0;s<e.length;s++)e[s]=1;return e}function Rr(n,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function XB(n,t){const e=n.reduce((s,r)=>s*r,1);if(t==null||t==="float32")return Jo(n,new Float32Array(e));if(t==="int32")return Jo(n,new Int32Array(e));if(t==="bool")return Jo(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function iu(n){n.forEach(t=>{H(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function el(n,t,e){if(t===0)return 0;if(t===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=e[r]*n[r];return s}function yp(n,t,e){if(t===0)return[];if(t===1)return[n];const s=new Array(t);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/e[r]),n-=s[r]*e[r];return s[s.length-1]=n,s}function y2(n){return n&&n.then&&typeof n.then=="function"}const vF="tfjsflags";let WX=class{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=jX,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(At().getBool("IS_TEST")||At().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,s){if(this.flagRegistry[t]={evaluationFn:e,setHook:s},this.urlFlags[t]!=null){const r=this.urlFlags[t];At().getBool("IS_TEST")||At().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${r}.`),this.set(t,r)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(y2(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);vF in t&&t[vF].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=HX(r,i)})}};function jX(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...s)=>(qX(t,s[0],s[1]),s.join("="))),t}function qX(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}function HX(n,t){const e=t.toLowerCase();return e==="true"||e==="false"?e==="true":`${+e}`===e?+e:t}function At(){return YB}let YB=null;function KX(n){YB=n}const oa=globalThis||void 0||self;let MT;function QB(){if(MT==null){let n;if(typeof window<"u")n=window;else if(typeof oa<"u")n=oa;else if(typeof Un<"u")n=Un;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");MT=n}return MT}function XX(){const n=QB();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function b2(n,t){const e=XX();if(e.has(n))return e.get(n);{const s=t();return e.set(n,s),e.get(n)}}const fw="Abs",ey="Acos",ny="Acosh",bp="Add",x2="AddN",w2="All",v2="Any",dw="ArgMax",pw="ArgMin",sy="Asin",ry="Asinh",iy="Atan",oy="Atanh",ay="Atan2",mw="AvgPool",S2="AvgPoolGrad",gw="AvgPool3D",I2="AvgPool3DGrad",yw="BatchMatMul",bw="BatchToSpaceND",T2="Bincount",C2="BitwiseAnd",YX="BroadcastTo",ZB="BroadcastArgs",ly="Cast",uy="Ceil",cy="ClipByValue",E2="Complex",xw="ComplexAbs",ww="Concat",vw="Conv2D",$2="Conv2DBackpropFilter",Sw="Conv2DBackpropInput",Iw="Conv3D",A2="Conv3DBackpropFilterV2",k2="Conv3DBackpropInputV2",hy="Cos",fy="Cosh",_2="Cumprod",Tw="Cumsum",N2="CropAndResize",R2="DenseBincount",D2="DepthToSpace",Cw="DepthwiseConv2dNative",O2="DepthwiseConv2dNativeBackpropFilter",F2="DepthwiseConv2dNativeBackpropInput",JB="Diag",Ew="Dilation2D",FE="Dilation2DBackpropInput",ME="Dilation2DBackpropFilter",QX="Draw",dy="RealDiv",M2="Einsum",py="Elu",L2="EluGrad",my="Erf",$w="Equal",gy="Exp",Aw="ExpandDims",yy="Expm1",z2="FFT",B2="Fill",P2="FlipLeftRight",by="Floor",xy="FloorDiv",kw="FusedBatchNorm",_w="GatherV2",tP="GatherNd",Nw="Greater",wy="GreaterEqual",vy="Identity",V2="IFFT",U2="Imag",Sy="IsFinite",Iy="IsInf",Ty="IsNan",Rw="LeakyRelu",Dw="Less",Ow="LessEqual",eP="LinSpace",Cy="Log",Ey="Log1p",Fw="LogicalAnd",Mw="LogicalNot",Lw="LogicalOr",ZX="LogSoftmax",zw="LRN",G2="LRNGrad",Bw="Max",$y="Maximum",Pw="MaxPool",W2="MaxPoolGrad",Vw="MaxPool3D",j2="MaxPool3DGrad",nP="MaxPoolWithArgmax",Uw="Mean",Gw="Min",Ay="Minimum",Ww="MirrorPad",ky="Mod",sP="Multinomial",_y="Multiply",jw="Neg",qw="NotEqual",q2="NonMaxSuppressionV3",H2="NonMaxSuppressionV4",K2="NonMaxSuppressionV5",Hw="OnesLike",Kw="OneHot",Xw="Pack",Yw="PadV2",Ny="Pow",Qw="Prelu",Zw="Prod",rP="RaggedGather",iP="RaggedRange",oP="RaggedTensorToTensor",X2="Range",Y2="Real",Ry="Reciprocal",Dy="Relu",Jw="Reshape",tv="ResizeNearestNeighbor",Q2="ResizeNearestNeighborGrad",ev="ResizeBilinear",Z2="ResizeBilinearGrad",Oy="Relu6",nv="Reverse",Fy="Round",My="Rsqrt",aP="ScatterNd",lP="TensorScatterUpdate",uP="SearchSorted",sv="Select",Ly="Selu",rv="Slice",zy="Sin",By="Sinh",Py="Sign",Vy="Sigmoid",Uy="Softplus",Gy="Sqrt",iv="Sum",ov="SpaceToBatchND",av="SplitV",lv="Softmax",cP="SparseFillEmptyRows",hP="SparseReshape",fP="SparseSegmentMean",dP="SparseSegmentSum",pP="SparseToDense",Wy="SquaredDifference",J2="Square",tA="StaticRegexReplace",eA="StridedSlice",mP="StringNGrams",gP="StringSplit",yP="StringToHashBucketFast",jy="Sub",qy="Tan",Hy="Tanh",Ky="Tile",nA="TopK",sA="Transform",Od="Transpose",rA="Unique",uv="Unpack",cv="UnsortedSegmentSum",hv="ZerosLike",Xy="Step",JX="FromPixels",iA="RotateWithOffset",nx="_FusedMatMul",sx="FusedConv2D",bP="FusedDepthwiseConv2D";function Ui(...n){At().getBool("IS_TEST")||At().getBool("PROD")||console.warn(...n)}function tY(...n){At().getBool("IS_TEST")||At().getBool("PROD")||console.log(...n)}const rx=b2("kernelRegistry",()=>new Map),LE=b2("gradRegistry",()=>new Map);function SF(n,t){const e=wP(n,t);return rx.get(e)}function IF(n){return LE.get(n)}function TF(n){const t=rx.entries(),e=[];for(;;){const{done:s,value:r}=t.next();if(s)break;const[i,o]=r,[a]=i.split("_");a===n&&e.push(o)}return e}function xP(n){const{kernelName:t,backendName:e}=n,s=wP(t,e);rx.has(s)&&Ui(`The kernel '${t}' for backend '${e}' is already registered`),rx.set(s,n)}function eY(n){const{kernelName:t}=n;LE.has(t)&&At().getBool("DEBUG")&&Ui(`Overriding the gradient for '${t}'`),LE.set(t,n)}function wP(n,t){return`${t}_${n}`}function vP(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var LT,CF;function nY(){if(CF)return LT;CF=1,LT=t;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(F,A,P){this.low=F|0,this.high=A|0,this.unsigned=!!P}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0});function e(F){return(F&&F.__isLong__)===!0}t.isLong=e;var s={},r={};function i(F,A){var P,L,tt;return A?(F>>>=0,(tt=0<=F&&F<256)&&(L=r[F],L)?L:(P=a(F,(F|0)<0?-1:0,!0),tt&&(r[F]=P),P)):(F|=0,(tt=-128<=F&&F<128)&&(L=s[F],L)?L:(P=a(F,F<0?-1:0,!1),tt&&(s[F]=P),P))}t.fromInt=i;function o(F,A){if(isNaN(F))return A?T:S;if(A){if(F<0)return T;if(F>=b)return N}else{if(F<=-w)return k;if(F+1>=w)return B}return F<0?o(-F,A).neg():a(F%y|0,F/y|0,A)}t.fromNumber=o;function a(F,A,P){return new t(F,A,P)}t.fromBits=a;var l=Math.pow;function c(F,A,P){if(F.length===0)throw Error("empty string");if(F==="NaN"||F==="Infinity"||F==="+Infinity"||F==="-Infinity")return S;if(typeof A=="number"?(P=A,A=!1):A=!!A,P=P||10,P<2||36<P)throw RangeError("radix");var L;if((L=F.indexOf("-"))>0)throw Error("interior hyphen");if(L===0)return c(F.substring(1),A,P).neg();for(var tt=o(l(P,8)),st=S,j=0;j<F.length;j+=8){var Z=Math.min(8,F.length-j),J=parseInt(F.substring(j,j+Z),P);if(Z<8){var ot=o(l(P,Z));st=st.mul(ot).add(o(J))}else st=st.mul(tt),st=st.add(o(J))}return st.unsigned=A,st}t.fromString=c;function f(F,A){return typeof F=="number"?o(F,A):typeof F=="string"?c(F,A):a(F.low,F.high,typeof A=="boolean"?A:F.unsigned)}t.fromValue=f;var d=65536,m=1<<24,y=d*d,b=y*y,w=b/2,x=i(m),S=i(0);t.ZERO=S;var T=i(0,!0);t.UZERO=T;var $=i(1);t.ONE=$;var E=i(1,!0);t.UONE=E;var R=i(-1);t.NEG_ONE=R;var B=a(-1,2147483647,!1);t.MAX_VALUE=B;var N=a(-1,-1,!0);t.MAX_UNSIGNED_VALUE=N;var k=a(0,-2147483648,!1);t.MIN_VALUE=k;var _=t.prototype;return _.toInt=function(){return this.unsigned?this.low>>>0:this.low},_.toNumber=function(){return this.unsigned?(this.high>>>0)*y+(this.low>>>0):this.high*y+(this.low>>>0)},_.toString=function(A){if(A=A||10,A<2||36<A)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(k)){var P=o(A),L=this.div(P),tt=L.mul(P).sub(this);return L.toString(A)+tt.toInt().toString(A)}else return"-"+this.neg().toString(A);for(var st=o(l(A,6),this.unsigned),j=this,Z="";;){var J=j.div(st),ot=j.sub(J.mul(st)).toInt()>>>0,pt=ot.toString(A);if(j=J,j.isZero())return pt+Z;for(;pt.length<6;)pt="0"+pt;Z=""+pt+Z}},_.getHighBits=function(){return this.high},_.getHighBitsUnsigned=function(){return this.high>>>0},_.getLowBits=function(){return this.low},_.getLowBitsUnsigned=function(){return this.low>>>0},_.getNumBitsAbs=function(){if(this.isNegative())return this.eq(k)?64:this.neg().getNumBitsAbs();for(var A=this.high!=0?this.high:this.low,P=31;P>0&&(A&1<<P)==0;P--);return this.high!=0?P+33:P+1},_.isZero=function(){return this.high===0&&this.low===0},_.eqz=_.isZero,_.isNegative=function(){return!this.unsigned&&this.high<0},_.isPositive=function(){return this.unsigned||this.high>=0},_.isOdd=function(){return(this.low&1)===1},_.isEven=function(){return(this.low&1)===0},_.equals=function(A){return e(A)||(A=f(A)),this.unsigned!==A.unsigned&&this.high>>>31===1&&A.high>>>31===1?!1:this.high===A.high&&this.low===A.low},_.eq=_.equals,_.notEquals=function(A){return!this.eq(A)},_.neq=_.notEquals,_.ne=_.notEquals,_.lessThan=function(A){return this.comp(A)<0},_.lt=_.lessThan,_.lessThanOrEqual=function(A){return this.comp(A)<=0},_.lte=_.lessThanOrEqual,_.le=_.lessThanOrEqual,_.greaterThan=function(A){return this.comp(A)>0},_.gt=_.greaterThan,_.greaterThanOrEqual=function(A){return this.comp(A)>=0},_.gte=_.greaterThanOrEqual,_.ge=_.greaterThanOrEqual,_.compare=function(A){if(e(A)||(A=f(A)),this.eq(A))return 0;var P=this.isNegative(),L=A.isNegative();return P&&!L?-1:!P&&L?1:this.unsigned?A.high>>>0>this.high>>>0||A.high===this.high&&A.low>>>0>this.low>>>0?-1:1:this.sub(A).isNegative()?-1:1},_.comp=_.compare,_.negate=function(){return!this.unsigned&&this.eq(k)?k:this.not().add($)},_.neg=_.negate,_.add=function(A){e(A)||(A=f(A));var P=this.high>>>16,L=this.high&65535,tt=this.low>>>16,st=this.low&65535,j=A.high>>>16,Z=A.high&65535,J=A.low>>>16,ot=A.low&65535,pt=0,q=0,et=0,U=0;return U+=st+ot,et+=U>>>16,U&=65535,et+=tt+J,q+=et>>>16,et&=65535,q+=L+Z,pt+=q>>>16,q&=65535,pt+=P+j,pt&=65535,a(et<<16|U,pt<<16|q,this.unsigned)},_.subtract=function(A){return e(A)||(A=f(A)),this.add(A.neg())},_.sub=_.subtract,_.multiply=function(A){if(this.isZero())return S;if(e(A)||(A=f(A)),n){var P=n.mul(this.low,this.high,A.low,A.high);return a(P,n.get_high(),this.unsigned)}if(A.isZero())return S;if(this.eq(k))return A.isOdd()?k:S;if(A.eq(k))return this.isOdd()?k:S;if(this.isNegative())return A.isNegative()?this.neg().mul(A.neg()):this.neg().mul(A).neg();if(A.isNegative())return this.mul(A.neg()).neg();if(this.lt(x)&&A.lt(x))return o(this.toNumber()*A.toNumber(),this.unsigned);var L=this.high>>>16,tt=this.high&65535,st=this.low>>>16,j=this.low&65535,Z=A.high>>>16,J=A.high&65535,ot=A.low>>>16,pt=A.low&65535,q=0,et=0,U=0,X=0;return X+=j*pt,U+=X>>>16,X&=65535,U+=st*pt,et+=U>>>16,U&=65535,U+=j*ot,et+=U>>>16,U&=65535,et+=tt*pt,q+=et>>>16,et&=65535,et+=st*ot,q+=et>>>16,et&=65535,et+=j*J,q+=et>>>16,et&=65535,q+=L*pt+tt*ot+st*J+j*Z,q&=65535,a(U<<16|X,q<<16|et,this.unsigned)},_.mul=_.multiply,_.divide=function(A){if(e(A)||(A=f(A)),A.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&A.low===-1&&A.high===-1)return this;var P=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,A.low,A.high);return a(P,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?T:S;var L,tt,st;if(this.unsigned){if(A.unsigned||(A=A.toUnsigned()),A.gt(this))return T;if(A.gt(this.shru(1)))return E;st=T}else{if(this.eq(k)){if(A.eq($)||A.eq(R))return k;if(A.eq(k))return $;var j=this.shr(1);return L=j.div(A).shl(1),L.eq(S)?A.isNegative()?$:R:(tt=this.sub(A.mul(L)),st=L.add(tt.div(A)),st)}else if(A.eq(k))return this.unsigned?T:S;if(this.isNegative())return A.isNegative()?this.neg().div(A.neg()):this.neg().div(A).neg();if(A.isNegative())return this.div(A.neg()).neg();st=S}for(tt=this;tt.gte(A);){L=Math.max(1,Math.floor(tt.toNumber()/A.toNumber()));for(var Z=Math.ceil(Math.log(L)/Math.LN2),J=Z<=48?1:l(2,Z-48),ot=o(L),pt=ot.mul(A);pt.isNegative()||pt.gt(tt);)L-=J,ot=o(L,this.unsigned),pt=ot.mul(A);ot.isZero()&&(ot=$),st=st.add(ot),tt=tt.sub(pt)}return st},_.div=_.divide,_.modulo=function(A){if(e(A)||(A=f(A)),n){var P=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,A.low,A.high);return a(P,n.get_high(),this.unsigned)}return this.sub(this.div(A).mul(A))},_.mod=_.modulo,_.rem=_.modulo,_.not=function(){return a(~this.low,~this.high,this.unsigned)},_.and=function(A){return e(A)||(A=f(A)),a(this.low&A.low,this.high&A.high,this.unsigned)},_.or=function(A){return e(A)||(A=f(A)),a(this.low|A.low,this.high|A.high,this.unsigned)},_.xor=function(A){return e(A)||(A=f(A)),a(this.low^A.low,this.high^A.high,this.unsigned)},_.shiftLeft=function(A){return e(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?a(this.low<<A,this.high<<A|this.low>>>32-A,this.unsigned):a(0,this.low<<A-32,this.unsigned)},_.shl=_.shiftLeft,_.shiftRight=function(A){return e(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?a(this.low>>>A|this.high<<32-A,this.high>>A,this.unsigned):a(this.high>>A-32,this.high>=0?0:-1,this.unsigned)},_.shr=_.shiftRight,_.shiftRightUnsigned=function(A){if(e(A)&&(A=A.toInt()),A&=63,A===0)return this;var P=this.high;if(A<32){var L=this.low;return a(L>>>A|P<<32-A,P>>>A,this.unsigned)}else return A===32?a(P,0,this.unsigned):a(P>>>A-32,0,this.unsigned)},_.shru=_.shiftRightUnsigned,_.shr_u=_.shiftRightUnsigned,_.toSigned=function(){return this.unsigned?a(this.low,this.high,!1):this},_.toUnsigned=function(){return this.unsigned?this:a(this.low,this.high,!0)},_.toBytes=function(A){return A?this.toBytesLE():this.toBytesBE()},_.toBytesLE=function(){var A=this.high,P=this.low;return[P&255,P>>>8&255,P>>>16&255,P>>>24,A&255,A>>>8&255,A>>>16&255,A>>>24]},_.toBytesBE=function(){var A=this.high,P=this.low;return[A>>>24,A>>>16&255,A>>>8&255,A&255,P>>>24,P>>>16&255,P>>>8&255,P&255]},t.fromBytes=function(A,P,L){return L?t.fromBytesLE(A,P):t.fromBytesBE(A,P)},t.fromBytesLE=function(A,P){return new t(A[0]|A[1]<<8|A[2]<<16|A[3]<<24,A[4]|A[5]<<8|A[6]<<16|A[7]<<24,P)},t.fromBytesBE=function(A,P){return new t(A[4]<<24|A[5]<<16|A[6]<<8|A[7],A[0]<<24|A[1]<<16|A[2]<<8|A[3],P)},LT}var SP=nY();const IP=xX(SP),sY=bX({__proto__:null,default:IP},[SP]);const bh=IP||sY;function fv(n){return bh.fromString(n,!0,16)}const TP=fv("c3a5c85c97cb3127"),gh=fv("b492b66fbe98f273"),Wr=fv("9ae16a3b2f90404f");function zE(n){return n.xor(n.shru(47))}function CP(n,t,e){const s=n.slice(t,t+e);return bh.fromBytes(Array.from(s),!0,!0)}function Bn(n,t){return CP(n,t,8)}function EF(n,t){return CP(n,t,4)}function nr(n,t){return t===0?n:n.shru(t).or(n.shl(64-t))}function Zu(n,t,e=fv("9ddfea08eb382d69")){let s=n.xor(t).mul(e);s=s.xor(s.shru(47));let r=t.xor(s).mul(e);return r=r.xor(r.shru(47)),r=r.mul(e),r}function rY(n,t,e,s,r,i){r=r.add(n),i=nr(i.add(r).add(s),21);const o=r;return r=r.add(t),r=r.add(e),i=i.add(nr(r,44)),[r.add(s),i.add(o)]}function l1(n,t,e,s){return rY(Bn(n,t),Bn(n,t+8),Bn(n,t+16),Bn(n,t+24),e,s)}function iY(n,t=n.length){if(t>=8){const e=Wr.add(t*2),s=Bn(n,0).add(Wr),r=Bn(n,t-8),i=nr(r,37).mul(e).add(s),o=nr(s,25).add(r).mul(e);return Zu(i,o,e)}if(t>=4){const e=Wr.add(t*2),s=EF(n,0);return Zu(s.shl(3).add(t),EF(n,t-4),e)}if(t>0){const e=n[0],s=n[t>>1],r=n[t-1],i=e+(s<<8),o=t+(r<<2);return zE(Wr.mul(i).xor(TP.mul(o))).mul(Wr)}return Wr}function oY(n,t=n.length){const e=Wr.add(t*2),s=Bn(n,0).mul(gh),r=Bn(n,8),i=Bn(n,t-8).mul(e),o=Bn(n,t-16).mul(Wr);return Zu(nr(s.add(r),43).add(nr(i,30)).add(o),s.add(nr(r.add(Wr),18)).add(i),e)}function aY(n,t=n.length){const e=Wr.add(t*2),s=Bn(n,0).mul(Wr),r=Bn(n,8),i=Bn(n,t-8).mul(e),o=Bn(n,t-16).mul(Wr),a=nr(s.add(r),43).add(nr(i,30)).add(o),l=Zu(a,s.add(nr(r.add(Wr),18)).add(i),e),c=Bn(n,16).mul(e),f=Bn(n,24),d=a.add(Bn(n,t-32)).mul(e),m=l.add(Bn(n,t-24)).mul(e);return Zu(nr(c.add(f),43).add(nr(d,30)).add(m),c.add(nr(f.add(s),18)).add(d),e)}function lY(n,t=n.length){const e=bh.fromNumber(81,!0);if(t<=32)return t<=16?iY(n,t):oY(n,t);if(t<=64)return aY(n,t);let s=e,r=e.mul(gh).add(113),i=zE(r.mul(Wr).add(113)).mul(Wr),o=[bh.UZERO,bh.UZERO],a=[bh.UZERO,bh.UZERO];s=s.mul(Wr).add(Bn(n,0));let l=0;const c=(t-1>>6)*64,f=c+(t-1&63)-63;do s=nr(s.add(r).add(o[0]).add(Bn(n,l+8)),37).mul(gh),r=nr(r.add(o[1]).add(Bn(n,l+48)),42).mul(gh),s=s.xor(a[1]),r=r.add(o[0]).add(Bn(n,l+40)),i=nr(i.add(a[0]),33).mul(gh),o=l1(n,l,o[1].mul(gh),s.add(a[0])),a=l1(n,l+32,i.add(a[1]),r.add(Bn(n,l+16))),[i,s]=[s,i],l+=64;while(l!==c);const d=gh.add(i.and(255).shl(1));return l=f,a[0]=a[0].add(t-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),s=nr(s.add(r).add(o[0]).add(Bn(n,l+8)),37).mul(d),r=nr(r.add(o[1]).add(Bn(n,l+48)),42).mul(d),s=s.xor(a[1].mul(9)),r=r.add(o[0].mul(9).add(Bn(n,l+40))),i=nr(i.add(a[0]),33).mul(d),o=l1(n,l,o[1].mul(d),s.add(a[0])),a=l1(n,l+32,i.add(a[1]),r.add(Bn(n,l+16))),[i,s]=[s,i],Zu(Zu(o[0],a[0],d).add(zE(r).mul(TP)).add(i),Zu(o[1],a[1],d).add(s),d)}function kc(n,t){return t==="string"?Ju(n):af([n],t)}function uY(n,t){return n instanceof Float32Array&&t==="float32"||n instanceof Int32Array&&t==="int32"||n instanceof Uint8Array&&t==="bool"}function af(n,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=zh(n)),At().getBool("DEBUG")&&BX(n,t),uY(n,t))return n;if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool"){const e=new Uint8Array(n.length);for(let s=0;s<e.length;++s)Math.round(n[s])!==0&&(e[s]=1);return e}else throw new Error(`Unknown data type ${t}`)}function ei(){return At().platform.now()}function Ju(n,t="utf-8"){return t=t||"utf-8",At().platform.encode(n,t)}function lc(n,t="utf-8"){return t=t||"utf-8",At().platform.decode(n,t)}function So(n){return At().platform.isTypedArray!=null?At().platform.isTypedArray(n):vP(n)}function zh(n,t=[],e=!1){if(t==null&&(t=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||y2(n)||n==null||So(n)&&e)t.push(n);else if(Array.isArray(n)||So(n))for(let s=0;s<n.length;++s)zh(n[s],t,e);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)zh(n[r],t,e)}return t}let cY=class{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new fY)}profileKernel(t,e,s){let r;const i=()=>{r=s()};let o;const a=ei();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of r)c.dataSync();o=Promise.resolve({kernelMs:ei()-a})}if(At().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<r.length;c++){const f=r[c];f.data().then(d=>{hY(d,f.dtype,t)})}return{kernelName:t,outputs:r,inputs:e,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:s,timeMs:r,inputs:i,extraInfo:o}=t;s.forEach(a=>{Promise.all([a.data(),r,o]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],i,l[2])})})}};function hY(n,t,e){if(t!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${e}'`),!0}return!1}let fY=class{logKernelProfile(t,e,s,r,i,o){const a=typeof r=="number"?Dd(`${r}ms`,9):r.error,l=Dd(t,25),c=e.rank,f=e.size,d=Dd(e.shape.toString(),14);let m="";for(const y in i){const b=i[y];if(b!=null){const w=b.shape||e.shape,x=w.length;m+=`${y}: ${x}D ${x>0?w:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${d}	%c${f}	%c${m}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function dY(n,t,e){const s={},r={};for(let l=0;l<t.length;l++)s[t[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],f=c.inputs;for(const d in f){const m=f[d];let y=!1;for(let b=0;b<t.length;b++)if(s[m.id]){c.outputs.forEach(w=>s[w.id]=!0),y=!0,r[c.id]=!0;break}if(y)break}}const i={};i[e.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],f=c.inputs;for(let d=0;d<c.outputs.length;d++)if(i[c.outputs[d].id]){for(const m in f)i[f[m].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(r[c.id]&&o[c.id]){const f={};for(const m in c.inputs){const y=c.inputs[m];s[y.id]&&(f[m]=y)}const d=Object.assign({},c);d.inputs=f,d.outputs=c.outputs,a.push(d)}}return a}function pY(n,t,e,s){for(let r=t.length-1;r>=0;r--){const i=t[r],o=[];if(i.outputs.forEach(l=>{const c=n[l.id];c!=null?o.push(c):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=e(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const f=i.inputs[l];if(!mn(c.shape,f.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${f.shape}'`);if(n[f.id]==null)n[f.id]=c;else{const d=n[f.id];n[f.id]=s(d,c),d.dispose()}}}}const $F=20,Xm=3,zT=7;function mY(n,t,e,s){const r=de(t),i=gY(n,t,e,r),o=t.length,a=F1(n,t,e,r,i),l=["Tensor"];return s&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${o}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function gY(n,t,e,s){const r=Lt(t),i=s[s.length-1],o=new Array(i).fill(0),a=t.length,l=e==="complex64"?ng(n):n;if(a>1)for(let c=0;c<r/i;c++){const f=c*i;for(let d=0;d<i;d++)o[d]=Math.max(o[d],eg(l[f+d],0,e).length)}return o}function eg(n,t,e){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(zT))} + ${parseFloat(n[1].toFixed(zT))}j`:ty(n)?s=`'${n}'`:e==="bool"?s=EP(n):s=parseFloat(n.toFixed(zT)).toString(),Dd(s,t)}function EP(n){return n===0?"false":"true"}function F1(n,t,e,s,r,i=!0){const o=e==="complex64"?2:1,a=t[0],l=t.length;if(l===0){if(e==="complex64"){const w=ng(n);return[eg(w[0],0,e)]}return e==="bool"?[EP(n[0])]:[n[0].toString()]}if(l===1){if(a>$F){const x=Xm*o;let S=Array.from(n.slice(0,x)),T=Array.from(n.slice((a-Xm)*o,a*o));return e==="complex64"&&(S=ng(S),T=ng(T)),["["+S.map(($,E)=>eg($,r[E],e)).join(", ")+", ..., "+T.map(($,E)=>eg($,r[a-Xm+E],e)).join(", ")+"]"]}return["["+(e==="complex64"?ng(n):Array.from(n)).map((x,S)=>eg(x,r[S],e)).join(", ")+"]"]}const c=t.slice(1),f=s.slice(1),d=s[0]*o,m=[];if(a>$F){for(let w=0;w<Xm;w++){const x=w*d,S=x+d;m.push(...F1(n.slice(x,S),c,e,f,r,!1))}m.push("...");for(let w=a-Xm;w<a;w++){const x=w*d,S=x+d;m.push(...F1(n.slice(x,S),c,e,f,r,w===a-1))}}else for(let w=0;w<a;w++){const x=w*d,S=x+d;m.push(...F1(n.slice(x,S),c,e,f,r,w===a-1))}const y=l===2?",":"";m[0]="["+(a>0?m[0]+y:"");for(let w=1;w<m.length-1;w++)m[w]=" "+m[w]+y;let b=`,
`;for(let w=2;w<l;w++)b+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(i?"":b),m}function ng(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}let br=class{constructor(t,e,s){if(this.dtype=e,this.shape=t.slice(),this.size=Lt(t),s!=null){const r=s.length;H(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||gs(e,this.size),this.strides=de(t)}set(t,...e){e.length===0&&(e=[0]),H(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const s=this.locToIndex(e);this.values[s]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(const r of t){if(r<0||r>=this.shape[e]){const i=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(i)}e++}let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=this.strides[r]*t[r];return this.values[s]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let s=0;s<t.length-1;++s)e+=this.strides[s]*t[s];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const e=new Array(this.shape.length);for(let s=0;s<e.length-1;++s)e[s]=Math.floor(t/this.strides[s]),t-=e[s]*this.strides[s];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return qo().makeTensor(this.values,this.shape,this.dtype)}},qo=null,wd=null;function yY(n){qo=n}function bY(n){wd=n}let Vs=class{constructor(t,e,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=Lt(t),this.strides=de(t),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return wd.buffer(this.shape,this.dtype,t)}bufferSync(){return wd.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return Jo(this.shape,t,this.dtype==="complex64")}arraySync(){return Jo(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=qo().read(this.dataId);if(this.dtype==="string"){const e=await t;try{return e.map(s=>lc(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),qo().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=qo().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>lc(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await qo().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),qo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return wd.print(this,t)}clone(){return this.throwIfDisposed(),wd.clone(this)}toString(t=!1){const e=this.dataSync();return mY(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),wd.cast(this,t)}variable(t=!0,e,s){return this.throwIfDisposed(),qo().makeVariable(this,t,e,s)}};Object.defineProperty(Vs,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Dt(){return b2("Tensor",()=>Vs)}Dt();let ix=class extends Vs{constructor(t,e,s,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!mn(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);qo().disposeTensor(this),this.dataId=t.dataId,qo().incRef(this,null)}dispose(){qo().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(ix,Symbol.hasInstance,{value:n=>n instanceof Vs&&n.assign!=null&&n.assign instanceof Function});var AF;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(AF||(AF={}));var BE;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(BE||(BE={}));var PE;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(PE||(PE={}));var VE;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(VE||(VE={}));var UE;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(UE||(UE={}));const xY={float32:VE,int32:BE,bool:PE,complex64:UE};function Ei(n,t){if(n==="string"||t==="string"){if(n==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return xY[n][t]}function oA(n){return Ei(n,"int32")}function $P(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function AP(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}function bs(n,t){if(n.dtype===t.dtype)return[n,t];const e=Ei(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function kP(n){const t=[];return _P(n,t,new Set),t}function _P(n,t,e){if(n==null)return;if(n instanceof Vs){t.push(n);return}if(!wY(n))return;const s=n;for(const r in s){const i=s[r];e.has(i)||(e.add(i),_P(i,t,e))}}function wY(n){return Array.isArray(n)||typeof n=="object"}function BT(n){return n.kernelName!=null}let kF=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}},aA=class GE{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new kF}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,s=1){return t in this.registryFactory?(Ui(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:e,asyncInit:s}=this.initializeBackend(t);if(!(s?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new cY(this.backendInstance),!0}setupRegisteredKernels(){TF(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){TF(t).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const s=e.factory();if(s&&!(s instanceof d2)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(o=>r<this.pendingBackendInitId?!1:(this.registry[t]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Ui(`Initialization of backend ${t} failed`),Ui(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return Ui(`Initialization of backend ${t} failed`),Ui(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const s=this.state.tensorInfo.get(e),r=s.backend,i=this.readSync(e),o=r.refCount(e);r.disposeData(e,!0),s.backend=t,t.move(e,i,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let s=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=e(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,e,s){t();try{const r=s();return e(),r}catch(r){throw e(),r}}nextTensorId(){return GE.nextTensorId++}nextVariableId(){return GE.nextVariableId++}clone(t){const e=ft.runKernel(vy,{x:t}),s={x:t},r=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return ft.runKernel(ly,l,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[e],r,i,{}),e}runKernel(t,e,s){if(this.backendName==null&&this.backend,!(SF(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,s){const r=this.backend.numDataIds();let i=0;s.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-e-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)}runKernelFunc(t){let e,s=[];const r=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=BT(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(BT(t)){const{kernelName:b,inputs:w,attrs:x}=t;this.backendName==null&&this.backend;const S=SF(b,this.backendName);H(S!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),a=()=>{const T=this.backend.numDataIds();l=S.kernelFunc({inputs:w,attrs:x,backend:this.backend});const $=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,T,$);const E=$.map(R=>R.rank!=null?R:this.makeTensorFromTensorInfo(R));if(r){const R=this.getTensorsForGradient(b,w,E);s=this.saveTensorsForBackwardMode(R)}return E}}else{const{forwardFunc:b}=t,w=x=>{r&&(s=x.map(S=>this.keep(this.clone(S))))};a=()=>{const x=this.backend.numDataIds();l=this.tidy(()=>b(this.backend,w));const S=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,x,S),S}}const{inputs:f,attrs:d}=t,m=BT(t)?null:t.backwardsFunc;let y;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=a():(y=this.profiler.profileKernel(c,f,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(y),e=y.outputs)}),r&&this.addTapeNode(c,f,e,m,s,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(f).map(b=>f[b]!=null?f[b].shape:null),outputShapes:e.map(b=>b.shape),kernelTimeMs:y.timeMs,extraInfo:y.extraInfo}),Array.isArray(l)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,e,s){const r=IF(t);if(r!=null){const i=r.inputsToSave||[],o=r.outputsToSave||[];let a;r.saveAllInputs?(H(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(e).map(c=>e[c])):a=i.map(c=>e[c]);const l=s.filter((c,f)=>o[f]);return a.concat(l)}return[]}makeTensor(t,e,s,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=t;s==="string"&&ty(t[0])&&(i=t.map(l=>Ju(l)));const o=r.write(i,e,s),a=new Vs(e,s,o,this.nextTensorId());if(this.trackTensor(a,r),s==="string"){const l=this.state.tensorInfo.get(o),c=VX(i);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(t,e,s,r){s=s||"float32";const i={dataId:t,shape:e,dtype:s};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(t,e){const{dataId:s,shape:r,dtype:i}=t,o=new Vs(r,i,s,this.nextTensorId());return this.trackTensor(o,e),o}makeVariable(t,e=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));const i=new ix(t,e,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*ex(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof ix||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const s=t.size*ex(t.dtype);this.state.numBytes-=s}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,s,r,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:s,saved:i},l=IF(t);l!=null&&(r=l.gradFunc),r!=null&&(a.gradient=c=>(c=c.map((f,d)=>{if(f==null){const m=s[d],y=Rr(m.size,m.dtype);return this.makeTensor(y,m.shape,m.dtype)}return f}),r(c.length>1?c:c[0],i,o))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=kP(t),s=new Set(e.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!s.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(t,e,s,r=!1){if(H(e.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));H(i instanceof Vs,()=>"The result y returned by f() must be a tensor.");const o=dY(this.state.activeTape,e,i);if(!r&&o.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=s??vY(i.shape),pY(a,o,c=>this.tidy(c),SY);const l=e.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const f of c.saved)f.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(t){return H(DE(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{H(e.every(a=>a instanceof Vs),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};e.forEach((a,l)=>{r[l]=a});const i=(a,l)=>(s=t(...e,l),H(s.value instanceof Vs,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),H(DE(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(a,l)=>{const c=s.gradFunc(a,l),f=Array.isArray(c)?c:[c];H(f.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),H(f.every(m=>m instanceof Vs),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return f.forEach((m,y)=>{d[y]=()=>m}),d};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=ei(),s=await this.backend.time(t);return s.wallMs=ei()-e,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new kF;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};aA.nextTensorId=0;aA.nextVariableId=0;function vY(n){const t=g2(Lt(n),"float32");return ft.makeTensor(t,n,"float32")}function NP(){const n=QB();if(n._tfengine==null){const t=new WX(n);n._tfengine=new aA(t)}return KX(n._tfengine.ENV),yY(()=>n._tfengine),n._tfengine}const ft=NP();function SY(n,t){const e={a:n,b:t};return ft.runKernel(bp,e)}function IY(){return typeof navigator<"u"&&navigator!=null}function RP(n){if(n||IY()){if(n||(n=navigator),n.product==="ReactNative")return!0;const t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!t){const e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function DP(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const li=At();li.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});li.registerFlag("IS_BROWSER",()=>DP());li.registerFlag("IS_NODE",()=>typeof Un<"u"&&typeof Un.versions<"u"&&typeof Un.versions.node<"u");li.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));li.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));li.registerFlag("PROD",()=>!1);li.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>li.getBool("DEBUG"));li.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);li.registerFlag("IS_TEST",()=>!1);li.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>li.getBool("DEBUG"));li.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);li.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);li.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);var OP={},dv={};dv.byteLength=EY;dv.toByteArray=AY;dv.fromByteArray=NY;var Ya=[],po=[],TY=typeof Uint8Array<"u"?Uint8Array:Array,PT="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var dd=0,CY=PT.length;dd<CY;++dd)Ya[dd]=PT[dd],po[PT.charCodeAt(dd)]=dd;po[45]=62;po[95]=63;function FP(n){var t=n.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var e=n.indexOf("=");e===-1&&(e=t);var s=e===t?0:4-e%4;return[e,s]}function EY(n){var t=FP(n),e=t[0],s=t[1];return(e+s)*3/4-s}function $Y(n,t,e){return(t+e)*3/4-e}function AY(n){var t,e=FP(n),s=e[0],r=e[1],i=new TY($Y(n,s,r)),o=0,a=r>0?s-4:s,l;for(l=0;l<a;l+=4)t=po[n.charCodeAt(l)]<<18|po[n.charCodeAt(l+1)]<<12|po[n.charCodeAt(l+2)]<<6|po[n.charCodeAt(l+3)],i[o++]=t>>16&255,i[o++]=t>>8&255,i[o++]=t&255;return r===2&&(t=po[n.charCodeAt(l)]<<2|po[n.charCodeAt(l+1)]>>4,i[o++]=t&255),r===1&&(t=po[n.charCodeAt(l)]<<10|po[n.charCodeAt(l+1)]<<4|po[n.charCodeAt(l+2)]>>2,i[o++]=t>>8&255,i[o++]=t&255),i}function kY(n){return Ya[n>>18&63]+Ya[n>>12&63]+Ya[n>>6&63]+Ya[n&63]}function _Y(n,t,e){for(var s,r=[],i=t;i<e;i+=3)s=(n[i]<<16&16711680)+(n[i+1]<<8&65280)+(n[i+2]&255),r.push(kY(s));return r.join("")}function NY(n){for(var t,e=n.length,s=e%3,r=[],i=16383,o=0,a=e-s;o<a;o+=i)r.push(_Y(n,o,o+i>a?a:o+i));return s===1?(t=n[e-1],r.push(Ya[t>>2]+Ya[t<<4&63]+"==")):s===2&&(t=(n[e-2]<<8)+n[e-1],r.push(Ya[t>>10]+Ya[t>>4&63]+Ya[t<<2&63]+"=")),r.join("")}var lA={};lA.read=function(n,t,e,s,r){var i,o,a=r*8-s-1,l=(1<<a)-1,c=l>>1,f=-7,d=e?r-1:0,m=e?-1:1,y=n[t+d];for(d+=m,i=y&(1<<-f)-1,y>>=-f,f+=a;f>0;i=i*256+n[t+d],d+=m,f-=8);for(o=i&(1<<-f)-1,i>>=-f,f+=s;f>0;o=o*256+n[t+d],d+=m,f-=8);if(i===0)i=1-c;else{if(i===l)return o?NaN:(y?-1:1)*(1/0);o=o+Math.pow(2,s),i=i-c}return(y?-1:1)*o*Math.pow(2,i-s)};lA.write=function(n,t,e,s,r,i){var o,a,l,c=i*8-r-1,f=(1<<c)-1,d=f>>1,m=r===23?Math.pow(2,-24)-Math.pow(2,-77):0,y=s?0:i-1,b=s?1:-1,w=t<0||t===0&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(a=isNaN(t)?1:0,o=f):(o=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-o))<1&&(o--,l*=2),o+d>=1?t+=m/l:t+=m*Math.pow(2,1-d),t*l>=2&&(o++,l/=2),o+d>=f?(a=0,o=f):o+d>=1?(a=(t*l-1)*Math.pow(2,r),o=o+d):(a=t*Math.pow(2,d-1)*Math.pow(2,r),o=0));r>=8;n[e+y]=a&255,y+=b,a/=256,r-=8);for(o=o<<r|a,c+=r;c>0;n[e+y]=o&255,y+=b,o/=256,c-=8);n[e+y-b]|=w*128};(function(n){const t=dv,e=lA,s=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;n.Buffer=f,n.SlowBuffer=R,n.INSPECT_MAX_BYTES=50;const r=2147483647;n.kMaxLength=r;const{Uint8Array:i,ArrayBuffer:o,SharedArrayBuffer:a}=globalThis;f.TYPED_ARRAY_SUPPORT=l(),!f.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function l(){try{const G=new i(1),O={foo:function(){return 42}};return Object.setPrototypeOf(O,i.prototype),Object.setPrototypeOf(G,O),G.foo()===42}catch{return!1}}Object.defineProperty(f.prototype,"parent",{enumerable:!0,get:function(){if(f.isBuffer(this))return this.buffer}}),Object.defineProperty(f.prototype,"offset",{enumerable:!0,get:function(){if(f.isBuffer(this))return this.byteOffset}});function c(G){if(G>r)throw new RangeError('The value "'+G+'" is invalid for option "size"');const O=new i(G);return Object.setPrototypeOf(O,f.prototype),O}function f(G,O,M){if(typeof G=="number"){if(typeof O=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return b(G)}return d(G,O,M)}f.poolSize=8192;function d(G,O,M){if(typeof G=="string")return w(G,O);if(o.isView(G))return S(G);if(G==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof G);if(Nn(G,o)||G&&Nn(G.buffer,o)||typeof a<"u"&&(Nn(G,a)||G&&Nn(G.buffer,a)))return T(G,O,M);if(typeof G=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const Y=G.valueOf&&G.valueOf();if(Y!=null&&Y!==G)return f.from(Y,O,M);const at=$(G);if(at)return at;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof G[Symbol.toPrimitive]=="function")return f.from(G[Symbol.toPrimitive]("string"),O,M);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof G)}f.from=function(G,O,M){return d(G,O,M)},Object.setPrototypeOf(f.prototype,i.prototype),Object.setPrototypeOf(f,i);function m(G){if(typeof G!="number")throw new TypeError('"size" argument must be of type number');if(G<0)throw new RangeError('The value "'+G+'" is invalid for option "size"')}function y(G,O,M){return m(G),G<=0?c(G):O!==void 0?typeof M=="string"?c(G).fill(O,M):c(G).fill(O):c(G)}f.alloc=function(G,O,M){return y(G,O,M)};function b(G){return m(G),c(G<0?0:E(G)|0)}f.allocUnsafe=function(G){return b(G)},f.allocUnsafeSlow=function(G){return b(G)};function w(G,O){if((typeof O!="string"||O==="")&&(O="utf8"),!f.isEncoding(O))throw new TypeError("Unknown encoding: "+O);const M=B(G,O)|0;let Y=c(M);const at=Y.write(G,O);return at!==M&&(Y=Y.slice(0,at)),Y}function x(G){const O=G.length<0?0:E(G.length)|0,M=c(O);for(let Y=0;Y<O;Y+=1)M[Y]=G[Y]&255;return M}function S(G){if(Nn(G,i)){const O=new i(G);return T(O.buffer,O.byteOffset,O.byteLength)}return x(G)}function T(G,O,M){if(O<0||G.byteLength<O)throw new RangeError('"offset" is outside of buffer bounds');if(G.byteLength<O+(M||0))throw new RangeError('"length" is outside of buffer bounds');let Y;return O===void 0&&M===void 0?Y=new i(G):M===void 0?Y=new i(G,O):Y=new i(G,O,M),Object.setPrototypeOf(Y,f.prototype),Y}function $(G){if(f.isBuffer(G)){const O=E(G.length)|0,M=c(O);return M.length===0||G.copy(M,0,0,O),M}if(G.length!==void 0)return typeof G.length!="number"||cr(G.length)?c(0):x(G);if(G.type==="Buffer"&&Array.isArray(G.data))return x(G.data)}function E(G){if(G>=r)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+r.toString(16)+" bytes");return G|0}function R(G){return+G!=G&&(G=0),f.alloc(+G)}f.isBuffer=function(O){return O!=null&&O._isBuffer===!0&&O!==f.prototype},f.compare=function(O,M){if(Nn(O,i)&&(O=f.from(O,O.offset,O.byteLength)),Nn(M,i)&&(M=f.from(M,M.offset,M.byteLength)),!f.isBuffer(O)||!f.isBuffer(M))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(O===M)return 0;let Y=O.length,at=M.length;for(let Ct=0,Mt=Math.min(Y,at);Ct<Mt;++Ct)if(O[Ct]!==M[Ct]){Y=O[Ct],at=M[Ct];break}return Y<at?-1:at<Y?1:0},f.isEncoding=function(O){switch(String(O).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},f.concat=function(O,M){if(!Array.isArray(O))throw new TypeError('"list" argument must be an Array of Buffers');if(O.length===0)return f.alloc(0);let Y;if(M===void 0)for(M=0,Y=0;Y<O.length;++Y)M+=O[Y].length;const at=f.allocUnsafe(M);let Ct=0;for(Y=0;Y<O.length;++Y){let Mt=O[Y];if(Nn(Mt,i))Ct+Mt.length>at.length?(f.isBuffer(Mt)||(Mt=f.from(Mt)),Mt.copy(at,Ct)):i.prototype.set.call(at,Mt,Ct);else if(f.isBuffer(Mt))Mt.copy(at,Ct);else throw new TypeError('"list" argument must be an Array of Buffers');Ct+=Mt.length}return at};function B(G,O){if(f.isBuffer(G))return G.length;if(o.isView(G)||Nn(G,o))return G.byteLength;if(typeof G!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof G);const M=G.length,Y=arguments.length>2&&arguments[2]===!0;if(!Y&&M===0)return 0;let at=!1;for(;;)switch(O){case"ascii":case"latin1":case"binary":return M;case"utf8":case"utf-8":return Ie(G).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return M*2;case"hex":return M>>>1;case"base64":return Ns(G).length;default:if(at)return Y?-1:Ie(G).length;O=(""+O).toLowerCase(),at=!0}}f.byteLength=B;function N(G,O,M){let Y=!1;if((O===void 0||O<0)&&(O=0),O>this.length||((M===void 0||M>this.length)&&(M=this.length),M<=0)||(M>>>=0,O>>>=0,M<=O))return"";for(G||(G="utf8");;)switch(G){case"hex":return et(this,O,M);case"utf8":case"utf-8":return Z(this,O,M);case"ascii":return pt(this,O,M);case"latin1":case"binary":return q(this,O,M);case"base64":return j(this,O,M);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return U(this,O,M);default:if(Y)throw new TypeError("Unknown encoding: "+G);G=(G+"").toLowerCase(),Y=!0}}f.prototype._isBuffer=!0;function k(G,O,M){const Y=G[O];G[O]=G[M],G[M]=Y}f.prototype.swap16=function(){const O=this.length;if(O%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let M=0;M<O;M+=2)k(this,M,M+1);return this},f.prototype.swap32=function(){const O=this.length;if(O%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let M=0;M<O;M+=4)k(this,M,M+3),k(this,M+1,M+2);return this},f.prototype.swap64=function(){const O=this.length;if(O%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let M=0;M<O;M+=8)k(this,M,M+7),k(this,M+1,M+6),k(this,M+2,M+5),k(this,M+3,M+4);return this},f.prototype.toString=function(){const O=this.length;return O===0?"":arguments.length===0?Z(this,0,O):N.apply(this,arguments)},f.prototype.toLocaleString=f.prototype.toString,f.prototype.equals=function(O){if(!f.isBuffer(O))throw new TypeError("Argument must be a Buffer");return this===O?!0:f.compare(this,O)===0},f.prototype.inspect=function(){let O="";const M=n.INSPECT_MAX_BYTES;return O=this.toString("hex",0,M).replace(/(.{2})/g,"$1 ").trim(),this.length>M&&(O+=" ... "),"<Buffer "+O+">"},s&&(f.prototype[s]=f.prototype.inspect),f.prototype.compare=function(O,M,Y,at,Ct){if(Nn(O,i)&&(O=f.from(O,O.offset,O.byteLength)),!f.isBuffer(O))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof O);if(M===void 0&&(M=0),Y===void 0&&(Y=O?O.length:0),at===void 0&&(at=0),Ct===void 0&&(Ct=this.length),M<0||Y>O.length||at<0||Ct>this.length)throw new RangeError("out of range index");if(at>=Ct&&M>=Y)return 0;if(at>=Ct)return-1;if(M>=Y)return 1;if(M>>>=0,Y>>>=0,at>>>=0,Ct>>>=0,this===O)return 0;let Mt=Ct-at,Oe=Y-M;const Cn=Math.min(Mt,Oe),En=this.slice(at,Ct),un=O.slice(M,Y);for(let Je=0;Je<Cn;++Je)if(En[Je]!==un[Je]){Mt=En[Je],Oe=un[Je];break}return Mt<Oe?-1:Oe<Mt?1:0};function _(G,O,M,Y,at){if(G.length===0)return-1;if(typeof M=="string"?(Y=M,M=0):M>2147483647?M=2147483647:M<-2147483648&&(M=-2147483648),M=+M,cr(M)&&(M=at?0:G.length-1),M<0&&(M=G.length+M),M>=G.length){if(at)return-1;M=G.length-1}else if(M<0)if(at)M=0;else return-1;if(typeof O=="string"&&(O=f.from(O,Y)),f.isBuffer(O))return O.length===0?-1:F(G,O,M,Y,at);if(typeof O=="number")return O=O&255,typeof i.prototype.indexOf=="function"?at?i.prototype.indexOf.call(G,O,M):i.prototype.lastIndexOf.call(G,O,M):F(G,[O],M,Y,at);throw new TypeError("val must be string, number or Buffer")}function F(G,O,M,Y,at){let Ct=1,Mt=G.length,Oe=O.length;if(Y!==void 0&&(Y=String(Y).toLowerCase(),Y==="ucs2"||Y==="ucs-2"||Y==="utf16le"||Y==="utf-16le")){if(G.length<2||O.length<2)return-1;Ct=2,Mt/=2,Oe/=2,M/=2}function Cn(un,Je){return Ct===1?un[Je]:un.readUInt16BE(Je*Ct)}let En;if(at){let un=-1;for(En=M;En<Mt;En++)if(Cn(G,En)===Cn(O,un===-1?0:En-un)){if(un===-1&&(un=En),En-un+1===Oe)return un*Ct}else un!==-1&&(En-=En-un),un=-1}else for(M+Oe>Mt&&(M=Mt-Oe),En=M;En>=0;En--){let un=!0;for(let Je=0;Je<Oe;Je++)if(Cn(G,En+Je)!==Cn(O,Je)){un=!1;break}if(un)return En}return-1}f.prototype.includes=function(O,M,Y){return this.indexOf(O,M,Y)!==-1},f.prototype.indexOf=function(O,M,Y){return _(this,O,M,Y,!0)},f.prototype.lastIndexOf=function(O,M,Y){return _(this,O,M,Y,!1)};function A(G,O,M,Y){M=Number(M)||0;const at=G.length-M;Y?(Y=Number(Y),Y>at&&(Y=at)):Y=at;const Ct=O.length;Y>Ct/2&&(Y=Ct/2);let Mt;for(Mt=0;Mt<Y;++Mt){const Oe=parseInt(O.substr(Mt*2,2),16);if(cr(Oe))return Mt;G[M+Mt]=Oe}return Mt}function P(G,O,M,Y){return je(Ie(O,G.length-M),G,M,Y)}function L(G,O,M,Y){return je(wn(O),G,M,Y)}function tt(G,O,M,Y){return je(Ns(O),G,M,Y)}function st(G,O,M,Y){return je(rs(O,G.length-M),G,M,Y)}f.prototype.write=function(O,M,Y,at){if(M===void 0)at="utf8",Y=this.length,M=0;else if(Y===void 0&&typeof M=="string")at=M,Y=this.length,M=0;else if(isFinite(M))M=M>>>0,isFinite(Y)?(Y=Y>>>0,at===void 0&&(at="utf8")):(at=Y,Y=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const Ct=this.length-M;if((Y===void 0||Y>Ct)&&(Y=Ct),O.length>0&&(Y<0||M<0)||M>this.length)throw new RangeError("Attempt to write outside buffer bounds");at||(at="utf8");let Mt=!1;for(;;)switch(at){case"hex":return A(this,O,M,Y);case"utf8":case"utf-8":return P(this,O,M,Y);case"ascii":case"latin1":case"binary":return L(this,O,M,Y);case"base64":return tt(this,O,M,Y);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return st(this,O,M,Y);default:if(Mt)throw new TypeError("Unknown encoding: "+at);at=(""+at).toLowerCase(),Mt=!0}},f.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function j(G,O,M){return O===0&&M===G.length?t.fromByteArray(G):t.fromByteArray(G.slice(O,M))}function Z(G,O,M){M=Math.min(G.length,M);const Y=[];let at=O;for(;at<M;){const Ct=G[at];let Mt=null,Oe=Ct>239?4:Ct>223?3:Ct>191?2:1;if(at+Oe<=M){let Cn,En,un,Je;switch(Oe){case 1:Ct<128&&(Mt=Ct);break;case 2:Cn=G[at+1],(Cn&192)===128&&(Je=(Ct&31)<<6|Cn&63,Je>127&&(Mt=Je));break;case 3:Cn=G[at+1],En=G[at+2],(Cn&192)===128&&(En&192)===128&&(Je=(Ct&15)<<12|(Cn&63)<<6|En&63,Je>2047&&(Je<55296||Je>57343)&&(Mt=Je));break;case 4:Cn=G[at+1],En=G[at+2],un=G[at+3],(Cn&192)===128&&(En&192)===128&&(un&192)===128&&(Je=(Ct&15)<<18|(Cn&63)<<12|(En&63)<<6|un&63,Je>65535&&Je<1114112&&(Mt=Je))}}Mt===null?(Mt=65533,Oe=1):Mt>65535&&(Mt-=65536,Y.push(Mt>>>10&1023|55296),Mt=56320|Mt&1023),Y.push(Mt),at+=Oe}return ot(Y)}const J=4096;function ot(G){const O=G.length;if(O<=J)return String.fromCharCode.apply(String,G);let M="",Y=0;for(;Y<O;)M+=String.fromCharCode.apply(String,G.slice(Y,Y+=J));return M}function pt(G,O,M){let Y="";M=Math.min(G.length,M);for(let at=O;at<M;++at)Y+=String.fromCharCode(G[at]&127);return Y}function q(G,O,M){let Y="";M=Math.min(G.length,M);for(let at=O;at<M;++at)Y+=String.fromCharCode(G[at]);return Y}function et(G,O,M){const Y=G.length;(!O||O<0)&&(O=0),(!M||M<0||M>Y)&&(M=Y);let at="";for(let Ct=O;Ct<M;++Ct)at+=zr[G[Ct]];return at}function U(G,O,M){const Y=G.slice(O,M);let at="";for(let Ct=0;Ct<Y.length-1;Ct+=2)at+=String.fromCharCode(Y[Ct]+Y[Ct+1]*256);return at}f.prototype.slice=function(O,M){const Y=this.length;O=~~O,M=M===void 0?Y:~~M,O<0?(O+=Y,O<0&&(O=0)):O>Y&&(O=Y),M<0?(M+=Y,M<0&&(M=0)):M>Y&&(M=Y),M<O&&(M=O);const at=this.subarray(O,M);return Object.setPrototypeOf(at,f.prototype),at};function X(G,O,M){if(G%1!==0||G<0)throw new RangeError("offset is not uint");if(G+O>M)throw new RangeError("Trying to access beyond buffer length")}f.prototype.readUintLE=f.prototype.readUIntLE=function(O,M,Y){O=O>>>0,M=M>>>0,Y||X(O,M,this.length);let at=this[O],Ct=1,Mt=0;for(;++Mt<M&&(Ct*=256);)at+=this[O+Mt]*Ct;return at},f.prototype.readUintBE=f.prototype.readUIntBE=function(O,M,Y){O=O>>>0,M=M>>>0,Y||X(O,M,this.length);let at=this[O+--M],Ct=1;for(;M>0&&(Ct*=256);)at+=this[O+--M]*Ct;return at},f.prototype.readUint8=f.prototype.readUInt8=function(O,M){return O=O>>>0,M||X(O,1,this.length),this[O]},f.prototype.readUint16LE=f.prototype.readUInt16LE=function(O,M){return O=O>>>0,M||X(O,2,this.length),this[O]|this[O+1]<<8},f.prototype.readUint16BE=f.prototype.readUInt16BE=function(O,M){return O=O>>>0,M||X(O,2,this.length),this[O]<<8|this[O+1]},f.prototype.readUint32LE=f.prototype.readUInt32LE=function(O,M){return O=O>>>0,M||X(O,4,this.length),(this[O]|this[O+1]<<8|this[O+2]<<16)+this[O+3]*16777216},f.prototype.readUint32BE=f.prototype.readUInt32BE=function(O,M){return O=O>>>0,M||X(O,4,this.length),this[O]*16777216+(this[O+1]<<16|this[O+2]<<8|this[O+3])},f.prototype.readBigUInt64LE=Wn(function(O){O=O>>>0,ie(O,"offset");const M=this[O],Y=this[O+7];(M===void 0||Y===void 0)&&Ae(O,this.length-8);const at=M+this[++O]*2**8+this[++O]*2**16+this[++O]*2**24,Ct=this[++O]+this[++O]*2**8+this[++O]*2**16+Y*2**24;return BigInt(at)+(BigInt(Ct)<<BigInt(32))}),f.prototype.readBigUInt64BE=Wn(function(O){O=O>>>0,ie(O,"offset");const M=this[O],Y=this[O+7];(M===void 0||Y===void 0)&&Ae(O,this.length-8);const at=M*2**24+this[++O]*2**16+this[++O]*2**8+this[++O],Ct=this[++O]*2**24+this[++O]*2**16+this[++O]*2**8+Y;return(BigInt(at)<<BigInt(32))+BigInt(Ct)}),f.prototype.readIntLE=function(O,M,Y){O=O>>>0,M=M>>>0,Y||X(O,M,this.length);let at=this[O],Ct=1,Mt=0;for(;++Mt<M&&(Ct*=256);)at+=this[O+Mt]*Ct;return Ct*=128,at>=Ct&&(at-=Math.pow(2,8*M)),at},f.prototype.readIntBE=function(O,M,Y){O=O>>>0,M=M>>>0,Y||X(O,M,this.length);let at=M,Ct=1,Mt=this[O+--at];for(;at>0&&(Ct*=256);)Mt+=this[O+--at]*Ct;return Ct*=128,Mt>=Ct&&(Mt-=Math.pow(2,8*M)),Mt},f.prototype.readInt8=function(O,M){return O=O>>>0,M||X(O,1,this.length),this[O]&128?(255-this[O]+1)*-1:this[O]},f.prototype.readInt16LE=function(O,M){O=O>>>0,M||X(O,2,this.length);const Y=this[O]|this[O+1]<<8;return Y&32768?Y|4294901760:Y},f.prototype.readInt16BE=function(O,M){O=O>>>0,M||X(O,2,this.length);const Y=this[O+1]|this[O]<<8;return Y&32768?Y|4294901760:Y},f.prototype.readInt32LE=function(O,M){return O=O>>>0,M||X(O,4,this.length),this[O]|this[O+1]<<8|this[O+2]<<16|this[O+3]<<24},f.prototype.readInt32BE=function(O,M){return O=O>>>0,M||X(O,4,this.length),this[O]<<24|this[O+1]<<16|this[O+2]<<8|this[O+3]},f.prototype.readBigInt64LE=Wn(function(O){O=O>>>0,ie(O,"offset");const M=this[O],Y=this[O+7];(M===void 0||Y===void 0)&&Ae(O,this.length-8);const at=this[O+4]+this[O+5]*2**8+this[O+6]*2**16+(Y<<24);return(BigInt(at)<<BigInt(32))+BigInt(M+this[++O]*2**8+this[++O]*2**16+this[++O]*2**24)}),f.prototype.readBigInt64BE=Wn(function(O){O=O>>>0,ie(O,"offset");const M=this[O],Y=this[O+7];(M===void 0||Y===void 0)&&Ae(O,this.length-8);const at=(M<<24)+this[++O]*2**16+this[++O]*2**8+this[++O];return(BigInt(at)<<BigInt(32))+BigInt(this[++O]*2**24+this[++O]*2**16+this[++O]*2**8+Y)}),f.prototype.readFloatLE=function(O,M){return O=O>>>0,M||X(O,4,this.length),e.read(this,O,!0,23,4)},f.prototype.readFloatBE=function(O,M){return O=O>>>0,M||X(O,4,this.length),e.read(this,O,!1,23,4)},f.prototype.readDoubleLE=function(O,M){return O=O>>>0,M||X(O,8,this.length),e.read(this,O,!0,52,8)},f.prototype.readDoubleBE=function(O,M){return O=O>>>0,M||X(O,8,this.length),e.read(this,O,!1,52,8)};function nt(G,O,M,Y,at,Ct){if(!f.isBuffer(G))throw new TypeError('"buffer" argument must be a Buffer instance');if(O>at||O<Ct)throw new RangeError('"value" argument is out of bounds');if(M+Y>G.length)throw new RangeError("Index out of range")}f.prototype.writeUintLE=f.prototype.writeUIntLE=function(O,M,Y,at){if(O=+O,M=M>>>0,Y=Y>>>0,!at){const Oe=Math.pow(2,8*Y)-1;nt(this,O,M,Y,Oe,0)}let Ct=1,Mt=0;for(this[M]=O&255;++Mt<Y&&(Ct*=256);)this[M+Mt]=O/Ct&255;return M+Y},f.prototype.writeUintBE=f.prototype.writeUIntBE=function(O,M,Y,at){if(O=+O,M=M>>>0,Y=Y>>>0,!at){const Oe=Math.pow(2,8*Y)-1;nt(this,O,M,Y,Oe,0)}let Ct=Y-1,Mt=1;for(this[M+Ct]=O&255;--Ct>=0&&(Mt*=256);)this[M+Ct]=O/Mt&255;return M+Y},f.prototype.writeUint8=f.prototype.writeUInt8=function(O,M,Y){return O=+O,M=M>>>0,Y||nt(this,O,M,1,255,0),this[M]=O&255,M+1},f.prototype.writeUint16LE=f.prototype.writeUInt16LE=function(O,M,Y){return O=+O,M=M>>>0,Y||nt(this,O,M,2,65535,0),this[M]=O&255,this[M+1]=O>>>8,M+2},f.prototype.writeUint16BE=f.prototype.writeUInt16BE=function(O,M,Y){return O=+O,M=M>>>0,Y||nt(this,O,M,2,65535,0),this[M]=O>>>8,this[M+1]=O&255,M+2},f.prototype.writeUint32LE=f.prototype.writeUInt32LE=function(O,M,Y){return O=+O,M=M>>>0,Y||nt(this,O,M,4,4294967295,0),this[M+3]=O>>>24,this[M+2]=O>>>16,this[M+1]=O>>>8,this[M]=O&255,M+4},f.prototype.writeUint32BE=f.prototype.writeUInt32BE=function(O,M,Y){return O=+O,M=M>>>0,Y||nt(this,O,M,4,4294967295,0),this[M]=O>>>24,this[M+1]=O>>>16,this[M+2]=O>>>8,this[M+3]=O&255,M+4};function xt(G,O,M,Y,at){pe(O,Y,at,G,M,7);let Ct=Number(O&BigInt(4294967295));G[M++]=Ct,Ct=Ct>>8,G[M++]=Ct,Ct=Ct>>8,G[M++]=Ct,Ct=Ct>>8,G[M++]=Ct;let Mt=Number(O>>BigInt(32)&BigInt(4294967295));return G[M++]=Mt,Mt=Mt>>8,G[M++]=Mt,Mt=Mt>>8,G[M++]=Mt,Mt=Mt>>8,G[M++]=Mt,M}function Ot(G,O,M,Y,at){pe(O,Y,at,G,M,7);let Ct=Number(O&BigInt(4294967295));G[M+7]=Ct,Ct=Ct>>8,G[M+6]=Ct,Ct=Ct>>8,G[M+5]=Ct,Ct=Ct>>8,G[M+4]=Ct;let Mt=Number(O>>BigInt(32)&BigInt(4294967295));return G[M+3]=Mt,Mt=Mt>>8,G[M+2]=Mt,Mt=Mt>>8,G[M+1]=Mt,Mt=Mt>>8,G[M]=Mt,M+8}f.prototype.writeBigUInt64LE=Wn(function(O,M=0){return xt(this,O,M,BigInt(0),BigInt("0xffffffffffffffff"))}),f.prototype.writeBigUInt64BE=Wn(function(O,M=0){return Ot(this,O,M,BigInt(0),BigInt("0xffffffffffffffff"))}),f.prototype.writeIntLE=function(O,M,Y,at){if(O=+O,M=M>>>0,!at){const Cn=Math.pow(2,8*Y-1);nt(this,O,M,Y,Cn-1,-Cn)}let Ct=0,Mt=1,Oe=0;for(this[M]=O&255;++Ct<Y&&(Mt*=256);)O<0&&Oe===0&&this[M+Ct-1]!==0&&(Oe=1),this[M+Ct]=(O/Mt>>0)-Oe&255;return M+Y},f.prototype.writeIntBE=function(O,M,Y,at){if(O=+O,M=M>>>0,!at){const Cn=Math.pow(2,8*Y-1);nt(this,O,M,Y,Cn-1,-Cn)}let Ct=Y-1,Mt=1,Oe=0;for(this[M+Ct]=O&255;--Ct>=0&&(Mt*=256);)O<0&&Oe===0&&this[M+Ct+1]!==0&&(Oe=1),this[M+Ct]=(O/Mt>>0)-Oe&255;return M+Y},f.prototype.writeInt8=function(O,M,Y){return O=+O,M=M>>>0,Y||nt(this,O,M,1,127,-128),O<0&&(O=255+O+1),this[M]=O&255,M+1},f.prototype.writeInt16LE=function(O,M,Y){return O=+O,M=M>>>0,Y||nt(this,O,M,2,32767,-32768),this[M]=O&255,this[M+1]=O>>>8,M+2},f.prototype.writeInt16BE=function(O,M,Y){return O=+O,M=M>>>0,Y||nt(this,O,M,2,32767,-32768),this[M]=O>>>8,this[M+1]=O&255,M+2},f.prototype.writeInt32LE=function(O,M,Y){return O=+O,M=M>>>0,Y||nt(this,O,M,4,2147483647,-2147483648),this[M]=O&255,this[M+1]=O>>>8,this[M+2]=O>>>16,this[M+3]=O>>>24,M+4},f.prototype.writeInt32BE=function(O,M,Y){return O=+O,M=M>>>0,Y||nt(this,O,M,4,2147483647,-2147483648),O<0&&(O=4294967295+O+1),this[M]=O>>>24,this[M+1]=O>>>16,this[M+2]=O>>>8,this[M+3]=O&255,M+4},f.prototype.writeBigInt64LE=Wn(function(O,M=0){return xt(this,O,M,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),f.prototype.writeBigInt64BE=Wn(function(O,M=0){return Ot(this,O,M,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function qt(G,O,M,Y,at,Ct){if(M+Y>G.length)throw new RangeError("Index out of range");if(M<0)throw new RangeError("Index out of range")}function zt(G,O,M,Y,at){return O=+O,M=M>>>0,at||qt(G,O,M,4),e.write(G,O,M,Y,23,4),M+4}f.prototype.writeFloatLE=function(O,M,Y){return zt(this,O,M,!0,Y)},f.prototype.writeFloatBE=function(O,M,Y){return zt(this,O,M,!1,Y)};function Wt(G,O,M,Y,at){return O=+O,M=M>>>0,at||qt(G,O,M,8),e.write(G,O,M,Y,52,8),M+8}f.prototype.writeDoubleLE=function(O,M,Y){return Wt(this,O,M,!0,Y)},f.prototype.writeDoubleBE=function(O,M,Y){return Wt(this,O,M,!1,Y)},f.prototype.copy=function(O,M,Y,at){if(!f.isBuffer(O))throw new TypeError("argument should be a Buffer");if(Y||(Y=0),!at&&at!==0&&(at=this.length),M>=O.length&&(M=O.length),M||(M=0),at>0&&at<Y&&(at=Y),at===Y||O.length===0||this.length===0)return 0;if(M<0)throw new RangeError("targetStart out of bounds");if(Y<0||Y>=this.length)throw new RangeError("Index out of range");if(at<0)throw new RangeError("sourceEnd out of bounds");at>this.length&&(at=this.length),O.length-M<at-Y&&(at=O.length-M+Y);const Ct=at-Y;return this===O&&typeof i.prototype.copyWithin=="function"?this.copyWithin(M,Y,at):i.prototype.set.call(O,this.subarray(Y,at),M),Ct},f.prototype.fill=function(O,M,Y,at){if(typeof O=="string"){if(typeof M=="string"?(at=M,M=0,Y=this.length):typeof Y=="string"&&(at=Y,Y=this.length),at!==void 0&&typeof at!="string")throw new TypeError("encoding must be a string");if(typeof at=="string"&&!f.isEncoding(at))throw new TypeError("Unknown encoding: "+at);if(O.length===1){const Mt=O.charCodeAt(0);(at==="utf8"&&Mt<128||at==="latin1")&&(O=Mt)}}else typeof O=="number"?O=O&255:typeof O=="boolean"&&(O=Number(O));if(M<0||this.length<M||this.length<Y)throw new RangeError("Out of range index");if(Y<=M)return this;M=M>>>0,Y=Y===void 0?this.length:Y>>>0,O||(O=0);let Ct;if(typeof O=="number")for(Ct=M;Ct<Y;++Ct)this[Ct]=O;else{const Mt=f.isBuffer(O)?O:f.from(O,at),Oe=Mt.length;if(Oe===0)throw new TypeError('The value "'+O+'" is invalid for argument "value"');for(Ct=0;Ct<Y-M;++Ct)this[Ct+M]=Mt[Ct%Oe]}return this};const Xt={};function te(G,O,M){Xt[G]=class extends M{constructor(){super(),Object.defineProperty(this,"message",{value:O.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${G}]`,this.stack,delete this.name}get code(){return G}set code(at){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:at,writable:!0})}toString(){return`${this.name} [${G}]: ${this.message}`}}}te("ERR_BUFFER_OUT_OF_BOUNDS",function(G){return G?`${G} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),te("ERR_INVALID_ARG_TYPE",function(G,O){return`The "${G}" argument must be of type number. Received type ${typeof O}`},TypeError),te("ERR_OUT_OF_RANGE",function(G,O,M){let Y=`The value of "${G}" is out of range.`,at=M;return Number.isInteger(M)&&Math.abs(M)>2**32?at=oe(String(M)):typeof M=="bigint"&&(at=String(M),(M>BigInt(2)**BigInt(32)||M<-(BigInt(2)**BigInt(32)))&&(at=oe(at)),at+="n"),Y+=` It must be ${O}. Received ${at}`,Y},RangeError);function oe(G){let O="",M=G.length;const Y=G[0]==="-"?1:0;for(;M>=Y+4;M-=3)O=`_${G.slice(M-3,M)}${O}`;return`${G.slice(0,M)}${O}`}function fe(G,O,M){ie(O,"offset"),(G[O]===void 0||G[O+M]===void 0)&&Ae(O,G.length-(M+1))}function pe(G,O,M,Y,at,Ct){if(G>M||G<O){const Mt=typeof O=="bigint"?"n":"";let Oe;throw O===0||O===BigInt(0)?Oe=`>= 0${Mt} and < 2${Mt} ** ${(Ct+1)*8}${Mt}`:Oe=`>= -(2${Mt} ** ${(Ct+1)*8-1}${Mt}) and < 2 ** ${(Ct+1)*8-1}${Mt}`,new Xt.ERR_OUT_OF_RANGE("value",Oe,G)}fe(Y,at,Ct)}function ie(G,O){if(typeof G!="number")throw new Xt.ERR_INVALID_ARG_TYPE(O,"number",G)}function Ae(G,O,M){throw Math.floor(G)!==G?(ie(G,M),new Xt.ERR_OUT_OF_RANGE("offset","an integer",G)):O<0?new Xt.ERR_BUFFER_OUT_OF_BOUNDS:new Xt.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${O}`,G)}const Ge=/[^+/0-9A-Za-z-_]/g;function Nt(G){if(G=G.split("=")[0],G=G.trim().replace(Ge,""),G.length<2)return"";for(;G.length%4!==0;)G=G+"=";return G}function Ie(G,O){O=O||1/0;let M;const Y=G.length;let at=null;const Ct=[];for(let Mt=0;Mt<Y;++Mt){if(M=G.charCodeAt(Mt),M>55295&&M<57344){if(!at){if(M>56319){(O-=3)>-1&&Ct.push(239,191,189);continue}else if(Mt+1===Y){(O-=3)>-1&&Ct.push(239,191,189);continue}at=M;continue}if(M<56320){(O-=3)>-1&&Ct.push(239,191,189),at=M;continue}M=(at-55296<<10|M-56320)+65536}else at&&(O-=3)>-1&&Ct.push(239,191,189);if(at=null,M<128){if((O-=1)<0)break;Ct.push(M)}else if(M<2048){if((O-=2)<0)break;Ct.push(M>>6|192,M&63|128)}else if(M<65536){if((O-=3)<0)break;Ct.push(M>>12|224,M>>6&63|128,M&63|128)}else if(M<1114112){if((O-=4)<0)break;Ct.push(M>>18|240,M>>12&63|128,M>>6&63|128,M&63|128)}else throw new Error("Invalid code point")}return Ct}function wn(G){const O=[];for(let M=0;M<G.length;++M)O.push(G.charCodeAt(M)&255);return O}function rs(G,O){let M,Y,at;const Ct=[];for(let Mt=0;Mt<G.length&&!((O-=2)<0);++Mt)M=G.charCodeAt(Mt),Y=M>>8,at=M%256,Ct.push(at),Ct.push(Y);return Ct}function Ns(G){return t.toByteArray(Nt(G))}function je(G,O,M,Y){let at;for(at=0;at<Y&&!(at+M>=O.length||at>=G.length);++at)O[at+M]=G[at];return at}function Nn(G,O){return G instanceof O||G!=null&&G.constructor!=null&&G.constructor.name!=null&&G.constructor.name===O.name}function cr(G){return G!==G}const zr=(function(){const G="0123456789abcdef",O=new Array(256);for(let M=0;M<16;++M){const Y=M*16;for(let at=0;at<16;++at)O[Y+at]=G[M]+G[at]}return O})();function Wn(G){return typeof BigInt>"u"?No:G}function No(){throw new Error("BigInt not supported")}})(OP);const ou=OP.Buffer;function pv(n,t){let e=n;if(So(n))return t==="string"?[]:[n.length];if($P(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(AP(n))return[n.buffer.size/(t==null?4:ex(t))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(e)||So(e)&&t!=="string";)s.push(e.length),e=e[0];return Array.isArray(n)&&At().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&MP(n,s,[]),s}function MP(n,t,e){if(e=e||[],!Array.isArray(n)&&!So(n)){H(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}H(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),H(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const s=t.slice(1);for(let r=0;r<n.length;++r)MP(n[r],s,e.concat(r))}function _F(n,t,e,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==t||n==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${s}' must be ${n} tensor, but got ${t} tensor`)}}function rt(n,t,e,s="numeric"){if(n instanceof Dt())return _F(s,n.dtype,t,e),n;let r=gp(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),_F(s,r,t,e),n==null||!So(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${l}'`)}const i=pv(n,r);!So(n)&&!Array.isArray(n)&&(n=[n]);const a=r!=="string"?af(n,r):zh(n,[],!0);return ft.makeTensor(a,i,r)}function LP(n,t,e,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>rt(i,`${t}[${o}]`,e,s))}const RY="__op";function yt(n){const t=Object.keys(n);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const s=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+RY;const r=(...i)=>{ft.startScope(e);try{const o=s(...i);return y2(o)&&console.error("Cannot return a Promise inside of tidy."),ft.endScope(o),o}catch(o){throw ft.endScope(null),o}};return Object.defineProperty(r,"name",{value:e,configurable:!0}),r}function DY(n,t){const e=rt(n,"real","complex"),s=rt(t,"imag","complex");m2(e.shape,s.shape,`real and imag shapes, ${e.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:e,imag:s};return ft.runKernel(E2,r)}const jd=yt({complex_:DY});function mv(n,t,e,s){if(s==null)s=gp(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(AP(n)||$P(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return ft.backend.createTensorFromGPUData(n,t||e,s)}if(!So(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){iu(t);const r=Lt(t),i=Lt(e);H(r===i,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${i}`);for(let o=0;o<e.length;++o){const a=e[o],l=o===e.length-1?a!==Lt(t.slice(o)):!0;H(e[o]===t[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!So(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n=s!=="string"?af(n,s):zh(n,[],!0),ft.makeTensor(n,t,s)}function zP(n,t,e){const s=pv(n,e);return mv(n,t,s,e)}class xp{static join(t){return new xp(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(s=>So(s)?s.buffer:s),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let s=0;s<t.length;s++){const r=t[s];s!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=e+r.byteLength;this.shards.push({buffer:r,start:e,end:i}),e=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),e=Math.min(this.byteLength,e),e<=t)return new ArrayBuffer(0);const s=this.findShardForByte(t);if(s===-1)throw new Error(`Could not find start shard for byte ${t}`);const r=e-t,i=new ArrayBuffer(r),o=new Uint8Array(i);let a=0;for(let l=s;l<this.shards.length;l++){const c=this.shards[l],d=t+a-c.start,m=a,b=Math.min(e,c.end)-c.start,w=new Uint8Array(c.buffer,d,b-d);if(o.set(w,m),a+=w.length,e<c.end)break}return i}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(r){return t<r.start?-1:t>=r.end?1:0}if(e(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=OY(this.shards,e);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function OY(n,t){let e=0,s=n.length;for(;e<=s;){const r=Math.floor((s-e)/2)+e,i=t(n[r]);if(i===0)return r;i<0?s=r:e=r+1}return-1}function Pa(){return ft}function NF(){return ft.memory()}function vt(n,t){return ft.tidy(n,t)}function We(n){kP(n).forEach(e=>e.dispose())}function nl(n){return ft.keep(n)}function FY(){return ft.ready()}function BP(n,t,e=1){return ft.registerBackend(n,t,e)}function MY(){return ft.backend}const RF=4;async function DF(n,t){const e=[],s=[],r=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<r.length;++o){const a=r[o],l=Array.isArray(n)?n[o].tensor:n[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const f=new Promise(async d=>{const m=await l.bytes(),y=m.reduce((x,S)=>x+S.length,0)+RF*m.length,b=new Uint8Array(y);let w=0;for(let x=0;x<m.length;x++){const S=m[x],T=new Uint8Array(new Uint32Array([S.length]).buffer);b.set(T,w),w+=RF,b.set(S,w),w+=S.length}d(b)});s.push(f)}else s.push(l.data());t!=null&&(c.group=t),e.push(c)}const i=await Promise.all(s);return{data:LY(i),specs:e}}function LY(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(i=>{if(t+=i.byteLength,e.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(t);let r=0;return e.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const uA=typeof ou<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function OF(n){return uA?ou.byteLength(n,"utf8"):new Blob([n]).size}function zY(n){if(uA)return ou.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let s=0,r=t.length;s<r;s++)e+=String.fromCharCode(t[s]);return btoa(e)}function BY(n){if(uA){const s=ou.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let s=0;s<t.length;++s)e.set([t.charCodeAt(s)],s);return e.buffer}function PY(n){return xp.join(n)}function PP(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:OF(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:OF(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new xp(n.weightData).byteLength}}let Yy=class Wo{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Wo.instance==null&&(Wo.instance=new Wo),Wo.instance}static registerSaveRouter(t){Wo.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Wo.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Wo.getHandlers(t,"save")}static getLoadHandlers(t,e){return Wo.getHandlers(t,"load",e)}static getHandlers(t,e,s){const r=[];return(e==="load"?Wo.getInstance().loadRouters:Wo.getInstance().saveRouters).forEach(o=>{const a=o(t,s);a!==null&&r.push(a)}),r}};const VY=n=>Yy.getSaveHandlers(n);const WE="tensorflowjs",jE=1,Ih="models_store",qu="model_info_store";function VP(){if(!At().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function qE(n){const t=n.result;t.createObjectStore(Ih,{keyPath:"modelPath"}),t.createObjectStore(qu,{keyPath:"modelPath"})}let Bh=class{constructor(t){if(this.indexedDB=VP(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((s,r)=>{const i=this.indexedDB.open(WE,jE);i.onupgradeneeded=()=>qE(i),i.onsuccess=()=>{const o=i.result;if(e==null){const a=o.transaction(Ih,"readonly"),c=a.objectStore(Ih).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=f=>(o.close(),r(c.error)),a.oncomplete=()=>o.close()}else{e.weightData=xp.join(e.weightData);const a=PP(e),l=o.transaction(qu,"readwrite");let c=l.objectStore(qu),f;try{f=c.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(m){return r(m)}let d;f.onsuccess=()=>{d=o.transaction(Ih,"readwrite");const m=d.objectStore(Ih);let y;try{y=m.put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:a})}catch(b){return r(b)}y.onsuccess=()=>s({modelArtifactsInfo:a}),y.onerror=b=>{c=l.objectStore(qu);const w=c.delete(this.modelPath);w.onsuccess=()=>(o.close(),r(y.error)),w.onerror=x=>(o.close(),r(y.error))}},f.onerror=m=>(o.close(),r(f.error)),l.oncomplete=()=>{d==null?o.close():d.oncomplete=()=>o.close()}}},i.onerror=o=>r(i.error)})}};Bh.URL_SCHEME="indexeddb://";const UP=n=>At().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Bh.URL_SCHEME)?UY(n.slice(Bh.URL_SCHEME.length)):null;Yy.registerSaveRouter(UP);Yy.registerLoadRouter(UP);function UY(n){return new Bh(n)}function GY(n){return n.startsWith(Bh.URL_SCHEME)?n.slice(Bh.URL_SCHEME.length):n}let WY=class{constructor(){this.indexedDB=VP()}async listModels(){return new Promise((t,e)=>{const s=this.indexedDB.open(WE,jE);s.onupgradeneeded=()=>qE(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(qu,"readonly"),a=i.objectStore(qu).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;t(l)},a.onerror=l=>(r.close(),e(a.error)),i.oncomplete=()=>r.close()},s.onerror=r=>e(s.error)})}async removeModel(t){return t=GY(t),new Promise((e,s)=>{const r=this.indexedDB.open(WE,jE);r.onupgradeneeded=()=>qE(r),r.onsuccess=()=>{const i=r.result,o=i.transaction(qu,"readwrite"),a=o.objectStore(qu),l=a.get(t);let c;l.onsuccess=()=>{if(l.result==null)return i.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const f=a.delete(t),d=()=>{c=i.transaction(Ih,"readwrite");const y=c.objectStore(Ih).delete(t);y.onsuccess=()=>e(l.result.modelArtifactsInfo),y.onerror=b=>s(l.error)};f.onsuccess=d,f.onerror=m=>(d(),i.close(),s(l.error))}},l.onerror=f=>(i.close(),s(l.error)),o.oncomplete=()=>{c==null?i.close():c.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}};const Ul="/",vd="tensorflowjs_models",GP="info",jY="model_topology",qY="weight_specs",HY="weight_data",KY="model_metadata";function WP(n){return{info:[vd,n,GP].join(Ul),topology:[vd,n,jY].join(Ul),weightSpecs:[vd,n,qY].join(Ul),weightData:[vd,n,HY].join(Ul),modelMetadata:[vd,n,KY].join(Ul)}}function jP(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function XY(n){const t=n.split(Ul);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(Ul)}function YY(n){return n.startsWith(Ph.URL_SCHEME)?n.slice(Ph.URL_SCHEME.length):n}let Ph=class{constructor(t){if(!At().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=WP(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),r=PP(t),i=xp.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,zY(i));const o={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch{throw jP(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const a=JSON.parse(i);e.format=a.format,e.generatedBy=a.generatedBy,e.convertedBy=a.convertedBy,a.signature!=null&&(e.signature=a.signature),a.userDefinedMetadata!=null&&(e.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(e.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(e.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(e.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=BY(o),e}};Ph.URL_SCHEME="localstorage://";const qP=n=>At().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ph.URL_SCHEME)?QY(n.slice(Ph.URL_SCHEME.length)):null;Yy.registerSaveRouter(qP);Yy.registerLoadRouter(qP);function QY(n){return new Ph(n)}let ZY=class{constructor(){H(At().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),H(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=vd+Ul,s=Ul+GP;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(e)&&i.endsWith(s)){const o=XY(i);t[o]=JSON.parse(this.LS.getItem(i))}}return t}async removeModel(t){t=YY(t);const e=WP(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(this.LS.getItem(e.info));return jP(e),s}};const FF="://";let MF=class Gu{constructor(){this.managers={}}static getInstance(){return Gu.instance==null&&(Gu.instance=new Gu),Gu.instance}static registerManager(t,e){H(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(FF)&&(t=t.slice(0,t.indexOf(FF))),H(t.length>0,()=>"scheme must not be an empty string.");const s=Gu.getInstance();H(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=e}static getManager(t){const e=Gu.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(Gu.getInstance().managers)}};let JY=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){if(typeof window>"u"||!At().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,e);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return vP(t)}};if(At().get("IS_BROWSER")){At().setPlatform("browser",new JY);try{MF.registerManager(Ph.URL_SCHEME,new ZY)}catch{}try{MF.registerManager(Bh.URL_SCHEME,new WY)}catch{}}const tQ={importFetch:()=>require("node-fetch")};let VT,eQ=class{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return At().global.fetch!=null?At().global.fetch(t,e):(VT==null&&(VT=tQ.importFetch()),VT(t,e))}now(){const t=Un.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}};At().get("IS_NODE")&&!At().get("IS_BROWSER")&&At().setPlatform("node",new eQ);function Pe(n,t="float32",e){return t=t||"float32",iu(n),new br(n,t,e)}function nQ(n,t){const e=rt(n,"x","cast");if(!PX(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:e},r={dtype:t};return ft.runKernel(ly,s,r)}const ne=yt({cast_:nQ});function sQ(n){const e={x:rt(n,"x","clone","string_or_numeric")};return ft.runKernel(vy,e)}const Ah=yt({clone_:sQ});function rQ(n,t=!1){console.log(n.toString(t))}NP();const iQ={buffer:Pe,cast:ne,clone:Ah,print:rQ};bY(iQ);function oQ(n,t){let e=rt(n,"a","add"),s=rt(t,"b","add");[e,s]=bs(e,s);const r={a:e,b:s};return ft.runKernel(bp,r)}const Yt=yt({add_:oQ});function aQ(n,t){let e=rt(n,"a","floorDiv"),s=rt(t,"b","floorDiv");[e,s]=bs(e,s);const r={a:e,b:s};return ft.runKernel(xy,r)}const HP=yt({floorDiv_:aQ});function lQ(n,t){let e=rt(n,"a","div"),s=rt(t,"b","div");if([e,s]=bs(e,s),e.dtype==="int32"&&s.dtype==="int32")return HP(e,s);const r={a:e,b:s},i={};return ft.runKernel(dy,r,i)}const be=yt({div_:lQ});function uQ(n,t){let e=rt(n,"a","mul"),s=rt(t,"b","mul");[e,s]=bs(e,s);const r={a:e,b:s};return ft.runKernel(_y,r)}const ct=yt({mul_:uQ});function cQ(n){const t=rt(n,"x","abs");if(t.dtype==="complex64"){const e={x:t};return ft.runKernel(xw,e)}else{const e={x:t};return ft.runKernel(fw,e)}}const Ur=yt({abs_:cQ});function hQ(n){const e={x:rt(n,"x","acos")};return ft.runKernel(ey,e)}const fQ=yt({acos_:hQ});function dQ(n){const e={x:rt(n,"x","acosh")};return ft.runKernel(ny,e)}const pQ=yt({acosh_:dQ});function mQ(n,t=null,e=!1){const r={x:rt(n,"x","all","bool")},i={axis:t,keepDims:e};return ft.runKernel(w2,r,i)}const KP=yt({all_:mQ});function gQ(n,t=null,e=!1){const r={x:rt(n,"x","any","bool")},i={axis:t,keepDims:e};return ft.runKernel(v2,r,i)}const HE=yt({any_:gQ});function yQ(n,t=0){const s={x:rt(n,"x","argMax")},r={axis:t};return ft.runKernel(dw,s,r)}const Cg=yt({argMax_:yQ});function bQ(n,t=0){const s={x:rt(n,"x","argMin")},r={axis:t};return ft.runKernel(pw,s,r)}const xQ=yt({argMin_:bQ});function wQ(n){const e={x:rt(n,"x","asin")};return ft.runKernel(sy,e)}const vQ=yt({asin_:wQ});function SQ(n){const e={x:rt(n,"x","asinh")};return ft.runKernel(ry,e)}const IQ=yt({asinh_:SQ});function TQ(n){const e={x:rt(n,"x","atan")};return ft.runKernel(iy,e)}const CQ=yt({atan_:TQ});function EQ(n,t){let e=rt(n,"a","atan2"),s=rt(t,"b","atan2");[e,s]=bs(e,s);const r={a:e,b:s};return ft.runKernel(ay,r)}const $Q=yt({atan2_:EQ});function AQ(n){const e={x:rt(n,"x","atanh")};return ft.runKernel(oy,e)}const kQ=yt({atanh_:AQ});function Qy(n,t,e,s,r="NHWC",i){const o=n[3],a=[...t,o],l=lu(r);return vr(n,a,e,i,s,null,null,l)}function $o(n,t,e,s,r,i,o="channelsLast"){const[a,l]=Eg(t);let c;if(o==="channelsLast")c=[a,l,n[3],n[3]];else if(o==="channelsFirst")c=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return vr(n,c,e,s,r,i,!1,o)}function au(n,t,e,s,r,i,o="NDHWC"){const[a,l,c]=KE(t);let f,d;if(o==="NDHWC")d="channelsLast",f=[a,l,c,n[4],n[4]];else if(o==="NCDHW")d="channelsFirst",f=[a,l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return _c(n,f,e,s,r,!1,d,i)}function vr(n,t,e,s,r,i,o=!1,a="channelsLast"){let[l,c,f,d]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,f,d]=n;else if(a==="channelsFirst")[l,d,c,f]=n;else throw new Error(`Unknown dataFormat ${a}`);const[m,y,,b]=t,[w,x]=Eg(e),[S,T]=Eg(s),$=Fd(m,S),E=Fd(y,T),{padInfo:R,outHeight:B,outWidth:N}=RQ(r,c,f,w,x,$,E,i,a),k=o?b*d:b;let _;return a==="channelsFirst"?_=[l,k,B,N]:a==="channelsLast"&&(_=[l,B,N,k]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:f,inChannels:d,outHeight:B,outWidth:N,outChannels:k,padInfo:R,strideHeight:w,strideWidth:x,filterHeight:m,filterWidth:y,effectiveFilterHeight:$,effectiveFilterWidth:E,dilationHeight:S,dilationWidth:T,inShape:n,outShape:_,filterShape:t}}function _c(n,t,e,s,r,i=!1,o="channelsLast",a){let[l,c,f,d,m]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,c,f,d,m]=n;else if(o==="channelsFirst")[l,m,c,f,d]=n;else throw new Error(`Unknown dataFormat ${o}`);const[y,b,w,,x]=t,[S,T,$]=KE(e),[E,R,B]=KE(s),N=Fd(y,E),k=Fd(b,R),_=Fd(w,B),{padInfo:F,outDepth:A,outHeight:P,outWidth:L}=DQ(r,c,f,d,S,T,$,N,k,_,a),tt=i?x*m:x;let st;return o==="channelsFirst"?st=[l,tt,A,P,L]:o==="channelsLast"&&(st=[l,A,P,L,tt]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:f,inWidth:d,inChannels:m,outDepth:A,outHeight:P,outWidth:L,outChannels:tt,padInfo:F,strideDepth:S,strideHeight:T,strideWidth:$,filterDepth:y,filterHeight:b,filterWidth:w,effectiveFilterDepth:N,effectiveFilterHeight:k,effectiveFilterWidth:_,dilationDepth:E,dilationHeight:R,dilationWidth:B,inShape:n,outShape:st,filterShape:t}}function _Q(n,t,e,s,r){s==null&&(s=cA(n,t,e));const i=n[0],o=n[1],a=$g((i-t+2*s)/e+1,r),l=$g((o-t+2*s)/e+1,r);return[a,l]}function NQ(n,t,e,s,r,i){r==null&&(r=cA(n,t[0],s[0]));const o=[0,0,0,e];for(let a=0;a<3;a++)n[a]+2*r>=t[a]&&(o[a]=$g((n[a]-t[a]+2*r)/s[a]+1,i));return o}function cA(n,t,e,s=1){const r=Fd(t,s);return Math.floor((n[0]*(e-1)-e+r)/2)}function Eg(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function KE(n){return typeof n=="number"?[n,n,n]:n}function Fd(n,t){return t<=1?n:n+(n-1)*(t-1)}function RQ(n,t,e,s,r,i,o,a,l){let c,f,d;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const y=_Q([t,e],i,s,n,a);f=y[0],d=y[1]}else if(n==="same"){f=Math.ceil(t/s),d=Math.ceil(e/r);const m=Math.max(0,(f-1)*s+i-t),y=Math.max(0,(d-1)*r+o-e),b=Math.floor(m/2),w=m-b,x=Math.floor(y/2),S=y-x;c={top:b,bottom:w,left:x,right:S,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},f=Math.ceil((t-i+1)/s),d=Math.ceil((e-o+1)/r);else if(typeof n=="object"){const m=l==="channelsLast"?n[1][0]:n[2][0],y=l==="channelsLast"?n[1][1]:n[2][1],b=l==="channelsLast"?n[2][0]:n[3][0],w=l==="channelsLast"?n[2][1]:n[3][1];c={top:m,bottom:y,left:b,right:w,type:m===0&&y===0&&b===0&&w===0?"VALID":"EXPLICIT"},f=$g((t-i+m+y)/s+1,a),d=$g((e-o+b+w)/r+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:f,outWidth:d}}function DQ(n,t,e,s,r,i,o,a,l,c,f){let d,m,y,b;if(n==="valid"&&(n=0),typeof n=="number"){d={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const x=NQ([t,e,s,1],[a,l,c],1,[r,i,o],n,f);m=x[0],y=x[1],b=x[2]}else if(n==="same"){m=Math.ceil(t/r),y=Math.ceil(e/i),b=Math.ceil(s/o);const w=(m-1)*r+a-t,x=(y-1)*i+l-e,S=(b-1)*o+c-s,T=Math.floor(w/2),$=w-T,E=Math.floor(x/2),R=x-E,B=Math.floor(S/2),N=S-B;d={top:E,bottom:R,left:B,right:N,front:T,back:$,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:d,outDepth:m,outHeight:y,outWidth:b}}function $g(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function Vh(n){const[t,e,s]=Eg(n);return t===1&&e===1&&s===1}function Or(n,t){return Vh(n)||Vh(t)}function Uh(n){return Eg(n).every(t=>t>0)}function lu(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function fi(n,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")H(Wd(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(s=>{s.forEach(r=>{H(Wd(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${t}`)}}function OQ(n,t){const s={x:rt(n,"x","reshape","string_or_numeric")},r={shape:t};return ft.runKernel(Jw,s,r)}const gt=yt({reshape_:OQ});function FQ(n,t,e,s,r){const i=rt(n,"x","avgPool","float32"),o=1;H(Or(e,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);let a=i,l=!1;i.rank===3&&(l=!0,a=gt(i,[1,i.shape[0],i.shape[1],i.shape[2]])),H(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),fi("avgPool",s,r);const c={x:a},f={filterSize:t,strides:e,pad:s,dimRoundingMode:r};let d=ft.runKernel(mw,c,f);return d=ne(d,i.dtype),l?gt(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const hA=yt({avgPool_:FQ});function MQ(n,t,e,s,r,i="NDHWC"){const o=rt(n,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=gt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),H(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),H(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),H(typeof e=="number"&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),fi("avgPool3d",s,r);const c={x:a},f={filterSize:t,strides:e,pad:s,dimRoundingMode:r,dataFormat:i};let d=ft.runKernel(gw,c,f);return d=ne(d,a.dtype),l?gt(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const LQ=yt({avgPool3d_:MQ});function zQ(n,t=0){H(n.length>=1,()=>"Pass at least one tensor to concat");const e=LP(n,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),e.length===1)return Ah(e[0]);const s=e,r={axis:t};return ft.runKernel(ww,s,r)}const ii=yt({concat_:zQ});function BQ(n,t,e=!1,s=!1){let r=rt(n,"a","matMul"),i=rt(t,"b","matMul");[r,i]=bs(r,i);const o={a:r,b:i},a={transposeA:e,transposeB:s};return ft.runKernel(yw,o,a)}const fn=yt({matMul_:BQ});function PQ(n){const e={x:rt(n,"x","sigmoid","float32")};return ft.runKernel(Vy,e)}const wp=yt({sigmoid_:PQ});function VQ(n,t,e){const s=rt(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:t,size:e};return ft.runKernel(rv,r,i)}const Pn=yt({slice_:VQ});function UQ(n){const e={x:rt(n,"x","tanh","float32")};return ft.runKernel(Hy,e)}const gv=yt({tanh_:UQ});function GQ(n,t,e){const s=rt(n,"x","batchToSpaceND"),r=t.reduce((a,l)=>a*l);H(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),H(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),H(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);const i={x:s},o={blockShape:t,crops:e};return ft.runKernel(bw,i,o)}const fA=yt({batchToSpaceND_:GQ});function WQ(n){let t;return n.rank===0||n.rank===1?t=gt(n,[1,1,1,n.size]):n.rank===2?t=gt(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?t=gt(n,[1,n.shape[0],n.shape[1],n.shape[2]]):t=n,t}function jQ(n,t,e,s,r,i){i==null&&(i=.001);const o=rt(n,"x","batchNorm"),a=rt(t,"mean","batchNorm"),l=rt(e,"variance","batchNorm");let c;r!=null&&(c=rt(r,"scale","batchNorm"));let f;s!=null&&(f=rt(s,"offset","batchNorm")),H(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),H(f==null||a.rank===f.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),H(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const m={x:WQ(o),scale:c,offset:f,mean:a,variance:l},y={varianceEpsilon:i},b=ft.runKernel(kw,m,y);return gt(b,o.shape)}const yv=yt({batchNorm_:jQ});function qQ(n,t,e,s,r,i){const o=rt(n,"x","batchNorm"),a=rt(t,"mean","batchNorm"),l=rt(e,"variance","batchNorm");let c;r!=null&&(c=rt(r,"scale","batchNorm"));let f;return s!=null&&(f=rt(s,"offset","batchNorm")),H(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),H(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),H(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&H(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),f!=null&&H(f.rank===2||f.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${f.rank}.`),yv(o,a,l,f,c,i)}const HQ=yt({batchNorm2d_:qQ});function KQ(n,t,e,s,r,i){const o=rt(n,"x","batchNorm"),a=rt(t,"mean","batchNorm"),l=rt(e,"variance","batchNorm");let c;r!=null&&(c=rt(r,"scale","batchNorm"));let f;return s!=null&&(f=rt(s,"offset","batchNorm")),H(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),H(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),H(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&H(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),f!=null&&H(f.rank===3||f.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${f.rank}.`),yv(o,a,l,f,c,i)}const XQ=yt({batchNorm3d_:KQ});function YQ(n,t,e,s,r,i){const o=rt(n,"x","batchNorm"),a=rt(t,"mean","batchNorm"),l=rt(e,"variance","batchNorm");let c;r!=null&&(c=rt(r,"scale","batchNorm"));let f;return s!=null&&(f=rt(s,"offset","batchNorm")),H(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),H(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),H(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&H(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),f!=null&&H(f.rank===4||f.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${f.rank}.`),yv(o,a,l,f,c,i)}const QQ=yt({batchNorm4d_:YQ});function ZQ(n,t,e){const s=rt(n,"x","bincount"),r=rt(t,"weights","bincount");H(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),H(e>=0,()=>`size must be non-negative, but got ${e}.`),H(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},o={size:e};return ft.runKernel(T2,i,o)}const JQ=yt({bincount_:ZQ});function tZ(n,t){let e=rt(n,"broadcastTo","x");const s=e.shape;if(iu(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const c=e.shape.slice();for(;c.length<t.length;)c.unshift(1);e=gt(e,c)}const r=e.shape,i=Array.from(t);for(let c=t.length-1;c>=0;c--)if(r[c]===t[c])i[c]=1;else if(e.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(i.map((c,f)=>c>1?f:-1).filter(c=>c>=0).length===0)return Ah(e);const a={x:e},l={reps:i};return ft.runKernel(Ky,a,l)}const mg=yt({broadcastTo_:tZ});function eZ(n){const e={x:rt(n,"x","ceil","float32")};return ft.runKernel(uy,e)}const nZ=yt({ceil_:eZ});function bv(n,t,e){iu(n),e=e||gp(t);const s={shape:n,value:t,dtype:e};return ft.runKernel(B2,{},s)}function sZ(n,t,e){const s=rt(n,"x","clipByValue");if(H(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e)return bv(s.shape,t,s.dtype);const r={x:s},i={clipValueMin:t,clipValueMax:e};return ft.runKernel(cy,r,i)}const Hi=yt({clipByValue_:sZ});function rZ(n){return ii(n,0)}const iZ=yt({concat1d_:rZ});function oZ(n,t){return ii(n,t)}const aZ=yt({concat2d_:oZ});function lZ(n,t){return ii(n,t)}const uZ=yt({concat3d_:lZ});function cZ(n,t){return ii(n,t)}const hZ=yt({concat4d_:cZ});function fZ(n,t,e,s,r="NHWC",i=[1,1],o){const a=rt(n,"x","conv2d","float32"),l=rt(t,"filter","conv2d","float32");let c=a,f=!1;a.rank===3&&(f=!0,c=gt(a,[1,a.shape[0],a.shape[1],a.shape[2]])),H(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),H(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),fi("conv2d",s,o);const d=r==="NHWC"?c.shape[3]:c.shape[1];H(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),H(Or(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),H(Uh(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),H(Uh(e),()=>"Error in conv2D: Strides should be larger than 0.");const m={x:c,filter:l},y={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},b=ft.runKernel(vw,m,y);return f?gt(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Gh=yt({conv2d_:fZ});function dZ(n,t,e,s,r="NWC",i=1,o){const a=rt(n,"x","conv1d"),l=rt(t,"filter","conv1d");let c=a,f=!1;a.rank===2&&(f=!0,c=gt(a,[1,a.shape[0],a.shape[1]])),H(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),H(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),fi("conv1d",s,o),H(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),H(Or(e,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${i}'`),H(Uh(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),H(Uh(e),()=>"Error in conv1D: Stride should be larger than 0."),H(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const d=gt(l,[1,l.shape[0],l.shape[1],l.shape[2]]),m=gt(c,[c.shape[0],1,c.shape[1],c.shape[2]]),x=Gh(m,d,[1,e],s,"NHWC",[1,i],o);return f?gt(x,[x.shape[2],x.shape[3]]):gt(x,[x.shape[0],x.shape[2],x.shape[3]])}const XP=yt({conv1d_:dZ});function pZ(n,t,e,s,r,i="NHWC",o){H(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let a=n,l=t,c=!1;t.rank===3&&(c=!0,l=gt(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,n[0],n[1],n[2]]),H(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),H(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),H(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const f=i==="NHWC"?a[3]:a[1],d=i==="NHWC"?l.shape[3]:l.shape[1];H(f===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${f}) must match input depth for filter ${e.shape[2]}.`),H(d===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`),fi("conv2dDerInput",r,o);const m={dy:l,filter:e},y={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,inputShape:a},b=ft.runKernel(Sw,m,y);return c?gt(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const dA=yt({conv2DBackpropInput_:pZ});function mZ(n,t,e,s,r,i){const o=rt(n,"x","conv2dTranspose"),a=rt(t,"filter","conv2dTranspose");return dA(e,o,a,s,r,"NHWC",i)}const YP=yt({conv2dTranspose_:mZ});function gZ(n,t,e,s,r="NDHWC",i=[1,1,1]){const o=rt(n,"x","conv3d"),a=rt(t,"filter","conv3d");let l=o,c=!1;o.rank===4&&(c=!0,l=gt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),H(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),H(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),H(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),H(Or(e,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),H(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),H(Uh(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),H(Uh(e),()=>"Error in conv3D: Strides should be larger than 0.");const f={x:l,filter:a},d={strides:e,pad:s,dataFormat:r,dilations:i},m=ft.runKernel(Iw,f,d);return c?gt(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const yZ=yt({conv3d_:gZ});function bZ(n,t,e,s,r){H(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let i=n,o=t,a=!1;t.rank===4&&(a=!0,o=gt(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const l=i[4],c=o.shape[4];H(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),H(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),H(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),H(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),H(c===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${e.shape[4]}.`);const f={dy:o,filter:e},d={pad:r,strides:s,inputShape:i},m=ft.runKernel(k2,f,d);return a?gt(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const QP=yt({conv3DBackpropInput_:bZ});function xZ(n,t,e,s,r){const i=rt(n,"x","conv3dTranspose"),o=rt(t,"filter","conv3dTranspose");return QP(e,i,o,s,r)}const wZ=yt({conv3dTranspose_:xZ});function vZ(n){const e={x:rt(n,"x","cos","float32")};return ft.runKernel(hy,e)}const pA=yt({cos_:vZ});function SZ(n){const e={x:rt(n,"x","cosh","float32")};return ft.runKernel(fy,e)}const ZP=yt({cosh_:SZ});function IZ(n,t=0,e=!1,s=!1){const i={x:rt(n,"x","cumprod")},o={axis:t,exclusive:e,reverse:s};return ft.runKernel(_2,i,o)}const XE=yt({cumprod_:IZ});function TZ(n,t=0,e=!1,s=!1){const i={x:rt(n,"x","cumsum")},o={axis:t,exclusive:e,reverse:s};return ft.runKernel(Tw,i,o)}const JP=yt({cumsum_:TZ});function CZ(n,t,e,s=!1){const r=rt(n,"x","denseBincount"),i=rt(t,"weights","denseBincount");H(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),H(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),H(e>=0,()=>`size must be non-negative, but got ${e}.`),H(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const o={x:r,weights:i},a={size:e,binaryOutput:s};return ft.runKernel(R2,o,a)}const LF=yt({denseBincount_:CZ});function EZ(n,t,e="NHWC"){const s=rt(n,"x","depthToSpace","float32"),r=e==="NHWC"?s.shape[1]:s.shape[2],i=e==="NHWC"?s.shape[2]:s.shape[3],o=e==="NHWC"?s.shape[3]:s.shape[1];H(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),H(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${s.shape}`),H(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${t} for depthToSpace with input shape
        ${s.shape}`),H(o%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${s.shape}`);const a={x:s},l={blockSize:t,dataFormat:e};return ft.runKernel(D2,a,l)}const $Z=yt({depthToSpace_:EZ});function AZ(n,t,e,s,r="NHWC",i=[1,1],o){const a=rt(n,"x","depthwiseConv2d","float32"),l=rt(t,"filter","depthwiseConv2d","float32");let c=a,f=!1;a.rank===3&&(f=!0,c=gt(a,[1,a.shape[0],a.shape[1],a.shape[2]])),H(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),H(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d=r==="NHWC"?c.shape[3]:c.shape[1];H(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),fi("depthwiseConv2d",s,o);const m={x:c,filter:l},y={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},b=ft.runKernel(Cw,m,y);return f?gt(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const mA=yt({depthwiseConv2d_:AZ});function kZ(n,t,e,s,r=[1,1],i="NHWC"){const o=rt(n,"x","dilation2d"),a=rt(t,"filter","dilation2d");H(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),H(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),H(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,c=!1;o.rank===3&&(l=gt(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),H(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const f={x:l,filter:a},d={strides:e,pad:s,dilations:r},m=ft.runKernel(Ew,f,d);return c?gt(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const _Z=yt({dilation2d_:kZ});function qd(n,t){const e=n.length,s=[];for(let r=0;r<e;r++){const i=e-1-r,o=n[i]||1;(t[t.length-1-r]||1)>1&&o===1&&s.unshift(i)}return s}function Zs(n,t){const e=[];for(let s=0;s<t.length;s++){const r=n[n.length-s-1],i=t.length-s-1,o=t[i];(r==null||r===1&&o>1)&&e.unshift(i)}return e}function Ne(n,t){const e=Math.max(n.length,t.length),s=new Array(e);for(let r=0;r<e;r++){let i=n[n.length-r-1];i==null&&(i=1);let o=t[t.length-r-1];if(o==null&&(o=1),i===1)s[e-r-1]=o;else if(o===1)s[e-r-1]=i;else if(i!==o){const a=`Operands could not be broadcast together with shapes ${n} and ${t}.`;throw Error(a)}else s[e-r-1]=i}return s}function NZ(n,t){let e=rt(n,"a","equal","string_or_numeric"),s=rt(t,"b","equal","string_or_numeric");[e,s]=bs(e,s),Ne(e.shape,s.shape);const r={a:e,b:s};return ft.runKernel($w,r)}const hl=yt({equal_:NZ});function RZ(n,t,e){const s=rt(t,"a","where"),r=rt(e,"b","where"),i=rt(n,"condition","where","bool"),o=Ne(Ne(i.shape,s.shape),r.shape),a=mg(i,o),l=mg(s,o),c=mg(r,o),f={condition:a,t:l,e:c};return ft.runKernel(sv,f)}const Hr=yt({where_:RZ});function DZ(n){const e={x:rt(n,"x","zerosLike")};return ft.runKernel(hv,e)}const sn=yt({zerosLike_:DZ});function OZ(n,t){let e=rt(n,"a","div"),s=rt(t,"b","div");[e,s]=bs(e,s);const r=be(e,s),i=sn(r),o=hl(s,i);return Hr(o,i,r)}const FZ=yt({divNoNan_:OZ});function MZ(n,t){const e=rt(n,"t1","dot"),s=rt(t,"t2","dot");H((e.rank===1||e.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${s.rank}.`);const r=e.rank===1?e.size:e.shape[1],i=s.rank===1?s.size:s.shape[0];if(H(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),e.rank===1&&s.rank===1){const o=gt(e,[1,-1]),a=gt(s,[-1,1]),l=fn(o,a);return gt(l,[])}else if(e.rank===1&&s.rank===2){const o=gt(e,[1,-1]),a=gt(s,[s.shape[0],s.shape[1]]),l=fn(o,a);return gt(l,[l.size])}else if(e.rank===2&&s.rank===1){const o=gt(s,[-1,1]),a=fn(e,o);return gt(a,[a.size])}else{const o=gt(s,[s.shape[0],s.shape[1]]);return fn(e,o)}}const LZ=yt({dot_:MZ});function zZ(n,...t){const e=t.map((r,i)=>rt(r,`tensors${i}`,"einsum")),s={equation:n};return ft.runKernel(M2,e,s)}const Ym=yt({einsum_:zZ});function BZ(n){const e={x:rt(n,"x","elu","float32")};return ft.runKernel(py,e)}const xv=yt({elu_:BZ});function PZ(n){let t=rt(n,"x","erf");H(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=ne(t,"float32"));const e={x:t};return ft.runKernel(my,e)}const t4=yt({erf_:PZ});function gA(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function e4(n,t,e){const s=n.length+t.length,r=[];let i=0,o=0;for(let a=0;a<s;a++)e.indexOf(a)===-1?r.push(n[i++]):r.push(t[o++]);return r}function ur(n,t){const e=[],s=n.length;for(let i=0;i<s;i++)t.indexOf(i)===-1&&e.push(n[i]);const r=t.map(i=>n[i]);return[e,r]}function ks(n,t){const e=t.map(s=>1);return e4(n,e,t)}function Sr(n,t,e){H(gA(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function hs(n,t){if(gA(n,t))return null;const e=[];for(let s=0;s<t;++s)n.indexOf(s)===-1&&e.push(s);return n.forEach(s=>e.push(s)),e}function Nc(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function xs(n,t){const e=[];for(let s=t-n;s<t;++s)e.push(s);return e}function VZ(n,t=null,e=!1){const r={x:rt(n,"x","max")},i={reductionIndices:t,keepDims:e};return ft.runKernel(Bw,r,i)}const ta=yt({max_:VZ});function UZ(n,t=null,e=!1){const r={x:rt(n,"x","min")},i={axis:t,keepDims:e};return ft.runKernel(Gw,r,i)}const ox=yt({min_:UZ});function GZ(n,t){let e=rt(n,"base","pow"),s=rt(t,"exp","pow");[e,s]=bs(e,s);const r={a:e,b:s};return ft.runKernel(Ny,r)}const Wh=yt({pow_:GZ});function dn(n,t){if((So(n)&&t!=="string"||Array.isArray(n))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&So(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return mv(n,[],[],t)}function WZ(n){const e={x:rt(n,"x","sqrt","float32")};return ft.runKernel(Gy,e)}const Dr=yt({sqrt_:WZ});function jZ(n){const t=rt(n,"x","square"),e={};return ft.runKernel("Square",{x:t},e)}const Kn=yt({square_:jZ});function qZ(n,t=null,e=!1){let s=rt(n,"x","sum");s.dtype==="bool"&&(s=ne(s,"int32"));const r={x:s},i={axis:t,keepDims:e};return ft.runKernel(iv,r,i)}const me=yt({sum_:qZ});function HZ(n,t="euclidean",e=null,s=!1){n=rt(n,"x","norm");const r=n4(n,t,e);let i=r.shape;if(s){const o=Ve(e,n.shape);i=ks(r.shape,o)}return gt(r,i)}function n4(n,t,e=null){if(n.rank===0)return Ur(n);if(n.rank!==1&&e===null)return n4(gt(n,[-1]),t,e);if(n.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return me(Ur(n),e);if(t===1/0)return ta(Ur(n),e);if(t===-1/0)return ox(Ur(n),e);if(t==="euclidean"||t===2)return Dr(me(Wh(Ur(n),dn(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return ta(me(Ur(n),e[0]),e[1]-1);if(t===1/0)return ta(me(Ur(n),e[1]),e[0]);if(t===-1/0)return ox(me(Ur(n),e[1]),e[0]);if(t==="fro"||t==="euclidean")return Dr(me(Kn(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const wv=yt({norm_:HZ});function KZ(n,t=null,e=!1){return wv(n,"euclidean",t,e)}const XZ=yt({euclideanNorm_:KZ});function YZ(n){const e={x:rt(n,"x","exp")};return ft.runKernel(gy,e)}const fl=yt({exp_:YZ});function QZ(n,t=0){const e=rt(n,"x","expandDims","string_or_numeric");H(t<=e.rank,()=>"Axis must be <= rank of the tensor");const s={input:e},r={dim:t};return ft.runKernel(Aw,s,r)}const ni=yt({expandDims_:QZ});function ZZ(n){const e={x:rt(n,"x","expm1")};return ft.runKernel(yy,e)}const JZ=yt({expm1_:ZZ});function tJ(n,t){const e=rt(n,"x","tile","string_or_numeric");H(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);const s={x:e},r={reps:t};return ft.runKernel(Ky,s,r)}const Qo=yt({tile_:tJ});function eJ(n,t,e,s="float32"){t==null&&(t=n);const r=Pe([n,t],s),i=n<=t?n:t;for(let a=0;a<i;++a)r.set(1,a,a);const o=gt(r.toTensor(),[n,t]);if(e==null)return o;if(e.length===1)return Qo(ni(o,0),[e[0],1,1]);if(e.length===2)return Qo(ni(ni(o,0),0),[e[0],e[1],1,1]);if(e.length===3)return Qo(ni(ni(ni(o,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}const s4=yt({eye_:eJ});function nJ(n){const e={x:rt(n,"x","floor","float32")};return ft.runKernel(by,e)}const vv=yt({floor_:nJ});function sJ(n,t,e=0,s=0){const r=rt(n,"x","gather"),i=rt(t,"indices","gather","int32"),o={x:r,indices:i},a={axis:e,batchDims:s};return ft.runKernel(_w,o,a)}const yA=yt({gather_:sJ});function rJ(n,t){let e=rt(n,"a","greater","string_or_numeric"),s=rt(t,"b","greater","string_or_numeric");[e,s]=bs(e,s),Ne(e.shape,s.shape);const r={a:e,b:s};return ft.runKernel(Nw,r)}const Ki=yt({greater_:rJ});function iJ(n,t){let e=rt(n,"a","greaterEqual","string_or_numeric"),s=rt(t,"b","greaterEqual","string_or_numeric");[e,s]=bs(e,s),Ne(e.shape,s.shape);const r={a:e,b:s};return ft.runKernel(wy,r)}const lf=yt({greaterEqual_:iJ});function oJ(n){const e={input:rt(n,"input","imag")};return ft.runKernel(U2,e)}const bA=yt({imag_:oJ});function aJ(n){const e={x:rt(n,"x","isFinite")};return ft.runKernel(Sy,e)}const lJ=yt({isFinite_:aJ});function uJ(n){const e={x:rt(n,"x","isInf")};return ft.runKernel(Iy,e)}const cJ=yt({isInf_:uJ});function hJ(n){const e={x:rt(n,"x","isNaN")};return ft.runKernel(Ty,e)}const fJ=yt({isNaN_:hJ});function dJ(n,t=.2){const s={x:rt(n,"x","leakyRelu")},r={alpha:t};return ft.runKernel(Rw,s,r)}const xA=yt({leakyRelu_:dJ});function pJ(n,t){let e=rt(n,"a","less","string_or_numeric"),s=rt(t,"b","less","string_or_numeric");[e,s]=bs(e,s),Ne(e.shape,s.shape);const r={a:e,b:s};return ft.runKernel(Dw,r)}const ax=yt({less_:pJ});function mJ(n,t){let e=rt(n,"a","lessEqual","string_or_numeric"),s=rt(t,"b","lessEqual","string_or_numeric");[e,s]=bs(e,s),Ne(e.shape,s.shape);const r={a:e,b:s};return ft.runKernel(Ow,r)}const vp=yt({lessEqual_:mJ});function gJ(n,t=5,e=1,s=1,r=.5){const i=rt(n,"x","localResponseNormalization");H(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),H(Wd(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=i,a=!1;i.rank===3&&(a=!0,o=gt(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:o},c={depthRadius:t,bias:e,alpha:s,beta:r},f=ft.runKernel(zw,l,c);return a?gt(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const yJ=yt({localResponseNormalization_:gJ});function bJ(n){const e={x:rt(n,"x","log","float32")};return ft.runKernel(Cy,e)}const dl=yt({log_:bJ});function xJ(n){const e={x:rt(n,"x","log1p")};return ft.runKernel(Ey,e)}const r4=yt({log1p_:xJ});function wJ(n,t){H(DE(n),()=>"The f passed in variableGrads(f) must be a function"),H(t==null||Array.isArray(t)&&t.every(c=>c instanceof ix),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=t!=null;if(!e){t=[];for(const c in ft.registeredVariables)t.push(ft.registeredVariables[c])}const s=e?t.filter(c=>!c.trainable):null,r=t.length;t=t.filter(c=>c.trainable),H(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const i=!0,{value:o,grads:a}=ft.gradients(n,t,null,i);H(a.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),H(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return t.forEach((c,f)=>{a[f]!=null&&(l[c.name]=a[f])}),s?.forEach(c=>l[c.name]=null),{value:o,grads:l}}function Hd(n){return ft.customGrad(n)}function vJ(n){const e={x:rt(n,"x","neg")};return ft.runKernel(jw,e)}const ys=yt({neg_:vJ});function SJ(n){const e={x:rt(n,"x","softplus")};return ft.runKernel(Uy,e)}const Zy=yt({softplus_:SJ});function IJ(n){const t=rt(n,"x","logSigmoid");return Hd(s=>({value:ys(Zy(ys(s))),gradFunc:o=>ct(o,wp(ys(s)))}))(t)}const TJ=yt({logSigmoid_:IJ});function CJ(n,t){let e=rt(n,"a","sub"),s=rt(t,"b","sub");[e,s]=bs(e,s);const r={a:e,b:s};return ft.runKernel(jy,r)}const Se=yt({sub_:CJ});function EJ(n,t=-1){const e=rt(n,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return Hd((r,i)=>{const a=ta(r,t,!0),l=Se(r,a),c=Se(ne(l,"float32"),dl(me(fl(l),t,!0)));return i([c]),{value:c,gradFunc:(d,m)=>{const[y]=m,b=!0,w=fl(y);return Se(d,ct(me(d,t,b),w))}}})(e)}const i4=yt({logSoftmax_:EJ});function $J(n,t=null,e=!1){const s=rt(n,"x","logSumExp"),r=Ve(t,s.shape),i=ta(s,r,!0),o=Se(s,i),a=fl(o),l=me(a,r),c=dl(l),f=Yt(gt(i,c.shape),c);if(e){const d=ks(f.shape,r);return gt(f,d)}return f}const o4=yt({logSumExp_:$J});function AJ(n,t){const e=rt(n,"a","logicalAnd","bool"),s=rt(t,"b","logicalAnd","bool");Ne(e.shape,s.shape);const r={a:e,b:s};return ft.runKernel(Fw,r)}const Yl=yt({logicalAnd_:AJ});function kJ(n){const e={x:rt(n,"x","logicalNot","bool")};return ft.runKernel(Mw,e)}const wA=yt({logicalNot_:kJ});function _J(n,t){const e=rt(n,"a","logicalOr","bool"),s=rt(t,"b","logicalOr","bool");Ne(e.shape,s.shape);const r={a:e,b:s};return ft.runKernel(Lw,r)}const a4=yt({logicalOr_:_J});function NJ(n,t){const e=rt(n,"a","logicalXor","bool"),s=rt(t,"b","logicalXor","bool");return Ne(e.shape,s.shape),Yl(a4(n,t),wA(Yl(n,t)))}const RJ=yt({logicalXor_:NJ});function DJ(n,t,e,s,r){const i=rt(n,"x","maxPool"),o=1;let a=i,l=!1;i.rank===3&&(l=!0,a=gt(i,[1,i.shape[0],i.shape[1],i.shape[2]])),H(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),H(Or(e,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),fi("maxPool",s,r);const c={x:a},f={filterSize:t,strides:e,pad:s,dimRoundingMode:r},d=ft.runKernel(Pw,c,f);return l?gt(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const vA=yt({maxPool_:DJ});function OJ(n,t=[1,1,1],e,s,r,i="NDHWC"){const o=rt(n,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=gt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),H(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),H(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),fi("maxPool3d",s,r);const c={x:a},f={filterSize:t,strides:e,pad:s,dimRoundingMode:r,dataFormat:i},d=ft.runKernel(Vw,c,f);return l?gt(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const FJ=yt({maxPool3d_:OJ});function MJ(n,t){let e=rt(n,"a","maximum"),s=rt(t,"b","maximum");[e,s]=bs(e,s),e.dtype==="bool"&&(e=ne(e,"int32"),s=ne(s,"int32")),Ne(e.shape,s.shape);const r={a:e,b:s};return ft.runKernel($y,r)}const Rc=yt({maximum_:MJ});function LJ(n,t=null,e=!1){const r={x:rt(n,"x","mean")},i={axis:t,keepDims:e};return ft.runKernel(Uw,r,i)}const $s=yt({mean_:LJ});function sr(n,t="float32"){if(iu(n),t==="complex64"){const s=sr(n,"float32"),r=sr(n,"float32");return jd(s,r)}const e=Rr(Lt(n),t);return ft.makeTensor(e,n,t)}function Dc(n,t="float32"){if(iu(n),t==="complex64"){const s=Dc(n,"float32"),r=sr(n,"float32");return jd(s,r)}const e=g2(Lt(n),t);return ft.makeTensor(e,n,t)}function zJ(n,t){let e=rt(n,"a","minimum"),s=rt(t,"b","minimum");[e,s]=bs(e,s),e.dtype==="bool"&&(e=ne(e,"int32"),s=ne(s,"int32")),Ne(e.shape,s.shape);const r={a:e,b:s};return ft.runKernel(Ay,r)}const Ag=yt({minimum_:zJ});function BJ(n,t,e){H(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const s=rt(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");H(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const r=e==="reflect"?1:0;for(let a=0;a<s.rank;a++)H(t[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),H(t[a][0]>=0&&t[a][0]<=s.shape[a]-r&&t[a][1]>=0&&t[a][1]<=s.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-r} or less than 0 for input of shape ${s.shape}`);const i={paddings:t,mode:e},o={x:s};return ft.runKernel(Ww,o,i)}const PJ=yt({mirrorPad_:BJ});function VJ(n,t){let e=rt(n,"a","mod"),s=rt(t,"b","mod");[e,s]=bs(e,s);const r={a:e,b:s};return ft.runKernel(ky,r)}const UJ=yt({mod_:VJ});function GJ(n,t=null,e=!1){n=rt(n,"x","moments");const s=Ve(t,n.shape),r=$s(n,s,e);let i=r.shape;e||(i=ks(r.shape,s));const o=Kn(Se(ne(n,"float32"),gt(r,i))),a=$s(o,s,e);return{mean:r,variance:a}}const SA=yt({moments_:GJ});function WJ(n,t){let e=rt(n,"a","notEqual","string_or_numeric"),s=rt(t,"b","notEqual","string_or_numeric");[e,s]=bs(e,s),Ne(e.shape,s.shape);const r={a:e,b:s};return ft.runKernel(qw,r)}const lx=yt({notEqual_:WJ});function jJ(n,t,e=1,s=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:rt(n,"indices","oneHot","int32")},a={dtype:r,depth:t,onValue:e,offValue:s};return ft.runKernel(Kw,o,a)}const l4=yt({oneHot_:jJ});function qJ(n){const e={x:rt(n,"x","onesLike")};return ft.runKernel(Hw,e)}const Io=yt({onesLike_:qJ});function HJ(n,t,e=0){const s=rt(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:e},i={x:s};return ft.runKernel(Yw,i,r)}const IA=yt({pad_:HJ});function KJ(n,t,e){const s=rt(n,"x","spaceToBatchND");H(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),H(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),H(s.shape.reduce((o,a,l)=>l>0&&l<=t.length?o&&(a+e[l-1][0]+e[l-1][1])%t[l-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);const r={x:s},i={blockShape:t,paddings:e};return ft.runKernel(ov,r,i)}const TA=yt({spaceToBatchND_:KJ});function XJ(n,t,e,s,r,i,o){r==null&&(r=[1,1]),i==null&&(i=1),s===0&&(s="valid");const a=rt(n,"x","maxPool");let l=a,c=!1;a.rank===3&&(c=!0,l=gt(a,[1,a.shape[0],a.shape[1],a.shape[2]])),H(Or(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const f=$o(l.shape,t,i,r,s),d=[f.dilationHeight,f.dilationWidth];let m;s==="same"?m=QJ([f.filterHeight,f.filterWidth],d):m=[[0,0],[0,0]];const y=d[0]===1&&d[1]===1,[b,w]=YJ([f.inHeight,f.inWidth],d,m),x=y?s:"valid",S=y?l:TA(l,d,b),$=(e==="avg"?()=>hA(S,t,i,x,o):()=>vA(S,t,i,x,o))(),E=y?$:fA($,d,w);return c?gt(E,[E.shape[1],E.shape[2],E.shape[3]]):E}function YJ(n,t,e){const s=e.map(f=>f[0]),r=e.map(f=>f[1]),i=n.concat(s,r),o=t.map((f,d)=>(f-i[d]%f)%f),a=r.map((f,d)=>f+o[d]),l=t.map((f,d)=>[s[d],a[d]]),c=t.map((f,d)=>[0,o[d]]);return[l,c]}function QJ(n,t){const s=n.map((o,a)=>o+(o-1)*(t[a]-1)).map(o=>o-1),r=s.map(o=>Math.floor(o/2)),i=s.map((o,a)=>o-r[a]);return s.map((o,a)=>[r[a],i[a]])}const ZJ=yt({pool_:XJ});function JJ(n,t){const e=rt(n,"x","prelu"),s=rt(t,"alpha","prelu"),r={x:e,alpha:s};return ft.runKernel(Qw,r)}const CA=yt({prelu_:JJ});function ttt(n,t=null,e=!1){let s=rt(n,"x","prod");s.dtype==="bool"&&(s=ne(s,"int32"));const r={x:s},i={axis:t,keepDims:e};return ft.runKernel(Zw,r,i)}const ett=yt({prod_:ttt});var M1={exports:{}},ntt=M1.exports,zF;function stt(){return zF||(zF=1,(function(n){(function(t,e,s){function r(l){var c=this,f=a();c.next=function(){var d=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=d-(c.c=d|0)},c.c=1,c.s0=f(" "),c.s1=f(" "),c.s2=f(" "),c.s0-=f(l),c.s0<0&&(c.s0+=1),c.s1-=f(l),c.s1<0&&(c.s1+=1),c.s2-=f(l),c.s2<0&&(c.s2+=1),f=null}function i(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function o(l,c){var f=new r(l),d=c&&c.state,m=f.next;return m.int32=function(){return f.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,d&&(typeof d=="object"&&i(d,f),m.state=function(){return i(f,{})}),m}function a(){var l=4022871197,c=function(f){f=String(f);for(var d=0;d<f.length;d++){l+=f.charCodeAt(d);var m=.02519603282416938*l;l=m>>>0,m-=l,m*=l,l=m>>>0,m-=l,l+=m*4294967296}return(l>>>0)*23283064365386963e-26};return c}e&&e.exports?e.exports=o:this.alea=o})(ntt,n)})(M1)),M1.exports}var L1={exports:{}},rtt=L1.exports,BF;function itt(){return BF||(BF=1,(function(n){(function(t,e,s){function r(a){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var d=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^d^d>>>8},a===(a|0)?l.x=a:c+=a;for(var f=0;f<c.length+64;f++)l.x^=c.charCodeAt(f)|0,l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var c=new r(a),f=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var m=c.next()>>>11,y=(c.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},d.int32=c.next,d.quick=d,f&&(typeof f=="object"&&i(f,c),d.state=function(){return i(c,{})}),d}e&&e.exports?e.exports=o:this.xor128=o})(rtt,n)})(L1)),L1.exports}var z1={exports:{}},ott=z1.exports,PF;function att(){return PF||(PF=1,(function(n){(function(t,e,s){function r(a){var l=this,c="";l.next=function(){var d=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(d^d<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:c+=a;for(var f=0;f<c.length+64;f++)l.x^=c.charCodeAt(f)|0,f==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var c=new r(a),f=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var m=c.next()>>>11,y=(c.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},d.int32=c.next,d.quick=d,f&&(typeof f=="object"&&i(f,c),d.state=function(){return i(c,{})}),d}e&&e.exports?e.exports=o:this.xorwow=o})(ott,n)})(z1)),z1.exports}var B1={exports:{}},ltt=B1.exports,VF;function utt(){return VF||(VF=1,(function(n){(function(t,e,s){function r(a){var l=this;l.next=function(){var f=l.x,d=l.i,m,y;return m=f[d],m^=m>>>7,y=m^m<<24,m=f[d+1&7],y^=m^m>>>10,m=f[d+3&7],y^=m^m>>>3,m=f[d+4&7],y^=m^m<<7,m=f[d+7&7],m=m^m<<13,y^=m^m<<9,f[d]=y,l.i=d+1&7,y};function c(f,d){var m,y=[];if(d===(d|0))y[0]=d;else for(d=""+d,m=0;m<d.length;++m)y[m&7]=y[m&7]<<15^d.charCodeAt(m)+y[m+1&7]<<13;for(;y.length<8;)y.push(0);for(m=0;m<8&&y[m]===0;++m);for(m==8?y[7]=-1:y[m],f.x=y,f.i=0,m=256;m>0;--m)f.next()}c(l,a)}function i(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var c=new r(a),f=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var m=c.next()>>>11,y=(c.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},d.int32=c.next,d.quick=d,f&&(f.x&&i(f,c),d.state=function(){return i(c,{})}),d}e&&e.exports?e.exports=o:this.xorshift7=o})(ltt,n)})(B1)),B1.exports}var P1={exports:{}},ctt=P1.exports,UF;function htt(){return UF||(UF=1,(function(n){(function(t,e,s){function r(a){var l=this;l.next=function(){var f=l.w,d=l.X,m=l.i,y,b;return l.w=f=f+1640531527|0,b=d[m+34&127],y=d[m=m+1&127],b^=b<<13,y^=y<<17,b^=b>>>15,y^=y>>>12,b=d[m]=b^y,l.i=m,b+(f^f>>>16)|0};function c(f,d){var m,y,b,w,x,S=[],T=128;for(d===(d|0)?(y=d,d=null):(d=d+"\0",y=0,T=Math.max(T,d.length)),b=0,w=-32;w<T;++w)d&&(y^=d.charCodeAt((w+32)%d.length)),w===0&&(x=y),y^=y<<10,y^=y>>>15,y^=y<<4,y^=y>>>13,w>=0&&(x=x+1640531527|0,m=S[w&127]^=y+x,b=m==0?b+1:0);for(b>=128&&(S[(d&&d.length||0)&127]=-1),b=127,w=512;w>0;--w)y=S[b+34&127],m=S[b=b+1&127],y^=y<<13,m^=m<<17,y^=y>>>15,m^=m>>>12,S[b]=y^m;f.w=x,f.X=S,f.i=b}c(l,a)}function i(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var c=new r(a),f=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var m=c.next()>>>11,y=(c.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},d.int32=c.next,d.quick=d,f&&(f.X&&i(f,c),d.state=function(){return i(c,{})}),d}e&&e.exports?e.exports=o:this.xor4096=o})(ctt,n)})(P1)),P1.exports}var V1={exports:{}},ftt=V1.exports,GF;function dtt(){return GF||(GF=1,(function(n){(function(t,e,s){function r(a){var l=this,c="";l.next=function(){var d=l.b,m=l.c,y=l.d,b=l.a;return d=d<<25^d>>>7^m,m=m-y|0,y=y<<24^y>>>8^b,b=b-d|0,l.b=d=d<<20^d>>>12^m,l.c=m=m-y|0,l.d=y<<16^m>>>16^b,l.a=b-d|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):c+=a;for(var f=0;f<c.length+20;f++)l.b^=c.charCodeAt(f)|0,l.next()}function i(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var c=new r(a),f=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var m=c.next()>>>11,y=(c.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},d.int32=c.next,d.quick=d,f&&(typeof f=="object"&&i(f,c),d.state=function(){return i(c,{})}),d}e&&e.exports?e.exports=o:this.tychei=o})(ftt,n)})(V1)),V1.exports}var U1={exports:{}};const ptt={},mtt=Object.freeze(Object.defineProperty({__proto__:null,default:ptt},Symbol.toStringTag,{value:"Module"})),gtt=wX(mtt);var ytt=U1.exports,WF;function btt(){return WF||(WF=1,(function(n){(function(t,e,s){var r=256,i=6,o=52,a="random",l=s.pow(r,i),c=s.pow(2,o),f=c*2,d=r-1,m;function y(E,R,B){var N=[];R=R==!0?{entropy:!0}:R||{};var k=S(x(R.entropy?[E,$(e)]:E??T(),3),N),_=new b(N),F=function(){for(var A=_.g(i),P=l,L=0;A<c;)A=(A+L)*r,P*=r,L=_.g(1);for(;A>=f;)A/=2,P/=2,L>>>=1;return(A+L)/P};return F.int32=function(){return _.g(4)|0},F.quick=function(){return _.g(4)/4294967296},F.double=F,S($(_.S),e),(R.pass||B||function(A,P,L,tt){return tt&&(tt.S&&w(tt,_),A.state=function(){return w(_,{})}),L?(s[a]=A,P):A})(F,k,"global"in R?R.global:this==s,R.state)}function b(E){var R,B=E.length,N=this,k=0,_=N.i=N.j=0,F=N.S=[];for(B||(E=[B++]);k<r;)F[k]=k++;for(k=0;k<r;k++)F[k]=F[_=d&_+E[k%B]+(R=F[k])],F[_]=R;(N.g=function(A){for(var P,L=0,tt=N.i,st=N.j,j=N.S;A--;)P=j[tt=d&tt+1],L=L*r+j[d&(j[tt]=j[st=d&st+P])+(j[st]=P)];return N.i=tt,N.j=st,L})(r)}function w(E,R){return R.i=E.i,R.j=E.j,R.S=E.S.slice(),R}function x(E,R){var B=[],N=typeof E,k;if(R&&N=="object")for(k in E)try{B.push(x(E[k],R-1))}catch{}return B.length?B:N=="string"?E:E+"\0"}function S(E,R){for(var B=E+"",N,k=0;k<B.length;)R[d&k]=d&(N^=R[d&k]*19)+B.charCodeAt(k++);return $(R)}function T(){try{var E;return m&&(E=m.randomBytes)?E=E(r):(E=new Uint8Array(r),(t.crypto||t.msCrypto).getRandomValues(E)),$(E)}catch{var R=t.navigator,B=R&&R.plugins;return[+new Date,t,B,t.screen,$(e)]}}function $(E){return String.fromCharCode.apply(0,E)}if(S(s.random(),e),n.exports){n.exports=y;try{m=gtt}catch{}}else s["seed"+a]=y})(typeof self<"u"?self:ytt,[],Math)})(U1)),U1.exports}var UT,jF;function xtt(){if(jF)return UT;jF=1;var n=stt(),t=itt(),e=att(),s=utt(),r=htt(),i=dtt(),o=btt();return o.alea=n,o.xor128=t,o.xorwow=e,o.xorshift7=s,o.xor4096=r,o.tychei=i,UT=o,UT}var uf=xtt();let u4=class{constructor(t,e,s,r,i){this.mean=t,this.stdDev=e,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=uf.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let t,e,s=!1;for(;!s;){let r,i,o;do r=2*this.random()-1,i=2*this.random()-1,o=r*r+i*i;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*r*a,e=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(t))&&(s=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}},wtt=class{constructor(t=0,e=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=uf.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function vtt(n,t=0,e=1,s,r){if(iu(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new u4(t,e,s,!1,r),o=Pe(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const Stt=yt({randomNormal_:vtt});function Itt(n,t=0,e=1,s="float32",r){iu(n);const i=Pe(n,s),o=new wtt(t,e,null,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const Jy=yt({randomUniform_:Itt});function kg(n,t,e=1,s="float32"){if(e===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:t,step:e,dtype:s};return ft.runKernel(X2,{},r)}function Ttt(n){const e={input:rt(n,"input","real")};return ft.runKernel(Y2,e)}const ux=yt({real_:Ttt});function Ctt(n){const e={x:rt(n,"x","reciprocal")};return ft.runKernel(Ry,e)}const Ett=yt({reciprocal_:Ctt});function $tt(n){const e={x:rt(n,"x","relu")};return ft.runKernel(Dy,e)}const cf=yt({relu_:$tt});function Att(n){const e={x:rt(n,"x","relu6")};return ft.runKernel(Oy,e)}const c4=yt({relu6_:Att});function ktt(n,t){const s={x:rt(n,"x","reverse")},r={dims:t};return ft.runKernel(nv,s,r)}const jh=yt({reverse_:ktt});function _tt(n){const e={x:rt(n,"x","round")};return ft.runKernel(Fy,e)}const h4=yt({round_:_tt});function Ntt(n){const e={x:rt(n,"x","rsqrt","float32")};return ft.runKernel(My,e)}const f4=yt({rsqrt_:Ntt});function Rtt(n){const e={x:rt(n,"x","selu")};return ft.runKernel(Ly,e)}const d4=yt({selu_:Rtt});function Dtt(n,t,e,s,r,i=[1,1],o="NHWC"){const a=rt(n,"x","separableConv2d"),l=rt(t,"depthwiseFilter","separableConv2d"),c=rt(e,"pointwiseFilter","separableConv2d");let f=a,d=!1;if(a.rank===3&&(d=!0,f=gt(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");H(f.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${f.rank}.`),H(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),H(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),H(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),H(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const m=l.shape[2],y=l.shape[3];H(c.shape[2]===m*y,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*y}, but got ${c.shape[2]}.`);const b=mA(f,l,s,r,o,i),x=Gh(b,c,1,"valid",o);return d?gt(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const p4=yt({separableConv2d_:Dtt});function Ott(n){const e={x:rt(n,"x","sign")};return ft.runKernel(Py,e)}const Ftt=yt({sign_:Ott});function Mtt(n){const e={x:rt(n,"x","sin","float32")};return ft.runKernel(zy,e)}const m4=yt({sin_:Mtt});function Ltt(n){const e={x:rt(n,"x","sinh")};return ft.runKernel(By,e)}const g4=yt({sinh_:Ltt});function ztt(n,t,e){const s=rt(n,"x","slice1d");return H(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Pn(s,[t],[e])}const EA=yt({slice1d_:ztt});function Btt(n,t,e){const s=rt(n,"x","slice2d");return H(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Pn(s,t,e)}const y4=yt({slice2d_:Btt});function Ptt(n,t,e){const s=rt(n,"x","slice3d");return H(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Pn(s,t,e)}const $A=yt({slice3d_:Ptt});function Vtt(n,t,e){const s=rt(n,"x","slice4d");return H(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Pn(s,t,e)}const cx=yt({slice4d_:Vtt});function Utt(n,t=-1){const e=rt(n,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);const s={logits:e},r={dim:t};return ft.runKernel(lv,s,r)}const AA=yt({softmax_:Utt});function Gtt(n){H(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const t={input:n};return ft.runKernel(z2,t)}const b4=yt({fft_:Gtt});function Wtt(n){H(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const t={input:n};return ft.runKernel(V2,t)}const YE=yt({ifft_:Wtt});function jtt(n){const t=n.shape[n.shape.length-1],e=n.size/t;let s;if(t<=2){const r=gt(n,[e,t]);s=YE(r)}else{const r=[e,2*(t-1)],i=gt(ux(n),[e,t]),o=gt(bA(n),[e,t]),a=jh(Pn(i,[0,1],[e,t-2]),1),l=ct(jh(Pn(o,[0,1],[e,t-2]),1),dn(-1)),c=ii([i,a],1),f=ii([o,l],1),d=gt(jd(c,f),[r[0],r[1]]);s=YE(d)}if(s=ux(s),n.rank===3&&n.shape[0]!==0){const r=s,i=n.shape[0];s=gt(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}const qtt=yt({irfft_:jtt});function Htt(n,t,e=0){const r={x:rt(n,"x","split")},i={numOrSizeSplits:t,axis:e};return ft.runKernel(av,r,i)}const ji=yt({split_:Htt});function Ktt(n,t){H(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const s=n.size/e;let r;if(t!=null&&t<e){const b=n.shape.map(x=>0),w=n.shape.map(x=>x);w[n.shape.length-1]=t,r=Pn(n,b,w),e=t}else if(t!=null&&t>e){const b=n.shape.map(w=>w);b[n.shape.length-1]=t-e,r=ii([n,sr(b)],n.shape.length-1),e=t}else r=n;const i=sn(r),o=gt(jd(r,i),[s,e]),a=b4(o),l=Math.floor(e/2)+1,c=ux(a),f=bA(a),d=ji(c,[l,e-l],c.shape.length-1),m=ji(f,[l,e-l],f.shape.length-1),y=r.shape.slice();return y[r.shape.length-1]=l,gt(jd(d[0],m[0]),y)}const Xtt=yt({rfft_:Ktt});function Ytt(n,t){let e=rt(n,"a","squaredDifference"),s=rt(t,"b","squaredDifference");[e,s]=bs(e,s),Ne(e.shape,s.shape);const r={a:e,b:s},i={};return ft.runKernel(Wy,r,i)}const Qtt=yt({squaredDifference_:Ytt});function Ztt(n,t){const e=rt(n,"x","squeeze","string_or_numeric");return gt(e,Ac(e.shape,t).newShape)}const tb=yt({squeeze_:Ztt});function Jtt(n,t=0){const e=LP(n,"tensors","stack","string_or_numeric");H(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&H(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");const s=e,r={axis:t};return ft.runKernel(Xw,s,r)}const Ql=yt({stack_:Jtt});function tet(n,t=0){const s={x:rt(n,"x","step")},r={alpha:t};return ft.runKernel(Xy,s,r)}const eb=yt({step_:tet});function eet(n,t,e,s,r=0,i=0,o=0,a=0,l=0){const f={x:rt(n,"x","stridedSlice","string_or_numeric")},d={begin:t,end:e,strides:s,beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return ft.runKernel(eA,f,d)}const net=yt({stridedSlice_:eet});function set(n){const e={x:rt(n,"x","tan","float32")};return ft.runKernel(qy,e)}const ret=yt({tan_:set});function Ti(n,t){jB(n);const e=pv(n,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return mv(n,null,e,t)}function GT(n,t,e){if(jB(n),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=pv(n,e);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return mv(n,t,s,e)}function x4(n,t,e){const s=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(e.rank<r)throw new Error(i+` update.rank < ${r}. `);if(n.length<s+(e.rank-r))throw new Error(i+` Output shape length < ${s+(e.rank-r)}`);if(e.rank!==r+n.length-s)throw new Error(i+` update.rank != ${r+n.length-s}`);for(let o=0;o<r;++o)if(e.shape[o]!==t.shape[o])throw new Error(i+` updates.shape[${o}] (${e.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<e.rank-r;++o)if(e.shape[o+r]!==n[o+s])throw new Error(i+` updates.shape[${o+r}] (${e.shape[o+r]}) != shape[${o+r}] (${n[o+r]})`)}function iet(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}x4(e,t,n)}function hf(n,t,e){const s=t.shape.length,r=s>1?t.shape[s-1]:1,i=e.length;let o=1;for(let d=r;d<i;++d)o*=e[d];const a=r<1?1:r,l=Lt(t.shape)/a,c=[...de(e.slice(0,r)),1],f=Lt(e);return{sliceRank:r,numUpdates:l,sliceSize:o,strides:c,outputSize:f}}function oet(n,t=1,e=!0){const s=rt(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const i={x:s},o={k:t,sorted:e},[a,l]=ft.runKernel(nA,i,o);return{values:a,indices:l}}const aet=yt({topk_:oet});function uet(n,t=0,e=1,s,r){if(iu(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new u4(t,e,s,!0,r),o=Pe(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const w4=yt({truncatedNormal_:uet});function cet(n,t=0){const e=rt(n,"x","unique","string_or_numeric");H(e.rank>0,()=>"The input tensor must be at least 1D");const s={x:e},r={axis:t},[i,o]=ft.runKernel(rA,s,r);return{values:i,indices:o}}const het=yt({unique_:cet});function fet(n,t,e){const s=rt(n,"x","unsortedSegmentSum"),r=rt(t,"segmentIds","unsortedSegmentSum","int32");H(Wd(e),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:r},o={numSegments:e};return ft.runKernel(cv,i,o)}const v4=yt({unsortedSegmentSum_:fet});function det(n,t=0){const e=rt(n,"x","unstack","string_or_numeric");H(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);const s={value:e},r={axis:t};return ft.runKernel(uv,s,r)}const qh=yt({unstack_:det});function pet(n,t=!0,e,s){return ft.makeVariable(n,t,e,s)}function S4(n,t){const e=[];for(let i=0;i<t.length;i++)t[i]&&e.push(i);const s=Pe(n,"int32"),r=Pe([e.length,n.length],"int32");for(let i=0;i<e.length;i++){const o=s.indexToLoc(e[i]),a=i*n.length;r.values.set(o,a)}return r.toTensor()}function met(n,t,e){const s=rt(n,"x","transpose");if(t==null&&(t=s.shape.map((o,a)=>a).reverse()),H(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`),t.forEach(o=>{H(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:t};return s.dtype==="complex64"?vt(()=>{let o=ux(s),a=bA(s);return o=ft.runKernel(Od,{x:o},i),a=ft.runKernel(Od,{x:a},i),e&&(a=ys(a)),jd(o,a)}):ft.runKernel(Od,r,i)}const en=yt({transpose_:met});function get(n,t){if(t==null)return n.shape.slice();if(mn(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let s=0;s<n.shape.length;s++)t[s]==null&&n.shape[s]!=null?e.push(n.shape[s]):e.push(t[s]);return e}return t}function yet(n,t,e,s){const r=rt(n,"x","dropout");if(H(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),H(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return n instanceof Vs?r.clone():r;const i=get(r,e),o=1-t,a=be(vv(Yt(Jy(i,0,1,"float32",s),o)),o);return ct(r,a)}const bet=yt({dropout_:yet});function xet(n,t,e,s,r,i="NHWC",o){let a=n;n.rank===3&&(a=gt(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;l.rank===3&&(l=gt(t,[1,t.shape[0],t.shape[1],t.shape[2]])),H(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),H(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),H(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const c=i==="NHWC"?a.shape[3]:a.shape[1],f=i==="NHWC"?l.shape[3]:l.shape[1];H(c===e[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${e[2]}.`),H(f===e[3],()=>`Error in conv2dDerFilter: depth of dy (${f}) must match output depth for filter (${e[3]}).`),fi("conv2dDerFilter",r,o);const d={x:a,dy:l},m={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,filterShape:e};return ft.runKernel($2,d,m)}const kA=yt({conv2DBackpropFilter_:xet});function _A(n,t,e){if(e==null||e==="linear")return n;if(e==="relu")return ct(n,eb(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function NA(n,t){let e=t;const s=Zs(n.shape,t.shape);return s.length>0&&(e=me(e,s)),gt(e,n.shape)}function RA(n,t,e,s){if(t==="linear")return n;if(t==="relu")return cf(n);if(t==="elu")return xv(n);if(t==="relu6")return c4(n);if(t==="prelu")return CA(n,e);if(t==="leakyrelu")return xA(n,s);if(t==="sigmoid")return wp(n);throw new Error(`Unknown fused activation ${t}.`)}const DA=(n,t)=>!(n>0)||t==="linear";function wet({x:n,filter:t,strides:e,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:f}){if(l=l||"linear",DA(ft.state.gradientDepth,l)===!1){H(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let B=Gh(n,t,e,s,r,i,o);return a!=null&&(B=Yt(B,a)),RA(B,l,c,f)}const d=rt(n,"x","conv2d","float32"),m=rt(t,"filter","conv2d","float32");let y=d,b=!1;d.rank===3&&(b=!0,y=gt(d,[1,d.shape[0],d.shape[1],d.shape[2]])),H(y.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${y.rank}.`),H(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),fi("fused conv2d",s,o);const w=r==="NHWC"?y.shape[3]:y.shape[1];H(m.shape[2]===w,()=>`Error in conv2d: depth of input (${w}) must match input depth for filter ${m.shape[2]}.`),H(Or(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);const x=vr(y.shape,m.shape,e,i,s,o);let S;a!=null&&(S=rt(a,"bias","fused conv2d"),[S]=bs(S,d),r==="NHWC"?Ne(x.outShape,S.shape):(H(S.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${S.shape.length}.`),H(S.shape.length===0||S.shape[0]===x.outChannels||S.shape[0]===1,()=>`Error in fused conv2d: bias shape (${S.shape}) is not compatible with the number of output channels (${x.outChannels})`)));let T;if(c!=null){const B=c.shape;if(H(B.length<=1||B.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${B.length}.`),B.length===1)H(B[0]===1||B[0]===x.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${B}) is not compatible with the number of output channels (${x.outChannels}).`);else if(B.length===3)try{Ne(B,x.outShape)}catch{const k=`Error in fused conv2d: PReLU activation weights (${B}) is not compatible with the output shape of the conv2d (${x.outShape}).`;throw Error(k)}T=rt(c,"prelu weights","fused conv2d")}const $=(B,N)=>{H(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[k,_,F,A]=N,P=_A(B,F,l);H(Vh(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const L=dA(_.shape,P,k,e,s),tt=kA(_,P,k.shape,e,s),st=[L,tt];if(A!=null){const j=NA(A,P);st.push(j)}return st},E={x:y,filter:m,bias:S,preluActivationWeights:T},R={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:f};return a==null?Hd((N,k,_)=>{let F=ft.runKernel(sx,E,R);return _([k,N,F]),b&&(F=gt(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:$}})(y,m):Hd((N,k,_,F)=>{let A=ft.runKernel(sx,E,R);return F([k,N,A,_]),b&&(A=gt(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:$}})(y,m,S)}const vet=yt({fusedConv2d_:wet});function Iet(n,t,e,s,r,i=[1,1],o){let a=n;n.rank===3&&(a=gt(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;l.rank===3&&(l=gt(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={x:a,dy:l},f={strides:s,pad:r,dimRoundingMode:o,dilations:i,filterShape:e};return ft.runKernel(O2,c,f)}const Tet=yt({depthwiseConv2dNativeBackpropFilter_:Iet});function Cet(n,t,e,s,r,i=[1,1],o){let a=t,l=!1;t.rank===3&&(l=!0,a=gt(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={dy:a,filter:e},f={strides:s,pad:r,dimRoundingMode:o,dilations:i,inputShape:n},d=ft.runKernel(F2,c,f);return l?gt(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Eet=yt({depthwiseConv2dNativeBackpropInput_:Cet});function $et({a:n,b:t,transposeA:e=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(DA(ft.state.gradientDepth,i)===!1){let A=fn(n,t,e,s);return r!=null&&(A=Yt(A,r)),RA(A,i,o,a)}let l=rt(n,"a","fused matMul"),c=rt(t,"b","fused matMul");[l,c]=bs(l,c);const f=e?l.shape[l.rank-2]:l.shape[l.rank-1],d=s?c.shape[c.rank-1]:c.shape[c.rank-2],m=e?l.shape[l.rank-1]:l.shape[l.rank-2],y=s?c.shape[c.rank-2]:c.shape[c.rank-1],b=l.shape.slice(0,-2),w=c.shape.slice(0,-2),x=Lt(b),S=Lt(w);H(f===d,()=>`Error in fused matMul: inner shapes (${f}) and (${d}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${e} and transposeB=${s} must match.`);const $=Ne(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([m,y]),E=e?gt(l,[x,f,m]):gt(l,[x,m,f]),R=s?gt(c,[S,y,d]):gt(c,[S,d,y]);let B;r!=null&&(B=rt(r,"bias","fused matMul"),[B]=bs(B,l),Ne($,B.shape));let N;o!=null&&(N=rt(o,"prelu weights","fused matMul"));const k=(A,P)=>{const[L,tt,st,j]=P,Z=_A(gt(A,st.shape),st,i);let J,ot;if(!e&&!s?(J=fn(Z,tt,!1,!0),ot=fn(L,Z,!0,!1)):!e&&s?(J=fn(Z,tt,!1,!1),ot=fn(Z,L,!0,!1)):e&&!s?(J=fn(tt,Z,!1,!0),ot=fn(L,Z,!1,!1)):(J=fn(tt,Z,!0,!0),ot=fn(Z,L,!0,!0)),r!=null){const pt=NA(j,Z);return[J,ot,pt]}else return[J,ot]},_={a:E,b:R,bias:B,preluActivationWeights:N},F={transposeA:e,transposeB:s,activation:i,leakyreluAlpha:a};return r==null?Hd((P,L,tt)=>{const st=ft.runKernel(nx,_,F);return tt([P,L,st]),{value:gt(st,$),gradFunc:k}})(E,R):Hd((P,L,tt,st)=>{const j=ft.runKernel(nx,_,F);return st([P,L,j,tt]),{value:gt(j,$),gradFunc:k}})(E,R,B)}const qF=yt({fusedMatMul_:$et});function Aet(n,t,e,s,r="bilinear",i=0){const o=rt(n,"image","cropAndResize"),a=rt(t,"boxes","cropAndResize","float32"),l=rt(e,"boxInd","cropAndResize","int32"),c=a.shape[0];H(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),H(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),H(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),H(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),H(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),H(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const f={image:o,boxes:a,boxInd:l},d={method:r,extrapolationValue:i,cropSize:s};return ft.runKernel(N2,f,d)}const ket=yt({cropAndResize_:Aet});function _et(n){const t=rt(n,"image","flipLeftRight","float32");H(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const e={image:t};return ft.runKernel(P2,e,{})}const Net=yt({flipLeftRight_:_et});function Ret(n){const t=rt(n,"image","grayscaleToRGB"),e=t.rank-1,s=t.shape[e];H(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),H(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(t.rank);return r.fill(1,0,e),r[e]=3,Qo(t,r)}const Det=yt({grayscaleToRGB_:Ret});function Oet(n){const t=rt(n,"image","RGBToGrayscale"),e=t.rank-1,s=t.shape[e];H(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),H(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=t.dtype,i=ne(t,"float32"),o=Ti([.2989,.587,.114]);let a;switch(t.rank){case 2:a=Ym("ij,j->i",i,o);break;case 3:a=Ym("ijk,k->ij",i,o);break;case 4:a=Ym("ijkl,l->ijk",i,o);break;case 5:a=Ym("ijklm,m->ijkl",i,o);break;case 6:a=Ym("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return a=ni(a,-1),ne(a,r)}const Fet=yt({rgbToGrayscale_:Oet});function Met(n,t,e=0,s=.5){const r=rt(n,"image","rotateWithOffset","float32");H(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},o={radians:t,fillValue:e,center:s};return ft.runKernel(iA,i,o)}const Let=yt({rotateWithOffset_:Met});function Sp(n,t,e,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=n.shape[0];return e=Math.min(e,o),H(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),H(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),H(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),H(t.rank===1,()=>"scores must be a 1D tensor"),H(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),H(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:e,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}function zet(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY){const i=rt(n,"boxes","nonMaxSuppression","float32"),o=rt(t,"scores","nonMaxSuppression","float32"),a=Sp(i,o,e,s,r);e=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l={maxOutputSize:e,iouThreshold:s,scoreThreshold:r};return ft.runKernel(q2,{boxes:i,scores:o},l)}const Bet=yt({nonMaxSuppression_:zet});function Pet(n,t,e){const s=Vet(n,t,e),r=s<0?-(s+1):s;n.splice(r,0,t)}function Vet(n,t,e){return Get(n,t,e||Uet)}function Uet(n,t){return n>t?1:n<t?-1:0}function Get(n,t,e){let s=0,r=n.length,i=0,o=!1;for(;s<r;){i=s+(r-s>>>1);const a=e(t,n[i]);a>0?s=i+1:(r=i,o=!a)}return o?s:-s-1}function OA(n,t,e,s,r){return LA(n,t,e,s,r,0)}function FA(n,t,e,s,r,i){return LA(n,t,e,s,r,0,!1,i,!0)}function MA(n,t,e,s,r,i){return LA(n,t,e,s,r,i,!0)}function LA(n,t,e,s,r,i,o=!1,a=!1,l=!1){const c=[];for(let x=0;x<t.length;x++)t[x]>r&&c.push({score:t[x],boxIndex:x,suppressBeginIndex:0});c.sort(HF);const f=i>0?-.5/i:0,d=[],m=[];for(;d.length<e&&c.length>0;){const x=c.pop(),{score:S,boxIndex:T,suppressBeginIndex:$}=x;if(S<r)break;let E=!1;for(let R=d.length-1;R>=$;--R){const B=Wet(n,T,d[R]);if(B>=s){E=!0;break}if(x.score=x.score*jet(s,f,B),x.score<=r)break}x.suppressBeginIndex=d.length,E||(x.score===S?(d.push(T),m.push(x.score)):x.score>r&&Pet(c,x,HF))}const y=d.length,b=e-y;a&&b>0&&(d.push(...new Array(b).fill(0)),m.push(...new Array(b).fill(0)));const w={selectedIndices:d};return o&&(w.selectedScores=m),l&&(w.validOutputs=y),w}function Wet(n,t,e){const s=n.subarray(t*4,t*4+4),r=n.subarray(e*4,e*4+4),i=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(r[0],r[2]),f=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),m=Math.max(r[1],r[3]),y=(a-i)*(l-o),b=(d-c)*(m-f);if(y<=0||b<=0)return 0;const w=Math.max(i,c),x=Math.max(o,f),S=Math.min(a,d),T=Math.min(l,m),$=Math.max(S-w,0)*Math.max(T-x,0);return $/(y+b-$)}function jet(n,t,e){const s=Math.exp(t*e*e);return e<=n?s:0}function HF(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}async function qet(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY){const i=rt(n,"boxes","nonMaxSuppressionAsync"),o=rt(t,"scores","nonMaxSuppressionAsync"),a=Sp(i,o,e,s,r);e=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l=await Promise.all([i.data(),o.data()]),c=l[0],f=l[1],{selectedIndices:d}=OA(c,f,e,s,r);return i!==n&&i.dispose(),o!==t&&o.dispose(),Ti(d,"int32")}const Het=qet;function Ket(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=rt(n,"boxes","nonMaxSuppression"),a=rt(t,"scores","nonMaxSuppression"),l=Sp(o,a,e,s,r,i);e=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const c={boxes:o,scores:a},f={maxOutputSize:e,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},d=ft.runKernel(K2,c,f);return{selectedIndices:d[0],selectedScores:d[1]}}const Xet=yt({nonMaxSuppressionWithScore_:Ket});async function Yet(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=rt(n,"boxes","nonMaxSuppressionAsync"),a=rt(t,"scores","nonMaxSuppressionAsync"),l=Sp(o,a,e,s,r,i);e=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),f=c[0],d=c[1],{selectedIndices:m,selectedScores:y}=MA(f,d,e,s,r,i);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:Ti(m,"int32"),selectedScores:Ti(y)}}const Qet=Yet;function Zet(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=rt(n,"boxes","nonMaxSuppression"),a=rt(t,"scores","nonMaxSuppression"),l=Sp(o,a,e,s,r,null),c=l.maxOutputSize,f=l.iouThreshold,d=l.scoreThreshold,m={boxes:o,scores:a},y={maxOutputSize:c,iouThreshold:f,scoreThreshold:d,padToMaxOutputSize:i},b=ft.runKernel(H2,m,y);return{selectedIndices:b[0],validOutputs:b[1]}}const Jet=yt({nonMaxSuppressionPadded_:Zet});async function tnt(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=rt(n,"boxes","nonMaxSuppressionAsync"),a=rt(t,"scores","nonMaxSuppressionAsync"),l=Sp(o,a,e,s,r,null),c=l.maxOutputSize,f=l.iouThreshold,d=l.scoreThreshold,[m,y]=await Promise.all([o.data(),a.data()]),{selectedIndices:b,validOutputs:w}=FA(m,y,c,f,d,i);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:Ti(b,"int32"),validOutputs:dn(w,"int32")}}const ent=tnt;function nnt(n,t,e=!1,s=!1){const r=rt(n,"images","resizeBilinear");H(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),H(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),H(s===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=gt(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:e,halfPixelCenters:s,size:t},c=ft.runKernel(ev,a,l);return o?gt(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const I4=yt({resizeBilinear_:nnt});function snt(n,t,e=!1,s=!1){const r=rt(n,"images","resizeNearestNeighbor");H(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),H(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),H(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),H(s===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=gt(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:e,halfPixelCenters:s,size:t},c=ft.runKernel(tv,a,l);return o?gt(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const T4=yt({resizeNearestNeighbor_:snt});function rnt(n,t="binary",e=!1,s=.5){const r=rt(n,"image","threshold"),i=.2989,o=.587,a=.114,l=r.shape[0]*r.shape[1];let c=ct(Ti([s]),255),f,d,m,y;if(H(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),H(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),H(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),H(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[f,d,m]=ji(r,[1,1,1],-1);const x=ct(f,i),S=ct(d,o),T=ct(m,a);y=Yt(Yt(x,S),T)}else y=n;if(t==="otsu"){const x=JQ(ne(h4(y),"int32"),zP([]),256);c=int(x,l)}const b=e?vp(y,c):Ki(y,c);return ne(ct(b,255),"int32")}function int(n,t){let e=Ti([-1]),s=Ti([0]),r=Ti([0]),i,o,a,l,c,f;for(let d=0;d<n.size-1;d++){i=Pn(n,0,d+1),o=Pn(n,d+1),c=be(me(i),t),f=be(me(o),t);const m=me(ct(i,kg(0,i.size)));a=be(m,me(i));const y=bv(o.shape,i.size),b=Yt(kg(0,o.size),y),w=ct(o,b);l=be(me(w),me(o));const x=Se(a,l),S=Se(a,l),T=ct(c,f);r=ct(ct(T,x),S);const $=Ki(r,s);s=Hr($,r,s),e=Hr($,Ti([d]),e)}return e}const ont=yt({threshold_:rnt});function ant(n,t,e="nearest",s="constant",r=0,i){const o=rt(n,"image","transform","float32"),a=rt(t,"transforms","transform","float32");H(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),H(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),H(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const l={image:o,transforms:a},c={interpolation:e,fillMode:s,fillValue:r,outputShape:i};return ft.runKernel(sA,l,c)}const lnt=yt({transform_:ant});function unt(n,t,e){const s=rt(n,"a","bandPart");H(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,o]=s.shape.slice(-2);let a,l;typeof t=="number"?(H(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),H(t<=i,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`),a=rt(t<0?i:t,"numLower","bandPart")):(H(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=Hr(ax(t,0),i,Ag(t,i))),typeof e=="number"?(H(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),H(e<=o,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${o}).`),l=rt(e<0?o:e,"numUpper","bandPart")):(H(e.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Hr(ax(e,0),o,Ag(e,o)));const c=gt(kg(0,i,1,"int32"),[-1,1]),f=kg(0,o,1,"int32"),d=Se(c,f),m=Yl(vp(d,a),lf(d,ys(l))),y=sr([i,o],s.dtype);return gt(Ql(qh(gt(s,[-1,i,o])).map(b=>Hr(m,b,y))),r)}const cnt=yt({bandPart_:unt});function hnt(n){let t;if(Array.isArray(n)){t=!1,H(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let i=1;i<n.length;++i)H(n[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${r})`)}else t=!0,n=ji(n,n.shape[0],0).map(r=>tb(r,[0]));H(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],s=n;for(let r=0;r<n.length;++r)e.push(ft.tidy(()=>{let i=s[r];if(r>0)for(let o=0;o<r;++o){const a=ct(me(ct(e[o],i)),e[o]);i=Se(i,a)}return be(i,wv(i,"euclidean"))}));return t?Ql(e,0):e}const fnt=yt({gramSchmidt_:hnt});function dnt(n,t=!1){if(H(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return KF(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),s=qh(gt(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],i=[];s.forEach(l=>{const[c,f]=KF(l,t);r.push(c),i.push(f)});const o=gt(Ql(r,0),n.shape),a=gt(Ql(i,0),n.shape);return[o,a]}}function KF(n,t=!1){return ft.tidy(()=>{H(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],s=n.shape[1];let r=s4(e),i=Ah(n);const o=GT([[1]],[1,1]);let a=Ah(o);const l=e>=s?s:e;for(let c=0;c<l;++c){const f=i,d=a,m=r;[a,i,r]=ft.tidy(()=>{const y=Pn(i,[c,c],[e-c,1]),b=wv(y),w=Pn(i,[c,c],[1,1]),x=Hr(Ki(w,0),GT([[-1]]),GT([[1]])),S=Se(w,ct(x,b)),T=be(y,S);T.shape[0]===1?a=Ah(o):a=ii([o,Pn(T,[1,0],[T.shape[0]-1,T.shape[1]])],0);const $=ys(be(fn(x,S),b)),E=Pn(i,[c,0],[e-c,s]),R=ct($,a),B=en(a);if(c===0)i=Se(E,fn(R,fn(B,E)));else{const _=Se(E,fn(R,fn(B,E)));i=ii([Pn(i,[0,0],[c,s]),_],0)}const N=en(R),k=Pn(r,[0,c],[e,r.shape[1]-c]);if(c===0)r=Se(k,fn(fn(k,a),N));else{const _=Se(k,fn(fn(k,a),N));r=ii([Pn(r,[0,0],[e,c]),_],1)}return[a,i,r]}),We([f,d,m])}return!t&&e>s&&(r=Pn(r,[0,0],[e,s]),i=Pn(i,[0,0],[s,s])),[r,i]})}const pnt=yt({qr_:dnt});const jl={flipLeftRight:Net,grayscaleToRGB:Det,resizeNearestNeighbor:T4,resizeBilinear:I4,rgbToGrayscale:Fet,rotateWithOffset:Let,cropAndResize:ket,nonMaxSuppression:Bet,nonMaxSuppressionAsync:Het,nonMaxSuppressionWithScore:Xet,nonMaxSuppressionWithScoreAsync:Qet,nonMaxSuppressionPadded:Jet,nonMaxSuppressionPaddedAsync:ent,threshold:ont,transform:lnt},mnt={bandPart:cnt,gramSchmidt:fnt,qr:pnt};const gnt=new Map,ynt=new Map;let Ip=class{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}},Tp=class Sd{constructor(){this.classNameMap={}}static getMap(){return Sd.instance==null&&(Sd.instance=new Sd),Sd.instance}static register(t){Sd.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function Ht(n,t,e){H(n.className!=null,()=>"Class being registered does not have the static className property defined."),H(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),H(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof e>"u"&&(e=n.className);const s=e,r=t+">"+s;return Tp.register(n),gnt.set(r,n),ynt.set(n,r),n}let Oc=class extends Ip{minimize(t,e=!1,s){const{value:r,grads:i}=this.computeGradients(t,s);if(s!=null){const o=s.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return We(i),e?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return wJ(t,e)}dispose(){this.iterations_!=null&&We(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:dn(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}};Object.defineProperty(Oc,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});let C4=class extends Oc{static get className(){return"Adadelta"}constructor(t,e,s=null){super(),this.learningRate=t,this.rho=e,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=ft.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=ft.registeredVariables[s],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:vt(()=>sn(i).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:vt(()=>sn(i).variable(o))});const a=Array.isArray(t)?t[r].tensor:t[s];if(a==null)return;const l=this.accumulatedGrads[r].variable,c=this.accumulatedUpdates[r].variable;vt(()=>{const f=Yt(ct(l,this.rho),ct(Kn(a),1-this.rho)),d=ct(be(Dr(Yt(c,this.epsilon)),Dr(Yt(l,this.epsilon))),a),m=Yt(ct(c,this.rho),ct(Kn(d),1-this.rho));l.assign(f),c.assign(m);const y=Yt(ct(d,-this.learningRate),i);i.assign(y)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(We(this.accumulatedGrads.map(t=>t.variable)),We(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=t.length/2,s=!1;this.accumulatedGrads=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}};let E4=class extends Oc{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=ft.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:vt(()=>bv(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(t)?t[r].tensor:t[s];if(o==null)return;const a=this.accumulatedGrads[r].variable;vt(()=>{const l=Yt(a,Kn(o));a.assign(l);const c=Yt(ct(be(o,Dr(Yt(l,ft.backend.epsilon()))),-this.learningRate),i);i.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&We(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}};let $4=class extends Oc{static get className(){return"Adam"}constructor(t,e,s,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],vt(()=>{this.accBeta1=dn(e).variable(),this.accBeta2=dn(s).variable()}),r==null&&(this.epsilon=ft.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);vt(()=>{const s=Se(1,this.accBeta1),r=Se(1,this.accBeta2);e.forEach((i,o)=>{const a=ft.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:vt(()=>sn(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:vt(()=>sn(a).variable(l))});const c=Array.isArray(t)?t[o].tensor:t[i];if(c==null)return;const f=this.accumulatedFirstMoment[o].variable,d=this.accumulatedSecondMoment[o].variable,m=Yt(ct(f,this.beta1),ct(c,1-this.beta1)),y=Yt(ct(d,this.beta2),ct(Kn(c),1-this.beta2)),b=be(m,s),w=be(y,r);f.assign(m),d.assign(y);const x=Yt(ct(be(b,Yt(Dr(w),this.epsilon)),-this.learningRate),a);a.assign(x)}),this.accBeta1.assign(ct(this.accBeta1,this.beta1)),this.accBeta2.assign(ct(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&We(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&We(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),vt(()=>{this.accBeta1.assign(Wh(this.beta1,this.iterations_+1)),this.accBeta2.assign(Wh(this.beta2,this.iterations_+1))});const e=t.length/2,s=!1;this.accumulatedFirstMoment=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}};let A4=class extends Oc{static get className(){return"Adamax"}constructor(t,e,s,r=null,i=0){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],vt(()=>{this.iteration=dn(0).variable(),this.accBeta1=dn(e).variable()}),r==null&&(this.epsilon=ft.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);vt(()=>{const s=Se(1,this.accBeta1),r=be(-this.learningRate,Yt(ct(this.iteration,this.decay),1));e.forEach((i,o)=>{const a=ft.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:sn(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:sn(a).variable(l)});const c=Array.isArray(t)?t[o].tensor:t[i];if(c==null)return;const f=this.accumulatedFirstMoment[o].variable,d=this.accumulatedWeightedInfNorm[o].variable,m=Yt(ct(f,this.beta1),ct(c,1-this.beta1)),y=ct(d,this.beta2),b=Ur(c),w=Rc(y,b);f.assign(m),d.assign(w);const x=Yt(ct(be(r,s),be(m,Yt(w,this.epsilon))),a);a.assign(x)}),this.iteration.assign(Yt(this.iteration,1)),this.accBeta1.assign(ct(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&We(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&We(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}};let zA=class extends Oc{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=Array.isArray(t)?t[r].tensor:t[s];if(i==null)return;const o=ft.registeredVariables[s];vt(()=>{const a=Yt(ct(this.c,i),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=nl(dn(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}};let k4=class extends zA{static get className(){return"Momentum"}constructor(t,e,s=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=s,this.accumulations=[],this.m=dn(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=ft.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:vt(()=>sn(i).variable(!1))});const o=this.accumulations[r].variable,a=Array.isArray(t)?t[r].tensor:t[s];a!=null&&vt(()=>{let l;const c=Yt(ct(this.m,o),a);this.useNesterov?l=Yt(ct(this.c,Yt(a,ct(c,this.m))),i):l=Yt(ct(this.c,c),i),o.assign(c),i.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&We(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}};let _4=class extends Oc{static get className(){return"RMSProp"}constructor(t,e=.9,s=0,r=null,i=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=ft.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=ft.registeredVariables[s],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:vt(()=>sn(i).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:vt(()=>sn(i).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:vt(()=>sn(i).variable(o))});const a=Array.isArray(t)?t[r].tensor:t[s];if(a==null)return;const l=this.accumulatedMeanSquares[r].variable,c=this.accumulatedMoments[r].variable;vt(()=>{const f=Yt(ct(l,this.decay),ct(Kn(a),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[r].variable,m=Yt(ct(d,this.decay),ct(a,1-this.decay)),y=be(ct(a,this.learningRate),Dr(Se(f,Yt(Kn(m),this.epsilon)))),b=Yt(ct(c,this.momentum),y);l.assign(f),d.assign(m),c.assign(b);const w=Se(i,b);i.assign(w)}else{const d=Yt(ct(l,this.decay),ct(Kn(a),1-this.decay)),m=Yt(ct(c,this.momentum),be(ct(a,this.learningRate),Dr(Yt(d,this.epsilon))));l.assign(d),c.assign(m);const y=Se(i,m);i.assign(y)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&We(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&We(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&We(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,s=!1;this.accumulatedMeanSquares=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}};const bnt=[C4,E4,$4,A4,k4,_4,zA];function xnt(){for(const n of bnt)Ht(n)}function BA(n,t){const e=n.shape.length,s=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${e}`);if(Lt(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=t.shape,i=r[r.length-1];let o=1;for(let d=0;d<r.length-1;++d)o*=r[d];const a=n.shape,l=r.slice();l.pop();let c=1;for(let d=i;d<e;++d)c*=a[d],l.push(a[d]);const f=[...de(n.shape).map(d=>d/c),1].slice(0,i);return[l,o,c,f]}const QE=-2,wnt=-1;function PA(n,t,e){const s=n.shape.length;H(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`),H(s===e.length,()=>`Error in slice${s}D: Length of size ${e} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)H(t[r]+e[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${t[r]+e[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function vnt(n){const t=[];let e=0;for(;n>0;)n&1&&t.push(e),n/=2,e++;return t}function VA(n,t,e){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((t[r]-n[r])/e[r]);return s}function N4(n,t,e,s){const r=[...n];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<e;i++)i===0?r[t]=1:(r.splice(t,0,1),r.pop());return r}function R4(n,t,e){return e<=n?e:e-(t-1)}function D4(n,t){const e=[];for(let s=0;s<n;s++)e.push(t+s);return e}function Snt(n,t,e,s,r,i,o,a,l){const c=n.length;let f=new Array(c),d=new Array(c),m=new Array(c);if(t.length&&e>0){const y=t[0],b=e+1;f=O4(o,y,b,s,n),d=F4(a,y,b,r,n),m=N4(i,y,b,n)}else for(let y=0;y<c;y++)f[y]=L4(o,s,i,n,y,l),d[y]=z4(a,r,i,n,y,l),m[y]=M4(i,y,l);return{begin:f,end:d,strides:m}}function O4(n,t,e,s,r){const i=[...r],o=D4(e,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const l=R4(t,e,a);let c=s[l];n&1<<l&&(c=0),i[a]=c}return i}function F4(n,t,e,s,r){const i=[...r],o=D4(e,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const l=R4(t,e,a);let c=s[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),i[a]=c}for(let a=0;a<i.length;a++){const l=r[a];i[a]<0&&(i[a]+=l),i[a]=Lh(0,i[a],r[a])}return i}function M4(n,t,e){let s=n[t];return(e&1<<t||s==null)&&(s=1),s}function L4(n,t,e,s,r,i){let o=t[r];const a=e[r]||1;(n&1<<r||i&1<<r||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=s[r];return o<0&&(o+=l),o=Lh(0,o,l-1),o}function z4(n,t,e,s,r,i){let o=t[r];const a=e[r]||1;(n&1<<r||i&1<<r||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=s[r];return o<0&&(o+=l),a>0?o=Lh(0,o,l):o=Lh(-1,o,l-1),o}function UA(n,t,e){let s=e.length;for(let r=0;r<e.length;r++)if(e[r]>1){s=r;break}for(let r=s+1;r<e.length;r++)if(t[r]>0||e[r]!==n[r])return!1;return!0}function GA(n,t){let e=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)e+=n[s]*t[s];return e}function Sv(n,t,e){let s;const r=n.shape.length;typeof t=="number"?s=[t,...new Array(r-1).fill(0)]:t.length<r?s=t.concat(new Array(r-t.length).fill(0)):s=t.slice(),s.forEach(o=>{H(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return e==null?i=new Array(r).fill(-1):typeof e=="number"?i=[e,...new Array(r-1).fill(-1)]:e.length<r?i=e.concat(new Array(r-e.length).fill(-1)):i=e,i=i.map((o,a)=>o>=0?o:(H(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-s[a])),[s,i]}function WA(n,t,e,s,r,i,o,a,l){let c;if(s==null?(c=new Array(t.length),c.fill(1)):c=s,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let f=!1;const d={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:c.slice(),beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let $=0;$<d.dims;$++)f&&(1<<$&a)!==0&&d.numAddAxisAfterEllipsis++,1<<$&o&&(f=!0);f||(d.ellipsisMask|=1<<d.dims,d.dims++);const m={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Int(d,m);let y=!0,b=!0,w=!0;const x=[],S=[];for(let $=0;$<n.length;++$){if(m.strides[$]===0)throw Error(`strides[${$}] must be non-zero`);const E=!!(m.shrinkAxisMask&1<<$),R=n[$];if(R===-1){x.push(E?1:-1);continue}const B=[m.beginMask&1<<$,m.endMask&1<<$],N=[m.strides[$]>0?0:-1,m.strides[$]>0?R:R-1];if(E&&m.strides[$]<=0)throw Error("only stride 1 allowed on non-range indexing.");w=w&&m.strides[$]===1;const k=!!(m.beginMask&1<<$&&m.endMask&1<<$);if(m.beginValid&&m.endValid){if(E){const P=m.begin[$]<0?R+m.begin[$]:m.begin[$];if(m.begin[$]=P,m.end[$]=m.begin[$]+1,P<0||P>=R)throw Error(`slice index ${m.begin[$]} of dimension ${$} out of bounds.`)}else m.begin[$]=XF(m.begin[$],0,m.strides[$],R,B,N),m.end[$]=XF(m.end[$],1,m.strides[$],R,B,N);const A=m.strides[$]===1&&m.begin[$]===0&&m.end[$]===R;y=y&&A,b=b&&($===0&&m.strides[$]===1||A)}else y=y&&m.strides[$]===1&&k,b=b&&($===0&&m.strides[$]===1||k);let _,F=!1;if(m.beginValid&&m.endValid?(_=m.end[$]-m.begin[$],F=!0):E?(_=1,F=!0):k&&R>=0&&(m.strides[$]<0?_=-R:_=R,F=!0),F){let A;_===0||_<0!=m.strides[$]<0?A=0:A=Math.trunc(_/m.strides[$])+(_%m.strides[$]!==0?1:0),x.push(A)}else x.push(-1)}for(let $=0;$<m.finalShapeGatherIndices.length;++$){const E=m.finalShapeGatherIndices[$];E>=0?S.push(x[E]):E===QE&&S.push(1)}return{finalShapeSparse:S.filter(($,E)=>m.finalShapeGatherIndices[E]!==QE),finalShape:S,isIdentity:y,sliceDim0:b,isSimpleSlice:w,begin:m.begin,end:m.end,strides:m.strides}}function Int(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=n.begin!=null,t.endValid=n.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(t.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<r;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=s}else if(1<<s&n.newAxisMask)t.finalShapeGatherIndices.push(QE),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);n.begin!=null&&(t.begin[e]=n.begin[s]),n.end!=null&&(t.end[e]=n.end[s]),t.strides[e]=n.strides[s],n.beginMask&1<<s&&(t.beginMask|=1<<e),n.endMask&1<<s&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<s?(t.finalShapeGatherIndices.push(wnt),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(s)),t.inputShapeGatherIndicesSparse[e]=s,e++}}function XF(n,t,e,s,r,i){if(r[t])return e>0?i[t]:i[t+1&1];{const o=n<0?s+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}const Tnt=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:PA,computeFlatOffset:GA,computeOutShape:VA,getNormalizedAxes:Snt,isSliceContinous:UA,maskToAxes:vnt,parseSliceParams:Sv,sliceInfo:WA,startForAxis:L4,startIndicesWithElidedDims:O4,stopForAxis:z4,stopIndicesWithElidedDims:F4,stridesForAxis:M4,stridesWithElidedDims:N4},Symbol.toStringTag,{value:"Module"}));let Cnt=class{static sgd(t){return new zA(t)}static momentum(t,e,s=!1){return new k4(t,e,s)}static rmsprop(t,e=.9,s=0,r=null,i=!1){return new _4(t,e,s,r,i)}static adam(t=.001,e=.9,s=.999,r=null){return new $4(t,e,s,r)}static adadelta(t=.001,e=.95,s=null){return new C4(t,e,s)}static adamax(t=.002,e=.9,s=.999,r=null,i=0){return new A4(t,e,s,r,i)}static adagrad(t,e=.1){return new E4(t,e)}};const pd=Cnt;const Ent=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function B4(){return new Promise(n=>Ent(()=>n()))}function jA(n,t){const e=n[0].length;n.forEach((r,i)=>{H(r.length===e,()=>`Error in concat${e}D: rank of tensors[${i}] must be the same as the rank of the rest (${e})`)}),H(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const s=n[0];n.forEach((r,i)=>{for(let o=0;o<e;o++)H(o===t||r[o]===s[o],()=>`Error in concat${e}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function sl(n,t){const e=n[0].slice();for(let s=1;s<n.length;s++)e[t]+=n[s][t];return e}var Ho;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(Ho||(Ho={}));function P4(n,t,e){let s=new Array;if(e==null&&t==null)return s;if(t==null)for(;s.length<n+e.length;)s.push(-1);else s=t.slice();if(e==null)return s;if(n+e.length!==s.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${s.length}`);for(let r=1;r<e.length;++r){const i=e[r],o=s[s.length-e.length+r],a=s[o];if(i>=0)if(a>=0){if(a!==i)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+n}] = ${i} but shape[${r+n}] = ${a}`)}else s[o]=i}return s}function V4(n){const t={FIRST_DIM_SIZE:Ho.FIRST_DIM_SIZE,VALUE_ROWIDS:Ho.VALUE_ROWIDS,ROW_LENGTHS:Ho.ROW_LENGTHS,ROW_SPLITS:Ho.ROW_SPLITS,ROW_LIMITS:Ho.ROW_LIMITS,ROW_STARTS:Ho.ROW_STARTS},e=[];for(const s of n)if(s in t)e.push(t[s]);else break;return e}function U4(n){return n.length===0?0:n[0]===Ho.FIRST_DIM_SIZE?n.length-1:n.length}function G4(n,t){if(n==null||t==null)return;const e=n.length,s=t.length;if(e>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(e,s-1);++r){const i=n[r],o=t[r+1];if(i>=0&&o>=0&&i!==1&&i!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-n.length}] = ${i} but ragged tensor input.flatValues.shape[${r-n.length}] = ${o}`)}}const qA=30;function Iv(n){return n<=qA?n:OE(n,Math.floor(Math.sqrt(n)))}function HA(n,t,e){const s=e*(typeof n=="number"?n:n[0]),r=t*(typeof n=="number"?n:n[1]);return[s,r]}function nb(n,t,e,s=!0){let r=[];if(s)r=r.concat(t.slice(0)),r.push(n[0]/e),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const i=t.length;for(let o=0;o<i;++o)r=r.concat([n[o+1]/t[o],t[o]]);r=r.concat(n.slice(i+1))}return r}function sb(n,t,e=!0){const s=[];if(e){s.push(t);for(let r=t+1;r<n;++r)r<=2*t?(s.push(r),s.push(r-(t+1))):s.push(r)}else{const r=[],i=[];for(let o=1;o<n;++o)o>=t*2+1||o%2===1?i.push(o):r.push(o);s.push(...r),s.push(0),s.push(...i)}return s}function rb(n,t,e,s=!0){const r=[];s?r.push(n[0]/e):r.push(n[0]*e);for(let i=1;i<n.length;++i)i<=t.length?s?r.push(t[i-1]*n[i]):r.push(n[i]/t[i-1]):r.push(n[i]);return r}function KA(n,t){const e=[0];for(let s=0;s<t;++s)e.push(n[s][0]);return e}function XA(n,t,e){const s=n.slice(0,1);for(let r=0;r<e;++r)s.push(n[r+1]-t[r][0]-t[r][1]);return s}const Tv=1.7580993408473768,Cv=1.0507009873554805;const YA=.3275911,QA=.254829592,ZA=-.284496736,JA=1.421413741,tk=-1.453152027,ek=1.061405429;function Zl(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(n.length*2);for(let s=0;s<e.length;s+=2)e[s]=n[s/2],e[s+1]=t[s/2];return e}function W4(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)t[s/2]=n[s],e[s/2]=n[s+1];return{real:t,imag:e}}function j4(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let r=0;r<n.length;r+=4)e[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:e,imag:s}}function q4(n){const t=Math.floor(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let r=2;r<n.length;r+=4)e[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:e,imag:s}}function nk(n,t){const e=n[t*2],s=n[t*2+1];return{real:e,imag:s}}function H4(n,t,e,s){n[s*2]=t,n[s*2+1]=e}function K4(n,t){const e=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const i=(t?2:-2)*Math.PI*(r/n);e[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:e,imag:s}}function X4(n,t,e){const s=(e?2:-2)*Math.PI*(n/t),r=Math.cos(s),i=Math.sin(s);return{real:r,imag:i}}const WT="->",$nt=/->/g,YF=",",QF="...";function sk(n,t){n=n.replace(/\s/g,"");const e=(n.length-n.replace($nt,"").length)/WT.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${WT}").`);const[s,r]=n.split(WT);H(s.indexOf(QF)===-1,()=>`The ellipsis notation ("${QF}") is not supported yet.`);const i=s.split(YF),o=i.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let m=0;m<r.length;++m){const y=r[m];if(!i.some(b=>b.indexOf(y)!==-1))throw new Error(`Output subscripts contain the label ${y} not present in the input subscripts.`);a.indexOf(y)===-1&&a.push(y)}for(let m=0;m<s.length;++m){const y=s[m];a.indexOf(y)===-1&&y!==YF&&a.push(y)}const l=new Array(i.length);for(let m=0;m<o;++m){if(new Set(i[m].split("")).size!==i[m].length)throw new Error(`Found duplicate axes in input component ${i[m]}. Support for duplicate axes in input is not implemented yet.`);l[m]=[];for(let y=0;y<i[m].length;++y)l[m].push(a.indexOf(i[m][y]))}const c=a.length,f=r.length,d=[];for(let m=f;m<c;++m)d.push(m);return{allDims:a,summedDims:d,idDims:l}}function rk(n,t){let e=new Array(n);e.fill(-1);for(let r=0;r<t.length;++r)e[t[r]]=r;const s=[];for(let r=0;r<n;++r)e[r]===-1&&s.push(r);return e=e.filter(r=>r!==-1),{permutationIndices:e,expandDims:s}}function ik(n,t,e){const s=new Array(n);for(let r=0;r<e.length;++r){const i=e[r].shape;for(let o=0;o<t[r].length;++o)s[t[r][o]]===void 0?s[t[r][o]]=i[o]:H(s[t[r][o]]===i[o],()=>`Expected dimension ${s[t[r][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function ok(n,t){const e=n,s=[];let r=0;n.length===0&&e.push(-1),r=n.length+1;for(let o=0;o<r;++o)s.push([]);const i=[];for(let o=0;o<e.length;++o){const a=e[o],l=Ant(t,a);for(const c of l)i.indexOf(c)===-1&&(s[o].push(c),i.push(c))}return{path:e,steps:s}}function ak(n){return n.every((t,e)=>t===e)}function Ant(n,t){const e=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(t)!==-1||t===-1)&&e.push(s);return e}function lk(n,t,e=0){let s=[];if(typeof t=="number")H(n.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),s=new Array(t).fill(n.shape[e]/t);else{const r=t.reduce((o,a)=>(a===-1&&(o+=1),o),0);H(r<=1,()=>"There should be only one negative value in split array.");const i=t.indexOf(-1);if(i!==-1){const o=t.reduce((a,l)=>l>0?a+l:a);t[i]=n.shape[e]-o}H(n.shape[e]===t.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),s=t}return s}function Y4(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function Q4(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function Z4(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function J4(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function tV(n,t){return`size ${n} must be non-negative, not ${t}`}function eV(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function nV(n,t){const e=Lt(n),s=Lt(t);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${t}`}function sV(n,t){const e=Lt(n),s=Lt(t);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${t}`}function ZE(){return"segment ids must be >= 0"}function rV(){return"segment ids are not increasing"}function iV(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function oV(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function aV(n,t){let e=!1,s;for(n<=qA?(s=n,e=!0):s=OE(n,Math.floor(Math.sqrt(n)));!e;)s>t||s===n?e=!0:s=OE(n,s+1);return s}function lV(n,t,e){const s=[],r=n.length;for(let i=0;i<r;i++)i!==t?s.push(n[i]):s.push(e);return s}function uk(n,t,e,s){const r=t.shape.length,i=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(e<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${e}).`);for(let d=0;d<s;++d)if(n.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const o=n.shape[e],a=[];let l=1,c=1,f=1;for(let d=0;d<s;++d)a.push(n.shape[d]),l*=n.shape[d];for(let d=s;d<e;d++)a.push(n.shape[d]),c*=n.shape[d];for(let d=s;d<r;d++)a.push(t.shape[d]);for(let d=e+1;d<i;d++)a.push(n.shape[d]),f*=n.shape[d];return{batchSize:l,sliceSize:f,outerSize:c,dimSize:o,outputShape:a}}const knt=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:uk,computeOutShape:lV,segOpComputeOptimalWindowSize:aV},Symbol.toStringTag,{value:"Module"}));function Jl(n){try{return n.map(t=>lc(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function uV(n){return n.map(t=>Ju(t))}const _nt=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:QA,ERF_A2:ZA,ERF_A3:JA,ERF_A4:tk,ERF_A5:ek,ERF_P:YA,PARALLELIZE_THRESHOLD:qA,get RowPartitionType(){return Ho},SELU_SCALE:Cv,SELU_SCALEALPHA:Tv,applyActivation:RA,assertAndGetBroadcastShape:Ne,assertAxesAreInnerMostDims:Sr,assertParamsConsistent:jA,assignToTypedArray:H4,axesAreInnerMostDims:gA,calculateShapes:hf,checkEinsumDimSizes:ik,checkPadOnDimRoundingMode:fi,combineLocations:e4,combineRaggedTensorToTensorShapes:P4,complexWithEvenIndex:j4,complexWithOddIndex:q4,computeConv2DInfo:vr,computeConv3DInfo:_c,computeDefaultPad:cA,computeDilation2DInfo:Qy,computeOptimalWindowSize:Iv,computeOutAndReduceShapes:ur,computeOutShape:sl,computePool2DInfo:$o,computePool3DInfo:au,convertConv2DDataFormat:lu,decodeEinsumEquation:sk,eitherStridesOrDilationsAreOne:Or,expandShapeToKeepDim:ks,exponent:X4,exponents:K4,fromStringArrayToUint8:uV,fromUint8ToStringArray:Jl,getAxesPermutation:hs,getBroadcastDims:qd,getComplexWithIndex:nk,getEinsumComputePath:ok,getEinsumPermutation:rk,getFusedBiasGradient:NA,getFusedDyActivation:_A,getImageCenter:HA,getInnerMostAxes:xs,getPermuted:sb,getRaggedRank:U4,getReductionAxes:Zs,getReshaped:nb,getReshapedPermuted:rb,getRowPartitionTypesHelper:V4,getSliceBeginCoords:KA,getSliceSize:XA,getSparseFillEmptyRowsIndicesDenseShapeMismatch:Y4,getSparseFillEmptyRowsNegativeIndexErrorMessage:Q4,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:Z4,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:eV,getSparseReshapeInputOutputMismatchErrorMessage:sV,getSparseReshapeInputOutputMultipleErrorMessage:nV,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:J4,getSparseReshapeNegativeOutputDimErrorMessage:tV,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:oV,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:ZE,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:rV,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:iV,getUndoAxesPermutation:Nc,isIdentityPermutation:ak,log:tY,mergeRealAndImagArrays:Zl,prepareAndValidate:BA,prepareSplitSize:lk,segment_util:knt,shouldFuse:DA,slice_util:Tnt,splitRealAndImagArrays:W4,stridesOrDilationsArePositive:Uh,tupleValuesAreOne:Vh,upcastType:Ei,validateDefaultValueShape:G4,validateInput:iet,validateUpdateShape:x4,warn:Ui},Symbol.toStringTag,{value:"Module"}));xnt();const cV={kernelName:fw,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ct(n,eb(ne(e,"float32"),-1))}}};const Nnt={kernelName:ey,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Kn(ne(e,"float32")),r=Dr(Se(dn(1),s));return ys(be(n,r))}}}};const Rnt={kernelName:ny,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Dr(Se(Kn(ne(e,"float32")),1));return be(n,s)}}}};const Dnt={kernelName:bp,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Ne(e.shape,s.shape);return{a:()=>{let a=n;const l=Zs(e.shape,r);return l.length>0&&(a=me(a,l)),gt(a,e.shape)},b:()=>{let a=n;const l=Zs(s.shape,r);return l.length>0&&(a=me(a,l)),gt(a,s.shape)}}}};const Ont={kernelName:x2,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((s,r)=>{e[r]=()=>n.clone()}),e}};const Fnt={kernelName:dw,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>sn(e)}}};const Mnt={kernelName:pw,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>sn(e)}}};const Lnt={kernelName:sy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>be(n,Dr(Se(dn(1),Kn(ne(e,"float32")))))}}};const znt={kernelName:ry,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Dr(Yt(dn(1),Kn(ne(e,"float32"))));return be(n,s)}}}};const Bnt={kernelName:ay,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Ne(e.shape,s.shape);return{a:()=>{const a=Yt(Kn(e),Kn(s));let l=ct(n,be(s,a));const c=Zs(e.shape,r);return c.length>0&&(l=me(l,c)),gt(l,e.shape)},b:()=>{const a=Yt(Kn(e),Kn(s));let l=ys(ct(n,be(e,a)));const c=Zs(s.shape,r);return c.length>0&&(l=me(l,c)),gt(l,s.shape)}}}};const Pnt={kernelName:iy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>be(n,Yt(Kn(ne(e,"float32")),1))}}};const Vnt={kernelName:oy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>be(n,Se(dn(1),Kn(ne(e,"float32"))))}}};function Unt(n,t,e,s,r,i){const o=rt(n,"dy","avgPool3dGrad"),a=rt(t,"input","avgPool3dGrad");let l=o,c=a,f=!1;a.rank===4&&(f=!0,l=gt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=gt(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),H(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),H(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),fi("avgPool3dGrad",r,i);const d={dy:l,input:c},m={filterSize:e,strides:s,pad:r,dimRoundingMode:i},y=ft.runKernel(I2,d,m);return f?gt(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const Gnt=yt({avgPool3dGrad_:Unt});const Wnt={kernelName:gw,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:a}=e;return{x:()=>Gnt(n,s,r,i,o,a)}}};function jnt(n,t,e,s,r){const i=rt(n,"dy","avgPoolGrad"),o=rt(t,"input","avgPoolGrad");H(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,c=!1;o.rank===3&&(c=!0,a=gt(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=gt(i,[1,i.shape[0],i.shape[1],i.shape[2]])),H(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),H(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const f={dy:l,input:a},d={filterSize:e,strides:s,pad:r},m=ft.runKernel(S2,f,d);return c?gt(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const qnt=yt({avgPoolGrad_:jnt});const Hnt={kernelName:mw,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:r,strides:i,pad:o}=e;return{x:()=>qnt(n,s,r,i,o)}}};const Knt={kernelName:yw,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[s,r]=t,{transposeA:i,transposeB:o}=e;return!i&&!o?{a:()=>fn(n,r,!1,!0),b:()=>fn(s,n,!0,!1)}:!i&&o?{a:()=>fn(n,r,!1,!1),b:()=>fn(n,s,!0,!1)}:i&&!o?{a:()=>fn(r,n,!1,!0),b:()=>fn(s,n,!1,!1)}:{a:()=>fn(r,n,!0,!0),b:()=>fn(n,s,!0,!0)}}};const Xnt={kernelName:bw,gradFunc:(n,t,e)=>{const{blockShape:s,crops:r}=e;return{x:()=>TA(n,s,r)}}};const Ynt={kernelName:YX,gradFunc:(n,t,e)=>{const s=e,r=s.inputShape,i=s.shape,o=Array.from(i);for(let l=r.length-1;l>=0;l--)if(r[l]===i[l])o[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>me(n,a,!0)}}};const Qnt={kernelName:ly,gradFunc:n=>({x:()=>n.clone()})};const Znt={kernelName:uy,gradFunc:n=>({x:()=>sn(n)})};const Jnt={kernelName:cy,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{clipValueMin:r,clipValueMax:i}=e;return{x:()=>Hr(Yl(lf(s,r),vp(s,i)),n,sn(n))}}};const tst={kernelName:xw,inputsToSave:["x"],gradFunc:cV.gradFunc};const est={kernelName:ww,saveAllInputs:!0,gradFunc:(n,t,e)=>{const s=t.map(l=>l.shape),{axis:r}=e,i=Ve(r,t[0].shape)[0],o=s.map(l=>l[i]);return ji(n,o,i).map(l=>()=>l)}};const nst={kernelName:vw,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,{dilations:i,strides:o,pad:a,dataFormat:l}=e;return H(Vh(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>dA(s.shape,n,r,o,a,l),filter:()=>kA(s,n,r.shape,o,a,l)}}};const sst={kernelName:Sw,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>Gh(n,r,i,o,a,1,l),filter:()=>kA(n,s,r.shape,i,o,a,l)}}};function rst(n,t,e,s,r){let i=n;n.rank===4&&(i=gt(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=t;o.rank===4&&(o=gt(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),H(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),H(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),H(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),H(i.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${e[3]}.`),H(o.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${e[4]}).`);const a={x:i,dy:o},l={strides:s,pad:r,filterShape:e};return ft.runKernel(A2,a,l)}const ist=yt({conv3DBackpropFilter_:rst});const ost={kernelName:Iw,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:r,pad:i}=e;H(Vh(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,a]=t;return{x:()=>QP(o.shape,n,a,r,i),filter:()=>ist(o,n,a.shape,r,i)}}};const ast={kernelName:hy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ct(ys(m4(ne(e,"float32"))),n)}}};const lst={kernelName:fy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ct(g4(ne(e,"float32")),n)}}};const ust={kernelName:Tw,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r,exclusive:i,reverse:o}=e;return{x:()=>{const a=hs([r],s.rank);let l=JP(n,r,i,!o);return a!=null&&(l=en(l,a)),l}}}};const cst={kernelName:Cw,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:o}=e,a=s??[1,1];H(Vh(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=t;return H(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),H(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),H(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),H(Or(r,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${a}'.`),fi("depthwiseConv2d",i,o),{x:()=>Eet(l.shape,n,c,r,i,a,o),filter:()=>Tet(l,n,c.shape,r,i,a,o)}}};const hst={kernelName:Ew,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,i={x:s,filter:r,dy:n},o={x:s,filter:r,dy:n};return{x:()=>ft.runKernel(FE,i,e),filter:()=>ft.runKernel(ME,o,e)}}};const fst={kernelName:py,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,s={dy:n,y:e};return{x:()=>ft.runKernel(L2,s)}}};const dst={kernelName:my,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=ct(fl(ys(Kn(e))),2/Math.sqrt(Math.PI));return{x:()=>ct(n,s)}}};const pst={kernelName:gy,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ct(n,e)}}};const mst={kernelName:Aw,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>gt(n,e.shape)}}};const gst={kernelName:yy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ct(n,fl(e))}}};const yst={kernelName:by,gradFunc:n=>({x:()=>sn(n)})};const bst={kernelName:xy,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Ne(e.shape,s.shape);return{a:()=>{const a=be(n,ne(s,"float32")),l=Zs(e.shape,r);return l.length>0?gt(me(a,l),e.shape):a},b:()=>{let a=ct(n,ne(e,"float32"));const l=Zs(s.shape,r);l.length>0&&(a=gt(me(a,l),s.shape));const c=Kn(s);return ys(be(a,ne(c,"float32")))}}}};const xst={kernelName:kw,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:s}=e,[r,i,o,a]=t,l=a??dn(1),c=Zs(i.shape,r.shape),f=[];if(i.rank===1){for(let E=0;E<r.shape.length-1;++E)f.push(r.shape[E]);f.push(1)}const d=Se(r,i),m=ct(n,l),y=f4(Yt(o,dn(s))),b=ct(ct(ct(y,y),y),dn(-.5));return{x:()=>i.rank===1?gt(ct(ct(n,Qo(gt(y,[1,1,1,i.shape[0]]),f)),l),r.shape):gt(ct(ct(n,y),l),r.shape),mean:()=>{let E=ct(ct(y,dn(-1)),m);return i.rank===1&&(E=me(E,c)),gt(E,i.shape)},variance:()=>{let E=ct(ct(b,d),m);return i.rank===1&&(E=me(E,c)),gt(E,i.shape)},scale:()=>{const E=ct(d,y);let R=ct(n,E);return i.rank===1&&(R=me(R,c)),gt(R,i.shape)},offset:()=>{let E=n;return i.rank===1&&(E=me(E,c)),gt(E,i.shape)}}}};const wst={kernelName:_w,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[s,r]=t,{axis:i,batchDims:o}=e,a=Ve(i,s.shape)[0],l=(c,f,d)=>()=>{const m=c.shape,y=f.size,b=m.slice(0,a),w=b.length,x=m.slice(i,m.length).slice(1),S=x.length,T=ZF(0,w),$=ZF(w+1,w+1+S),E=JF([b,[y],x]),R=gt(d,E),B=gt(f,[y]),N=JF([[w],T,$]),k=en(R,N);let _=v4(k,B,c.shape[a]);const F=Nc(N);return _=en(_,F),_};if(o===1){const c=s.shape[0],f=s.split(c,0);return{x:()=>Ql(f.map((y,b)=>l(y,r.slice(b,1),n.slice(b,1))())).reshape(s.shape),indices:()=>r}}else return{x:l(s,r,n),indices:()=>r}}};function ZF(n,t){const e=[];for(let s=n;s<t;++s)e.push(s);return e}function JF(n){const t=[];for(let e=0;e<n.length;++e)for(let s=0;s<n[e].length;++s)t.push(n[e][s]);return t}const vst={kernelName:wy,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>sn(e),b:()=>sn(s)}}};const Sst={kernelName:vy,gradFunc:n=>({x:()=>ne(n,"float32")})};const Ist={kernelName:Sy,gradFunc:n=>({x:()=>sn(n)})};const Tst={kernelName:Iy,gradFunc:n=>({x:()=>sn(n)})};const Cst={kernelName:Ty,gradFunc:n=>({x:()=>sn(n)})};const Est={kernelName:Rw,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{alpha:r}=e,i=Ki(s,0);return{x:()=>Hr(i,n,ct(n,r))}}};const $st={kernelName:Ey,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>be(n,Yt(e,1))}}};const Ast={kernelName:Cy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>be(n,ne(e,"float32"))}}};const kst={kernelName:ZX,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e;return{logits:()=>{const o=fl(s);return Se(n,ct(me(n,r,!0),o))}}}};function _st(n,t,e,s=5,r=1,i=1,o=.5){const a={x:n,y:t,dy:e},l={depthRadius:s,bias:r,alpha:i,beta:o};return ft.runKernel(G2,a,l)}const Nst=yt({localResponseNormalizationBackprop_:_st});const Rst={kernelName:zw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{depthRadius:i,bias:o,alpha:a,beta:l}=e;return{x:()=>Nst(s,r,n,i,o,a,l)}}};function hV(n,t,e,s){return t.rank<e.rank&&(t=gt(t,ks(t.shape,s))),n.rank<e.rank&&(n=gt(n,ks(n.shape,s))),{x:()=>ct(n,ne(hl(e,t),n.dtype))}}const tM={kernelName:Bw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{reductionIndices:r}=s,i=t[0],o=t[1],a=Ve(r,i.shape),l=hV(n,o,i,a);return{x:()=>l.x()}}};const Dst={kernelName:$y,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>ct(n,ne(lf(e,s),"float32")),b:()=>ct(n,ne(ax(e,s),"float32"))}}};function Ost(n,t,e,s,r,i,o){const a=rt(n,"dy","maxPool3dGrad"),l=rt(t,"input","maxPool3dGrad"),c=rt(e,"output","maxPool3dGrad");let f=a,d=l,m=c,y=!1;l.rank===4&&(y=!0,f=gt(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=gt(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),m=gt(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),H(f.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${f.rank}.`),H(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),H(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),fi("maxPool3dGrad",i,o);const b={dy:f,input:d,output:m},w={filterSize:s,strides:r,pad:i,dimRoundingMode:o},x=ft.runKernel(j2,b,w);return y?gt(x,[x.shape[1],x.shape[2],x.shape[3],x.shape[4]]):x}const Fst=yt({maxPool3dGrad_:Ost});const Mst={kernelName:Vw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=e;return{x:()=>Fst(n,s,r,i,o,a,l)}}};function Lst(n,t,e,s,r,i,o){const a=rt(n,"dy","maxPoolGrad"),l=rt(t,"input","maxPoolGrad"),c=rt(e,"output","maxPoolGrad");H(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),H(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),H(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),fi("maxPoolGrad",i,o);const f={dy:a,input:l,output:c},d={filterSize:s,strides:r,pad:i,dimRoundingMode:o};return ft.runKernel(W2,f,d)}const zst=yt({maxPoolGrad_:Lst});const Bst={kernelName:Pw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{filterSize:i,strides:o,pad:a}=e;return{x:()=>zst(n,s,r,i,o,a)}}};const Pst={kernelName:Uw,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e,i=Ve(r,s.shape),a=ur(s.shape,i)[1],l=Lt(a);return{x:()=>{const f=s.shape.slice();i.forEach(y=>{f[y]=1});const d=gt(n,f);return be(ct(d,Dc(s.shape,"float32")),l)}}}};const Vst={kernelName:Gw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{axis:r}=s,[i,o]=t,a=Ve(r,i.shape),l=hV(n,o,i,a);return{x:()=>l.x()}}};const Ust={kernelName:Ay,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>ct(n,ne(vp(e,s),"float32")),b:()=>ct(n,ne(Ki(e,s),"float32"))}}};const Gst={kernelName:Ww,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:r}=e,i=r.map(o=>o[0]);return{x:()=>Pn(n,i,s.shape)}}};const Wst={kernelName:ky,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Ne(e.shape,s.shape);return{a:()=>{const a=Zs(e.shape,r);return a.length>0?gt(me(n,a),e.shape):n},b:()=>{const a=ct(n,ys(vv(be(e,s)))),l=Zs(s.shape,r);return l.length>0?gt(me(a,l),s.shape):a}}}};const jst={kernelName:_y,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Ne(e.shape,s.shape);return{a:()=>{const a=ct(n,ne(s,"float32")),l=Zs(e.shape,r);return l.length>0?gt(me(a,l),e.shape):a},b:()=>{const a=ct(n,ne(e,"float32")),l=Zs(s.shape,r);return l.length>0?gt(me(a,l),s.shape):a}}}};const qst={kernelName:jw,gradFunc:n=>({x:()=>ys(n)})};const Hst={kernelName:Kw,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>sr(e.shape,"float32")}}};const Kst={kernelName:Hw,gradFunc:n=>({x:()=>sn(n)})};const Xst={kernelName:Xw,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:s}=e;return qh(n,s).map(i=>()=>i)}};const eM={kernelName:Yw,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:r}=e,i=r.map(o=>o[0]);return{x:()=>Pn(n,i,s.shape)}}};const Yst={kernelName:Ny,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,s,r]=t,i=e,o=s,a=Ne(i.shape,o.shape);return{a:()=>{const f=ne(o,"float32");let d=ct(n,ct(f,Wh(i,Se(f,dn(1)))));const m=Zs(i.shape,a);return m.length>0&&(d=me(d,m)),gt(d,i.shape)},b:()=>{const f=Ki(i,0),d=Hr(f,dl(i),sn(i));let m=ct(n,ct(r,d));const y=Zs(o.shape,a);return y.length>0&&(m=me(m,y)),gt(m,o.shape)}}}};const Qst={kernelName:Qw,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,s]=t,r=Ki(e,0);return{x:()=>Hr(r,n,ct(n,s)),alpha:()=>{let i=Hr(r,sn(n),ct(n,e));const o=Zs(s.shape,n.shape);return o.length>0&&(i=me(i,o)),gt(i,s.shape)}}}};function Zst(n,t,e){const s=n.shape.slice();s[e]=1;const r=gt(t,s),i=XE(n,e,!0,!1),o=XE(n,e,!0,!0),a=ct(i,o);return ct(r,a)}function Jst(n,t,e){const s=n.shape.length,r=s-e.length,i=hs(e,s);let o=n;i!=null&&(o=en(n,i));const a=o.shape.slice(),c=a.splice(s-e.length,e.length).reduce((m,y)=>m*y,1);a.push(c);const f=o.reshape(a);let d=Zst(f,t,r);if(d=d.reshape(o.shape),i!=null){const m=Nc(i);d=en(d,m)}return d}const trt={kernelName:Zw,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e;let i=[];return r==null?i=s.shape.map((o,a)=>a):typeof r=="number"?i=[r]:i=r,{x:()=>Jst(s,n,i)}}};const ert={kernelName:dy,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Ne(e.shape,s.shape);return{a:()=>{const a=be(n,ne(s,"float32")),l=Zs(e.shape,r);return l.length>0?gt(me(a,l),e.shape):a},b:()=>{let a=ct(n,ne(e,"float32"));const l=Zs(s.shape,r);l.length>0&&(a=gt(me(a,l),s.shape));const c=Kn(s);return ys(be(a,ne(c,"float32")))}}}};const nrt={kernelName:Ry,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>be(n,ys(Kn(e)))}}};const srt={kernelName:Oy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=ct(vp(e,6),eb(e));return{x:()=>ct(n,ne(s,"float32"))}}};const rrt={kernelName:Dy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ct(n,ne(eb(e),"float32"))}}};const irt={kernelName:Jw,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>gt(n,e.shape)}}};const ort={kernelName:ev,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,r={dy:n,images:s};return{images:()=>ft.runKernel(Z2,r,e)}}};const art={kernelName:tv,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,r={dy:n,images:s};return{images:()=>ft.runKernel(Q2,r,e)}}};const lrt={kernelName:nv,gradFunc:(n,t,e)=>{const{dims:s}=e,r=Ve(s,n.shape);return{x:()=>jh(n,r)}}};const urt={kernelName:Fy,gradFunc:n=>({x:()=>sn(n)})};const crt={kernelName:My,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ys(be(n,ct(Wh(e,1.5),2)))}}};const hrt={kernelName:sv,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>ne(sn(e),"float32"),t:()=>ct(n,ne(e,n.dtype)),e:()=>ct(n,ne(wA(e),n.dtype))}}};const frt={kernelName:Ly,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Ki(e,dn(0)),r=dn(Tv),i=dn(Cv),o=ct(n,i),a=ct(ct(n,r),fl(ne(e,"float32")));return Hr(s,o,a)}}}};const drt={kernelName:Vy,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ct(n,ct(e,Se(dn(1),e)))}}};const prt={kernelName:Py,gradFunc:n=>({x:()=>sn(n)})};const mrt={kernelName:zy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ct(pA(ne(e,"float32")),n)}}};const grt={kernelName:By,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ct(ZP(ne(e,"float32")),n)}}};const yrt={kernelName:rv,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{begin:r,size:i}=e,o=s.shape,[a,l]=Sv(s,r,i),c=[];for(let f=0;f<n.rank;f++)c.push([a[f],o[f]-a[f]-l[f]]);return{x:()=>IA(n,c)}}};const brt={kernelName:lv,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{dim:r}=e,i=!0,o=ct(n,s);return{logits:()=>Se(o,ct(me(o,[r],i),s))}}};const xrt={kernelName:Uy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ct(n,wp(e))}}};const nM={kernelName:ov,gradFunc:(n,t,e)=>{const{blockShape:s,paddings:r}=e;return{x:()=>fA(n,s,r)}}};const sM={kernelName:av,gradFunc:(n,t,e)=>{const{axis:s}=e;return{x:()=>ii(n,s)}}};const wrt={kernelName:Gy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>be(n,ct(Dr(ne(e,"float32")),2))}}};const vrt={kernelName:J2,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ct(n,ct(ne(e,"float32"),2))}}};const Srt={kernelName:Wy,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=dn(2);return{a:()=>ct(n,ct(r,Se(e,s))),b:()=>ct(n,ct(r,Se(s,e)))}}};const Irt={kernelName:Xy,gradFunc:n=>({x:()=>sn(n)})};const Trt={kernelName:jy,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Ne(e.shape,s.shape);return{a:()=>{let a=n;const l=Zs(e.shape,r);return l.length>0&&(a=me(a,l)),gt(a,e.shape)},b:()=>{let a=n;const l=Zs(s.shape,r);return l.length>0&&(a=me(a,l)),gt(ys(a),s.shape)}}}};const Crt={kernelName:iv,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,r=s.shape.slice(),{axis:i}=e;Ve(i,s.shape).forEach(c=>{r[c]=1});const a=gt(n,r),l=ct(a,Dc(s.shape,"float32"));return{x:()=>l}}};const Ert={kernelName:qy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>be(n,Kn(pA(e)))}}};const $rt={kernelName:Hy,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ct(Se(dn(1),Kn(e)),n)}}};const Art={kernelName:Ky,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{reps:r}=e;return{x:()=>{let o=sn(s);if(s.rank===1)for(let a=0;a<r[0];++a)o=Yt(o,Pn(n,[a*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)o=Yt(o,Pn(n,[a*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)o=Yt(o,Pn(n,[a*s.shape[0],l*s.shape[1],c*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)for(let f=0;f<r[3];++f)o=Yt(o,Pn(n,[a*s.shape[0],l*s.shape[1],c*s.shape[2],f*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return o}}}};const krt={kernelName:Od,gradFunc:(n,t,e)=>{const s=e,{perm:r}=s,i=Nc(r);return{x:()=>en(n,i)}}};const _rt={kernelName:uv,gradFunc:(n,t,e)=>{const s=e,{axis:r}=s;return{value:()=>Ql(n,r)}}};const Nrt={kernelName:cv,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Rrt(n,e)}}};function Rrt(n,t){const e=Rc(t,sn(t)),s=yA(n,e);let r=lf(t,dn(0,"int32"));const i=s.rank-r.rank;for(let a=0;a<i;++a)r=ni(r,a+1);r=Yl(r,Dc(s.shape,"bool"));const o=sn(s);return Hr(r,s,o)}const Drt={kernelName:hv,gradFunc:n=>({x:()=>sn(n)})};const Ort=[cV,Nnt,Rnt,Dnt,Ont,Fnt,Mnt,Lnt,znt,Bnt,Pnt,Vnt,Wnt,Hnt,Knt,Xnt,Ynt,Qnt,Znt,Jnt,tst,est,sst,nst,ost,ast,lst,ust,cst,hst,ert,fst,dst,pst,mst,gst,bst,yst,xst,wst,vst,Sst,Ist,Tst,Cst,Est,$st,Ast,kst,Rst,tM,tM,Dst,Mst,Bst,Pst,Vst,Ust,Gst,Wst,jst,qst,Hst,Kst,Xst,eM,eM,Yst,Qst,trt,nrt,srt,rrt,irt,ort,art,lrt,urt,crt,hrt,frt,drt,prt,mrt,grt,yrt,brt,xrt,nM,nM,sM,sM,wrt,Srt,vrt,Irt,Trt,Crt,Ert,$rt,Art,krt,_rt,Nrt,Drt];for(const n of Ort)eY(n);Dt().prototype.abs=function(){return this.throwIfDisposed(),Ur(this)};Dt().prototype.acos=function(){return this.throwIfDisposed(),fQ(this)};Dt().prototype.acosh=function(){return this.throwIfDisposed(),pQ(this)};Dt().prototype.add=function(n){return this.throwIfDisposed(),Yt(this,n)};Dt().prototype.all=function(n,t){return this.throwIfDisposed(),KP(this,n,t)};Dt().prototype.any=function(n,t){return this.throwIfDisposed(),HE(this,n,t)};Dt().prototype.argMax=function(n){return this.throwIfDisposed(),Cg(this,n)};Dt().prototype.argMin=function(n){return this.throwIfDisposed(),xQ(this,n)};Dt().prototype.asScalar=function(){return this.throwIfDisposed(),H(this.size===1,()=>"The array must have only 1 element."),gt(this,[])};Dt().prototype.asType=function(n){return this.throwIfDisposed(),ne(this,n)};Dt().prototype.as1D=function(){return this.throwIfDisposed(),gt(this,[this.size])};Dt().prototype.as2D=function(n,t){return this.throwIfDisposed(),gt(this,[n,t])};Dt().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),gt(this,[n,t,e])};Dt().prototype.as4D=function(n,t,e,s){return this.throwIfDisposed(),gt(this,[n,t,e,s])};Dt().prototype.as5D=function(n,t,e,s,r){return this.throwIfDisposed(),gt(this,[n,t,e,s,r])};Dt().prototype.asin=function(){return this.throwIfDisposed(),vQ(this)};Dt().prototype.asinh=function(){return this.throwIfDisposed(),IQ(this)};Dt().prototype.atan=function(){return this.throwIfDisposed(),CQ(this)};Dt().prototype.atan2=function(n){return this.throwIfDisposed(),$Q(this,n)};Dt().prototype.atanh=function(){return this.throwIfDisposed(),kQ(this)};Dt().prototype.avgPool=function(n,t,e,s){return this.throwIfDisposed(),hA(this,n,t,e,s)};Dt().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),fA(this,n,t)};Dt().prototype.batchNorm=function(n,t,e,s,r){return this.throwIfDisposed(),yv(this,n,t,e,s,r)};Dt().prototype.broadcastTo=function(n){return this.throwIfDisposed(),mg(this,n)};Dt().prototype.cast=function(n){return this.throwIfDisposed(),ne(this,n)};Dt().prototype.ceil=function(){return this.throwIfDisposed(),nZ(this)};Dt().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Hi(this,n,t)};Dt().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof Vs&&(n=[n]),ii([this,...n],t)};Dt().prototype.conv1d=function(n,t,e,s,r,i){return this.throwIfDisposed(),XP(this,n,t,e,s,r,i)};Dt().prototype.conv2dTranspose=function(n,t,e,s,r){return this.throwIfDisposed(),YP(this,n,t,e,s,r)};Dt().prototype.conv2d=function(n,t,e,s,r,i){return this.throwIfDisposed(),Gh(this,n,t,e,s,r,i)};Dt().prototype.cos=function(){return this.throwIfDisposed(),pA(this)};Dt().prototype.cosh=function(){return this.throwIfDisposed(),ZP(this)};Dt().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),XE(this,n,t,e)};Dt().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),JP(this,n,t,e)};Dt().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),$Z(this,n,t)};Dt().prototype.depthwiseConv2d=function(n,t,e,s,r,i){return this.throwIfDisposed(),mA(this,n,t,e,s,r,i)};Dt().prototype.dilation2d=function(n,t,e,s,r){return this.throwIfDisposed(),_Z(this,n,t,e,s,r)};Dt().prototype.divNoNan=function(n){return this.throwIfDisposed(),FZ(this,n)};Dt().prototype.div=function(n){return this.throwIfDisposed(),be(this,n)};Dt().prototype.dot=function(n){return this.throwIfDisposed(),LZ(this,n)};Dt().prototype.elu=function(){return this.throwIfDisposed(),xv(this)};Dt().prototype.equal=function(n){return this.throwIfDisposed(),hl(this,n)};Dt().prototype.erf=function(){return this.throwIfDisposed(),t4(this)};Dt().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),XZ(this,n,t)};Dt().prototype.exp=function(){return this.throwIfDisposed(),fl(this)};Dt().prototype.expandDims=function(n){return this.throwIfDisposed(),ni(this,n)};Dt().prototype.expm1=function(){return this.throwIfDisposed(),JZ(this)};Dt().prototype.fft=function(){return this.throwIfDisposed(),b4(this)};Dt().prototype.flatten=function(){return this.throwIfDisposed(),gt(this,[this.size])};Dt().prototype.floor=function(){return this.throwIfDisposed(),vv(this)};Dt().prototype.floorDiv=function(n){return this.throwIfDisposed(),HP(this,n)};Dt().prototype.gather=function(n,t,e){return this.throwIfDisposed(),yA(this,n,t,e)};Dt().prototype.greaterEqual=function(n){return this.throwIfDisposed(),lf(this,n)};Dt().prototype.greater=function(n){return this.throwIfDisposed(),Ki(this,n)};Dt().prototype.ifft=function(){return this.throwIfDisposed(),YE(this)};Dt().prototype.irfft=function(){return this.throwIfDisposed(),qtt(this)};Dt().prototype.isFinite=function(){return this.throwIfDisposed(),lJ(this)};Dt().prototype.isInf=function(){return this.throwIfDisposed(),cJ(this)};Dt().prototype.isNaN=function(){return this.throwIfDisposed(),fJ(this)};Dt().prototype.leakyRelu=function(n){return this.throwIfDisposed(),xA(this,n)};Dt().prototype.lessEqual=function(n){return this.throwIfDisposed(),vp(this,n)};Dt().prototype.less=function(n){return this.throwIfDisposed(),ax(this,n)};Dt().prototype.localResponseNormalization=function(n,t,e,s){return this.throwIfDisposed(),yJ(this,n,t,e,s)};Dt().prototype.logSigmoid=function(){return this.throwIfDisposed(),TJ(this)};Dt().prototype.logSoftmax=function(n){return this.throwIfDisposed(),i4(this,n)};Dt().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),o4(this,n,t)};Dt().prototype.log=function(){return this.throwIfDisposed(),dl(this)};Dt().prototype.log1p=function(){return this.throwIfDisposed(),r4(this)};Dt().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Yl(this,n)};Dt().prototype.logicalNot=function(){return this.throwIfDisposed(),wA(this)};Dt().prototype.logicalOr=function(n){return this.throwIfDisposed(),a4(this,n)};Dt().prototype.logicalXor=function(n){return this.throwIfDisposed(),RJ(this,n)};Dt().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),fn(this,n,t,e)};Dt().prototype.maxPool=function(n,t,e,s){return this.throwIfDisposed(),vA(this,n,t,e,s)};Dt().prototype.max=function(n,t){return this.throwIfDisposed(),ta(this,n,t)};Dt().prototype.maximum=function(n){return this.throwIfDisposed(),Rc(this,n)};Dt().prototype.mean=function(n,t){return this.throwIfDisposed(),$s(this,n,t)};Dt().prototype.min=function(n,t){return this.throwIfDisposed(),ox(this,n,t)};Dt().prototype.minimum=function(n){return this.throwIfDisposed(),Ag(this,n)};Dt().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),PJ(this,n,t)};Dt().prototype.mod=function(n){return this.throwIfDisposed(),UJ(this,n)};Dt().prototype.mul=function(n){return this.throwIfDisposed(),ct(this,n)};Dt().prototype.neg=function(){return this.throwIfDisposed(),ys(this)};Dt().prototype.norm=function(n,t,e){return this.throwIfDisposed(),wv(this,n,t,e)};Dt().prototype.notEqual=function(n){return this.throwIfDisposed(),lx(this,n)};Dt().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),l4(this,n,t,e)};Dt().prototype.onesLike=function(){return this.throwIfDisposed(),Io(this)};Dt().prototype.pad=function(n,t){return this.throwIfDisposed(),IA(this,n,t)};Dt().prototype.pool=function(n,t,e,s,r,i){return this.throwIfDisposed(),ZJ(this,n,t,e,s,r,i)};Dt().prototype.pow=function(n){return this.throwIfDisposed(),Wh(this,n)};Dt().prototype.prelu=function(n){return this.throwIfDisposed(),CA(this,n)};Dt().prototype.prod=function(n,t){return this.throwIfDisposed(),ett(this,n,t)};Dt().prototype.reciprocal=function(){return this.throwIfDisposed(),Ett(this)};Dt().prototype.relu=function(){return this.throwIfDisposed(),cf(this)};Dt().prototype.relu6=function(){return this.throwIfDisposed(),c4(this)};Dt().prototype.reshapeAs=function(n){return this.throwIfDisposed(),gt(this,n.shape)};Dt().prototype.reshape=function(n){return this.throwIfDisposed(),gt(this,n)};Dt().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),I4(this,n,t,e)};Dt().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),T4(this,n,t,e)};Dt().prototype.reverse=function(n){return this.throwIfDisposed(),jh(this,n)};Dt().prototype.rfft=function(){return this.throwIfDisposed(),Xtt(this)};Dt().prototype.round=function(){return this.throwIfDisposed(),h4(this)};Dt().prototype.rsqrt=function(){return this.throwIfDisposed(),f4(this)};Dt().prototype.selu=function(){return this.throwIfDisposed(),d4(this)};Dt().prototype.separableConv2d=function(n,t,e,s,r,i){return this.throwIfDisposed(),p4(this,n,t,e,s,r,i)};Dt().prototype.sigmoid=function(){return this.throwIfDisposed(),wp(this)};Dt().prototype.sign=function(){return this.throwIfDisposed(),Ftt(this)};Dt().prototype.sin=function(){return this.throwIfDisposed(),m4(this)};Dt().prototype.sinh=function(){return this.throwIfDisposed(),g4(this)};Dt().prototype.slice=function(n,t){return this.throwIfDisposed(),Pn(this,n,t)};Dt().prototype.softmax=function(n){return this.throwIfDisposed(),AA(this,n)};Dt().prototype.softplus=function(){return this.throwIfDisposed(),Zy(this)};Dt().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),TA(this,n,t)};Dt().prototype.split=function(n,t){return this.throwIfDisposed(),ji(this,n,t)};Dt().prototype.sqrt=function(){return this.throwIfDisposed(),Dr(this)};Dt().prototype.square=function(){return this.throwIfDisposed(),Kn(this)};Dt().prototype.squaredDifference=function(n){return this.throwIfDisposed(),Qtt(this,n)};Dt().prototype.squeeze=function(n){return this.throwIfDisposed(),tb(this,n)};Dt().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof Vs?[this,n]:[this,...n];return Ql(e,t)};Dt().prototype.step=function(n){return this.throwIfDisposed(),eb(this,n)};Dt().prototype.stridedSlice=function(n,t,e,s,r,i,o,a){return this.throwIfDisposed(),net(this,n,t,e,s,r,i,o,a)};Dt().prototype.sub=function(n){return this.throwIfDisposed(),Se(this,n)};Dt().prototype.sum=function(n,t){return this.throwIfDisposed(),me(this,n,t)};Dt().prototype.tan=function(){return this.throwIfDisposed(),ret(this)};Dt().prototype.tanh=function(){return this.throwIfDisposed(),gv(this)};Dt().prototype.tile=function(n){return this.throwIfDisposed(),Qo(this,n)};Dt().prototype.toBool=function(){return this.throwIfDisposed(),ne(this,"bool")};Dt().prototype.toFloat=function(){return this.throwIfDisposed(),ne(this,"float32")};Dt().prototype.toInt=function(){return this.throwIfDisposed(),ne(this,"int32")};Dt().prototype.topk=function(n,t){return this.throwIfDisposed(),aet(this,n,t)};Dt().prototype.transpose=function(n){return this.throwIfDisposed(),en(this,n)};Dt().prototype.unique=function(n){return this.throwIfDisposed(),het(this,n)};Dt().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),v4(this,n,t)};Dt().prototype.unstack=function(n){return this.throwIfDisposed(),qh(this,n)};Dt().prototype.where=function(n,t){return this.throwIfDisposed(),Hr(n,this,t)};Dt().prototype.zerosLike=function(){return this.throwIfDisposed(),sn(this)};let Wu=class fV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,fV.prototype)}},Qa=class dV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,dV.prototype)}},lt=class pV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,pV.prototype)}},Be=class mV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,mV.prototype)}},Frt=class gV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,gV.prototype)}};let yV=class{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=t}};function Hh(n,t){if(Array.isArray(n)){let e=[];for(let s=0;s<t;s++)e=e.concat(n);return e}else{const e=new Array(t);return e.fill(n),e}}function ja(n,t){if(!n)throw new Frt(t)}function rM(n,t){let e=0;for(const s of n)s===t&&e++;return e}function si(n){return n.length===1?n[0]:n}function vn(n){return Array.isArray(n)?n:[n]}function Pl(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function xh(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let uo={};function ck(n){if(n==null)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function JE(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(t=>JE(t));else{const t=Object.keys(n);for(const e of t){const s=n[e];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[e]=s.value:JE(s))}}}function ib(n,t={},e={},s="object",r=!1){if(typeof n=="string"){const i=n;let o;if(i in e)o=e[i];else if(i in uo)o=uo[i];else if(o=t[i],o==null)throw new lt(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const i=n;if(i.className==null||i.config==null)throw new lt(`${s}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const o=i.className;let a,l;if(o in e?[a,l]=e[o]:o in uo?[a,l]=uo.className:o in t&&([a,l]=t[o]),a==null)throw new lt(`Unknown ${s}: ${o}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const c={};for(const y of Object.keys(uo))c[y]=uo[y];for(const y of Object.keys(e))c[y]=e[y];const f=i.config;f.customObjects=c;const d=Object.assign({},uo);for(const y of Object.keys(e))uo[y]=e[y];JE(i.config);const m=l(a,i.config,e,r);return uo=Object.assign({},d),m}else{const c=Object.assign({},uo);for(const d of Object.keys(e))uo[d]=e[d];const f=new a(i.config);return uo=Object.assign({},c),f}}}function Mrt(n,t){return n<t?-1:n>t?1:0}function u1(n,t){return-1*Mrt(n,t)}function tc(n){if(n==null)return n;const t=[];for(const e of n)t.indexOf(e)===-1&&t.push(e);return t}function Lrt(n){if(n==null)throw new lt(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function ff(n,t,e){if(e!=null&&n.indexOf(e)<0)throw new lt(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function hk(n,t,e=0,s=1/0){return ja(e>=0),ja(s>=e),Array.isArray(n)&&n.length>=e&&n.length<=s&&n.every(r=>typeof r===t)}function rr(n,t){Array.isArray(n)?(H(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,s)=>rr(e,`element ${s+1} of ${t}`))):H(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${bV(n)}.`)}function bV(n){return n===null?"null":Array.isArray(n)?"["+n.map(t=>bV(t)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function zrt(n,t,e){let s=e!=null?e():ei(),r;return(...o)=>{const a=e!=null?e():ei();return a-s<t||(s=a,r=n(...o)),r}}function xV(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}let Brt=0;function wV(){return Brt++}const c1={};function Ev(n=""){return n in c1||(c1[n]=0),c1[n]+=1,n+c1[n].toString()}const Prt=["channelsFirst","channelsLast"],Vrt=["nearest","bilinear"],Urt=["valid","same","causal"],Grt=["max","avg"],Wrt=["sum","mul","concat","ave"];const md=new Map;function ws(n){ff(Prt,"DataFormat",n)}function jrt(n){ff(Vrt,"InterpolationFormat",n)}function Xi(n){ff(Urt,"PaddingMode",n)}function vV(n){ff(Grt,"PoolMode",n)}const gg=[],iM="/";function kh(n,t){gg.push(n);try{const e=t();return gg.pop(),e}catch(e){throw gg.pop(),e}}function qrt(){return gg.length===0?"":gg.join(iM)+iM}function SV(n){if(!TV(n))throw new Error("Not a valid tensor name: '"+n+"'");return qrt()+n}function IV(n){if(!TV(n))throw new Error("Not a valid tensor name: '"+n+"'");md.has(n)||md.set(n,0);const t=md.get(n);if(md.set(n,md.get(n)+1),t>0){const e=`${n}_${t}`;return md.set(e,1),e}else return n}const Hrt=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function TV(n){return!!n.match(Hrt)}function Krt(n){return n===parseInt(n.toString(),10)}function ec(n,t,e){t==null&&(t=0),e==null&&(e=n.length);let s=1;for(let r=t;r<e;++r)s*=n[r];return s}function Kd(n){if(n.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s<t&&(t=s)}return t}function uc(n){if(n.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s>t&&(t=s)}return t}function aa(n,t){if(t<n)throw new lt(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let s=n;s<t;++s)e.push(s);return e}let jT;function Gs(){return jT==null&&(jT=MY().epsilon()),jT}function la(){return"channelsLast"}function rl(n,t){return ne(n,t)}function ob(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),gt(n,e)}function Xrt(n,t){return vt(()=>{if(n.shape.length!==2)throw new lt(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const e=ob(n,1);return t$(e,[1,t,1])})}function Yrt(n){const t=[ec(n.shape)];return gt(n,t)}function Qrt(n){if(n.rank<=1)throw new lt(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],ec(n.shape,1)];return gt(n,t)}function _h(n,t,e){return vt(()=>{switch(n.rank){case 1:return EA(n,t,e);case 2:return y4(n,[t,0],[e,n.shape[1]]);case 3:return $A(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return cx(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Pn(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Pn(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new lt(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function qT(n,t,e){return vt(()=>{switch(n.rank){case 1:return EA(n,t,e);case 2:return y4(n,[0,t],[n.shape[0],e]);case 3:return $A(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return cx(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new lt(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function h1(n,t,e,s){return vt(()=>{switch(n.rank){case 1:return EA(n,t,e);case 2:switch(s){case 1:return _h(n,t,e);case 2:return qT(n,t,e);default:throw new lt(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return _h(n,t,e);case 2:return $A(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return qT(n,t,e);default:throw new lt(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return _h(n,t,e);case 2:return cx(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return cx(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return qT(n,t,e);default:throw new lt(`The axis is not within the rank of the tensor ${s}`)}default:throw new lt(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function fk(n,t=-1){let e;return t<0&&(e=n[0].rank,e!==0?t=e:t=0),t===n[0].rank&&(t=-1),ii(n,t)}function oM(n,t){switch(n.rank){case 1:return iZ([n,t]);case 2:return aZ([n,t],0);case 3:return uZ([n,t],0);case 4:return hZ([n,t],0);default:throw new lt(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function t$(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new lt(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return Qo(n,t)}function $v(n,t=0,e=1,s,r){return Stt(n,t,e,s,r)}function il(n,t,e,s){if(n.rank<2||t.rank<2)throw new Be(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3){const r=n.shape.slice(-1)[0],i=t.shape.slice(-2)[0];if(r!==i)throw new Be(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`)}if(n.rank===2&&t.rank===2)return qF({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?e$(n.rank,s,la()):null,activation:e});{const r=n.shape.slice(),i=r.pop();n=gt(n,[-1,i]);const o=t.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],f=Array.from({length:t.rank},(b,w)=>w===0?t.rank-2:w<=t.rank-2?w-1:w);t=gt(en(t,f),[l,-1]);const d=[...r,...c];return gt(qF({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?e$(n.rank,s,la()):null,activation:e}),d)}}function CV(n,t,e){return vt(()=>(Array.isArray(t)?t=Ti(t,"int32"):t=ne(t,"int32"),yA(n,t,e)))}function ab(n){return ct(n,n)}function e$(n,t,e){const s=t.shape;if(t.rank!==1&&t.rank!==n)throw new lt(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(n===5){if(e==="channelsFirst")return s.length===1?gt(t,[1,s[0],1,1,1]):gt(t,[1,s[3],s[0],s[1],s[2]]);if(e==="channelsLast")return s.length===1?gt(t,[1,1,1,1,s[0]]):gt(t,[1].concat(s))}else if(n===4){if(e==="channelsFirst")return s.length===1?gt(t,[1,s[0],1,1]):gt(t,[1,s[2],s[0],s[1]]);if(e==="channelsLast")return s.length===1?gt(t,[1,1,1,s[0]]):gt(t,[1].concat(s))}else if(n===3){if(e==="channelsFirst")return s.length===1?gt(t,[1,s[0],1]):gt(t,[1,s[1],s[0]]);if(e==="channelsLast")return s.length===1?gt(t,[1,1,s[0]]):gt(t,[1].concat(s))}else if(n<3)return t;throw new lt(`Unsupported input rank by biasAdd: ${t.rank}`)}function ma(n,t,e){return vt(()=>(e==null&&(e=la()),ws(e),Yt(n,e$(n.rank,t,e))))}function Zrt(n,t=1){if(t!==1)throw new Be(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return xv(n)}function Jrt(n){return vt(()=>be(n,Yt(Ur(n),1)))}function EV(n,t,e,s){return vt(()=>bet(n,t,e,s))}function tit(n){return vt(()=>{const t=Yt(.5,ct(.2,n));return Hi(t,0,1)})}function lb(n,t,e=!1){return e?n():t()}const eit=["fanIn","fanOut","fanAvg"],nit=["normal","uniform","truncatedNormal"];function sit(n){ff(eit,"FanMode",n)}function rit(n){ff(nit,"Distribution",n)}let Ao=class extends Ip{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},$V=class extends Ao{apply(t,e){return sr(t,e)}};$V.className="Zeros";Ht($V);let dk=class extends Ao{apply(t,e){return Dc(t,e)}};dk.className="Ones";Ht(dk);let AV=class extends Ao{constructor(t){if(super(),typeof t!="object")throw new lt(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new lt(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return vt(()=>ct(dn(this.value),Dc(t,e)))}getConfig(){return{value:this.value}}};AV.className="Constant";Ht(AV);let kV=class extends Ao{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return Jy(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};kV.className="RandomUniform";Ht(kV);let _V=class extends Ao{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Be(`randomNormal does not support dType ${e}.`);return $v(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};_V.className="RandomNormal";Ht(_V);let NV=class extends Ao{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Be(`truncatedNormal does not support dType ${e}.`);return w4(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};NV.className="TruncatedNormal";Ht(NV);let RV=class extends Ao{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,e){return vt(()=>{if(t.length!==2||t[0]!==t[1])throw new lt("Identity matrix initializer can only be used for 2D square matrices.");return ct(this.gain,s4(t[0]))})}getConfig(){return{gain:this.gain}}};RV.className="Identity";Ht(RV);function iit(n,t="channelsLast"){let e,s;if(ws(t),n.length===2)e=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(t==="channelsFirst"){const r=ec(n,2);e=n[1]*r,s=n[0]*r}else if(t==="channelsLast"){const r=ec(n,0,n.length-2);e=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=ec(n);e=Math.sqrt(r),s=Math.sqrt(r)}return[e,s]}let $i=class extends Ao{constructor(t){if(super(),t.scale<0)throw new lt(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,sit(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,rit(this.distribution),this.seed=t.seed}apply(t,e){const s=iit(t),r=s[0],i=s[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,r):this.mode==="fanOut"?o/=Math.max(1,i):o/=Math.max(1,(r+i)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Be(`${this.getClassName()} does not support dType ${e}.`);return w4(t,0,a,e,this.seed)}else{const a=Math.sqrt(3*o);return Jy(t,-a,a,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};$i.className="VarianceScaling";Ht($i);let pk=class extends $i{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return $i.className}};pk.className="GlorotUniform";Ht(pk);let mk=class extends $i{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return $i.className}};mk.className="GlorotNormal";Ht(mk);let gk=class extends $i{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return $i.className}};gk.className="HeNormal";Ht(gk);let yk=class extends $i{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return $i.className}};yk.className="HeUniform";Ht(yk);let bk=class extends $i{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return $i.className}};bk.className="LeCunNormal";Ht(bk);let xk=class extends $i{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return $i.className}};xk.className="LeCunUniform";Ht(xk);let DV=class extends Ao{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,e){return vt(()=>{if(t.length<2)throw new Be("Shape must be at least 2D.");if(e!=="int32"&&e!=="float32"&&e!==void 0)throw new TypeError(`Unsupported data type ${e}.`);e=e;const s=Lt(t.slice(0,-1)),r=t[t.length-1],i=s*r;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const o=[Math.max(r,s),Math.min(r,s)],a=$v(o,0,1,e,this.seed),l=mnt.qr(a,!1);let c=l[0];const d=l[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return c=ct(c,d.sign()),s<r&&(c=c.transpose()),ct(dn(this.gain),c.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}};DV.className="Orthogonal";Ht(DV);const aM={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function lM(n,t={}){return ib(n,Tp.getMap().classNameMap,t,"initializer")}function us(n){return ck(n)}function Jn(n){if(typeof n=="string"){const t=n in aM?aM[n]:n;if(t==="GlorotNormal")return new mk;if(t==="GlorotUniform")return new pk;if(t==="HeNormal")return new gk;if(t==="HeUniform")return new yk;if(t==="LeCunNormal")return new bk;if(t==="LeCunUniform")return new xk;{const e={};return e.className=t,e.config={},lM(e)}}else return n instanceof Ao?n:lM(n)}function n$(n){return Array.isArray(n)&&Array.isArray(n[0])}function hx(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function Te(n){let t;if(Array.isArray(n)){if(n.length!==1)throw new lt(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function ln(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new lt(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function fx(n){let t=0;for(const e of n)e.shape.length===0?t+=1:t+=e.shape.reduce((s,r)=>s*r);return t}const uM="Variable";let oit=class{constructor(t,e="float32",s=uM,r=!0,i=null){this.dtype=e??"float32",this.shape=t.shape,this.id=wV(),s=s??uM,this.originalName=SV(s),this.name=IV(this.originalName),this.trainable_=r,this.constraint=i,this.val=pet(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),ait(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}};function ait(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}function s$(n){return n.map(t=>t.read())}function wk(n){n.forEach(t=>{t[0].write(t[1])})}let Ws=class{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}},pl=class{constructor(t,e,s,r,i,o,a){this.dtype=t,this.shape=e,this.sourceLayer=s,this.inputs=r,this.callArgs=i,this.outputTensorIndex=a,this.id=wV(),o!=null&&(this.originalName=SV(o),this.name=IV(this.originalName)),this.rank=e.length}},lit=0,Av=class{constructor(t,e){this.callArgs=e,this.id=lit++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const s of t.inboundLayers)s?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},uit=0,Ue=class extends Ip{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=uit++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const s=this.getClassName();e=Pl(s)+"_"+Ev(s)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let s;if(t.batchInputShape!=null)s=t.batchInputShape;else if(t.inputShape!=null){let i=null;t.batchSize!=null&&(i=t.batchSize),s=[i].concat(t.inputShape)}this.batchInputShape=s;let r=t.dtype;r==null&&(r=t.inputDType),r==null&&(r="float32"),this.dtype=r}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new Qa(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new lt(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return si(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return si(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Wu(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Wu(`Layer ${this.name} is not connected, no input to return.`);return si(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Wu(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Wu(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return si(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const e=vn(t);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=vn(this.inputSpec);if(e.length!==s.length)throw new lt(`Layer ${this.name} expects ${s.length} inputs, but it received ${e.length} input tensors. Input received: ${t}`);for(let r=0;r<e.length;r++){const i=e[r],o=s[r];if(o==null)continue;const a=i.rank;if(o.ndim!=null&&a!==o.ndim)throw new lt(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new lt(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new lt(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&i.dtype!==o.dtype)throw new lt(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${i.dtype}.`);if(o.axes){const l=i.shape;for(const c in o.axes){const f=Number(c),d=o.axes[c],m=f>=0?l[f]:l[l.length+f];if(d!=null&&[d,null].indexOf(m)===-1)throw new lt(`Input ${r} is incompatible with layer ${this.name}: expected axis ${f} of input shape to have value ${d} but got shape ${l}.`)}}if(o.shape!=null)for(let l=0;l<o.shape.length;++l){const c=o.shape[l],f=i.shape[l];if(c!=null&&f!=null&&c!==f)throw new lt(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${i.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const s=vn(t),r=fit(t),i=dit(t);if(r===i)throw new lt("Arguments to apply() must be all SymbolicTensors or all Tensors");return kh(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const o=[];for(const a of vn(t))o.push(a.shape);this.build(si(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(t),i){let o=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,o);const a=vn(o),l=[];for(let c of a)s.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(o=si(l),this.activityRegularizer!=null)throw new Be("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=cit(t),a=this.computeOutputShape(o);let l;const c=hit(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((f,d)=>new pl(c,f,this,vn(t),e,this.name,d)):l=new pl(c,a,this,vn(t),e,this.name),this.addInboundNode(t,l,null,null,o,a,e),this._refCount++,this.activityRegularizer!=null)throw new Be("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&t[r]!=null&&t[r]!==s&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Wu(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const s=JSON.stringify(e.outputShapes);t.indexOf(s)===-1&&t.push(s)}if(t.length===1){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new Wu(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Qa(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return fx(this.weights)}build(t){this.built=!0}getWeights(t=!1){return s$(t?this.trainableWeights:this.weights)}setWeights(t){vt(()=>{const e=this.weights;if(e.length!==t.length)throw new lt(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;const s=[],r=s$(e);for(let i=0;i<r.length;++i){const o=r[i],a=e[i],l=t[i];if(!mn(o.shape,l.shape))throw new lt(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);s.push([a,l])}wk(s)})}addWeight(t,e,s,r,i,o,a,l){if(this._addedWeightNames.indexOf(t)!==-1)throw new lt(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=l!=null?l():Jn("zeros"));const c=r.apply(e,s),f=new oit(c,s,t,o,a);return c.dispose(),i!=null&&this.addLoss(()=>i.apply(f.read())),o==null&&(o=!0),o?this._trainableWeights.push(f):this._nonTrainableWeights.push(f),f}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=vn(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}setMaskMetadata(t,e,s){if(!this.supportsMasking)return;const r=this.computeMask(t,s),i=vn(e),o=vn(r);if(i.length!==o.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let a=0;a<i.length;a++)i[a].kerasMask=o[a]}addInboundNode(t,e,s,r,i,o,a=null){const l=vn(t);e=vn(e),s=vn(s),r=vn(r),i=hx(i),o=hx(o);const c=[],f=[],d=[];for(const m of l)c.push(m.sourceLayer),f.push(m.nodeIndex),d.push(m.tensorIndex);new Av({outboundLayer:this,inboundLayers:c,nodeIndices:f,tensorIndices:d,inputTensors:l,outputTensors:e,inputMasks:s,outputMasks:r,inputShapes:i,outputShapes:o},a);for(let m=0;m<e.length;m++)e[m].sourceLayer=this,e[m].nodeIndex=this.inboundNodes.length-1,e[m].tensorIndex=m}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}};function cit(n){n=vn(n);const t=[];for(const e of n)t.push(e.shape);return si(t)}function hit(n){return"float32"}function OV(n,t,e){if((t==null||e!=null&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),t.inboundNodes.length===0)return[n];{const s=t.inboundNodes[e];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let i=0;i<s.inboundLayers.length;i++){const o=s.inputTensors[i],a=s.inboundLayers[i],l=s.nodeIndices[i],c=OV(o,a,l);for(const f of c)r.indexOf(f)===-1&&r.push(f)}return r}}}function fit(n){let t=!0;for(const e of vn(n))if(!(e instanceof pl)){t=!1;break}return t}function dit(n){let t=!0;for(const e of vn(n))if(e instanceof pl){t=!1;break}return t}let ub=class extends Ue{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:Ev("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new lt("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new lt("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new lt("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=t.dtype||"float32";this.batchInputShape=e,this.dtype=s,this.inputSpec=[{shape:e}];const r=new pl(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new Av({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new lt(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};ub.className="InputLayer";Ht(ub);function pit(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new lt("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;n.shape!=null&&t==null&&(t=[null].concat(n.shape));let e=n.dtype;return e==null&&(e="float32"),new ub({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}function mit(n,t){if(n.dtype==null||n.dtype===t.dtype)return t;try{return ne(t,n.dtype)}catch{throw new lt(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}let _d=class FV{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof FV)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,s){if(this.id2Value[t.id]==null)this.id2Value[t.id]=mit(t,e),this.name2Id[t.name]=t.id,s!=null&&(this.id2Mask[t.id]=s);else throw new lt(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof pl){if(this.id2Value[t.id]==null)throw new lt(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const e=this.name2Id[t];if(e==null)throw new lt(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof pl){if(this.id2Value[t.id]==null)throw new lt(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const e=this.name2Id[t];if(e==null)throw new lt(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&We(this.id2Mask)}};const dx=new yV,px=new yV;function git(n){dx?.setMaxEntries(n),px?.setMaxEntries(n)}function sg(n,t,e,s){const r=e==null?!1:e.training,i=Array.isArray(n),o=i?n:[n],a=o.map(b=>b.name),l=[],c=t.names();for(const b of a)c.indexOf(b)!==-1?l.push(t.getValue(b)):l.push(null);const f=a.join(",")+"|"+t.names().sort().join(",");let d=dx.get(f),m;if(d==null){const b=yit(o,t);d=b.sorted,m=b.recipientCounts,dx.put(f,d),px.put(f,m)}m={},r||Object.assign(m,px.get(f));const y=new _d(t);for(let b=0;b<d.length;++b){const w=d[b],x=w.sourceLayer;if(x instanceof ub)continue;const S=[],T=[],$=[];let E=!1;for(const _ of w.inputs){const F=y.getValue(_),A=y.getMask(_);S.push(F),T.push(A),A!=null&&(E=!0),r||(m[_.name]--,m[_.name]===0&&!t.hasKey(_)&&a.indexOf(_.name)===-1&&!F.isDisposed&&_.sourceLayer.stateful!==!0&&$.push(F))}E&&(e=e||{},e.mask=T[0]);const R=vn(x.apply(S,e));let B=null;x.supportsMasking&&(B=x.computeMask(S,T));const N=xit(w),k=Array.isArray(N)?N:[N];for(let _=0;_<k.length;++_){y.hasKey(k[_])||y.add(k[_],R[_],Array.isArray(B)?B[0]:B);const F=a.indexOf(k[_].name);F!==-1&&(l[F]=R[_])}r||We($)}return y.disposeMasks(),i?l:l[0]}function yit(n,t){H(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],s={};if(n.length===1){const r=cM(n[0],t);e=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of n){const{sorted:o,recipientMap:a}=cM(i,t);for(const l of o)r.has(l.name)||(e.push(l),r.add(l.name));for(const l in a)s[l]==null&&(s[l]=new Set),a[l].forEach(c=>s[l].add(c))}}return{sorted:e,recipientCounts:bit(s)}}function bit(n){const t={};for(const e in n)t[e]=n[e].size;return t}function cM(n,t){const e=new Set,s=[],r={};for(const a of t.names())e.add(a);const i=[],o=[];for(i.push(n);i.length>0;){const a=i[i.length-1];if(e.has(a.name)){i.pop();continue}const l=o[o.length-1]===i.length-1;if(a.inputs.length===0||l)i.pop(),s.push(a),e.add(a.name),l&&o.pop();else{o.push(i.length-1);for(const c of a.inputs)r[c.name]==null&&(r[c.name]=new Set),r[c.name].add(a.name),!e.has(c.name)&&i.push(c)}}return{sorted:s,recipientMap:r}}function xit(n){let t;if(n.sourceLayer.inboundNodes.length===1)t=n.sourceLayer.output;else{let e=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){e=s;break}t=n.sourceLayer.getOutputAt(e)}return t}const wit=At();wit.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,git);function vk(n,t){return vt(()=>Dr(me(ct(n,n),t,!0)))}let cb=class extends Ip{getConfig(){return{}}},MV=class extends cb{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return vt(()=>{const e=vk(t,this.axis),s=Hi(e,0,this.maxValue);return ct(t,be(s,Yt(Gs(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};MV.className="MaxNorm";Ht(MV);let LV=class extends cb{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return vt(()=>be(t,Yt(Gs(),vk(t,this.axis))))}getConfig(){return{axis:this.axis}}};LV.className="UnitNorm";Ht(LV);let zV=class extends cb{apply(t){return cf(t)}};zV.className="NonNeg";Ht(zV);let BV=class extends cb{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return vt(()=>{const e=vk(t,this.axis),s=Yt(ct(this.rate,Hi(e,this.minValue,this.maxValue)),ct(1-this.rate,e));return ct(t,be(s,Yt(Gs(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};BV.className="MinMaxNorm";Ht(BV);const hM={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Ks(n){return ck(n)}function fM(n,t={}){return ib(n,Tp.getMap().classNameMap,t,"constraint")}function Xs(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in hM?hM[n]:n,config:{}};return fM(e)}else return n instanceof cb?n:fM(n)}async function fh(n){if(n==null)return;const t=[],e=[],s=[];for(const r in n){const i=n[r];if(typeof i!="number"){const o=i;t.push(o.data()),e.push(r),s.push(o)}}if(t.length>0){const r=await Promise.all(t);for(let i=0;i<r.length;++i)n[e[i]]=r[i][0];We(s)}}function PV(n){if(n!=null)for(const t in n){const e=n[t];typeof e!="number"&&e.dispose()}}var dM;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(dM||(dM={}));const vit=125;let _g=class{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}},Sit=class{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}},Iit=class extends _g{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});const s=e.size==null?0:e.size;this.seen+=s;for(const r in e){const i=e[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*s;else{let o;r in this.totals?o=this.totals[r]:this.totals[r]=0;const a=vt(()=>Yt(this.totals[r],ct(i,s)));this.totals[r]=a,o?.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?e[s]=this.totals[s]/this.seen:vt(()=>{const r=ct(be(1,this.seen),this.totals[s]);e[s]=r,this.totals[s].dispose(),nl(e[s])}))}},Tit=class extends _g{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(const s in e)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(e[s])}async syncData(){const t=[],e=[],s=[];for(const i in this.history){const o=this.history[i];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const l=o[a];t.push(l.data()),e.push(i),s.push(a)}}const r=await Promise.all(t);for(let i=0;i<r.length;++i)this.history[e[i]][s[i]].dispose(),this.history[e[i]][s[i]]=r[i][0]}},Cit=class extends _g{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||B4,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=vit),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");RE(this.yieldEvery)&&(this.maybeWait=zrt(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,s){const r=[];this.yield!=null&&(await fh(s),r.push(this.yield(t,e,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await fh(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const s=[];this.epochEnd!=null&&(await fh(e),s.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(t,e){this.batchBegin!=null&&(await fh(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const s=[];this.batchEnd!=null&&(await fh(e),s.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):RE(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(s)}async onTrainBegin(t){this.trainBegin!=null&&(await fh(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await fh(t),await this.trainEnd(t))}};function VV(n,t){return n==null&&(n={}),n instanceof _g?[n]:Array.isArray(n)&&n[0]instanceof _g?n:vn(n).map(s=>new Cit(s,t))}let UV=class za{constructor(){}static registerCallbackConstructor(t,e){H(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),za.checkForDuplicate(e),za.constructors[t]==null&&(za.constructors[t]=[]),za.constructors[t].push(e)}static checkForDuplicate(t){for(const e in za.constructors)za.constructors[+e].forEach(r=>{if(r===t)throw new lt("Duplicate callback constructor.")})}static clear(){za.constructors={}}static createCallbacks(t){const e=[];for(const s in za.constructors){const r=+s;t>=r&&e.push(...za.constructors[r])}return e.map(s=>new s)}};UV.constructors={};function GV(n,t,e,s,r,i,o,a,l){const c=new Tit,f=[new Iit,...UV.createCallbacks(t)];n!=null&&f.push(...n),f.push(c);const d=new Sit(f);return d.setParams({epochs:e,initialEpoch:s,samples:r,steps:i,batchSize:o,verbose:t,doValidation:a,metrics:l}),{callbackList:d,history:c}}function ql(n,t={},e=!1){return ib(n,Tp.getMap().classNameMap,t,"layer",e)}function mx(n,t){return vt(()=>{n.dtype!=="float32"&&(n=ne(n,"float32"));const e=me(ab(n),t,!0),s=bv(e.shape,Gs()),r=Dr(Rc(e,s));return be(n,r)})}function kv(n,t){return vt(()=>$s(ab(Se(t,n)),-1))}function Sk(n,t){return vt(()=>$s(Ur(Se(t,n)),-1))}function Ik(n,t){return vt(()=>{const e=Se(n,t),s=Hi(Ur(n),Gs(),Number.MAX_VALUE),r=Ur(be(e,s));return ct(100,$s(r,-1))})}function Eit(n,t){return vt(()=>{const e=Hi(t,Gs(),Number.MAX_VALUE),s=dl(Yt(1,e)),r=Hi(n,Gs(),Number.MAX_VALUE),i=dl(Yt(1,r));return $s(ab(Se(s,i)),-1)})}function $it(n,t){return vt(()=>{const e=Rc(0,Se(1,ct(n,t)));return $s(ab(e),-1)})}function Ait(n,t){return vt(()=>{const e=Rc(0,Se(1,ct(n,t)));return $s(e,-1)})}function kit(n,t){return vt(()=>{const e=me(ct(n,t),-1),s=ta(ct(Se(1,n),t),-1);return Rc(0,Yt(1,Se(s,e)))})}function _it(n,t){return vt(()=>{const e=Math.log(2),s=Se(t,n),r=Se(Yt(s,Zy(ct(-2,s))),e);return $s(r,-1)})}function Ng(n,t,e=!1){return vt(()=>{if(e)t=AA(t);else{const s=me(t,t.shape.length-1,!0);t=be(t,s)}return t=Hi(t,Gs(),1-Gs()),ys(me(ct(ne(n,"float32"),dl(t)),t.shape.length-1))})}function gx(n,t,e=!1){return vt(()=>{const s=ne(vv(Yrt(n)),"int32");t=Hi(t,Gs(),1-Gs());const r=t.shape,i=gt(l4(s,r[r.length-1]),r);return Ng(i,t,e)})}function Nit(n,t){if(!mn(n.shape,t.shape))throw new lt(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return vt(()=>{const e=cf(t),s=ys(Ur(t));return Yt(Se(e,ct(t,n)),r4(fl(s)))})}function _v(n,t){return vt(()=>{let e;return e=Hi(t,Gs(),1-Gs()),e=dl(be(e,Se(1,e))),$s(Nit(n,e),-1)})}function Rit(n,t){return vt(()=>{const e=Hi(n,Gs(),1),s=Hi(t,Gs(),1);return me(ct(n,dl(be(e,s))),-1)})}function Dit(n,t){return vt(()=>{const e=dl(Yt(Gs(),t));return $s(Se(t,ct(n,e)),-1)})}function WV(n,t){return vt(()=>{const e=mx(n,-1),s=mx(t,-1),r=ct(e,s);return ys(me(r,-1))})}const yx={meanSquaredError:kv,meanAbsoluteError:Sk,meanAbsolutePercentageError:Ik,meanSquaredLogarithmicError:Eit,squaredHinge:$it,hinge:Ait,categoricalHinge:kit,logcosh:_it,categoricalCrossentropy:Ng,sparseCategoricalCrossentropy:gx,binaryCrossentropy:_v,kullbackLeiblerDivergence:Rit,poisson:Dit,cosineProximity:WV};function HT(n){if(typeof n=="string"){if(n in yx)return yx[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new lt(t)}else return n}function jV(n,t){return vt(()=>{const e=ct(.5,Io(t)),s=rl(Ki(t,e),n.dtype);return $s(hl(n,s),-1)})}function qV(n,t){return vt(()=>rl(hl(Cg(n,-1),Cg(t,-1)),"float32"))}function Oit(n,t){return vt(()=>ne(me(Yl(hl(n,1),hl(t,1))),"float32"))}function Fit(n,t){return vt(()=>ne(me(Yl(hl(n,0),hl(t,1))),"float32"))}function Mit(n,t){return vt(()=>{const e=Oit(n,t),s=Fit(n,t),r=Yt(e,s);return ne(Hr(Ki(r,0),be(e,r),0),"float32")})}function Lit(n,t){return _v(n,t)}function zit(n,t){return n.rank===t.rank&&(n=tb(n,[n.rank-1])),t=Cg(t,-1),t.dtype!==n.dtype&&(t=ne(t,n.dtype)),ne(hl(n,t),"float32")}const Bit=kv,Pit=kv,Vit=Sk,Uit=Sk,Git=Ik,Wit=Ik,HV=Ng,jit=WV,KV=gx,bx={binaryAccuracy:jV,categoricalAccuracy:qV,precision:Mit,categoricalCrossentropy:HV,sparseCategoricalCrossentropy:KV,mse:Bit,MSE:Pit,mae:Vit,MAE:Uit,mape:Git,MAPE:Wit,cosine:jit};function qit(n){if(typeof n=="string"&&n in bx)return bx[n];if(typeof n!="string"&&n!=null)return n;throw new lt(`Unknown metric ${n}`)}function f1(n){if(ja(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let t;for(const e of Object.keys(yx))if(yx[e]===n){t=e;break}if(t!==void 0)return t;for(const e of Object.keys(bx))if(bx[e]===n){t=e;break}return t!==void 0?t:n.name}}function Hit(n){const t={Adagrad:()=>pd.adagrad(.01),Adadelta:()=>pd.adadelta(1,.95,Gs()),Adam:()=>pd.adam(.001,.9,.999,Gs()),Adamax:()=>pd.adamax(.002,.9,.999,Gs(),0),RMSProp:()=>pd.rmsprop(.001,.9,0,Gs()),SGD:()=>pd.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new lt(`Unknown Optimizer ${n}`)}const pM=1*1024*1024;function mM(n,t,e=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!r$(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const s=JSON.stringify(n);s.length>pM&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${pM}.`)}}function r$(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if(typeof e!="string"||!r$(n[e]))return!1;return!0}else if(Array.isArray(n)){for(const t of n)if(!r$(t))return!1;return!0}else return!1;else{const t=typeof n;return t==="string"||t==="number"||t==="boolean"}}function Kit(n,t,e,s=console.log){const r=Yit(n),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(f=>Math.floor(t*f)));let o;if(!r){i.push("Receives inputs"),o=[];for(const f in n.nodesByDepth)o.push(...n.nodesByDepth[f])}s("_".repeat(t)),xx(i,e,s),s("=".repeat(t));const a=n.layers;for(let f=0;f<a.length;++f)r?Qit(a[f],e,s):Zit(a[f],e,o,s),s((f===a.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const l=Xit(n),c=fx(n.nonTrainableWeights);s(`Total params: ${l+c}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${c}`),s("_".repeat(t))}function Xit(n){let t;return n.collectedTrainableWeights!=null?t=fx(n.collectedTrainableWeights):t=fx(n.trainableWeights),t}function Yit(n){let t=!0;const e=[],s=[];for(const r in n.nodesByDepth)e.push(n.nodesByDepth[r]);for(const r of e){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){t=!1;break}s.push(...r)}if(t)for(const r of n.layers){let i=!1;for(const o of r.inboundNodes)if(s.indexOf(o)!==-1)if(i){t=!1;break}else i=!0;if(!t)break}return t}function xx(n,t,e=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,t[r]),s+=" ".repeat(t[r]-s.length);e(s)}function Qit(n,t,e){let s,r;try{r=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const i=n.name,o=n.getClassName(),a=[`${i} (${o})`,r,s,n.countParams().toString()];xx(a,t,e)}function Zit(n,t,e,s){let r,i;try{i=n.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const o=[];for(const d of n.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(d)===-1))for(let m=0;m<d.inboundLayers.length;++m){const y=d.inboundLayers[m].name,b=d.nodeIndices[m],w=d.tensorIndices[m];o.push(`${y}[${b}][${w}]`)}const a=n.name,l=n.getClassName(),c=o.length===0?"":o[0],f=[`${a} (${l})`,i,r,n.countParams().toString(),c];xx(f,t,s);for(let d=1;d<o.length;++d)xx(["","","","",o[d]],t,s)}function XV(n,t,e){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&t===0&&typeof e=="string"}function i$(n,t){if(n===null)return null;if(typeof n=="string")return xh(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];XV(t,r,i)?e.push(i):e.push(i$(i,t))}return e}else{const e={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")e[s]=r;else{const i=xh(s);e[i]=i$(r,i)}}return e}}function o$(n,t){if(n==null)return null;if(typeof n=="string")return Pl(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];XV(t,r,i)?e.push(i):e.push(o$(i,t))}return e}else{const e={};for(const s of Object.keys(n)){const r=n[s],i=Pl(s);(s==="name"||s==="className")&&typeof r=="string"?e[i]=r:e[i]=o$(r,s)}return e}}const YV="4.22.0";const Jit=n=>{const t=Object.keys(n);if(t.length===0)return!1;const e=t[0].split("/");return!isNaN(parseInt(e[e.length-1],10))};let tot=class Ba extends Ue{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){const T=this.getClassName().toLowerCase();this.name=Ev(T)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],tc(this.inputs).length!==this.inputs.length)throw new lt(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(T=>T.name)}`);tc(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(T=>T.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const T of this.outputs){const $=T.sourceLayer,E=T.nodeIndex,R=T.tensorIndex;this.outputLayers.push($),this.outputLayersNodeIndices.push(E),this.outputLayersTensorIndices.push(R)}for(const T of this.inputs){const $=T.sourceLayer,E=T.nodeIndex,R=T.tensorIndex;ja(E===0,"input layer has >1 nodes"),ja(R===0,"input layer has >1 tensors"),this.inputLayers.push($),this.inputLayersNodeIndices.push(E),this.inputLayersTensorIndices.push(R)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let T=0;T<this.inputLayers.length;T++){const $=this.inputLayers[T];if(!($ instanceof ub))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${T} (0-based) originates from layer type ${$.getClassName()}.`);this.inputNames.push($.name),this.feedInputShapes.push($.batchInputShape),this.feedInputNames.push($.name)}for(const T of this.outputLayers)this.outputNames.push(T.name);this.internalInputShapes=this.inputs.map(T=>T.shape),this.internalOutputShapes=this.outputs.map(T=>T.shape);const e={},s={},r={},i={},o={},a=[],l=(T,$,E,R,B,N)=>{(R==null||B==null||N==null)&&(R=T.sourceLayer,B=T.nodeIndex,N=T.tensorIndex);const k=R.inboundNodes[B];if(E.indexOf(k)!==-1)throw new Qa(`The tensor ${T.name} at layer "${R.name}" is part of a cycle.`);if($.indexOf(k)!==-1)return;this.containerNodes.add(Ba.nodeKey(R,B)),R.id in o||(o[R.id]=Object.keys(o).length),E.indexOf(k)===-1&&E.push(k);const _=k.inboundLayers.length;for(let F=0;F<_;F++){const A=k.inputTensors[F],P=k.inboundLayers[F],L=k.nodeIndices[F],tt=k.tensorIndices[F];l(A,$,E,P,L,tt)}for($.push(k);E.indexOf(k)>=0;)E.splice(E.indexOf(k),1);a.push(k)},c=[],f=[];for(const T of this.outputs)l(T,c,f);const d=a.slice().reverse();for(const T of d){s[T.id]=T,T.id in e||(e[T.id]=0);let $=e[T.id];const E=r[T.outboundLayer.id]==null?0:r[T.outboundLayer.id];$=Math.max($,E),r[T.outboundLayer.id]=$,i[T.outboundLayer.id]=T.outboundLayer,e[T.id]=$;for(let R=0;R<T.inboundLayers.length;R++){const B=T.inboundLayers[R],N=T.nodeIndices[R],k=B.inboundNodes[N],_=e[k.id]==null?0:e[k.id];e[k.id]=Math.max($+1,_),s[k.id]=k}}const m={};for(const T in e){const $=e[T];$ in m||(m[$]=[]),m[$].push(s[T])}const y={};for(const T in r){const $=r[T];$ in y||(y[$]=[]),y[$].push(i[T])}let b=Object.keys(y).map(T=>parseInt(T,10)).sort(u1);this.layers=[];for(const T of b){const $=y[T];$.sort((E,R)=>{const B=o[E.id],N=o[R.id];return B<N?-1:B>N?1:0});for(const E of $)E instanceof Ba&&this.internalContainerRefs.push(E),this.layers.push(E)}this.layersByDepth=y,b=Object.keys(m).map(T=>parseInt(T,10)).sort(u1);const w=this.inputs.slice(),x=[];for(const T of b)for(const $ of m[T]){const E=$.outboundLayer;if(E!=null){for(const R of $.inputTensors)if(w.indexOf(R)===-1)throw new Qa(`Graph disconnected: cannot obtain value for tensor ${R} at layer "${E.name}". The following previous layers were accessed without issue: ${x}`);for(const R of $.outputTensors)w.push(R);x.push(E.name)}}this.nodesByDepth=m;const S=this.layers.map(T=>T.name);for(const T of S){const $=S.filter(E=>E===T).length;if($!==1)throw new Qa(`The name "${T}" is used ${$} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(S))}this.outboundNodes=[],this.inboundNodes=[],new Av({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(T=>null),outputMasks:this.outputs.map(T=>null),inputShapes:this.inputs.map(T=>T.shape),outputShapes:this.outputs.map(T=>T.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(s=>s.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new lt("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.layers)e.push(...s.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const s={};let r=0;const i=Jit(t);i&&this.parseWeights(t);for(const a of this.layers)for(const[l,c]of a.weights.entries()){const f=i?`${c.name.split("/").slice(0,-1).join("/")+"/"}${l}`:c.originalName;if(s[f]!=null)throw new lt(`Duplicate weight name: ${f}`);s[f]=c,r++}const o=[];for(const a in t){let l=a;if(s[a]==null){const c=a.split("/");l=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(s[l]!=null)o.push([s[l],t[a]]);else if(e)throw new lt(`Provided weight data has no target variable: ${a}`);delete s[l]}if(e){const a=[];for(const l in s)a.push(l);if(a.length>0)throw new lt(`${a.length} of ${r} weights are not set: ${a}`)}wk(o)}parseWeights(t){for(const e in Object.keys(t)){const s=e.split("/"),r=["vars","layer_checkpoint_dependencies"],i=s.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!r.includes(o)).join("/");i!==e&&(t[i]=t[e],delete t[e])}}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${YV}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){const s=o$(this.updatedConfig());return e?JSON.stringify(s):s}call(t,e){return vt(()=>{t=vn(t);const s=new _d;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],t[r]);return sg(this.outputs,s,e)})}computeMask(t,e){return vt(()=>{t=vn(t);let s;return e==null?s=Hh(null,t.length):s=vn(e),this.runInternalGraph(t,s)[1]})}computeOutputShape(t){const e=hx(t);if(e.length!==this.inputLayers.length)throw new lt(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let a=0;a<e.length;a++){const l=this.inputLayers[a],c=e[a],f=l.name+"_0_0";s[f]=c}const r=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(u1);if(r.length>1)for(const a of r){const l=this.nodesByDepth[a];for(const c of l){const f=c.outboundLayer;if(this.inputLayers.map(w=>w.id).indexOf(f.id)!==-1)continue;const d=[];for(let w=0;w<c.inboundLayers.length;w++){const x=c.inboundLayers[w],S=c.nodeIndices[w],T=c.tensorIndices[w],$=`${x.name}_${S}_${T}`,E=s[$];d.push(E)}const m=f.computeOutputShape(si(d)),y=hx(m),b=f.inboundNodes.indexOf(c);for(let w=0;w<y.length;w++){const x=`${f.name}_${b}_${w}`;s[x]=y[w]}}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],c=this.outputLayersNodeIndices[a],f=this.outputLayersTensorIndices[a],d=`${l.name}_${c}_${f}`;o.push(d)}for(let a=0;a<o.length;a++){const l=o[a];ja(l in s),i.push(s[l])}return si(i)}runInternalGraph(t,e){e==null&&(e=Hh(null,t.length));const s={};for(let l=0;l<this.inputs.length;++l){const c=this.inputs[l],f=t[l],d=e[l];s[c.id]=[f,d]}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(u1);for(const l of r){const c=this.nodesByDepth[l];for(const f of c){const d=f.outboundLayer,m=f.inputTensors,y=f.outputTensors,b=new Array;for(const w of m)w.id in s&&b.push(s[w.id]);if(b.length===m.length){let w={},x,S,T,$;if(f.callArgs!=null&&(w=f.callArgs),b.length===1){const[E,R]=b[0];w.mask==null&&(w.mask=R),T=vn(d.call(E,w)),$=vn(d.computeMask(E,R)),x=[E],S=[R]}else x=b.map(E=>E[0]),S=b.map(E=>E[1]),w.mask==null&&(w.mask=S),T=vn(d.call(x,w)),$=vn(d.computeMask(x,S));if(d.activityRegularizer)throw new Be("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let E=0;E<y.length;++E){const R=y[E],B=T[E],N=$[E];s[R.id]=[B,N]}}}}const i=[],o=[],a=[];for(const l of this.outputs){ja(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[c,f]=s[l.id];a.push(c.shape),i.push(c),o.push(f)}return[i,o,a]}buildNodeConversionMap(t){const e={};let s;for(const r of this.layers){s=r instanceof Ba?1:0;for(let i=0;i<r.inboundNodes.length;i++){const o=Ba.nodeKey(r,i);this.containerNodes.has(o)&&(e[o]=s,s+=1)}}return e}getLayer(t,e){if(e!=null)return this.findLayer(e);if(t==null)throw new lt("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(const s of this.layers)if(s.name===t)return s;throw new lt(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new lt(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return vt(()=>{const t=[];for(const e of this.layers)for(let s=0;s<e.inboundNodes.length;++s){const r=Ba.nodeKey(e,s);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),s=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),c=[];for(let d=0;d<o.inboundNodes.length;d++){const m=o.inboundNodes[d],y=Ba.nodeKey(o,d);let b={};if(this.containerNodes.has(y)){if(m.callArgs)try{JSON.stringify(m.callArgs),b=m.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),b={}}if(m.inboundLayers.length>0){const w=[];for(let x=0;x<m.inboundLayers.length;x++){const S=m.inboundLayers[x],T=m.nodeIndices[x],$=m.tensorIndices[x],E=Ba.nodeKey(S,T);let R=e[E];R==null&&(R=0),w.push([S.name,R,$,b])}c.push(w)}}}const f={};f.name=o.name,f.className=a,f.config=l,f.inboundNodes=c,s.push(f)}t.layers=s;const r=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],l=this.inputLayersNodeIndices[o],c=Ba.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let f=e[c];f==null&&(f=0);const d=this.inputLayersTensorIndices[o];r.push([a.name,f,d])}t.inputLayers=r;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],l=this.outputLayersNodeIndices[o],c=Ba.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let f=e[c];f==null&&(f=0);const d=this.outputLayersTensorIndices[o];i.push([a.name,f,d])}return t.outputLayers=i,t}static fromConfig(t,e,s={},r=!1){const i={},o={};function a(x,S){x.name in o?o[x.name].push(S):o[x.name]=[S]}function l(x,S){const T=[];let $;for(const E of S){const R=E[0],B=E[1],N=E[2];if($=E[3]==null?{}:E[3],!(R in i)){a(x,S);return}const k=i[R];if(k.inboundNodes.length<=B){a(x,S);return}const _=k.inboundNodes[B];T.push(_.outputTensors[N])}T.length>0&&x.apply(si(T),$)}function c(x){const S=x.name,T=ql(x,e.customObjects!=null?e.customObjects:{});T.setFastWeightInitDuringBuild(r),i[S]=T,x.inboundNodes.forEach(E=>{if(!(E instanceof Array))throw new lt(`Corrupted configuration, expected array for nodeData: ${E}`);a(T,E)})}const f=e.name,d=e.layers;for(const x of d)c(x);for(;!Lrt(o);)for(const x of d){const S=i[x.name];if(S.name in o){const T=o[S.name];delete o[S.name];for(const $ of T)l(S,$)}}const m=[],y=[],b=e.inputLayers;for(const x of b){const S=x[0],T=x[1],$=x[2];ja(S in i);const R=i[S].inboundNodes[T].outputTensors;m.push(R[$])}const w=e.outputLayers;for(const x of w){const S=x[0],T=x[1],$=x[2];ja(S in i);const R=i[S].inboundNodes[T].outputTensors;y.push(R[$])}return new t({inputs:m,outputs:y,name:f})}get stateful(){if(this._stateful)throw new lt("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){vt(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function eot(n,t,e){const s=t.length;if(n==null||Array.isArray(n)&&n.length===0)return t.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return t.forEach(i=>{i in n?r.push(n[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${e} must be either an array with ${s} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}function QV(n,t){return eot(n,t,"classWeight")}async function ZV(n,t,e,s){if(e!=null){const r=vt(()=>{if(n.shape.length===1)return Ah(n);if(n.shape.length===2){if(n.shape[1]>1)return Cg(n,1);if(n.shape[1]===1)return gt(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());We(r);const o=[];return i.forEach(a=>{if(e[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(e[a])}),Ti(o,"float32")}else return null}function not(n,t){return ct(n,t)}const sot=32;function JV(n,t){let e,s;const r=t;e=r.xs,s=r.ys,H(e!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const i=gM("input",n.inputNames,e),o=gM("output",n.outputNames,s),a=i[0].shape[0];H(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),H(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<i.length;l++)H(i[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)H(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function gM(n,t,e){if(e instanceof Vs)return[e];if(Array.isArray(e))return H(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const s=[];for(const r of t){if(e[r]==null)throw new lt(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(e[r])}return s}}function rot(n){if(n.length===3)throw new Be("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function iot(n,t,e){const s=e.batchesPerEpoch!=null;if(H(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),H(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),H(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),H(!s||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),H(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=e.validationData!=null;let i,o;if(r)if(yM(e.validationData))H(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const x=rot(e.validationData);i=x.xs,o=x.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;r?c=l.slice().concat(l.map(x=>"val_"+x)):c=l.slice();const f=VV(e.callbacks,e.yieldEvery),d=e.verbose==null?1:e.verbose,{callbackList:m,history:y}=GV(f,d,e.epochs,null,null,oot(t,e),null,r,c);m.setModel(n),n.history=y,await m.onTrainBegin(),n.stopTraining_=!1;let b=e.initialEpoch==null?0:e.initialEpoch,w=await t.iterator();for(;b<e.epochs;){const x={};await m.onEpochBegin(b);let S=0,T=0;for(s||(w=await t.iterator());!s||S<e.batchesPerEpoch;){const $=await w.next();if(s&&$.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${S} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if($.value!=null){const{xs:E,ys:R}=JV(n,$.value),B={};B.batch=T,B.size=E[0].shape[0],await m.onBatchBegin(T,B);const N=[];if(e.classWeight!=null){const F=QV(e.classWeight,n.outputNames);for(let A=0;A<F.length;++A)N.push(await ZV(R[A],null,F[A]))}const k=E.concat(R).concat(N),_=a(k);We(k);for(let F=0;F<l.length;++F){const A=l[F],P=_[F];B[A]=P,nl(P)}await m.onBatchEnd(T,B),PV(B),T++,S++}if(s?S>=e.batchesPerEpoch:$.done){if(r){let E;yM(e.validationData)?E=vn(await n.evaluateDataset(e.validationData,{batches:e.validationBatches})):E=vn(n.evaluate(i,o,{batchSize:e.validationBatchSize==null?sot:e.validationBatchSize,verbose:0}));for(let R=0;R<n.metricsNames.length;++R)x[`val_${n.metricsNames[R]}`]=E[R]}break}if(n.stopTraining_)break}if(await m.onEpochEnd(b,x),b++,n.stopTraining_)break}return await m.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function oot(n,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function yM(n){return typeof n.iterator=="function"}function aot(n){return typeof n.next=="function"}async function lot(n,t,e){e=e||{};const s=e.batches!=null,r=n.testFunction;let i=[];if(e.verbose>0)throw new Be("Verbose mode is not implemented yet.");H(!s||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const o=aot(t)?t:await t.iterator();let a=0,l=0;for(;!s||l<e.batches;){const c=await o.next();if(i=vt(()=>{if(c.value){const{xs:f,ys:d}=JV(n,c.value),m=f.concat(d),y=vt(()=>r(m));if(We(m),l===0)for(let w=0;w<y.length;++w)i.push(dn(0));const b=m[0].shape[0];for(let w=0;w<y.length;++w){const x=y[w],S=i[w];i[w]=vt(()=>Yt(i[w],ct(b,x))),l>0&&We(S)}We(y),a+=b,++l}return i}),c.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<i.length;++c){const f=i[c];i[c]=be(i[c],a),We(f)}return si(i)}function KT(n){H(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Qm(n,t,e){return n==null?[null]:Array.isArray(n)?n.map(s=>_h(s,t,e-t)):_h(n,t,e-t)}function a$(n,t){return vt(()=>n==null?null:Array.isArray(n)?n.map(e=>a$(e,t)):CV(n,t.dtype==="int32"?t:ne(t,"int32")))}function XT(n,t){const e=[];let s=0,r=null;for(;s<n;)r=s+t,r>=n&&(r=n),e.push([s,r]),s=r;return e}function tU(n){const t=[];n instanceof Vs&&(n=[n]);for(let e=0;e<n.length;++e){const s=n[e];if(s.rank===1)t.push(ob(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function Go(n,t){if(n==null)return;const e=[];if(t instanceof Vs)e.push(t.id);else if(Array.isArray(t))t.forEach(r=>e.push(r.id));else if(t!=null)for(const r in t){const i=t[r];e.push(i.id)}const s=[];if(n instanceof Vs)e.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{e.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const i=n[r];e.indexOf(i.id)===-1&&s.push(i)}s.forEach(r=>{r.isDisposed||r.dispose()})}function uot(n){return n instanceof Vs}function l$(n){return Array.isArray(n)}function bM(n){return!uot(n)&&!l$(n)}function xM(n,t,e,s=!0,r=""){if(t==null||t.length===0){if(n!=null){let o=!1;if(l$(n)&&n.length>0)o=!0;else if(bM(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new lt(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return t.map(o=>null);let i;if(bM(n)){n=n,i=[];for(const o of t){if(n[o]==null)throw new lt(`No data provided for "${o}". Need data for each key in: ${t}`);i.push(n[o])}}else if(l$(n)){if(n=n,n.length!==t.length)throw new lt(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,t.length>1)throw new lt(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=tU(i),e!=null)for(let o=0;o<t.length;++o){if(e[o]==null)continue;const a=i[o];if(a.shape.length!==e[o].length)throw new lt(`Error when checking ${r}: expected ${t[o]} to have ${e[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[o].length;++l){if(l===0&&!s)continue;const c=a.shape[l],f=e[o][l];if(f!=null&&f>=0&&c!==f)throw new lt(`${r} expected a batch of elements where each example has shape [${e[o].slice(1,e[o].length)}] (i.e.,tensor shape [*,${e[o].slice(1,e[o].length)}]) but the ${r} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function cot(n,t,e){const s=tc(n.map(i=>i.shape[0]));s.sort();const r=tc(t.map(i=>i.shape[0]));if(r.sort(),s.length>1)throw new lt(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(r.length>1)throw new lt(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(i=>i.shape))}`);if(s.length>0&&r.length>0&&!mn(s,r))throw new lt(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function hot(n,t,e){const s=[kv,_v,Ng];for(let r=0;r<n.length;++r){const i=n[r],o=t[r],a=e[r];if(o!=null){if(o===Ng&&i.shape[i.shape.length-1]===1)throw new lt(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(o)!==-1){const l=i.shape.slice(1),c=a.slice(1);for(let f=0;f<l.length;++f){const d=l[f],m=c[f];if(m!=null&&d!==m)throw new lt(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function wM(n,t,e,s=!0,r=""){let i;if(Array.isArray(n)){if(n.length!==t.length)throw new lt(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(t.length>1)throw new lt(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(e!=null)for(let o=0;o<t.length;++o){if(e[o]==null)continue;const a=i[o];if(a.shape.length!==e[o].length)throw new lt(`Error when checking ${r}: expected ${t[o]} to have ${e[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[o].length;++l){if(l===0&&!s)continue;const c=a.shape[l],f=e[o][l];if(f!=null&&f!==c)throw new lt(`Error when checking ${r}: expected ${t[o]} to have shape ${JSON.stringify(e[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function fot(n,t){if(n==null||Array.isArray(n)&&n.length===0)return t.map(s=>[]);let e;if(typeof n=="string"||typeof n=="function")e=[n];else if(Array.isArray(n)||typeof n=="object")e=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(e))return t.map(s=>e);{const s=[];for(const r of t){let i=e.hasOwnProperty(r)?e[r]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}const dot="layers-model";let Md=class extends tot{constructor(t){super(t),this.isTraining=!1}summary(t,e,s=console.log){if(!this.built)throw new lt("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Kit(this,t,e,s)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=Hit(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Oc))throw new lt("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const o in t.loss)if(this.outputNames.indexOf(o)===-1)throw new lt(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)t.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),e.push(HT(t.loss[o]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new lt(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(a=>HT(a))}else{const o=HT(t.loss);this.outputs.forEach(a=>{e.push(o)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],l=this.outputNames[o];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const s=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],kh("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const r=fot(t.metrics,this.outputNames),i=(o,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,o])};kh("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=r[o];(c=>{let d,m,y;for(const b of c){if(typeof b=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(b)!==-1){const x=this.internalOutputShapes[o];x[x.length-1]===1||this.lossFunctions[o]===_v?["accuracy","acc"].indexOf(b)!==-1?m=jV:["crossentropy","ce"].indexOf(b)!==-1&&(m=Lit):this.lossFunctions[o]===gx?["accuracy","acc"].indexOf(b)!==-1?m=zit:["crossentropy","ce"].indexOf(b)!==-1&&(m=KV):["accuracy","acc"].indexOf(b)!==-1?m=qV:["crossentropy","ce"].indexOf(b)!==-1&&(m=HV);let S;["accuracy","acc"].indexOf(b)!==-1?S="acc":["crossentropy","ce"].indexOf(b)!==-1&&(S="ce"),y=m,d=""+S}else y=qit(b),d=""+f1(b);let w;kh(d,()=>{w=y}),i(o,d,w)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,s={}){const r=s.batchSize==null?32:s.batchSize;KT(r);const o=this.standardizeUserDataXY(t,e,!0,r);try{const a=o[0].concat(o[1]);this.makeTestFunction();const l=this.testFunction,c=this.testLoop(l,a,r,s.verbose,s.steps);return si(c)}finally{Go(o[0],t),Go(o[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),lot(this,t,e)}checkNumSamples(t,e,s,r="steps"){let i;if(s!=null){if(i=null,e!=null)throw new lt(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?i=t[0].shape[0]:i=t.shape[0];else throw new lt(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new lt("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(e),r=s?e:[e],i=this.retrieveSymbolicTensors(r),o=new _d;if(t instanceof Vs&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new lt(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],t[l])}else for(const l of this.inputs){const c=t[l.name];if(c==null)throw new lt(`No value is provided for the model's input ${l.name}`);o.add(l,c)}const a=sg(i,o);return s?a:a[0]}retrieveSymbolicTensors(t){const e=Hh(null,t.length);let s=t.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],o=i.map(a=>a.name);for(let a=0;a<t.length;++a){const l=o.indexOf(t[a]);if(l!==-1&&(e[a]=i[l],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw e.forEach((i,o)=>{i==null&&r.push(t[o])}),new lt(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return e}predictLoop(t,e=32,s=!1){return vt(()=>{const r=this.checkNumSamples(t);if(s)throw new Be("Verbose predictLoop() is not implemented yet.");const i=XT(r,e),o=this.outputs.map(a=>[]);for(let a=0;a<i.length;++a)vt(()=>{const c=i[a][0],f=i[a][1],d=Qm(t,c,f),m=[];if(Array.isArray(d))for(let b=0;b<d.length;++b)m.push({key:this.inputs[b],value:d[b]});else m.push({key:this.inputs[0],value:d});const y=new _d(m);return sg(this.outputs,y)}).forEach((c,f)=>o[f].push(c));return si(o.map(a=>ii(a,0)))})}predict(t,e={}){const s=tU(t);wM(s,this.inputNames,this.feedInputShapes,!1);try{const r=e.batchSize==null?32:e.batchSize;return KT(r),this.predictLoop(s,r)}finally{Go(s,t)}}predictOnBatch(t){wM(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,s=!0,r){if(this.optimizer_==null)throw new Qa("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===gx?i.push(a.slice(0,a.length-1).concat([1])):i.push(a)}if(t=xM(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=xM(e,this.feedOutputNames,i,!1,"target"),cot(t,e),hot(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&t[0].shape[0]%r!==0)throw new lt(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,s,r,i=!0,o){const[a,l]=this.standardizeUserDataXY(t,e,i,o);if(s!=null)throw new Error("sample weight is not supported yet.");let c=null;if(r!=null){const f=QV(r,this.outputNames);c=[];for(let d=0;d<f.length;++d)c.push(await ZV(l[d],null,f[d]))}return[a,l,c]}testLoop(t,e,s,r=0,i){return vt(()=>{const o=this.checkNumSamples(e,s,i,"steps"),a=[];if(r>0)throw new Be("Verbose mode is not implemented yet.");if(i!=null)throw new Be("steps mode in testLoop() is not implemented yet");{const l=XT(o,s),c=Ti(aa(0,o));for(let f=0;f<l.length;++f){const d=l[f][0],m=l[f][1],y=_h(c,d,m-d),b=a$(e,y),w=t(b);if(f===0)for(let x=0;x<w.length;++x)a.push(dn(0));for(let x=0;x<w.length;++x){const S=w[x];a[x]=Yt(a[x],ct(m-d,S))}}for(let f=0;f<a.length;++f)a[f]=be(a[f],o)}return a})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let s=0;s<t.length;++s){const r=t[s];let i=r;if(rM(t,r)>1){const o=rM(t.slice(0,s),r);i+=`_${o}`}e.push(i)}return e}makeTrainFunction(){return t=>{const e=[],s=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const d=[];for(let w=0;w<this.inputs.length;++w)d.push({key:this.inputs[w],value:s[w]});const m=new _d(d),y=sg(this.outputs,m,{training:!0});let b;for(let w=0;w<this.lossFunctions.length;++w){const x=this.lossFunctions[w];let S=x(r[w],y[w]);i[w]!=null&&(S=not(S,i[w]));const T=$s(S);e.push(T),w===0?b=S:b=Yt(b,S)}for(let w=0;w<this.metricsTensors.length;++w){let x;if(this.outputs.length>1&&w<this.outputs.length)x=e[w];else{const S=this.metricsTensors[w][0],T=this.metricsTensors[w][1];x=$s(S(r[T],y[T]))}nl(x),o.push(x)}return b=$s(b),this.calculateLosses().forEach(w=>{b=Yt(b,w)}),b},l=this.collectedTrainableWeights.map(d=>d.read());return[this.optimizer_.minimize(a,!0,l)].concat(o)}}makeTestFunction(){this.testFunction=t=>vt(()=>{const e=[];let s;const r=t.slice(0,this.inputs.length),i=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let c=0;c<this.inputs.length;++c)o.push({key:this.inputs[c],value:r[c]});const a=new _d(o),l=sg(this.outputs,a);for(let c=0;c<this.lossFunctions.length;++c){const f=this.lossFunctions[c],d=$s(f(i[c],l[c]));c===0?s=d:s=Yt(s,d),e.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const f=this.metricsTensors[c][0],d=this.metricsTensors[c][1],m=$s(f(i[d],l[d]));e.push(m)}return e})}async fit(t,e,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,i,o,a,l,c,f,d,m;try{const y=s.batchSize==null?32:s.batchSize;KT(y);const w=await this.standardizeUserData(t,e,s.sampleWeight,s.classWeight,!1,y);r=w[0],i=w[1],m=w[2];let x=!1,S;if(s.validationData!=null&&s.validationData.length>0){if(x=!0,s.validationData.length===2)l=s.validationData[0],c=s.validationData[1];else throw s.validationData.length===3?new Be("validationData including sample weights is not supported yet."):new lt(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const F=await this.standardizeUserData(l,c,null,null,!0,y);f=F[0],d=F[1],S=f.concat(d)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){x=!0;const _=Math.floor(r[0].shape[0]*(1-s.validationSplit)),F=r[0].shape[0];f=Qm(r,_,F),o=r,r=Qm(r,0,_),d=Qm(i,_,F),a=i,i=Qm(i,0,_),S=f.concat(d)}else s.validationSteps!=null&&(x=!0);const T=r.concat(i).concat(m);this.checkTrainableWeightsConsistency();const $=this.makeTrainFunction(),E=this.getDedupedMetricsNames();let R,B;x?(this.makeTestFunction(),R=this.testFunction,B=E.slice().concat(E.map(_=>"val_"+_))):(R=null,S=[],B=E.slice());const N=VV(s.callbacks,s.yieldEvery);return await this.fitLoop($,T,E,y,s.epochs,s.verbose,N,R,S,s.shuffle,B,s.initialEpoch,null,null)}finally{this.isTraining=!1,Go(r,t),Go(i,e),Go(o,t),Go(a,e),Go(f,l),Go(d,c),m!=null&&We(m)}}async fitLoop(t,e,s,r,i,o,a,l,c,f,d,m,y,b){r==null&&(r=32),i==null&&(i=1),f==null&&(f=!0),m==null&&(m=0);let w=!1;if(l!=null&&c!=null&&(w=!0),b!=null&&(w=!0,y==null))throw new lt("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const x=this.checkNumSamples(e,r,y,"steps_per_epoch");let S;x!=null&&(S=aa(0,x)),o==null&&(o=1);const{callbackList:T,history:$}=GV(a,o,i,m,x,y,r,w,d);T.setModel(this),this.history=$,await T.onTrainBegin(),this.stopTraining_=!1;for(let E=m;E<i;++E){await T.onEpochBegin(E);const R={};if(y!=null)throw new Be("stepsPerEpoch mode is not implemented yet.");{if(f==="batch")throw new Be("batch shuffling is not implemneted yet");f&&LX(S);const B=Ti(S),N=XT(x,r);for(let k=0;k<N.length;++k){const _={};if(await T.onBatchBegin(k,_),vt(()=>{const F=N[k][0],A=N[k][1],P=_h(B,F,A-F);_.batch=k,_.size=A-F;const L=a$(e,P),tt=t(L);for(let st=0;st<s.length;++st){const j=s[st],Z=tt[st];_[j]=Z,nl(Z)}if(k===N.length-1&&w){const st=this.testLoop(l,c,r);for(let j=0;j<s.length;++j){const Z=s[j],J=st[j];nl(J),R["val_"+Z]=J}}}),await T.onBatchEnd(k,_),PV(_),this.stopTraining_)break}B.dispose()}if(await T.onEpochEnd(E,R),this.stopTraining_)break}return await T.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,e){return iot(this,t,e)}async trainOnBatch(t,e){const s=await this.standardizeUserData(t,e),r=s[0],i=s[1],a=this.makeTrainFunction()(r.concat(i)),l=[];for(const c of a){const f=await c.data();l.push(f[0])}return We(a),Go(s[0],t),Go(s[1],e),si(l)}getNamedWeights(t){const e=[],s=t!=null&&t.trainableOnly,r=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let o=0;o<r.length;++o)s&&!r[o].trainable||e.push({name:r[o].originalName,tensor:i[o]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const e=NF().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-NF().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=Pl(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>Pl(e))}else{const e=Object.keys(this.loss);t={};const s=this.loss;for(const r of e)if(typeof s[r]=="string")t[r]=Pl(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Pl(f1(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>Pl(f1(t)));{const t={};for(const e in this.metrics)t[e]=Pl(f1(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const e=i$(t.optimizer_config),s=ql(e);let r;if(typeof t.loss=="string")r=xh(t.loss);else if(Array.isArray(t.loss))r=t.loss.map(o=>xh(o));else if(t.loss!=null){r={};for(const o in t.loss)r[o]=xh(t.loss[o])}let i;if(Array.isArray(t.metrics))i=t.metrics.map(o=>xh(o));else if(t.metrics!=null){i={};for(const o in t.metrics)i[o]=xh(t.metrics[o])}this.compile({loss:r,metrics:i,optimizer:s})}async save(t,e){if(typeof t=="string"){const c=VY(t);if(c.length===0)throw new lt(`Cannot find any save handlers for URL '${t}'`);if(c.length>1)throw new lt(`Found more than one (${c.length}) save handlers for URL '${t}'`);t=c[0]}if(t.save==null)throw new lt("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await DF(this.getNamedWeights(e)),a={modelTopology:this.toJSON(null,!1),format:dot,generatedBy:`TensorFlow.js tfjs-layers v${YV}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:f,specs:d}=await DF(await this.optimizer.getWeights(),c);s.specs.push(...d),s.data=PY([s.data,f])}return this.userDefinedMetadata!=null&&(mM(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=s.data,a.weightSpecs=s.specs,t.save(a)}setUserDefinedMetadata(t){mM(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}};Md.className="Model";Ht(Md);let eU=class extends Md{};eU.className="Functional";Ht(eU);let nU=class u$ extends Md{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:Ev("sequential_"),t.layers!=null)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new lt(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof u$||t instanceof Md;let s;if(e){if(s=t,s.outputs.length!==1)throw new lt("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new lt("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new lt("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=pit({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(r)}if(e)this.outputs=s.outputs,this.inputs=s.inputs;else{if(t.inboundNodes.length!==1)throw new lt(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new lt("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=OV(this.outputs[0])}this.inboundNodes=[],new Av({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Hh(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=t.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(ln(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Md({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,s=console.log){this.built||this.build(),super.summary(t,e,s)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,s={}){if(!this.built)throw new Qa("The model needs to be compiled before being used.");return this.model.evaluate(t,e,s)}async evaluateDataset(t,e){if(!this.built)throw new Qa("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,s={}){if(!this.built)throw new Qa("The model needs to be compiled before being used.");return this.model.fit(t,e,s)}async fitDataset(t,e){if(!this.built)throw new Qa("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,s={},r=!1){let i,o={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new lt("Legacy serialization format not supported yet.");i=e}else H(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=e.layers,delete e.layers,o=e;const a=new t(o);if(!(a instanceof u$))throw new Be(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of i){const f=ql(l,void 0,r);r&&f.setFastWeightInitDuringBuild(!0),a.add(f)}return a}set stopTraining(t){if(this.model==null)throw new lt("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new lt("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const s={};s.className=e.getClassName(),s.config=e.getConfig(),t.push(s)}return{name:this.name,layers:t}}};nU.className="Sequential";Ht(nU);let Fr=class extends Ip{getConfig(){return{}}},sU=class extends Fr{apply(t,e=1){return Zrt(t,e)}};sU.className="elu";Ht(sU);let rU=class extends Fr{apply(t){return d4(t)}};rU.className="selu";Ht(rU);let iU=class extends Fr{apply(t){return cf(t)}};iU.className="relu";Ht(iU);let oU=class extends Fr{apply(t){return vt(()=>Ag(6,cf(t)))}};oU.className="relu6";Ht(oU);let aU=class extends Fr{apply(t){return t}};aU.className="linear";Ht(aU);let lU=class extends Fr{apply(t){return wp(t)}};lU.className="sigmoid";Ht(lU);let uU=class extends Fr{apply(t){return tit(t)}};uU.className="hardSigmoid";Ht(uU);let cU=class extends Fr{apply(t){return Zy(t)}};cU.className="softplus";Ht(cU);let hU=class extends Fr{apply(t){return Jrt(t)}};hU.className="softsign";Ht(hU);let fU=class extends Fr{apply(t){return gv(t)}};fU.className="tanh";Ht(fU);let Tk=class extends Fr{apply(t,e=-1){return AA(t,e)}};Tk.className="softmax";Ht(Tk);let dU=class extends Fr{apply(t,e=-1){return i4(t,e)}};dU.className="logSoftmax";Ht(dU);class pU extends Fr{apply(t){return vt(()=>vt(()=>{const e=Math.sqrt(2),s=ct(.5,Yt(1,t4(be(t,e))));return ct(t,s)}))}}pU.className="gelu";Ht(pU);class mU extends Fr{apply(t){return vt(()=>ct(.5,ct(t,Yt(1,gv(ct(Dr(be(2,Math.PI)),Yt(t,ct(.044715,Wh(t,3)))))))))}}mU.className="gelu_new";Ht(mU);let gU=class extends Fr{apply(t){return vt(()=>ct(t,gv(Zy(t))))}};gU.className="mish";Ht(gU);let yU=class extends Fr{apply(t,e=1){return vt(()=>ct(wp(ct(t,e)),t))}};yU.className="swish";Ht(yU);function cc(n){return n.getClassName()}function YT(n,t={}){return ib(n,Tp.getMap().classNameMap,t,"activation")}function hc(n){if(n==null){const t={};return t.className="linear",t.config={},YT(t)}if(typeof n=="string"){const t={};return t.className=n,t.config={},YT(t)}else return n instanceof Fr?n:YT(n)}function pot(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}let bU=class extends Ip{},xU=class extends bU{constructor(t){super(),pot(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return vt(()=>{let e=sr([1]);return this.hasL1&&(e=Yt(e,me(ct(this.l1,Ur(t))))),this.hasL2&&(e=Yt(e,me(ct(this.l2,ab(t))))),gt(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}};xU.className="L1L2";Ht(xU);const vM={l1l2:"L1L2"};function Mn(n){return ck(n)}function SM(n,t={}){return ib(n,Tp.getMap().classNameMap,t,"regularizer")}function ns(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in vM?vM[n]:n,config:{}};return SM(e)}else return n instanceof bU?n:SM(n)}let wU=class extends Ue{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=Te(t);let s=cf(t);return this.maxValue!=null&&(s=Hi(s,0,this.maxValue)),s}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}};wU.className="ReLU";Ht(wU);let vU=class extends Ue{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=Te(t);return xA(s,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};vU.className="LeakyReLU";Ht(vU);let SU=class extends Ue{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=Jn(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=ns(t.alphaRegularizer),this.alphaConstraint=Xs(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new lt(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=ln(t);const e=t.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)e[r-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<t.length;++r)s[r]=t[r];this.inputSpec=[new Ws({ndim:t.length,axes:s})],this.built=!0}call(t,e){return t=Te(t),CA(t,this.alpha.read())}getConfig(){const t={alphaInitializer:us(this.alphaInitializer),alphaRegularizer:Mn(this.alphaRegularizer),alphaConstraint:Ks(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}};SU.className="PReLU";Ht(SU);let IU=class extends Ue{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new Be(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=Te(t);return xv(s)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};IU.className="ELU";Ht(IU);let TU=class extends Ue{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){const s=Te(t);return ct(s,ne(Ki(s,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}};TU.className="ThresholdedReLU";Ht(TU);let CU=class extends Ue{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new Tk().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){return vt(()=>{let s=Te(t);const r=e.mask;if(r!=null){const i=ct(Se(Dc(s.shape),ne(r,s.dtype)),dn(-1e9));s=Yt(s,i)}return this.axis instanceof Array?this.axis.length>1?fl(Se(s,o4(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}};CU.className="Softmax";Ht(CU);function Ld(n,t,e){if(typeof n=="number")return Hh(n,t);if(n.length!==t)throw new lt(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let s=0;s<t;++s){const r=n[s];if(!Krt(r))throw new lt(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function ea(n,t,e,s,r=1){if(n==null)return n;const i=t+(t-1)*(r-1);let o;return e==="same"?o=n:o=n-i+1,Math.floor((o+s-1)/s)}function qa(n,t,e,s){if(n==null)return null;if(s==="valid")n=n*t+uc([e-t,0]);else if(s==="same")n=n*t;else throw new lt(`Unsupport padding mode: ${s}.`);return n}function Ck(n,t){return vt(()=>(ws(t),t==="channelsFirst"?en(n,[0,2,3,1]):n))}function EU(n,t){return vt(()=>(ws(t),t==="channelsFirst"?en(n,[0,2,3,4,1]):n))}function mot(n,t,e,s=1,r="valid",i,o=1){return vt(()=>{if(i==null&&(i=la()),ws(i),n.shape.length!==3)throw new lt(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(t.shape.length!==3)throw new lt(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new lt(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(i==="channelsFirst"&&(n=en(n,[0,2,1])),r==="causal")throw new Be("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=XP(n,t,s,r==="same"?"same":"valid","NWC",o);return e!=null&&(a=ma(a,e)),a})}function IM(n,t,e,s=[1,1],r="valid",i,o,a=null){return vt(()=>{if(i==null&&(i=la()),ws(i),n.rank!==3&&n.rank!==4)throw new lt(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(t.rank!==3&&t.rank!==4)throw new lt(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=Ck(n,i);if(r==="causal")throw new Be("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=vet({x:l,filter:t,strides:s,pad:r==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:e,activation:a}),i==="channelsFirst"&&(l=en(l,[0,3,1,2])),l})}function got(n,t,e,s=[1,1,1],r="valid",i,o){return vt(()=>{if(i==null&&(i=la()),ws(i),n.rank!==4&&n.rank!==5)throw new lt(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(t.rank!==4&&t.rank!==5)throw new lt(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=EU(n,i);if(r==="causal")throw new Be("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=yZ(a,t,s,r==="same"?"same":"valid","NDHWC",o),e!=null&&(a=ma(a,e)),i==="channelsFirst"&&(a=en(a,[0,4,1,2,3])),a})}let $U=class AU extends Ue{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",AU.verifyArgs(e),this.rank=t,rr(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Be(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Ld(e.kernelSize,t,"kernelSize"),this.strides=Ld(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,Xi(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ws(this.dataFormat),this.activation=hc(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=Jn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Xs(e.biasConstraint),this.biasRegularizer=ns(e.biasRegularizer),this.activityRegularizer=ns(e.activityRegularizer),this.dilationRate=Ld(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new lt(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new lt(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new lt(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(ja("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!hk(t.kernelSize,"number",1,3))throw new lt(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:cc(this.activation),useBias:this.useBias,biasInitializer:us(this.biasInitializer),biasRegularizer:Mn(this.biasRegularizer),activityRegularizer:Mn(this.activityRegularizer),biasConstraint:Ks(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}},Nv=class kU extends $U{constructor(t,e){super(t,e),this.kernel=null,kU.verifyArgs(e),this.filters=e.filters,rr(this.filters,"filters"),this.kernelInitializer=Jn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Xs(e.kernelConstraint),this.kernelRegularizer=ns(e.kernelRegularizer)}build(t){t=ln(t);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new lt(`The channel dimension of the input should be defined. Found ${t[e]}`);const s=t[e],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:s}}],this.built=!0}call(t,e){return vt(()=>{t=Te(t);let s;const r=this.bias==null?null:this.bias.read(),i=xV(this.activation.getClassName());if(i!=null&&this.rank===2)s=IM(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)s=mot(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=IM(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=got(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Be("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(t){t=ln(t);const e=[],s=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let i=0;i<s.length;++i){const o=ea(s[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);e.push(o)}let r=[t[0]];return this.dataFormat==="channelsLast"?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:us(this.kernelInitializer),kernelRegularizer:Mn(this.kernelRegularizer),kernelConstraint:Ks(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new lt(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},Ek=class _U extends Nv{constructor(t){super(2,t),_U.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!hk(t.kernelSize,"number",1,2))throw new lt(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};Ek.className="Conv2D";Ht(Ek);let $k=class NU extends Nv{constructor(t){super(3,t),NU.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new lt(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};$k.className="Conv3D";Ht($k);let RU=class extends Ek{constructor(t){if(super(t),this.inputSpec=[new Ws({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new lt(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=ln(t),t.length!==4)throw new lt("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new lt("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ws({ndim:4,axes:{[e]:s}})],this.built=!0}call(t,e){return vt(()=>{let s=Te(t);if(s.shape.length!==4)throw new lt(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const l=r[o],c=r[a],f=this.kernelSize[0],d=this.kernelSize[1],m=this.strides[0],y=this.strides[1],b=qa(l,m,f,this.padding),w=qa(c,y,d,this.padding),x=[i,b,w,this.filters];this.dataFormat!=="channelsLast"&&(s=en(s,[0,2,3,1]));let S=YP(s,this.kernel.read(),x,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(S=en(S,[0,3,1,2])),this.bias!=null&&(S=ma(S,this.bias.read(),this.dataFormat)),this.activation!=null&&(S=this.activation.apply(S)),S})}computeOutputShape(t){t=ln(t);const e=t.slice();let s,r,i;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3):(s=3,r=1,i=2);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return e[s]=this.filters,e[r]=qa(e[r],l,o,this.padding),e[i]=qa(e[i],c,a,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}};RU.className="Conv2DTranspose";Ht(RU);let DU=class extends $k{constructor(t){if(super(t),this.inputSpec=[new Ws({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new lt(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=ln(t),t.length!==5)throw new lt("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new lt("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ws({ndim:5,axes:{[e]:s}})],this.built=!0}call(t,e){return vt(()=>{let s=Te(t);if(s.shape.length!==5)throw new lt(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,a,l;this.dataFormat==="channelsFirst"?(l=2,o=3,a=4):(l=1,o=2,a=3);const c=r[l],f=r[o],d=r[a],m=this.kernelSize[0],y=this.kernelSize[1],b=this.kernelSize[2],w=this.strides[0],x=this.strides[1],S=this.strides[2],T=qa(c,w,m,this.padding),$=qa(f,x,y,this.padding),E=qa(d,S,b,this.padding),R=[i,T,$,E,this.filters];this.dataFormat!=="channelsLast"&&(s=en(s,[0,2,3,4,1]));let B=wZ(s,this.kernel.read(),R,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(B=en(B,[0,4,1,2,3])),this.bias!==null&&(B=ma(B,this.bias.read(),this.dataFormat)),this.activation!==null&&(B=this.activation.apply(B)),B})}computeOutputShape(t){t=ln(t);const e=t.slice();let s,r,i,o;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3,o=4):(s=4,r=1,i=2,o=3);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],f=this.strides[0],d=this.strides[1],m=this.strides[2];return e[s]=this.filters,e[r]=qa(e[r],f,a,this.padding),e[i]=qa(e[i],d,l,this.padding),e[o]=qa(e[o],m,c,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}};DU.className="Conv3DTranspose";Ht(DU);let OU=class extends Nv{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new lt("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new lt("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new lt(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Jn(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=ns(e.depthwiseRegularizer),this.depthwiseConstraint=Xs(e.depthwiseConstraint),this.pointwiseInitializer=Jn(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=ns(e.pointwiseRegularizer),this.pointwiseConstraint=Xs(e.pointwiseConstraint)}build(t){if(t=ln(t),t.length<this.rank+2)throw new lt(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new lt(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const s=t[e],r=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let a=0;a<this.rank;++a)i.push(1);i.push(s*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new Ws({ndim:this.rank+2,axes:{[e]:s}})],this.built=!0}call(t,e){return vt(()=>{t=Te(t);let s;if(this.rank===1)throw new Be("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=en(t,[0,2,3,1])),s=p4(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=ma(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=en(s,[0,3,1,2])),s})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=us(this.depthwiseInitializer),t.pointwiseInitializer=us(this.pointwiseInitializer),t.depthwiseRegularizer=Mn(this.depthwiseRegularizer),t.pointwiseRegularizer=Mn(this.pointwiseRegularizer),t.depthwiseConstraint=Ks(this.depthwiseConstraint),t.pointwiseConstraint=Ks(this.pointwiseConstraint),t}};OU.className="SeparableConv";let FU=class extends OU{constructor(t){super(2,t)}};FU.className="SeparableConv2D";Ht(FU);let MU=class LU extends Nv{constructor(t){super(1,t),LU.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!hk(t.kernelSize,"number",1,1))throw new lt(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};MU.className="Conv1D";Ht(MU);let zU=class extends Ue{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return vt(()=>{if(t=Te(t),this.dataFormat==="channelsLast"){const s=h1(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return h1(s,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=h1(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return h1(s,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};zU.className="Cropping2D";Ht(zU);let BU=class extends Ue{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ws(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,jrt(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const e=t[2]==null?null:this.size[0]*t[2],s=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,s]}else{const e=t[1]==null?null:this.size[0]*t[1],s=t[2]==null?null:this.size[1]*t[2];return[t[0],e,s,t[3]]}}call(t,e){return vt(()=>{let s=Te(t);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=en(s,[0,2,3,1]);const i=this.size[0]*r[2],o=this.size[1]*r[3],a=this.interpolation==="nearest"?jl.resizeNearestNeighbor(s,[i,o]):jl.resizeBilinear(s,[i,o]);return en(a,[0,3,1,2])}else{const i=this.size[0]*r[1],o=this.size[1]*r[2];return this.interpolation==="nearest"?jl.resizeNearestNeighbor(s,[i,o]):jl.resizeBilinear(s,[i,o])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}};BU.className="UpSampling2D";Ht(BU);function yot(n,t,e=[1,1],s="valid",r,i){return vt(()=>{r==null&&(r=la()),ws(r);let o=Ck(n,r);if(n.rank!==4)throw new lt(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(t.rank!==4)throw new lt(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=mA(o,t,e,s==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(o=en(o,[0,3,1,2])),o})}let PU=class extends $U{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Jn(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Xs(t.depthwiseConstraint),this.depthwiseRegularizer=ns(t.depthwiseRegularizer)}build(t){if(t=ln(t),t.length<4)throw new lt(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new lt(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const s=t[e],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return vt(()=>{t=Te(t);let s=yot(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=ma(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(t){t=ln(t);const e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,i=ea(e,this.kernelSize[0],this.padding,this.strides[0]),o=ea(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],r,i,o]:[t[0],i,o,r]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=us(this.depthwiseInitializer),t.depthwiseRegularizer=Mn(this.depthwiseRegularizer),t.depthwiseConstraint=Ks(this.depthwiseRegularizer),t}};PU.className="DepthwiseConv2D";Ht(PU);function VU(n,t,e,s){if(Array.isArray(n)){if(t!=null||e!=null)throw new lt("When inputs is an array, neither initialState or constants should be provided");s!=null&&(e=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return t=r(t),e=r(e),{inputs:n,initialState:t,constants:e}}function UU(n,t,e,s=!1,r,i,o=!1,a=!1){return vt(()=>{const l=t.shape.length;if(l<3)throw new lt(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(aa(2,l));t=en(t,c),o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=ne(ne(r,"bool"),"float32"),r.rank===l-1&&(r=ni(r,-1)),r=en(r,c)),s&&(t=jh(t,0),r!=null&&(r=jh(r,0)));const f=[];let d,m=e;const y=t.shape[0],b=qh(t);let w;r!=null&&(w=qh(r));for(let S=0;S<y;++S){const T=b[S],$=vt(()=>n(T,m));if(r==null)d=$[0],m=$[1];else{const E=vt(()=>{const R=w[S],B=Se(Io(R),R),N=Yt(ct($[0],R),ct(m[0],B)),k=m.map((_,F)=>Yt(ct($[1][F],R),ct(_,B)));return{output:N,newStates:k}});d=E.output,m=E.newStates}a&&f.push(d)}let x;return a&&(x=Ql(f,1)),[d,x,m]})}let Cp=class GU extends Ue{constructor(t){super(t);let e;if(t.cell==null)throw new lt("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new _k({cells:t.cell}):e=t.cell,e.stateSize==null)throw new lt("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Ws({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return aa(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){n$(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const s=e[0];let r;if(this.returnSequences?r=[t[0],t[1],s]:r=[t[0],s],this.returnState){const i=[];for(const o of e)i.push([t[0],o]);return[r].concat(i)}else return r}computeMask(t,e){return vt(()=>{Array.isArray(e)&&(e=e[0]);const s=this.returnSequences?e:null;if(this.returnState){const r=this.states.map(i=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let s=0;s<t;++s)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Be("Constants support is not implemented in RNN yet.");n$(t)&&(t=t[0]),t=t;const e=this.stateful?t[0]:null,s=t.slice(2);this.inputSpec[0]=new Ws({shape:[e,null,...s]});const r=[t[0]].concat(t.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!mn(this.stateSpec.map(o=>o.shape[o.shape.length-1]),i))throw new lt(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(o=>new Ws({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){vt(()=>{if(!this.stateful)throw new Wu("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new lt("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>sr([s,r])):this.states_=[sr([s,this.cell.stateSize])];else if(t==null)We(this.states_),this.keptStates!=null&&(We(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>sr([s,r])):this.states_[0]=sr([s,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new lt(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):We(this.states_);for(let r=0;r<this.states_.length;++r){const i=t[r],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,a=[s,o];if(!mn(i.shape,a))throw new lt(`State ${r} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>nl(r.clone()))})}apply(t,e){let s=e==null?null:e.initialState,r=e==null?null:e.constants;e==null&&(e={});const i=VU(t,s,r,this.numConstants);t=i.inputs,s=i.initialState,r=i.constants;let o=[],a=[];if(s!=null){e.initialState=s,o=o.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new Ws({shape:c.shape}));a=a.concat(this.stateSpec)}if(r!=null&&(e.constants=r,o=o.concat(r),this.numConstants=r.length),o[0]instanceof pl){const c=[t].concat(o),f=this.inputSpec.concat(a),d=this.inputSpec;this.inputSpec=f;const m=super.apply(c,e);return this.inputSpec=d,m}else return super.apply(t,e)}call(t,e){return vt(()=>{const s=e==null?null:e.mask,r=e==null?null:e.training;let i=e==null?null:e.initialState;t=Te(t),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(t));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new lt(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:r},c=UU((b,w)=>{const x=this.cell.call([b].concat(w),a);return[x[0],x.slice(1)]},t,i,this.goBackwards,s,null,this.unroll,this.returnSequences),f=c[0],d=c[1],m=c[2];this.stateful&&this.resetStates(m,r);const y=this.returnSequences?d:f;return this.returnState?[y].concat(m):y})}getInitialState(t){return vt(()=>{let e=sr(t.shape);return e=me(e,[1,2]),e=ob(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?t$(e,[1,s]):e):this.cell.stateSize>1?[t$(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===GU.className&&(e.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),t),e)}static fromConfig(t,e,s={}){const r=e.cell,i=ql(r,s);return new t(Object.assign(e,{cell:i}))}};Cp.className="RNN";Ht(Cp);let Rv=class extends Ue{},Ak=class extends Rv{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,rr(this.units,"units"),this.activation=hc(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Jn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Jn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Jn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ns(t.kernelRegularizer),this.recurrentRegularizer=ns(t.recurrentRegularizer),this.biasRegularizer=ns(t.biasRegularizer),this.kernelConstraint=Xs(t.kernelConstraint),this.recurrentConstraint=Xs(t.recurrentConstraint),this.biasConstraint=Xs(t.biasConstraint),this.dropout=Kd([1,uc([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Kd([1,uc([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=ln(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return vt(()=>{if(t=t,t.length!==2)throw new lt(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let s=t[1];t=t[0];const r=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=fc({ones:()=>Io(t),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=fc({ones:()=>Io(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?i=il(ct(t,o),this.kernel.read()):i=il(t,this.kernel.read()),this.bias!=null&&(i=ma(i,this.bias.read())),a!=null&&(s=ct(s,a));let l=Yt(i,il(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:cc(this.activation),useBias:this.useBias,kernelInitializer:us(this.kernelInitializer),recurrentInitializer:us(this.recurrentInitializer),biasInitializer:us(this.biasInitializer),kernelRegularizer:Mn(this.kernelRegularizer),recurrentRegularizer:Mn(this.recurrentRegularizer),biasRegularizer:Mn(this.biasRegularizer),activityRegularizer:Mn(this.activityRegularizer),kernelConstraint:Ks(this.kernelConstraint),recurrentConstraint:Ks(this.recurrentConstraint),biasConstraint:Ks(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}};Ak.className="SimpleRNNCell";Ht(Ak);let WU=class extends Cp{constructor(t){t.cell=new Ak(t),super(t)}call(t,e){return vt(()=>{this.cell.dropoutMask!=null&&(We(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(We(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}static fromConfig(t,e){return new t(e)}};WU.className="SimpleRNN";Ht(WU);let kk=class extends Rv{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new lt("GRUCell does not support reset_after parameter set to true.");this.units=t.units,rr(this.units,"units"),this.activation=hc(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=hc(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Jn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Jn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Jn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ns(t.kernelRegularizer),this.recurrentRegularizer=ns(t.recurrentRegularizer),this.biasRegularizer=ns(t.biasRegularizer),this.kernelConstraint=Xs(t.kernelConstraint),this.recurrentConstraint=Xs(t.recurrentConstraint),this.biasConstraint=Xs(t.biasConstraint),this.dropout=Kd([1,uc([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Kd([1,uc([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=ln(t);const e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return vt(()=>{if(t=t,t.length!==2)throw new lt(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training==null?!1:e.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=fc({ones:()=>Io(t),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=fc({ones:()=>Io(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,c;0<this.dropout&&this.dropout<1&&(t=ct(t,i[0]));let f=il(t,this.kernel.read());this.useBias&&(f=ma(f,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ct(r,o[0]));const d=this.recurrentKernel.read(),[m,y]=ji(d,[2*this.units,this.units],d.rank-1),b=il(r,m),[w,x,S]=ji(f,3,f.rank-1),[T,$]=ji(b,2,b.rank-1);a=this.recurrentActivation.apply(Yt(w,T)),l=this.recurrentActivation.apply(Yt(x,$));const E=il(ct(l,r),y);c=this.activation.apply(Yt(S,E));const R=Yt(ct(a,r),ct(Yt(1,ys(a)),c));return[R,R]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:cc(this.activation),recurrentActivation:cc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:us(this.kernelInitializer),recurrentInitializer:us(this.recurrentInitializer),biasInitializer:us(this.biasInitializer),kernelRegularizer:Mn(this.kernelRegularizer),recurrentRegularizer:Mn(this.recurrentRegularizer),biasRegularizer:Mn(this.biasRegularizer),activityRegularizer:Mn(this.activityRegularizer),kernelConstraint:Ks(this.kernelConstraint),recurrentConstraint:Ks(this.recurrentConstraint),biasConstraint:Ks(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}};kk.className="GRUCell";Ht(kk);let jU=class extends Cp{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new kk(t),super(t)}call(t,e){return vt(()=>{this.cell.dropoutMask!=null&&(We(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(We(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};jU.className="GRU";Ht(jU);let Dv=class extends Rv{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,rr(this.units,"units"),this.activation=hc(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=hc(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Jn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Jn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Jn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=ns(t.kernelRegularizer),this.recurrentRegularizer=ns(t.recurrentRegularizer),this.biasRegularizer=ns(t.biasRegularizer),this.kernelConstraint=Xs(t.kernelConstraint),this.recurrentConstraint=Xs(t.recurrentConstraint),this.biasConstraint=Xs(t.biasConstraint),this.dropout=Kd([1,uc([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Kd([1,uc([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=ln(t);const s=t[t.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;r=new(e=class extends Ao{apply(l,c){const f=i.apply([o]),d=new dk().apply([o]),m=i.apply([o*2]);return oM(oM(f,d),m)}},e.className="CustomInit",e)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return vt(()=>{const s=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new lt(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let r=t[1];const i=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=fc({ones:()=>Io(t),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=fc({ones:()=>Io(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let l,c,f,d;0<this.dropout&&this.dropout<1&&(t=ct(t,o[0]));let m=il(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ct(r,a[0])),m=Yt(m,il(r,this.recurrentKernel.read())),this.useBias&&(m=ma(m,this.bias.read()));const[y,b,w,x]=ji(m,4,m.rank-1);l=this.recurrentActivation.apply(y),c=this.recurrentActivation.apply(b),f=Yt(ct(c,i),ct(l,this.activation.apply(w))),d=this.recurrentActivation.apply(x);const S=ct(d,this.activation.apply(f));return[S,S,f]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:cc(this.activation),recurrentActivation:cc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:us(this.kernelInitializer),recurrentInitializer:us(this.recurrentInitializer),biasInitializer:us(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Mn(this.kernelRegularizer),recurrentRegularizer:Mn(this.recurrentRegularizer),biasRegularizer:Mn(this.biasRegularizer),activityRegularizer:Mn(this.activityRegularizer),kernelConstraint:Ks(this.kernelConstraint),recurrentConstraint:Ks(this.recurrentConstraint),biasConstraint:Ks(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}};Dv.className="LSTMCell";Ht(Dv);let qU=class extends Cp{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new Dv(t),super(t)}call(t,e){return vt(()=>{this.cell.dropoutMask!=null&&(We(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(We(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};qU.className="LSTM";Ht(qU);let _k=class extends Rv{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return vt(()=>{t=t;let s=t.slice(1);const r=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?r.push(s.splice(0,a.stateSize.length)):r.push(s.splice(0,1));r.reverse();const i=[];let o;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];s=r[a],a===0?o=[t[0]].concat(s):o=[o[0]].concat(s),o=l.call(o,e),i.push(o.slice(1))}s=[];for(const a of i.slice().reverse())s.push(...a);return[o[0]].concat(s)})}build(t){n$(t)&&(t=t[0]),t=t;let e;this.cells.forEach((s,r)=>{kh(`RNNCell_${r}`,()=>{s.build(t),Array.isArray(s.stateSize)?e=s.stateSize[0]:e=s.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e=i=>({className:i.getClassName(),config:i.getConfig()}),r={cells:this.cells.map(e)};return Object.assign(Object.assign({},t),r)}static fromConfig(t,e,s={}){const r=[];for(const i of e.cells)r.push(ql(i,s));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.cells)e.push(...s.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return s$(t)}setWeights(t){const e=[];for(const s of this.cells){const r=s.weights.length,i=t.splice(r);for(let o=0;o<s.weights.length;++o)e.push([s.weights[o],i[o]])}wk(e)}};_k.className="StackedRNNCells";Ht(_k);function fc(n){const{ones:t,rate:e,training:s=!1,count:r=1,dropoutFunc:i}=n,o=()=>i!=null?i(t(),e):EV(t(),e),a=()=>lb(o,t,s);return!r||r<=1?nl(a().clone()):Array(r).fill(void 0).map(a).map(c=>nl(c.clone()))}var bot=function(n,t){var e={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&t.indexOf(s)<0&&(e[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)t.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(e[s[r]]=n[s[r]]);return e};let HU=class extends Cp{constructor(t){if(t.unroll)throw new Be("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new Be("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new Ws({ndim:5})]}call(t,e){return vt(()=>{if(this.cell.dropoutMask!=null&&(We(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(We(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new lt("ConvRNN2D cell does not support constants");const s=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return vt(()=>{const{stateSize:e}=this.cell,s=t.shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)],o=sr(i);return Array.isArray(e)?Array(e.length).fill(o):[o]})}resetStates(t,e=!1){vt(()=>{if(!this.stateful)throw new Wu("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)];if(s[0]==null)throw new lt("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>sr(i)):this.states_=[sr(i)];else if(t==null)We(this.states_),this.keptStates!=null&&(We(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>sr(i)):this.states_[0]=sr(i);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new lt(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):We(this.states_);for(let a=0;a<this.states_.length;++a){const l=t[a],c=i;if(!mn(l.shape,c))throw new lt(`State ${a} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>nl(a.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:s,kernelSize:r,padding:i,strides:o,dilationRate:a}=this.cell,l=e==="channelsFirst",c=t[l?3:2],f=t[l?4:3],d=ea(c,r[0],i,o[0],a[0]),m=ea(f,r[1],i,o[1],a[1]);return[...t.slice(0,2),...l?[s,d,m]:[d,m,s]]}};HU.className="ConvRNN2D";let Nk=class extends Dv{constructor(t){const{filters:e,kernelSize:s,strides:r,padding:i,dataFormat:o,dilationRate:a}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,rr(this.filters,"filters"),this.kernelSize=Ld(s,2,"kernelSize"),this.kernelSize.forEach(l=>rr(l,"kernelSize")),this.strides=Ld(r||1,2,"strides"),this.strides.forEach(l=>rr(l,"strides")),this.padding=i||"valid",Xi(this.padding),this.dataFormat=o||"channelsLast",ws(this.dataFormat),this.dilationRate=Ld(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>rr(l,"dilationRate"))}build(t){var e;t=ln(t);const s=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[s]==null)throw new lt(`The channel dimension of the input should be defined. Found ${t[s]}`);const r=t[s],i=4,o=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const c=this.biasInitializer,f=this.filters;l=new(e=class extends Ao{apply(m,y){const b=c.apply([f]),w=Dc([f]),x=c.apply([f*2]);return fk([b,w,x])}},e.className="CustomInit",e)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return vt(()=>{if(t.length!==3)throw new lt(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training||!1,r=t[0],i=t[1],o=t[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=fc({ones:()=>Io(r),rate:this.dropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=(pt,q,et)=>!q||!q[et]?pt:ct(q[et],pt);let f=c(r,l,0),d=c(r,l,1),m=c(r,l,2),y=c(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=fc({ones:()=>Io(i),rate:this.recurrentDropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const b=this.recurrentDropoutMask;let w=c(i,b,0),x=c(i,b,1),S=c(i,b,2),T=c(i,b,3);const $=3,[E,R,B,N]=ji(this.kernel.read(),a,$),[k,_,F,A]=this.useBias?ji(this.bias.read(),a):[null,null,null,null];f=this.inputConv(f,E,k,this.padding),d=this.inputConv(d,R,_,this.padding),m=this.inputConv(m,B,F,this.padding),y=this.inputConv(y,N,A,this.padding);const[P,L,tt,st]=ji(this.recurrentKernel.read(),a,$);w=this.recurrentConv(w,P),x=this.recurrentConv(x,L),S=this.recurrentConv(S,tt),T=this.recurrentConv(T,st);const j=this.recurrentActivation.apply(Yt(f,w)),Z=this.recurrentActivation.apply(Yt(d,x)),J=Yt(ct(Z,o),ct(j,this.activation.apply(Yt(m,S)))),ot=ct(this.recurrentActivation.apply(Yt(y,T)),this.activation.apply(J));return[ot,ot,J]})}getConfig(){const t=super.getConfig(),{units:e}=t,s=bot(t,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(t,e,s,r){const i=Gh(t,e,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?ma(i,s,this.dataFormat):i}recurrentConv(t,e){return Gh(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};Nk.className="ConvLSTM2DCell";Ht(Nk);let KU=class extends HU{constructor(t){const e=new Nk(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}};KU.className="ConvLSTM2D";Ht(KU);let Rk=class extends Ue{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const e=t.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?e[r]:this.noiseShape[r]);return s}call(t,e){return vt(()=>{this.invokeCallHook(t,e);const s=Te(t);if(0<this.rate&&this.rate<1){const r=e.training==null?!1:e.training,i=this.getNoiseShape(s);return lb(()=>EV(s,this.rate,i,this.seed),()=>s,r)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}};Rk.className="Dropout";Ht(Rk);let XU=class extends Rk{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}};XU.className="SpatialDropout1D";Ht(XU);let YU=class extends Ue{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,rr(this.units,"units"),this.activation=hc(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=Jn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Jn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Xs(t.kernelConstraint),this.biasConstraint=Xs(t.biasConstraint),this.kernelRegularizer=ns(t.kernelRegularizer),this.biasRegularizer=ns(t.biasRegularizer),this.activityRegularizer=ns(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=ln(t);const e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=ln(t);const e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return vt(()=>{this.invokeCallHook(t,e);const s=Te(t),r=xV(this.activation.getClassName());let i;return r!=null?i=il(s,this.kernel.read(),r,this.bias?this.bias.read():null):(i=il(s,this.kernel.read()),this.bias!=null&&(i=ma(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const t={units:this.units,activation:cc(this.activation),useBias:this.useBias,kernelInitializer:us(this.kernelInitializer),biasInitializer:us(this.biasInitializer),kernelRegularizer:Mn(this.kernelRegularizer),biasRegularizer:Mn(this.biasRegularizer),activityRegularizer:Mn(this.activityRegularizer),kernelConstraint:Ks(this.kernelConstraint),biasConstraint:Ks(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}};YU.className="Dense";Ht(YU);let QU=class extends Ue{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=ln(t);for(const e of t.slice(1))if(e==null)throw new lt(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],ec(t,1)]}call(t,e){return vt(()=>{this.invokeCallHook(t,e);let s=Te(t);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let i=2;i<s.rank;++i)r.push(i);r.push(1),s=en(s,r)}return Qrt(s)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}};QU.className="Flatten";Ht(QU);let ZU=class extends Ue{constructor(t){super(t),this.supportsMasking=!0,this.activation=hc(t.activation)}call(t,e){return vt(()=>{this.invokeCallHook(t,e);const s=Te(t);return this.activation.apply(s)})}getConfig(){const t={activation:cc(this.activation)},e=super.getConfig();return Object.assign(t,e),t}};ZU.className="Activation";Ht(ZU);let JU=class extends Ue{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return vt(()=>(t=Te(t),Xrt(t,this.n)))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}};JU.className="RepeatVector";Ht(JU);let tG=class extends Ue{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){const s="Total size of new array must be unchanged.",r=e.slice();let i=1,o=null;for(let l=0;l<r.length;++l){const c=r[l];if(this.isUnknown(c))if(o===null)o=l;else throw new lt("Can only specifiy one unknown dimension.");else i*=c}const a=ec(t);if(o!==null){if(i===0||a%i!==0)throw new lt(s);r[o]=a/i}else if(a!==i)throw new lt(s);return r}computeOutputShape(t){let e=!1;for(let s=0;s<t.length;++s)if(this.isUnknown(t[s])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return vt(()=>{this.invokeCallHook(t,e);const s=Te(t),r=s.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return gt(s,i)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}};tG.className="Reshape";Ht(tG);let eG=class extends Ue{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=aa(1,t.dims.length+1);if(!mn(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Ws({ndim:this.dims.length+1})]}computeOutputShape(t){t=ln(t);const e=t.slice();return this.dims.forEach((s,r)=>{e[r+1]=t[s]}),e}call(t,e){return en(Te(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}};eG.className="Permute";Ht(eG);let nG=class extends Ue{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const s=Te(t);return HE(lx(s,this.maskValue),-1)}call(t,e){return vt(()=>{this.invokeCallHook(t,e);const s=Te(t),o=HE(lx(s,this.maskValue),-1,!0);return ct(s,ne(o,s.dtype))})}};nG.className="Masking";Ht(nG);let sG=class extends Ue{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(vn(t.inputLength))}this.inputDim=t.inputDim,rr(this.inputDim,"inputDim"),this.outputDim=t.outputDim,rr(this.outputDim,"outputDim"),this.embeddingsInitializer=Jn(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=ns(t.embeddingsRegularizer),this.activityRegularizer=ns(t.activityRegularizer),this.embeddingsConstraint=Xs(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return vt(()=>this.maskZero?(t=Te(t),lx(t,sn(t))):null)}computeOutputShape(t){if(t=ln(t),this.inputLength==null)return[...t,this.outputDim];const e=vn(this.inputLength);if(e.length!==t.length-1)throw new lt(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let s=0;for(let r=0;r<e.length;++r){const i=e[r],o=t[r+1];if(i!=null&&o!=null&&i!==o)throw new lt(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);i==null&&(e[s]=o),s++}}return[t[0],...e,this.outputDim]}call(t,e){return vt(()=>{this.invokeCallHook(t,e);let s=Te(t);s.dtype!=="int32"&&(s=rl(s,"int32"));const r=CV(this.embeddings.read(),gt(s,[s.size]));return gt(r,ln(this.computeOutputShape(s.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:us(this.embeddingsInitializer),embeddingsRegularizer:Mn(this.embeddingsRegularizer),activityRegularizer:Mn(this.activityRegularizer),embeddingsConstraint:Ks(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}};sG.className="Embedding";Ht(sG);let df=class extends Ue{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Be}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;const s=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const i=t[t.length-e.length+r],o=e[r];if(i==null||o==null||i<0||o<0)s.push(null);else if(i===1)s.push(o);else if(o===1)s.push(i);else{if(i!==o)throw new lt("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));s.push(i)}}return s}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[ln(t)]),t=t,t.length<2)throw new lt(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const i of t)i!=null&&i[0]!==null&&e.push(i[0]);if(e=tc(e),e.length>1)throw new lt(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let s=t[0]==null?null:t[0].slice(1);for(let i=1;i<t.length;++i){const o=t[i]==null?null:t[i].slice(1);s=this.computeElementwiseOpOutputShape(s,o)}const r=t.map(i=>i.length);t.indexOf(null)===-1&&tc(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return vt(()=>{if(t=t,this.reshapeRequired){const s=[],r=t.map(i=>i.rank);if(r.indexOf(null)===-1){const i=uc(r);for(let o of t){const a=o.rank;for(let l=0;l<i-a;++l)o=ob(o,1);s.push(o)}return this.mergeFunction(s)}else{let i=!1;for(const l of t){const c=l.rank;if(c==null){const f=l.shape,d=f[0],m=f.slice(1).concat([d]);let y=gt(l,[d].concat(ec(f.slice(1))));y=en(y,[1,0]),y=gt(y,m),s.push(y),i=!0}else if(c>1){const f=aa(1,c).concat([0]);s.push(en(l,f)),i=!0}else s.push(l)}let o=this.mergeFunction(s);const a=o.rank;if(i){if(a==null){const l=o.shape,c=l.length,f=l[c-1],d=[f].concat(l.slice(0,l.length-1));o=gt(en(gt(o,[-1,f]),[1,0]),d)}else if(a>1){const l=[a-1].concat(aa(0,a-1));o=en(o,l)}}return o}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let r=1;r<t.length;++r){const i=t[r]==null?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,i)}let s=[];for(const r of t)r!=null&&r[0]!==null&&s.push(r[0]);return s=tc(s),s.length===1?e=s.concat(e):e=[null].concat(e),e}computeMask(t,e){return vt(()=>{if(e==null)return null;if(!Array.isArray(e))throw new lt("`mask` should be an Array");if(!Array.isArray(t))throw new lt("`inputs` should be an Array");if(e.length!==t.length)throw new lt(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(r=>r==null))return null;e=e.map(r=>r==null?r:ni(r,0));let s=e[0];for(let r=1;r<e.length-1;++r)s=Yl(s,e[r]);return s})}},rG=class extends df{constructor(t){super(t)}mergeFunction(t){return vt(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=Yt(e,t[s]);return e})}};rG.className="Add";Ht(rG);let iG=class extends df{constructor(t){super(t)}mergeFunction(t){return vt(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=ct(e,t[s]);return e})}};iG.className="Multiply";Ht(iG);let oG=class extends df{constructor(t){super(t)}mergeFunction(t){return vt(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=Yt(e,t[s]);return ct(1/t.length,e)})}};oG.className="Average";Ht(oG);let aG=class extends df{constructor(t){super(t)}mergeFunction(t){return vt(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=Rc(e,t[s]);return e})}};aG.className="Maximum";Ht(aG);let lG=class extends df{constructor(t){super(t)}mergeFunction(t){return vt(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=Ag(e,t[s]);return e})}};lG.className="Minimum";Ht(lG);let uG=class extends df{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new lt("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const r of t)if(r!=null){e=!1;break}if(e)return;const s=[];for(let r=0;r<t.length;++r){const i=t[r].slice();i.splice(this.axis,1);let o=!1;for(const a of s)if(mn(a,i)){o=!0;break}o||s.push(i)}if(s.length>1)throw new lt("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return vt(()=>fk(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new lt("A `Concatenate` layer should be called on a list of inputs.");const e=t,s=e[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const i of e.slice(1)){if(s[r]==null||i[r]==null){s[r]=null;break}s[r]+=i[r]}return s}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new lt("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new lt("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new lt(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return vt(()=>{let s=!0;if(e.forEach(o=>{if(o!=null){s=!1;return}}),s)return null;const r=[];for(let o=0;o<t.length;++o)e[o]==null?r.push(ne(Io(t[o]),"bool")):e[o].rank<t[o].rank?r.push(ni(e[o],-1)):r.push(e[o]);const i=ii(r,this.axis);return KP(i,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}};uG.className="Concatenate";Ht(uG);function Zm(n,t){for(;n<0;)n+=t;return n}function xot(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new Be("batchDot is not implemented for tensors of 4D or higher rank yet");if(H(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),H(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),n.dtype==="complex64"||t.dtype==="complex64")throw new Be("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=t.shape.length;e==null&&(e=[s-1,r-2]);const i=e;return vt(()=>{let o;if(s>r){o=s-r;const l=[];for(let c=0;c<o;++c)l.push(1);t=gt(t,t.shape.concat(l))}else if(r>s){o=r-s;const l=[];for(let c=0;c<o;++c)l.push(1);n=gt(n,n.shape.concat(l))}else o=0;let a;if(n.shape.length===2&&t.shape.length===2)i[0]===i[1]?a=me(ct(n,t),i[0]):a=me(ct(en(n,[1,0]),t),i[1]);else{const l=i[0]!==n.shape.length-1,c=i[1]===t.shape.length-1;a=fn(n,t,l,c)}if(o>0){let l;s>r?l=s+r-3:l=s-1;const c=[];for(let f=l;f<l+o;++f)c.push(f);a=tb(a,c)}return a.shape.length===1&&(a=ni(a,1)),a})}let cG=class extends df{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){H(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],s=t[1];if(e.length>3||s.length>3)throw new Be("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,s);if(e[r[0]]!==s[r[1]])throw new lt(`Dimension incompatibility: ${e[r[0]]} !== ${s[r[1]]}`)}mergeFunction(t){if(t.length!==2)throw new lt(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],s=t[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,o)=>Zm(i,t[o].shape.length)):r=[Zm(this.axes,e.shape.length),Zm(this.axes,s.shape.length)],this.normalize&&(e=mx(e,r[0]),s=mx(s,r[1])),xot(e,s,r)}interpretAxes(t,e){let s;return Array.isArray(this.axes)?s=this.axes:s=[Zm(this.axes,t.length),Zm(this.axes,e.length)],s}computeOutputShape(t){H(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),s=t[1].slice();if(e.length>3||s.length>3)throw new Be("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,s);e.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const i=e.concat(s);return i.length===1&&i.push(1),i}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}};cG.className="Dot";Ht(cG);let hG=class extends Ue{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return vt(()=>{this.invokeCallHook(t,e);const s=Te(t);return lb(()=>Yt($v(s.shape,0,this.stddev),s),()=>s,e.training||!1)})}};hG.className="GaussianNoise";Ht(hG);let fG=class extends Ue{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return vt(()=>{this.invokeCallHook(t,e);const s=Te(t);return this.rate>0&&this.rate<1?lb(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return ct(s,$v(s.shape,1,i))},()=>s,e.training||!1):s})}};fG.className="GaussianDropout";Ht(fG);let dG=class extends Ue{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||Te(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return vt(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(t);return lb(()=>{const i=Te(t),a=-1.6732632423543772*1.0507009873554805;let l=lf(Jy(s),this.rate);l=rl(l,"float32");const c=((1-this.rate)*(1+this.rate*a**2))**-.5,f=-c*a*this.rate,d=Yt(ct(i,l),ct(Yt(l,-1),a));return Yt(ct(d,c),f)},()=>Te(t),e.training||!1)}return t})}};dG.className="AlphaDropout";Ht(dG);function Rg(n,t,e,s,r,i=.001){let o;if(n.rank===2)o=HQ(n,t,e,s,r,i);else if(n.rank===3)o=XQ(n,t,e,s,r,i);else if(n.rank===4)o=QQ(n,t,e,s,r,i);else throw new Be(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function wot(n,t,e,s,r=.001){return vt(()=>{const i=SA(n,s),o=i.mean,a=i.variance;return[Rg(n,o,a,e,t,r),o,a]})}function vot(n,t,e,s,r=.001){return vt(()=>{const i=SA(n,s),o=i.mean,a=i.variance,l=[];for(const b of aa(0,n.rank))s.indexOf(b)!==-1?l.push(1):l.push(n.shape[b]);const c=gt(o,l),f=gt(a,l),d=t==null?null:gt(t,l),m=e==null?null:gt(e,l);return[Rg(n,c,f,m,d,r),o,a]})}function Sot(n,t,e,s,r=.001){return mn(s.slice().sort(),aa(0,n.rank-1))?wot(n,t,e,s,r):vot(n,t,e,s,r)}let pG=class extends Ue{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Jn(t.betaInitializer||"zeros"),this.gammaInitializer=Jn(t.gammaInitializer||"ones"),this.movingMeanInitializer=Jn(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Jn(t.movingVarianceInitializer||"ones"),this.betaConstraint=Xs(t.betaConstraint),this.gammaConstraint=Xs(t.gammaConstraint),this.betaRegularizer=ns(t.betaRegularizer),this.gammaRegularizer=ns(t.gammaRegularizer)}build(t){t=ln(t);const e=this.axis>=0?this.axis:this.axis+t.length,s=t[e];if(s==null)throw new lt(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new Ws({ndim:t.length,axes:{[e]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return vt(()=>{const s=e.training==null?!1:e.training,r=Te(t),i=r.shape,o=i.length,a=aa(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const c=Hh(1,o);c[l]=i[l];const f=a.slice();f.sort();const d=!mn(f,aa(0,o).slice(0,o-1)),m=()=>{if(d){const T=gt(this.movingMean.read(),c),$=gt(this.movingVariance.read(),c),E=this.center?gt(this.beta.read(),c):null,R=this.scale?gt(this.gamma.read(),c):null;return Rg(r,T,$,E,R,this.epsilon)}else return Rg(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return m();const[y,b,w]=Sot(r,this.gamma.read(),this.beta.read(),a,this.epsilon),x=(T,$,E)=>{vt(()=>{const R=1-E,B=T.read(),N=ct(Se(B,$),R);T.write(Se(B,N))})};return x(this.movingMean,b,this.momentum),x(this.movingVariance,w,this.momentum),y})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:us(this.betaInitializer),gammaInitializer:us(this.gammaInitializer),movingMeanInitializer:us(this.movingMeanInitializer),movingVarianceInitializer:us(this.movingVarianceInitializer),betaRegularizer:Mn(this.betaRegularizer),gammaRegularizer:Mn(this.gammaRegularizer),betaConstraint:Ks(this.betaConstraint),gammaConstraint:Ks(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}};pG.className="BatchNormalization";Ht(pG);let mG=class extends Ue{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Jn(t.betaInitializer||"zeros"),this.gammaInitializer=Jn(t.gammaInitializer||"ones"),this.betaRegularizer=ns(t.betaRegularizer),this.gammaRegularizer=ns(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=ln(t);const e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=e);for(const i of this.axis)if(i<0||i>=e)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==tc(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>t[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(t,e){const s=Te(t),r=s.shape,i=r.length;return vt(()=>{let{mean:a,variance:l}=SA(s,this.axis,!0);const c=Hh(1,i);for(const w of this.axis)c[w]=r[w];const f=w=>w!=null&&w.shape.length!==i?gt(w,c):w;let d=this.scale?f(this.gamma.read()):null,m=this.center?f(this.beta.read()):null;const y=[],b=[];for(let w=0;w<i;++w)this.axis.indexOf(w)!==-1?(y.push(r[w]),b.push(1)):(y.push(1),b.push(r[w]));return a=Qo(a,y),l=Qo(l,y),d!=null&&(d=Qo(d,b)),m!=null&&(m=Qo(m,b)),Rg(s,a,l,m,d,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:us(this.betaInitializer),gammaInitializer:us(this.gammaInitializer),betaRegularizer:Mn(this.betaRegularizer),gammaRegularizer:Mn(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}};mG.className="LayerNormalization";Ht(mG);function Iot(n,t,e){return vt(()=>{if(n.rank!==4)throw new lt(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new lt("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=la()),e!=="channelsLast"&&e!=="channelsFirst")throw new lt(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return e==="channelsFirst"?s=[[0,0],[0,0],t[0],t[1]]:s=[[0,0],t[0],t[1],[0,0]],IA(n,s)})}let gG=class extends Ue{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?la():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new lt(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,s;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],s=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new lt(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new lt(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);s=t.padding[1]}this.padding=[e,s]}this.inputSpec=[new Ws({ndim:4})]}computeOutputShape(t){t=ln(t);let e,s;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?s=t[3]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],t[1],e,s]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?s=t[2]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],e,s,t[3]])}call(t,e){return vt(()=>Iot(Te(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};gG.className="ZeroPadding2D";Ht(gG);function Ov(n,t,e,s,r,i){return vt(()=>{ws(r),vV(i),Xi(s),e==null&&(e=[1,1]),s==null&&(s="valid"),r==null&&(r=la()),i==null&&(i="max"),n=Ck(n,r);let o;const a=s==="same"?"same":"valid";return i==="max"?o=vA(n,t,e,a):o=hA(n,t,e,a),r==="channelsFirst"&&(o=en(o,[0,3,1,2])),o})}function yG(n,t,e,s,r,i){return vt(()=>{ws(r),vV(i),Xi(s),e==null&&(e=[1,1,1]),s==null&&(s="valid"),r==null&&(r=la()),i==null&&(i="max"),n=EU(n,r);let o;const a=s==="same"?"same":"valid";return i==="max"?o=FJ(n,t,e,a):o=LQ(n,t,e,a),r==="channelsFirst"&&(o=en(o,[0,4,1,2,3])),o})}let bG=class extends Ue{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new lt(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(rr(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new lt(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);rr(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,Xi(this.padding),this.inputSpec=[new Ws({ndim:3})]}computeOutputShape(t){t=ln(t);const e=ea(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return vt(()=>{this.invokeCallHook(t,e),t=ob(Te(t),2);const s=this.poolingFunction(Te(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return tb(s,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}},xG=class extends bG{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return ws(i),Xi(r),Ov(t,e,s,r,i,"max")}};xG.className="MaxPooling1D";Ht(xG);let wG=class extends bG{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return ws(i),Xi(r),Ov(t,e,s,r,i,"avg")}};wG.className="AveragePooling1D";Ht(wG);let vG=class extends Ue{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new lt(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];rr(this.poolSize,"poolSize"),rr(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ws(this.dataFormat),Xi(this.padding),this.inputSpec=[new Ws({ndim:4})]}computeOutputShape(t){t=ln(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=ea(e,this.poolSize[0],this.padding,this.strides[0]),s=ea(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s]:[t[0],e,s,t[3]]}call(t,e){return vt(()=>(this.invokeCallHook(t,e),this.poolingFunction(Te(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},SG=class extends vG{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return ws(i),Xi(r),Ov(t,e,s,r,i,"max")}};SG.className="MaxPooling2D";Ht(SG);let IG=class extends vG{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return ws(i),Xi(r),Ov(t,e,s,r,i,"avg")}};IG.className="AveragePooling2D";Ht(IG);let TG=class extends Ue{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new lt(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];rr(this.poolSize,"poolSize"),rr(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ws(this.dataFormat),Xi(this.padding),this.inputSpec=[new Ws({ndim:5})]}computeOutputShape(t){t=ln(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=ea(e,this.poolSize[0],this.padding,this.strides[0]),s=ea(s,this.poolSize[1],this.padding,this.strides[1]),r=ea(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s,r]:[t[0],e,s,r,t[4]]}call(t,e){return vt(()=>(this.invokeCallHook(t,e),this.poolingFunction(Te(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},CG=class extends TG{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return ws(i),Xi(r),yG(t,e,s,r,i,"max")}};CG.className="MaxPooling3D";Ht(CG);let EG=class extends TG{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return ws(i),Xi(r),yG(t,e,s,r,i,"avg")}};EG.className="AveragePooling3D";Ht(EG);let $G=class extends Ue{constructor(t){super(t),this.inputSpec=[new Ws({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Be}},AG=class extends $G{constructor(t){super(t||{})}call(t,e){return vt(()=>{const s=Te(t);return $s(s,1)})}};AG.className="GlobalAveragePooling1D";Ht(AG);let kG=class extends $G{constructor(t){super(t||{})}call(t,e){return vt(()=>{const s=Te(t);return ta(s,1)})}};kG.className="GlobalMaxPooling1D";Ht(kG);let _G=class extends Ue{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ws(this.dataFormat),this.inputSpec=[new Ws({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new Be}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},NG=class extends _G{call(t,e){return vt(()=>{const s=Te(t);return this.dataFormat==="channelsLast"?$s(s,[1,2]):$s(s,[2,3])})}};NG.className="GlobalAveragePooling2D";Ht(NG);let RG=class extends _G{call(t,e){return vt(()=>{const s=Te(t);return this.dataFormat==="channelsLast"?ta(s,[1,2]):ta(s,[2,3])})}};RG.className="GlobalMaxPooling2D";Ht(RG);let DG=class extends Ue{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,s={}){const r=e.layer,i=ql(r,s);delete e.layer;const o={layer:i};return Object.assign(o,e),new t(o)}},OG=class extends DG{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=ln(t),t.length<3)throw new lt(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=ln(t);const e=[t[0]].concat(t.slice(2)),s=this.layer.computeOutputShape(e),r=t[1];return[s[0],r].concat(s.slice(1))}call(t,e){return vt(()=>(t=Te(t),UU((o,a)=>[Te(this.layer.call(o,e)),[]],t,[],!1,null,null,!1,!0)[1]))}};OG.className="TimeDistributed";Ht(OG);function Tot(n){ff(Wrt,"BidirectionalMergeMode",n)}const Cot="concat";let FG=class extends DG{constructor(t){super(t);const e=t.layer.getConfig(),s={};s.className=t.layer.getClassName(),s.config=e,this.forwardLayer=ql(s),e.goBackwards=e.goBackwards!==!0;const r={};if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=ql(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?Cot:t.mergeMode,Tot(this.mergeMode),t.weights)throw new Be("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,s=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,s)),this.backwardLayer.setWeights(t.slice(s))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let s,r,i;return this.returnState&&(i=e.slice(1)),s=e[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):si(r)}apply(t,e){let s=e==null?null:e.initialState,r=e==null?null:e.constants;e==null&&(e={});const i=VU(t,s,r,this.numConstants);if(t=i.inputs,s=i.initialState,r=i.constants,Array.isArray(t)&&(s=t.slice(1),t=t[0]),(s==null||s.length===0)&&r==null)return super.apply(t,e);const o=[],a=[];if(s!=null){const c=s.length;if(c%2>0)throw new lt("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=s,o.push(...s);const f=s.map(d=>new Ws({shape:d.shape}));this.forwardLayer.stateSpec=f.slice(0,c/2),this.backwardLayer.stateSpec=f.slice(c/2),a.push(...f)}if(r!=null)throw new Be("Support for constants in Bidirectional layers is not implemented yet.");const l=o[0]instanceof pl;for(const c of o)if(c instanceof pl!==l)throw new lt("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const c=[t].concat(o),f=this.inputSpec.concat(a),d=this.inputSpec;this.inputSpec=f;const m=super.apply(c,e);return this.inputSpec=d,m}else return super.apply(t,e)}call(t,e){return vt(()=>{const s=e.initialState;let r,i;if(s==null)r=this.forwardLayer.call(t,e),i=this.backwardLayer.call(t,e);else{const l=s.slice(0,s.length/2),c=s.slice(s.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:l})),i=this.backwardLayer.call(t,Object.assign(e,{initialState:c}))}let o;this.returnState&&(Array.isArray(r)&&(o=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=jh(i,1));let a;return this.mergeMode==="concat"?a=fk([r,i]):this.mergeMode==="sum"?a=Yt(r,i):this.mergeMode==="ave"?a=ct(.5,Yt(r,i)):this.mergeMode==="mul"?a=ct(r,i):this.mergeMode==null&&(a=[r,i]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){kh(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),kh(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[e,e]:s=e:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const s=ql(e.layer);if(delete e.layer,e.numConstants!=null)throw new Be("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=e;return r.layer=s,new t(r)}};FG.className="Bidirectional";Ht(FG);let MG=class extends Ue{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return vt(()=>(t=Te(t),t.dtype!=="float32"&&(t=rl(t,"float32")),Yt(ct(t,this.scale),this.offset)))}};MG.className="Rescaling";Ht(MG);const{resizeBilinear:Eot,cropAndResize:$ot}=jl;class LG extends Ue{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,s,r,i,o,a,l){return vt(()=>{let c,f=!1;const d=e/o,m=s/a,y=(r+e)/o,b=(i+s)/a,w=[d,m,y,b],x=[];t.rank===3?(f=!0,c=Ql([t])):c=t;for(let R=0;R<c.shape[0];R++)x.push(w);const S=zP(x,[x.length,4]),T=kg(0,x.length,1,"int32"),E=$ot(c,S,T,[r,i],"nearest");return rl(f?Te(qh(E)):E,l)})}upsize(t,e,s,r){return vt(()=>{const i=Eot(t,[e,s]);return rl(i,r)})}call(t,e){return vt(()=>{const s=Te(t),r=s.dtype,i=s.shape,o=i[i.length-3],a=i[i.length-2];let l=0;o!==this.height&&(l=Math.floor((o-this.height)/2));let c=0;return a!==this.width&&(c=Math.floor((a-this.width)/2),c===0&&(c=1)),l>=0&&c>=0?this.centerCrop(s,l,c,this.height,this.width,o,a,r):this.upsize(t,this.height,this.width,r)})}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=ln(t);const e=t.length-3,s=t.length-2;return t[e]=this.height,t[s]=this.width,t}}LG.className="CenterCrop";Ht(LG);function Aot(n,t,e,s){let r=Te(n);if(r.dtype!=="int32"&&(r=rl(r,"int32")),t==="int")return r;const i=r.shape;if(r.rank===0&&(r=ni(r,-1)),t==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=ni(r,-1)),r.rank>2)throw new lt(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(t),a=r;let l;if(typeof s<"u"&&t==="count"?l=LF(a,s,e,o):l=LF(a,[],e,o),t!=="tfIdf")return l;if(s)return ct(l,s);throw new lt("When outputMode is 'tfIdf', weights must be provided.")}class zG extends Ue{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return t=ln(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return vt(()=>{t=Te(t),t.dtype!=="int32"&&(t=rl(t,"int32"));let s;if(typeof e.countWeights<"u"){if(this.outputMode!=="count")throw new lt(`countWeights is not used when outputMode !== count.
              Received countWeights=${e.countWeights}`);s=Te(e.countWeights)}const r=ta(t),i=ox(t),o=Ki(this.numTokens,r).bufferSync().get(0),a=lf(i,0).bufferSync().get(0);if(!(o&&a))throw new lt(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return Aot(t,this.outputMode,this.numTokens,s)})}}zG.className="CategoryEncoding";Ht(zG);const kot=["bilinear","nearest"],TM=new Set(kot);class BG extends Ue{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(TM.has(t.interpolation))this.interpolation=t.interpolation;else throw new lt(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!t.cropToAspectRatio}computeOutputShape(t){t=ln(t);const e=t[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return vt(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return jl.resizeBilinear(t,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return jl.resizeNearestNeighbor(t,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...TM]} are supported`)})}}BG.className="Resizing";Ht(BG);class PG{constructor(t){this.seed=t}next(){if(this.seed!==void 0)return this.seed++}}PG.className="RandomSeed";class VG extends Ue{constructor(t){super(t),this.randomGenerator=new PG(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},e=super.getConfig();return Object.assign(t,e),t}}VG.className="BaseRandomLayer";const _ot=["bilinear","nearest"],CM=new Set(_ot);class UG extends VG{constructor(t){super(t);const{factor:e,interpolation:s="bilinear"}=t;if(this.factor=e,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new lt(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new lt(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new lt(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(CM.has(s))this.interpolation=s;else throw new lt(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=ln(t);const e=t[2];return[this.imgHeight,-1,e]}call(t,e){return vt(()=>{const s=Te(t);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=Jy([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*r;i=Math.round(i);const o=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return jl.resizeBilinear(t,o);case"nearest":return jl.resizeNearestNeighbor(t,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...CM]} are supported`)}})}}UG.className="RandomWidth";Ht(UG);const Not=At();Not.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var EM;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(EM||(EM={}));var $M;(function(n){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})($M||($M={}));var AM;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(AM||(AM={}));function ue(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&H(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}const Rot=S4;class Fv extends d2{nextDataId(){return Fv.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new WB(this,Pa())}write(t,e,s){this.firstUse&&(this.firstUse=!1,At().get("IS_NODE")&&Ui(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:s,refCount:1}),r}makeTensorInfo(t,e,s){let r;if(e==="string"&&s!=null&&s.length>0&&ty(s[0])){const i=s.map(o=>Ju(o));r=this.write(i,t,e)}else r=this.write(s,t,e);return{dataId:r,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){const e=this.data.get(t);e.refCount--}}move(t,e,s,r,i){this.data.set(t,{values:e,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:s}=this.data.get(t);if(e==="complex64"){const r=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return Zl(r,i)}return GX(this.data.get(t).values,e)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(r=>lc(r));return Pe(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Pe(t.shape,t.dtype,e)}makeOutput(t,e,s){return Pa().makeTensorFromTensorInfo(this.makeTensorInfo(e,s,t),this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(t);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=ei();return t(),{kernelMs:ei()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){ue([t],"where");const e=this.readSync(t.dataId);return Rot(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Fv.nextDataId=0;function GG(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const Dot=n=>{const{x:t}=n.inputs,e=n.backend;ue(t,"abs");let s=new Float32Array(Lt(t.shape));const r=e.data.get(t.dataId).values;return s=GG(r),e.makeOutput(s,t.shape,t.dtype)},Oot={kernelName:fw,backendName:"cpu",kernelFunc:Dot};function vs(n){return(t,e,s,r,i)=>{const o=Ne(t,e),a=o.length,l=de(o),c=Lt(o),f=Nr(i,c),d=t.length,m=e.length,y=de(t),b=de(e),w=qd(t,o),x=qd(e,o);if(w.length+x.length===0)for(let S=0;S<f.length;++S)f[S]=n(s[S%s.length],r[S%r.length]);else for(let S=0;S<f.length;++S){const T=yp(S,a,l),$=T.slice(-d);w.forEach(N=>$[N]=0);const E=el($,d,y),R=T.slice(-m);x.forEach(N=>R[N]=0);const B=el(R,m,b);f[S]=n(s[E],r[B])}return[f,o]}}function Ii(n){const{inputs:t,backend:e}=n,{real:s,imag:r}=t,i=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,a=e.makeTensorInfo(s.shape,"complex64"),l=e.data.get(a.dataId);return l.complexTensorInfos={real:e.makeTensorInfo(s.shape,"float32",i),imag:e.makeTensorInfo(r.shape,"float32",o)},a}const Fot={kernelName:E2,backendName:"cpu",kernelFunc:Ii};function wx(n,t,e="float32"){if(e==="complex64"){const r=wx(n,t,"float32"),i=wx(n,t,"float32");return Ii({inputs:{real:r,imag:i},backend:n})}const s=Rr(Lt(t),e);return n.makeTensorInfo(t,e,s)}function ml(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Mot={kernelName:vy,backendName:"cpu",kernelFunc:ml};function Kh(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.data.get(s.dataId).complexTensorInfos.real,i=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,i)}const Lot={kernelName:Y2,backendName:"cpu",kernelFunc:Kh};function WG(n,t,e,s){if(s==="int32"){const r=Int32Array.from(n);return[t,"int32",r]}if(s==="bool"){const r=af([0],e),[i,o]=vs((a,l)=>a!==l?1:0)(t,[],n,r,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${e} to ${s}`)}function dc(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return ml({inputs:{x:r},backend:e});const f=wx(e,r.shape,r.dtype),d=dc({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),m=Ii({inputs:{real:d,imag:f},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),m}if(r.dtype==="complex64"){const f=Kh({inputs:{input:r},backend:e}),d=dc({inputs:{x:f},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(f),d}if(!HB(r.dtype,i)){const f=ml({inputs:{x:r},backend:e});return{dataId:f.dataId,shape:f.shape,dtype:i}}const o=e.data.get(r.dataId).values,[a,l,c]=WG(o,r.shape,r.dtype,i);return e.makeTensorInfo(a,l,c)}const zot={kernelName:ly,backendName:"cpu",kernelFunc:dc};function Js(n,t,e,s){return e==null?({inputs:r,backend:i})=>{const{a:o,b:a}=r,l=i;ue([o,a],n);const c=l.data.get(o.dataId).values,f=l.data.get(a.dataId).values,d=o.dtype==="string"?Jl(c):c,m=o.dtype==="string"?Jl(f):f,y=s||o.dtype,[b,w]=t(o.shape,a.shape,d,m,y);return l.makeTensorInfo(w,y,b)}:({inputs:r,backend:i})=>{const{a:o,b:a}=r,l=i;if(o.dtype==="complex64"||a.dtype==="complex64"){const c=dc({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),f=l.data.get(c.dataId),d=f.complexTensorInfos.real,m=f.complexTensorInfos.imag,y=l.data.get(d.dataId).values,b=l.data.get(m.dataId).values,w=dc({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),x=l.data.get(w.dataId),S=x.complexTensorInfos.real,T=x.complexTensorInfos.imag,$=l.data.get(S.dataId).values,E=l.data.get(T.dataId).values,[R,B,N]=e(o.shape,a.shape,y,b,$,E),k=l.makeTensorInfo(N,"float32",R),_=l.makeTensorInfo(N,"float32",B),F=Ii({inputs:{real:k,imag:_},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(w),l.disposeIntermediateTensorInfo(k),l.disposeIntermediateTensorInfo(_),F}else{const c=l.data.get(o.dataId).values,f=l.data.get(a.dataId).values,d=s||o.dtype,[m,y]=t(o.shape,a.shape,c,f,d);return l.makeTensorInfo(y,d,m)}}}function Dk(n){return(t,e,s,r,i,o)=>{const a=Ne(t,e),l=Lt(a),c=a.length,f=de(a),d=Nr("float32",l),m=Nr("float32",l),y=qd(t,a),b=qd(e,a),w=Zl(s,r),x=Zl(i,o),S=t.length,T=de(t),$=e.length,E=de(e);if(y.length+b.length===0)for(let R=0;R<d.length;R++){const B=R%w.length,N=R%x.length,k=n(w[B*2],w[B*2+1],x[N*2],x[N*2+1]);d[R]=k.real,m[R]=k.imag}else for(let R=0;R<d.length;R++){const B=yp(R,c,f),N=B.slice(-S);y.forEach(P=>N[P]=0);const k=el(N,S,T),_=B.slice(-$);b.forEach(P=>_[P]=0);const F=el(_,$,E),A=n(w[k*2],w[k*2+1],x[F*2],x[F*2+1]);d[R]=A.real,m[R]=A.imag}return[d,m,a]}}const jG=vs(((n,t)=>n+t)),Bot=Dk(((n,t,e,s)=>({real:n+e,imag:t+s}))),Xd=Js(bp,jG,Bot),Pot={kernelName:bp,backendName:"cpu",kernelFunc:Xd};function Ok(n,t,e,s,r){const i=Lt(s),o=Rr(r,e);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(i>0?o[l]+=t[a]:o[l]+=1)}return o}function qG(n,t,e,s=!1){const r=n.shape[0],i=n.shape[1],o=Pe([r,e],t.dtype);for(let a=0;a<r;a++)for(let l=0;l<i;l++){const c=n.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=e||(s?o.set(1,a,c):t.size>0?o.set(o.get(a,c)+t.get(a,l),a,c):o.set(o.get(a,c)+1,a,c))}return o}const HG=vs(((n,t)=>n&t)),Vot=Js(C2,HG),Uot={kernelName:C2,backendName:"cpu",kernelFunc:Vot};function xl(n){return(t,e,s)=>{const r=gs(e,t.length);for(let i=0;i<t.length;++i)r[i]=n(t[i],s);return r}}function Tn(n,t,e){const s=xl(t);return Fc(n,s,e)}function Fc(n,t,e){return({inputs:s,attrs:r,backend:i})=>{const{x:o}=s;ue(o,n);const a=i,l=a.data.get(o.dataId).values;let c;if(o.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=Jl(l)}else c=l;const f=e||o.dtype,d=t(c,f,r);return a.makeTensorInfo(o.shape,f,d)}}const KG=xl(n=>Math.ceil(n)),Got=Fc(uy,KG),Wot={kernelName:uy,backendName:"cpu",kernelFunc:Got};function XG(n,t,e,s){const r=gs(e,Lt(t));if(s&&e!=="string"){let i=0;n.forEach(o=>{const a=Lt(o.shape);r.set(o.vals,i),i+=a})}else{let i=0;n.forEach(o=>{const a=e==="string"?Jl(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const f=c*t[1]+i;for(let d=0;d<o.shape[1];++d)r[f+d]=a[l++]}i+=o.shape[1]})}return r}const YG=vs((n,t)=>n===t?1:0),QG=Js($w,YG,null,"bool"),jot={kernelName:$w,backendName:"cpu",kernelFunc:QG};const ZG=xl(n=>Math.exp(n)),JG=Fc(gy,ZG,"float32"),qot={kernelName:gy,backendName:"cpu",kernelFunc:JG};const t6=xl(n=>Math.expm1(n)),Hot=Fc(yy,t6),Kot={kernelName:yy,backendName:"cpu",kernelFunc:Hot};const e6=xl(n=>Math.floor(n)),Xot=Fc(by,e6),Yot={kernelName:by,backendName:"cpu",kernelFunc:Xot};const n6=vs((n,t)=>Math.floor(n/t)),Qot=Js(xy,n6,null,"int32"),Zot={kernelName:xy,backendName:"cpu",kernelFunc:Qot};function s6(n,t,e,s,r,i,o,a,l){const c=Pe([s,i],e);for(let f=0;f<s;f++){const d=[];let m=0;for(let y=0;y<r;y++){const b=n[f*r+y];m+=b*o[y],d.push(b)}if(m<0||m>=l/i)throw new Error(`Invalid indices: ${d} does not index into ${a}`);for(let y=0;y<i;y++)c.values[f*i+y]=t.get(...t.indexToLoc(m*i+y))}return c}function r6(n,t,e){const s=Pe(e,n.dtype);for(let r=0;r<s.size;++r){const o=s.indexToLoc(r).slice(),a=o[0],l=o[2],c=t.locToIndex([a,l]);o[2]=t.values[c];const f=n.locToIndex(o);0<=f&&f<n.values.length&&(s.values[r]=n.values[f])}return s}const i6=vs((n,t)=>n>t?1:0),Jot=Js(Nw,i6,null,"bool"),tat={kernelName:Nw,backendName:"cpu",kernelFunc:Jot};const o6=vs((n,t)=>n>=t?1:0),eat=Js(wy,o6,null,"bool"),nat={kernelName:wy,backendName:"cpu",kernelFunc:eat};const a6=vs((n,t)=>n<t?1:0),sat=Js(Dw,a6,null,"bool"),rat={kernelName:Dw,backendName:"cpu",kernelFunc:sat};const l6=vs((n,t)=>n<=t?1:0),iat=Js(Ow,l6,null,"bool"),oat={kernelName:Ow,backendName:"cpu",kernelFunc:iat};function u6(n,t,e){const s=(t-n)/(e-1),r=Rr(e,"float32");r[0]=n;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}const c6=xl(n=>Math.log(n)),aat=Fc(Cy,c6),lat={kernelName:Cy,backendName:"cpu",kernelFunc:aat};function h6(n,t,e,s){const r=Nr(s,Lt(e));for(let i=0;i<r.length;++i){const o=i*t;let a=n[o];for(let l=0;l<t;++l){const c=n[o+l];(Number.isNaN(c)||c>a)&&(a=c)}r[i]=a}return r}const f6=vs(((n,t)=>Math.max(n,t))),uat=Js($y,f6),cat={kernelName:$y,backendName:"cpu",kernelFunc:uat};const d6=vs(((n,t)=>Math.min(n,t))),hat=Js(Ay,d6),fat={kernelName:Ay,backendName:"cpu",kernelFunc:hat};const Fk=vs(((n,t)=>n*t)),dat=Dk(((n,t,e,s)=>({real:n*e-t*s,imag:n*s+t*e}))),Mv=Js(_y,Fk,dat),pat={kernelName:_y,backendName:"cpu",kernelFunc:Mv};function p6(n,t,e){const s=kc(-1,e);return Fk([],t,s,n,e)}function mat(n){const{inputs:t,backend:e}=n,{x:s}=t;ue(s,"neg");const r=e.data.get(s.dataId).values,[i,o]=p6(r,s.shape,s.dtype);return e.makeTensorInfo(o,s.dtype,i)}const gat={kernelName:jw,backendName:"cpu",kernelFunc:mat};const m6=vs(((n,t)=>n!==t?1:0)),yat=Js(qw,m6,null,"bool"),bat={kernelName:qw,backendName:"cpu",kernelFunc:yat};function Mk(n,t,e,s,r){const i=t.length,o=Lt(t),a=de(t),l=de(r),c=Nr(e,Lt(r));for(let f=0;f<o;++f){const d=yp(f,i,a),m=new Array(d.length);for(let b=0;b<m.length;b++)m[b]=d[s[b]];const y=el(m,i,l);c[y]=n[f]}return c}function ui(n){const{inputs:t,attrs:e,backend:s}=n,{x:r}=t,{perm:i}=e;ue(r,"transpose");const o=r.shape.length,a=new Array(o);for(let d=0;d<a.length;d++)a[d]=r.shape[i[d]];const l=s.data.get(r.dataId).values,c=Mk(l,r.shape,r.dtype,i,a);return{dataId:s.write(c,a,r.dtype),shape:a,dtype:r.dtype}}const xat={kernelName:Od,backendName:"cpu",kernelFunc:ui};function g6(n,t,e,s){const[r,i]=ur(n,s),o=Ei(t,"int32"),a=Rr(Lt(r),o),l=Lt(i);for(let c=0;c<a.length;++c){const f=c*l;let d=1;for(let m=0;m<l;++m)d*=e[f+m];a[c]=d}return{outVals:a,outShape:r,outDtype:o}}function wat(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;ue(r,"prod");const a=r.shape.length,l=Ve(i,r.shape),c=hs(l,a);let f=l,d=r;const m=[];c!=null&&(d=ui({inputs:{x:r},backend:e,attrs:{perm:c}}),m.push(d),f=xs(f.length,a));const y=e.data.get(d.dataId).values,{outVals:b,outShape:w,outDtype:x}=g6(d.shape,d.dtype,y,f);let S=w;return o&&(S=ks(w,l)),m.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.makeTensorInfo(S,x,b)}const vat={kernelName:Zw,backendName:"cpu",kernelFunc:wat};function Sat(n,t,e){n.forEach((s,r)=>{if(s<0||s>=e){const i=yp(r,t.length,de(t)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${e})`)}})}function Iat(n,t){for(let e=0;e<n.length;++e){const s=n[e],r=e===n.length-1?t:n[e+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}function Tat(n,t,e,s){const r=[];let i=0;const o=t.length-1+e.length,a=new Array(o).fill(null).map(()=>[0]);Iat(e,s);let l=1;for(let c=0;c<t.length-1;++c){l*=t[c];const f=t[c+1];for(let d=1;d<l+1;++d)a[c].push(d*f)}for(let c=0;c<n.length;++c){let f=n[c],d=n[c]+1;for(let m=0;m<e.length;++m){const y=e[m],b=m+t.length-1;if(b>=0){const w=a[b],x=w[w.length-1]-y[f];for(let S=f;S<d;++S)a[b].push(y[S+1]+x)}f=y[f],d=y[d]}d!==f&&(r.push([f,d]),i+=d-f)}return{outSplits:a,valueSlices:r,numValues:i}}function Cat(n){const t=[];for(let e=0;e<n.length;++e){const s=n[e].length,r=gs("int32",s);t.push(r),n[e].forEach((i,o)=>r[o]=i)}return t}function kM(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let s=t;s<n.length;s++)e[t-1]*=n[s];return e}function Eat(n,t,e,s,r,i){const o=kM(t,2)[1],a=kM(i,2)[1];let l=0;for(const c of e)for(let f=c[0];f<c[1];++f){for(let d=0;d<s;++d)r[l*a+d]=n[f*o+d];++l}}function $at(n,t,e,s,r){const i=t.slice();i[0]=r;const o=gs(e,Lt(i)),a=n.length,l=a===0?0:a/t[0];return Eat(n,t,s,l,o,i),[o,i]}function y6(n,t,e,s,r,i,o,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const l=t[0][0]-1;if(Sat(i,o,l),s.length===0)throw new Error("params.rank must be nonzero");const c=s[0],{outSplits:f,valueSlices:d,numValues:m}=Tat(i,o,n,c),y=Cat(f),b=$at(e,s,r,d,m);return[y,b[0],b[1]]}const _M=2147483647;function b6(n,t,e,s,r,i,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=t.length===0,l=r.length===0,c=o.length===0,f=[];a||f.push(t[0]),l||f.push(r[0]),c||f.push(o[0]);for(let x=1;x<f.length;++x)if(f[x]!==f[x-1])throw new Error("starts, limits, and deltas must have the same shape");const d=f.length===0?1:f[0],m=gs("int32",d+1);m[0]=0;for(let x=0;x<d;++x){const S=a?n[0]:n[x],T=l?s[0]:s[x],$=c?i[0]:i[x];if($===0)throw new Error("Requires delta != 0");let E;if($>0&&T<S||$<0&&T>S)E=0;else if(E=Math.ceil(Math.abs((T-S)/$)),E>_M)throw new Error(`Requires ((limit - start) / delta) <= ${_M}`);m[x+1]=m[x]+E}const y=m[d],b=gs(e,y);let w=0;for(let x=0;x<d;++x){const S=m[x+1]-m[x];let T=a?n[0]:n[x];const $=c?i[0]:i[x];for(let E=0;E<S;++E)b[w++]=T,T+=$}return[m,b]}var co=Ho;class vx{constructor(t,e,s,r,i,o,a,l,c,f){this.shape=t,this.shapeShape=e,this.values=s,this.valuesShape=r,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=V4(f),this.raggedRank=U4(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===co.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===co.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case co.VALUE_ROWIDS:return vx.getMaxWidthValueRowID(e);case co.ROW_SPLITS:return vx.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${co[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(e===0||e===1)return 0;let s=0;for(let r=0;r<e-1;++r){const i=t[r+1]-t[r];i>s&&(s=i)}return s}static getMaxWidthValueRowID(t){const e=t.length;if(e===0)return 0;let s=0,r=t[0],i=0;for(let o=1;o<e;++o){const a=t[o];a!==r&&(r=a,i=Math.max(o-s,i),s=o)}return Math.max(e-s,i)}tensorShapeFromTensor(t,e,s=!0){if(e.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return RM(t,s)}calculateOutputSize(t){const e=this.valuesShape,s=this.defaultValueShape;G4(s,e);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=P4(this.raggedRank,r,e);o[0]<0&&(o[0]=t);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(t,e,s){const r=Math.min(t,s),i=[];let o=0;for(let a=0;a<r;++a,o+=e)i.push(o);for(let a=r;a<t;++a)i.push(-1);return H(i.length===t,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(t,e,s,r){const i=t.length,o=[];for(let a=0;a<i-1;++a){const l=t[a+1]-t[a];let c=Math.min(r,l),f=e[a];f===-1&&(c=0);for(let d=0;d<c;++d)o.push(f),f+=s;for(let d=0;d<l-c;++d)o.push(-1)}if(i>0&&o.length!==t[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(t,e,s,r){const i=t.length,o=[];if(i===0)return[];let a=0,l=t[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let c=e[l];o.push(c);for(let f=1;f<i;++f){const d=t[f];if(d===l)c>=0&&(++a,a<r?c+=s:c=-1);else{if(a=0,l=d,d>=e.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${e.length}`);c=e[d]}o.push(c)}if(o.length!==t.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(t,e,s,r){const i=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case co.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,e,s,r);case co.ROW_SPLITS:if(i.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(i,e,s,r);default:throw new Error(`Unsupported partition type: ${co[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case co.FIRST_DIM_SIZE:return t[0];case co.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case co.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${co[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),s=this.calculateOutputSize(e),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*s[l+1];const i=RM(s,!1),o=gs(this.valuesDType,Lt(i));if(r[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(e,r[0],s[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,r[c],s[c]);this.setOutput(this.raggedRank,l,o,i)}return[i,o]}setOutput(t,e,s,r){if(s.length===0)return;const i=this.values,o=s;let a=r.slice();a=a.slice(t+1);const l=Lt(a),c=e.length;let f=this.defaultValue;if(f.length!==l&&f.length!==1){const b=this.defaultValueShape;vt(()=>{const w=gt(f,b);f=mg(w,a).dataSync()})}let d=0,m=0,y=0;for(let b=0;b<=c;++b){let w=b<c?e[b]:-1;if(w===y){++y;continue}if(m<y){const x=i.subarray(d*l),S=o.subarray(m*l),T=(y-m)*l;NM(S,x,T)}if(b>=c){const x=s.length;w=Math.floor(x/l)}if(w>y)if(this.defaultValue.length===1)o.subarray(y*l,w*l).fill(this.defaultValue[0]),y=w;else for(;w>y;){const x=o.slice(y*l);NM(x,f,l),++y}w<0?(d=b+1,m=y):(d=b,m=y,y=m+1)}}}function NM(n,t,e){for(let s=0;s<e;s++)n[s]=t[s]}function RM(n,t){const e=[];for(let s of n){if(s<0){if(!t)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}e.push(s)}return e}function x6(n,t,e,s,r,i,o,a,l,c){return new vx(n,t,e,s,r,i,o,a,l,c).compute()}function w6(n,t,e,s){const r=n===t,i=n<t&&e<0,o=t<n&&e>1;if(r||i||o)return Rr(0,s);const a=Math.abs(Math.ceil((t-n)/e)),l=Rr(a,s);t<n&&e===1&&(e=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+e;return l}const v6=xl(n=>1/Math.sqrt(n)),Aat=Fc(My,v6),kat={kernelName:My,backendName:"cpu",kernelFunc:Aat};function Th(n,t,e,s,r,i,o,a,l,c){const f=[s/r,r],d=n.values,m=t.values;if(s===0)return Pe(e,t.dtype);const y=l instanceof br?l:Pe(f,t.dtype);typeof l=="string"||typeof l=="number"?y.values.fill(l):typeof l=="boolean"&&y.values.fill(+l);for(let b=0;b<i;b++){const w=[];let x=0;for(let S=0;S<o;S++){const T=d[b*o+S];w.push(T),x+=T*a[S]}if(x<0||x>=s/r)throw new Error(`Invalid indices: ${w} does not index into ${e}`);for(let S=0;S<r;S++)c?y.values[x*r+S]+=m[b*r+S]:y.values[x*r+S]=t.rank===0?m[0]:m[b*r+S]}return y}const _at=xl(n=>1/(1+Math.exp(-n))),S6=Tn(Vy,n=>1/(1+Math.exp(-n))),Nat={kernelName:Vy,backendName:"cpu",kernelFunc:S6};function I6(n,t,e,s,r){const i=UA(s,t,e),o=Lt(e),a=de(s);if(i){const d=GA(t,a);return r==="string"?n.slice(d,d+o):n.subarray(d,d+o)}const l=r==="string"?Jl(n):n,c=Pe(s,r,l),f=Pe(e,r);for(let d=0;d<f.size;++d){const m=f.indexToLoc(d),y=m.map((b,w)=>b+t[w]);f.set(c.get(...y),...m)}return r==="string"?uV(f.values):f.values}function Xh(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,size:o}=s;ue(r,"slice");const[a,l]=Sv(r,i,o);PA(r,a,l);const c=e.data.get(r.dataId).values,f=I6(c,a,l,r.shape,r.dtype);return e.makeTensorInfo(l,r.dtype,f)}const Rat={kernelName:rv,backendName:"cpu",kernelFunc:Xh};function T6(n,t,e,s,r,i,o){const a=t[0],l=i[0],c=new Array(l),f=new Array(a),d=t[1];if(l===0){if(a!==0)throw new Error(Y4(a));const x=gs(e,0),S=gs(r,0);return[x,[0,d],S,c,f]}let m=!0,y=0;const b=new Array(l).fill(0);for(let x=0;x<a;++x){const S=n[x*d];if(S<0)throw new Error(Q4(x,S));if(S>=l)throw new Error(Z4(x,S,l));++b[S],m=m&&S>=y,y=S}let w=!0;for(let x=0;x<l;++x){const S=b[x]===0;c[x]=S,w=w&&!S,b[x]=Math.max(b[x],1),x>0&&(b[x]+=b[x-1])}if(w&&m){const x=n,S=s;for(let T=0;T<a;++T)f[T]=T;return[x,[a,d],S,c,f]}else{const x=b[l-1],S=gs(e,x*d),T=gs(r,x),$=new Array(l).fill(0);for(let E=0;E<a;++E){const R=n[E*d],B=$[R],N=(R===0?0:b[R-1])+B;$[R]++;for(let k=0;k<d;++k)S[N*d+k]=n[E*d+k];T[N]=s[E],f[E]=N}for(let E=0;E<l;++E)if($[E]===0){const B=E===0?0:b[E-1];S[B*d+0]=E;for(let N=1;N<d;++N)S[B*d+N]=0;T[B]=o}return[S,[x,d],T,c,f]}}function C6(n,t,e,s,r){const i=Lt(s),o=t[0],a=r.length,l=[];let c=1,f=-1;for(let x=0;x<a;++x){const S=r[x];if(S===-1){if(f!==-1)throw new Error(J4(f,x));f=x,l.push(1)}else{if(S<0)throw new Error(tV(x,S));c*=S,l.push(S)}}if(f!==-1){if(c<=0)throw new Error(eV());const x=Math.trunc(i/c);if(c*x!==i)throw new Error(nV(s,l));l[f]=x}if(Lt(l)!==i)throw new Error(sV(s,l));const m=s.length,y=[];if(m>0){y[m-1]=1;for(let x=m-2;x>=0;--x)y[x]=y[x+1]*s[x+1]}const b=[];if(a>0){b[a-1]=1;for(let x=a-2;x>=0;--x)b[x]=b[x+1]*l[x+1]}const w=gs(e,o*a);for(let x=0;x<o;++x){let S=0;for(let T=0;T<m;++T)S+=n[x*m+T]*y[T];for(let T=0;T<a;++T)w[x*a+T]=Math.trunc(S/b[T]),S%=b[T]}return[w,[o,a],l]}function Lk(n,t,e,s,r,i=!1,o=0){const a=s.length,l=[t[0],n.length/t[0]],c=l[1],d=a>0?r[a-1]+1:0;if(d<0)throw new Error(ZE());const m=t.slice();m[0]=d;const y=m.reduce(($,E)=>$*E,1),b=gs(e,y);if(a===0)return d>0&&b.fill(o),[b,m];if(d<=0)throw new Error(ZE());let w=0,x=1,S=0,T=r[w];for(;;){let $=0;if(x<a){if($=r[x],T===$){++x;continue}if(T>=$)throw new Error(rV())}if(T<0||T>=d)throw new Error(iV(T,d));T>S&&b.fill(o,S*c,T*c);for(let E=w;E<x;++E){const R=s[E];if(R<0||R>=l[0])throw new Error(oV(E,s[E],l[0]));for(let B=0;B<c;B++)b[T*c+B]+=n[R*c+B]}if(i)for(let E=0;E<c;E++)b[T*c+E]/=x-w;if(w=x,++x,S=T+1,T=$,x>a)break}return S<d&&b.fill(o,S*c,d*c),[b,m]}const Dat=xl(n=>Math.sqrt(n)),Oat=Tn(Gy,n=>Math.sqrt(n)),Fat={kernelName:Gy,backendName:"cpu",kernelFunc:Oat};const E6=vs(((n,t)=>{const e=n-t;return e*e})),Mat=Js(Wy,E6),Lat={kernelName:Wy,backendName:"cpu",kernelFunc:Mat};const $6=xl((n,t)=>{const{pattern:e,replaceGlobal:s,rewrite:r}=t;return n.replace(new RegExp(e,s?"g":""),r)}),zat=Fc(tA,$6),Bat={kernelName:tA,backendName:"cpu",kernelFunc:zat};function A6(n,t,e,s){const r=Pe(n,t.dtype);for(let i=0;i<r.size;i++){const o=r.indexToLoc(i),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*e[l]+s[l];r.set(t.get(...a),...o)}return r}class Pat{constructor(t,e,s,r,i,o){this.separator=Ju(t),this.nGramWidths=e,this.leftPad=Ju(s),this.rightPad=Ju(r),this.padWidth=i,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const s=this.getPadWidth(e);return Math.max(0,t+2*s-e+1)}createNGrams(t,e,s,r,i,o){for(let a=0;a<i;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),f=Math.max(0,l-(i-(a+1))),d=o-(c+f),m=e+(c>0?0:a-l);let y=0;y+=c*this.leftPad.length;for(let T=0;T<d;++T)y+=t[m+T].length;y+=f*this.rightPad.length;const b=c+f+d-1;y+=b*this.separator.length,s[r+a]=new Uint8Array(y);const w=s[r+a];let x=0;const S=T=>T.forEach($=>w[x++]=$);for(let T=0;T<c;++T)S(this.leftPad),S(this.separator);for(let T=0;T<d-1;++T)S(t[m+T]),S(this.separator);if(d>0){S(t[m+d-1]);for(let T=0;T<f;++T)S(this.separator),S(this.rightPad)}else{for(let T=0;T<f-1;++T)S(this.rightPad),S(this.separator);S(this.rightPad)}}}compute(t,e){const s=t.length,r=e.length;if(r>0){let l=e[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<r;++c){let f=e[c]>=l;if(f=f&&e[c]<=s,!f)throw new Error(`Invalid split value ${e[c]}, must be in [${l}, ${s}]`);l=e[c]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const i=r-1,o=gs("int32",r);if(s===0||r===0){const l=new Array(s);for(let c=0;c<=i;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=i;++l){const c=e[l]-e[l-1];let f=0;this.nGramWidths.forEach(d=>{f+=this.getNumNGrams(c,d)}),this.preserveShort&&c>0&&f===0&&(f=1),o[l]=o[l-1]+f}const a=new Array(o[i]);for(let l=0;l<i;++l){const c=e[l];let f=o[l];if(this.nGramWidths.forEach(d=>{const m=e[l+1]-e[l],y=this.getNumNGrams(m,d);this.createNGrams(t,c,a,f,y,d),f+=y}),this.preserveShort&&f===o[l]){const d=e[l+1]-e[l];if(d===0)continue;const m=d+2*this.padWidth;this.createNGrams(t,c,a,f,1,m)}}return[a,o]}}function k6(n,t,e,s,r,i,o,a){return new Pat(e,s,r,i,o,a).compute(n,t)}function Vat(n,t,e,s){if(!n.length)return;if(t.length===0){for(let i=0;i<n.length;++i)s.push(n.subarray(i,i+1));return}if(t.length===1){const i=t[0];let o=n.indexOf(i);for(;o!==-1;){const a=n.subarray(0,o);(!e||a.length!==0)&&s.push(a),n=n.subarray(o+1),o=n.indexOf(i)}(!e||n.length!==0)&&s.push(n);return}let r=0;for(let i=0;i<n.length+1;i++)if(i===n.length||t.indexOf(n[i])!==-1){const o=n.subarray(r,i);(!e||o.length!==0)&&s.push(o),r=i+1}}function _6(n,t,e){const s=n.length,r=[];let i=0,o=0;const a=new Array(s);for(let m=0;m<s;++m){const y=r.length;Vat(n[m],t,e,r);const b=r.length-y;a[m]=b,i+=b,o=Math.max(o,b)}const l=gs("int32",i*2),c=new Array(i),f=[s,o];let d=0;for(let m=0;m<s;++m)for(let y=0;y<a[m];++y)l[d*2]=m,l[d*2+1]=y,c[d]=r[d],++d;return[l,c,f]}function N6(n,t){const e=gs("int32",n.length);for(let s=0;s<n.length;++s)e[s]=lY(n[s]).modulo(t).getLowBitsUnsigned();return e}const R6=vs(((n,t)=>n-t)),Uat=Dk(((n,t,e,s)=>({real:n-e,imag:t-s}))),zk=Js(jy,R6,Uat),Gat={kernelName:jy,backendName:"cpu",kernelFunc:zk};function D6(n,t){const e=new Array(n.rank);for(let r=0;r<e.length;r++)e[r]=n.shape[r]*t[r];const s=Pe(e,n.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=i[l]%n.shape[l];const a=n.locToIndex(o);s.values[r]=n.values[a]}return s}const rg=(n,t)=>{const e=t.value-n.value;return e===0?n.index-t.index:e};function O6(n,t,e=0,s=n.length-1){for(;s>e;){if(s-e>600){const a=s-e+1,l=t-e+1,c=Math.log(a),f=.5*Math.exp(2*c/3),d=.5*Math.sqrt(c*f*(a-f)/a)*Math.sign(l-a/2),m=Math.max(e,Math.floor(t-l*f/a+d)),y=Math.min(s,Math.floor(t+(a-l)*f/a+d));O6(n,t,m,y)}const r=n[t];let i=e,o=s;for(xd(n,e,t),rg(n[s],r)>0&&xd(n,e,s);i<o;){for(xd(n,i,o),i++,o--;rg(n[i],r)<0;)i=i+1;for(;rg(n[o],r)>0;)o=o-1}rg(n[e],r)===0?xd(n,e,o):(o=o+1,xd(n,o,s)),o<=t&&(e=o+1),t<=o&&(s=o-1)}}function F6(n,t,e,s,r){const i=t[t.length-1],[o,a]=[n.length/i,i],l=Nr(e,o*s),c=Nr("int32",o*s);for(let d=0;d<o;d++){const m=d*a,y=n.subarray(m,m+a);let b=new Array(y.length);y.forEach((T,$)=>b[$]={value:T,index:$}),s<b.length&&(O6(b,s),b=b.slice(0,s)),r&&b.sort(rg);const w=d*s,x=l.subarray(w,w+s),S=c.subarray(w,w+s);for(let T=0;T<s;T++)x[T]=b[T].value,S[T]=b[T].index}const f=t.slice();return f[f.length-1]=s,[Pe(f,e,l),Pe(f,"int32",c)]}function M6(n,t,e,s){const r=Ve(t,e)[0],i=[1,e[0],1];for(let b=0;b<r;b++)i[0]*=e[b];i[1]=e[r];for(let b=r+1;b<e.length;b++)i[2]*=e[b];const o=new Map,a=new Int32Array(e[r]),l=new br(i,s,n),c=[],f=i[0]===1&&i[2]===1;for(let b=0;b<e[r];b++){let w;if(f)w=n[b].toString();else{const S=[];for(let T=0;T<i[0];T++)for(let $=0;$<i[2];$++)S.push(l.get(T,b,$));w=S.join(",")}const x=o.get(w);if(x!=null)a[b]=x;else{const S=o.size;o.set(w,S),a[b]=S,c.push(b)}}const d=i.slice();d[1]=o.size;const m=new br(d,s);c.forEach((b,w)=>{for(let x=0;x<i[0];x++)for(let S=0;S<i[2];S++)m.set(l.get(x,b,S),x,w,S)});const y=e.slice();return y[r]=d[1],{outputValues:m.values,outputShape:y,indices:a}}const Wat=Object.freeze(Object.defineProperty({__proto__:null,addImpl:jG,bincountImpl:Ok,bincountReduceImpl:qG,bitwiseAndImpl:HG,castImpl:WG,ceilImpl:KG,concatImpl:XG,equalImpl:YG,expImpl:ZG,expm1Impl:t6,floorDivImpl:n6,floorImpl:e6,gatherNdImpl:s6,gatherV2Impl:r6,greaterEqualImpl:o6,greaterImpl:i6,lessEqualImpl:l6,lessImpl:a6,linSpaceImpl:u6,logImpl:c6,maxImpl:h6,maximumImpl:f6,minimumImpl:d6,multiplyImpl:Fk,negImpl:p6,notEqualImpl:m6,prodImpl:g6,raggedGatherImpl:y6,raggedRangeImpl:b6,raggedTensorToTensorImpl:x6,rangeImpl:w6,rsqrtImpl:v6,scatterImpl:Th,sigmoidImpl:_at,simpleAbsImpl:GG,sliceImpl:I6,sparseFillEmptyRowsImpl:T6,sparseReshapeImpl:C6,sparseSegmentReductionImpl:Lk,sqrtImpl:Dat,squaredDifferenceImpl:E6,staticRegexReplaceImpl:$6,stridedSliceImpl:A6,stringNGramsImpl:k6,stringSplitImpl:_6,stringToHashBucketFastImpl:N6,subImpl:R6,tileImpl:D6,topKImpl:F6,transposeImpl:Mk,uniqueImpl:M6},Symbol.toStringTag,{value:"Module"}));BP("cpu",()=>new Fv,1);const L6=Tn(py,n=>n>=0?n:Math.exp(n)-1),jat={kernelName:py,backendName:"cpu",kernelFunc:L6};function z6(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{alpha:i}=s;ue([r],"leakyRelu");const o=Lt(r.shape),a=e.data.get(r.dataId).values,l=Nr("float32",o);for(let c=0;c<a.length;c++)l[c]=a[c]<0?i*a[c]:a[c];return e.makeTensorInfo(r.shape,"float32",l)}const qat={kernelName:Rw,backendName:"cpu",kernelFunc:z6};const Hat=vs((n,t)=>n<0?t*n:n);function B6(n){const{inputs:t,backend:e}=n,{x:s,alpha:r}=t;ue([s,r],"prelu");const i=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,[a,l]=Hat(s.shape,r.shape,i,o,"float32");return e.makeTensorInfo(l,"float32",a)}const Kat={kernelName:Qw,backendName:"cpu",kernelFunc:B6};const P6=Tn(Dy,n=>Math.max(0,n)),Xat={kernelName:Dy,backendName:"cpu",kernelFunc:P6};const V6=Tn(Oy,n=>Math.min(Math.max(0,n),6)),Yat={kernelName:Oy,backendName:"cpu",kernelFunc:V6};function Sx(n,t,e,s,r){if(e==="linear")return ml({inputs:{x:t},backend:n});if(e==="relu")return P6({inputs:{x:t},backend:n});if(e==="elu")return L6({inputs:{x:t},backend:n});if(e==="relu6")return V6({inputs:{x:t},backend:n});if(e==="prelu")return B6({inputs:{x:t,alpha:s},backend:n});if(e==="leakyrelu")return z6({inputs:{x:t},backend:n,attrs:{alpha:r}});if(e==="sigmoid")return S6({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Gn(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{shape:i}=s,o=Lt(r.shape),a=qB(i,o),l=Lt(a);H(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),e.incRef(r.dataId);const c=e.data.get(r.dataId);if(c.complexTensorInfos!=null){const f=c.complexTensorInfos.real,d=c.complexTensorInfos.imag;f.shape=a,d.shape=a}return{dataId:r.dataId,shape:a,dtype:r.dtype}}const Qat={kernelName:Jw,backendName:"cpu",kernelFunc:Gn};function U6(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i}=t,{transposeA:o,transposeB:a}=s;ue([r,i],"matMul");const l=r.shape.length,c=i.shape.length,f=o?r.shape[l-2]:r.shape[l-1],d=a?i.shape[c-1]:i.shape[c-2],m=o?r.shape[l-1]:r.shape[l-2],y=a?i.shape[c-2]:i.shape[c-1],b=r.shape.slice(0,-2),w=i.shape.slice(0,-2),x=Lt(b),S=Lt(w),$=Ne(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([m,y]);H(f===d,()=>`Error in matMul: inner shapes (${f}) and (${d}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const E=o?[x,f,m]:[x,m,f],R=a?[S,y,d]:[S,d,y],B=Gn({inputs:{x:r},backend:e,attrs:{shape:E}}),N=Gn({inputs:{x:i},backend:e,attrs:{shape:R}}),k=o?B.shape[1]:B.shape[2],_=o?B.shape[2]:B.shape[1],F=a?N.shape[1]:N.shape[2],A=Math.max(x,S),P=e.data.get(B.dataId).values,L=e.data.get(N.dataId).values,tt=de(B.shape),st=de(N.shape),[j,Z,J]=o?[tt[0],1,tt[1]]:[tt[0],tt[1],1],[ot,pt,q]=a?[1,st[1],st[0]]:[st[1],1,st[0]],et=_*F,U=Pe([A,_,F],B.dtype),X=U.values,nt=e.blockSize;for(let xt=0;xt<A;xt++){const Ot=xt%x,qt=xt%S;for(let zt=0;zt<_;zt+=nt){const Wt=Math.min(zt+nt,_);for(let Xt=0;Xt<F;Xt+=nt){const te=Math.min(Xt+nt,F);for(let oe=0;oe<k;oe+=nt){const fe=Math.min(oe+nt,k);for(let pe=zt;pe<Wt;pe++)for(let ie=Xt;ie<te;ie++){let Ae=0;for(let Ge=oe;Ge<fe;Ge++){const Nt=P[Ot*j+pe*Z+Ge*J],Ie=L[Ge*ot+ie*pt+qt*q];Ae+=Nt*Ie}X[xt*et+(pe*F+ie)]+=Ae}}}}}return e.disposeIntermediateTensorInfo(B),e.disposeIntermediateTensorInfo(N),e.makeTensorInfo($,U.dtype,U.values)}const Zat={kernelName:yw,backendName:"cpu",kernelFunc:U6};function Jat(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:f,leakyreluAlpha:d}=s;let m,y,b;const w=[];m=U6({inputs:{a:r,b:i},attrs:{transposeA:l,transposeB:c},backend:e}),o&&(y=Xd({inputs:{a:m,b:o},backend:e}),w.push(m),m=y),f&&(b=Sx(e,m,f,a,d),w.push(m),m=b);for(const S of w)e.disposeIntermediateTensorInfo(S);return m}const tlt={kernelName:nx,backendName:"cpu",kernelFunc:Jat};const elt=Tn(ey,n=>Math.acos(n)),nlt={kernelName:ey,backendName:"cpu",kernelFunc:elt};const slt=Tn(ny,n=>Math.acosh(n)),rlt={kernelName:ny,backendName:"cpu",kernelFunc:slt};function ilt(n){const{inputs:t,backend:e}=n,s=t;ue(t,"addN");const r=s.map(a=>e.data.get(a.dataId).values),i=Pe(s[0].shape,s[0].dtype),o=i.values;for(let a=0;a<s.length;a++){const l=r[a];for(let c=0;c<o.length;c++)o[c]+=l[c]}return e.makeTensorInfo(i.shape,i.dtype,i.values)}const olt={kernelName:x2,backendName:"cpu",kernelFunc:ilt};function alt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;ue(r,"all");const a=Ve(i,r.shape);let l=a;const c=hs(l,r.shape.length);let f=r;c!=null&&(f=ui({inputs:{x:r},backend:e,attrs:{perm:c}}),l=xs(l.length,r.shape.length)),Sr("all",l,f.shape.length);const[d,m]=ur(f.shape,l),y=Lt(m),b=Rr(Lt(d),f.dtype),w=e.data.get(f.dataId).values;for(let S=0;S<b.length;++S){const T=S*y;let $=w[T];for(let E=0;E<y;++E){const R=w[T+E];$=$&&R}b[S]=$}c!=null&&e.disposeIntermediateTensorInfo(f);const x=e.makeTensorInfo(d,f.dtype,b);if(o){const S=ks(d,a),T=Gn({inputs:{x},backend:e,attrs:{shape:S}});return e.disposeIntermediateTensorInfo(x),T}return x}const llt={kernelName:w2,backendName:"cpu",kernelFunc:alt};function ult(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;ue(r,"any");const a=Ve(i,r.shape);let l=a;const c=hs(l,r.shape.length);let f=r;c!=null&&(f=ui({inputs:{x:r},backend:e,attrs:{perm:c}}),l=xs(l.length,r.shape.length)),Sr("any",l,f.shape.length);const[d,m]=ur(f.shape,l),y=Lt(m),b=Rr(Lt(d),f.dtype),w=e.data.get(f.dataId).values;for(let S=0;S<b.length;++S){const T=S*y;let $=w[T];for(let E=0;E<y;++E){const R=w[T+E];$=$||R}b[S]=$}c!=null&&e.disposeIntermediateTensorInfo(f);const x=e.makeTensorInfo(d,f.dtype,b);if(o){const S=ks(d,a),T=Gn({inputs:{x},backend:e,attrs:{shape:S}});return e.disposeIntermediateTensorInfo(x),T}return x}const clt={kernelName:v2,backendName:"cpu",kernelFunc:ult};function hlt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;ue(r,"argMax");let o=Ve(i,r.shape);const a=hs(o,r.shape.length);let l=r;const c=[];a!=null&&(l=ui({inputs:{x:r},backend:e,attrs:{perm:a}}),c.push(l),o=xs(o.length,l.shape.length)),o=[o[0]],Sr("argMax",o,l.shape.length);const[f,d]=ur(l.shape,o),m=Lt(f),y=Rr(m,"int32"),b=Lt(d),w=e.data.get(l.dataId).values;for(let x=0;x<y.length;++x){const S=x*b;let T=w[S],$=0;for(let E=0;E<b;++E){const R=w[S+E];R>T&&(T=R,$=E)}y[x]=$}return c.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.makeTensorInfo(f,"int32",y)}const flt={kernelName:dw,backendName:"cpu",kernelFunc:hlt};function dlt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;ue(r,"argMin");let o=Ve(i,r.shape);const a=hs(o,r.shape.length);let l=r;const c=[];a!=null&&(l=ui({inputs:{x:r},backend:e,attrs:{perm:a}}),c.push(l),o=xs(o.length,l.shape.length)),o=[o[0]],Sr("argMin",o,l.shape.length);const[f,d]=ur(l.shape,o),m=Lt(f),y=Rr(m,"int32"),b=Lt(d),w=e.data.get(l.dataId).values;for(let x=0;x<y.length;++x){const S=x*b;let T=w[S],$=0;for(let E=0;E<b;++E){const R=w[S+E];R<T&&(T=R,$=E)}y[x]=$}return c.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.makeTensorInfo(f,"int32",y)}const plt={kernelName:pw,backendName:"cpu",kernelFunc:dlt};const mlt=Tn(sy,n=>Math.asin(n)),glt={kernelName:sy,backendName:"cpu",kernelFunc:mlt};const ylt=Tn(ry,n=>Math.asinh(n)),blt={kernelName:ry,backendName:"cpu",kernelFunc:ylt};const xlt=Tn(iy,n=>Math.atan(n)),wlt={kernelName:iy,backendName:"cpu",kernelFunc:xlt};const vlt=vs((n,t)=>Math.atan2(n,t)),Slt=Js(ay,vlt),Ilt={kernelName:ay,backendName:"cpu",kernelFunc:Slt};const Tlt=Tn(oy,n=>Math.atanh(n)),Clt={kernelName:oy,backendName:"cpu",kernelFunc:Tlt};function Bk(n,t,e,s,r,i){const o=r.strideHeight,a=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,f=r.effectiveFilterHeight,d=r.effectiveFilterWidth,m=r.padInfo.top,y=r.padInfo.left,b=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=Pe(r.outShape,e),x=w.values,S=r.outShape[1]*r.outShape[2]*r.outShape[3],T=r.outShape[2]*r.outShape[3],$=r.outShape[3];for(let E=0;E<r.batchSize;++E){const R=E*S,B=E*s[0];for(let N=0;N<r.inChannels;++N)for(let k=0;k<r.outHeight;++k){const _=k*o-m,F=Math.max(0,_),A=Math.min(r.inHeight,f+_),P=R+k*T;for(let L=0;L<r.outWidth;++L){const tt=L*a-y,st=Math.max(0,tt),j=Math.min(r.inWidth,d+tt);let Z=b,J=0,ot=0;for(let q=F;q<A;q+=l){const et=B+q*s[1];for(let U=st;U<j;U+=c){const X=et+U*s[2],nt=n[X+N];i==="max"&&nt>Z?Z=nt:i==="avg"&&(J+=nt,ot++)}if(isNaN(Z))break}const pt=P+L*$+N;x[pt]=i==="avg"?J/ot:Z}}}return w}function G6(n,t,e,s,r=!1,i=!1){const o=Pe(s.outShape,"int32"),a=s.strideHeight,l=s.strideWidth,c=s.dilationHeight,f=s.dilationWidth,d=s.effectiveFilterHeight,m=s.effectiveFilterWidth,y=s.padInfo.top,b=s.padInfo.left,w=Pe(t,e,n);for(let x=0;x<s.batchSize;++x)for(let S=0;S<s.inChannels;++S)for(let T=0;T<s.outHeight;++T){const $=T*a-y;let E=$;for(;E<0;)E+=c;const R=Math.min(s.inHeight,d+$);for(let B=0;B<s.outWidth;++B){const N=B*l-b;let k=N;for(;k<0;)k+=f;const _=Math.min(s.inWidth,m+N);let F=Number.NEGATIVE_INFINITY,A=-1;for(let P=E;P<R;P+=c){const L=P-$;for(let tt=k;tt<_;tt+=f){const st=tt-N,j=w.get(x,P,tt,S);j>F&&(F=j,r?A=i?((x*s.inHeight+P)*s.inWidth+tt)*s.inChannels+S:(P*s.inWidth+tt)*s.inChannels+S:A=L*m+st)}}o.set(A,x,T,B,S)}}return o}function W6(n,t,e,s,r,i){const o=r.strideDepth,a=r.strideHeight,l=r.strideWidth,c=r.dilationDepth,f=r.dilationHeight,d=r.dilationWidth,m=r.effectiveFilterDepth,y=r.effectiveFilterHeight,b=r.effectiveFilterWidth,w=r.padInfo.front,x=r.padInfo.top,S=r.padInfo.left,T=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,$=Pe(r.outShape,e),E=$.values,R=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],B=r.outShape[2]*r.outShape[3]*r.outShape[4],N=r.outShape[3]*r.outShape[4],k=r.outShape[4];for(let _=0;_<r.batchSize;++_){const F=_*R,A=_*s[0];for(let P=0;P<r.inChannels;++P)for(let L=0;L<r.outDepth;++L){const tt=L*o-w;let st=tt;for(;st<0;)st+=c;const j=Math.min(r.inDepth,m+tt),Z=F+L*B;for(let J=0;J<r.outHeight;++J){const ot=J*a-x;let pt=ot;for(;pt<0;)pt+=f;const q=Math.min(r.inHeight,y+ot),et=Z+J*N;for(let U=0;U<r.outWidth;++U){const X=U*l-S;let nt=X;for(;nt<0;)nt+=d;const xt=Math.min(r.inWidth,b+X),Ot=et+U*k;let qt=T,zt=0,Wt=0;for(let te=st;te<j;te+=c){const oe=A+te*s[1];for(let fe=pt;fe<q;fe+=f){const pe=oe+fe*s[2];for(let ie=nt;ie<xt;ie+=d){const Ae=pe+ie*s[3],Ge=n[Ae+P];if(i==="max"&&Ge>qt?qt=Ge:i==="avg"&&(zt+=Ge,Wt++),isNaN(qt))break}if(isNaN(qt))break}if(isNaN(qt))break}const Xt=Ot+P;E[Xt]=i==="avg"?zt/Math.max(Wt,1):qt}}}}return $}function Elt(n,t){const e=Pe(t.outShape,"int32"),s=t.strideDepth,r=t.strideHeight,i=t.strideWidth,o=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,f=t.effectiveFilterHeight,d=t.effectiveFilterWidth,m=t.padInfo.front,y=t.padInfo.top,b=t.padInfo.left;for(let w=0;w<t.batchSize;++w)for(let x=0;x<t.inChannels;++x)for(let S=0;S<t.outDepth;++S){const T=S*s-m;let $=T;for(;$<0;)$+=o;const E=Math.min(t.inDepth,c+T);for(let R=0;R<t.outHeight;++R){const B=R*r-y;let N=B;for(;N<0;)N+=a;const k=Math.min(t.inHeight,f+B);for(let _=0;_<t.outWidth;++_){const F=_*i-b;let A=F;for(;A<0;)A+=l;const P=Math.min(t.inWidth,d+F);let L=Number.NEGATIVE_INFINITY,tt=-1;for(let st=$;st<E;st+=o){const j=st-T;for(let Z=N;Z<k;Z+=a){const J=Z-B;for(let ot=A;ot<P;ot+=l){const pt=ot-F,q=n.get(w,st,Z,ot,x);q>=L&&(L=q,tt=j*f*d+J*f+pt)}}}e.set(tt,w,S,R,_,x)}}}return e}function $lt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;ue(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,c=1;H(Or(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const f=$o(r.shape,i,o,c,a,l);let d;if(f.filterWidth===1&&f.filterHeight===1&&mn(f.inShape,f.outShape))d=ml({inputs:{x:r},backend:e});else{const m=e.data.get(r.dataId).values,y=de(r.shape),b=Bk(m,r.shape,r.dtype,y,f,"avg");d=e.makeTensorInfo(f.outShape,r.dtype,b.values)}return d}const Alt={kernelName:mw,backendName:"cpu",kernelFunc:$lt};function klt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s;ue(r,"avgPool3d");const f=au(r.shape,i,o,1,a,l,c),d=e.data.get(r.dataId).values,m=W6(d,r.shape,r.dtype,de(r.shape),f,"avg");return e.makeTensorInfo(m.shape,"float32",m.values)}const _lt={kernelName:gw,backendName:"cpu",kernelFunc:klt};function Nlt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=s;ue([r,i],"avgPool3DGrad");const f=au(i.shape,o,a,1,l,c),d=f.strideDepth,m=f.strideHeight,y=f.strideWidth,b=f.filterDepth,w=f.filterHeight,x=f.filterWidth,S=f.dilationDepth,T=f.dilationHeight,$=f.dilationWidth,E=f.effectiveFilterDepth,R=f.effectiveFilterHeight,B=f.effectiveFilterWidth,N=E-1-f.padInfo.front,k=B-1-f.padInfo.left,_=R-1-f.padInfo.top,F=Pe(i.shape,"float32"),A=1/(b*w*x),P=e.bufferSync(r);for(let L=0;L<f.batchSize;++L)for(let tt=0;tt<f.inChannels;++tt)for(let st=0;st<f.inDepth;++st)for(let j=0;j<f.inHeight;++j)for(let Z=0;Z<f.inWidth;++Z){const J=st-N,ot=j-_,pt=Z-k;let q=0;for(let et=0;et<E;et+=S){const U=(J+et)/d;if(!(U<0||U>=f.outDepth||Math.floor(U)!==U))for(let X=0;X<R;X+=T){const nt=(ot+X)/m;if(!(nt<0||nt>=f.outHeight||Math.floor(nt)!==nt))for(let xt=0;xt<B;xt+=$){const Ot=(pt+xt)/y;if(Ot<0||Ot>=f.outWidth||Math.floor(Ot)!==Ot)continue;const qt=P.get(L,U,nt,Ot,tt);q+=qt}}}F.set(q*A,L,st,j,Z,tt)}return e.makeTensorInfo(F.shape,F.dtype,F.values)}const Rlt={kernelName:I2,backendName:"cpu",kernelFunc:Nlt};function Dlt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,o=i;ue([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=s,f=$o(o.shape,a,l,1,c),d=f.strideHeight,m=f.strideWidth,y=f.filterHeight,b=f.filterWidth,w=f.dilationHeight,x=f.dilationWidth,S=f.effectiveFilterHeight,T=f.effectiveFilterWidth,$=T-1-f.padInfo.left,E=S-1-f.padInfo.top,R=Pe(o.shape,"float32"),B=1/(y*b),N=e.data.get(r.dataId).values,k=Pe(r.shape,"float32",N);for(let _=0;_<f.batchSize;++_)for(let F=0;F<f.inChannels;++F)for(let A=0;A<f.inHeight;++A)for(let P=0;P<f.inWidth;++P){const L=A-E,tt=P-$;let st=0;for(let j=0;j<S;j+=w){const Z=(L+j)/d;if(!(Z<0||Z>=f.outHeight||Math.floor(Z)!==Z))for(let J=0;J<T;J+=x){const ot=(tt+J)/m;if(ot<0||ot>=f.outWidth||Math.floor(ot)!==ot)continue;const pt=k.get(_,Z,ot,F);st+=pt}}R.set(st*B,_,A,P,F)}return e.makeTensorInfo(R.shape,R.dtype,R.values)}const Olt={kernelName:S2,backendName:"cpu",kernelFunc:Dlt};function Flt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,scale:i,offset:o,mean:a,variance:l}=t;H(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),H(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),H(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ue([r,a,l,i,o],"batchNorm");let{varianceEpsilon:c}=s;c==null&&(c=.001);const f=e.data.get(r.dataId).values,d=e.data.get(a.dataId).values,m=e.data.get(l.dataId).values,y=i?e.data.get(i.dataId).values:new Float32Array([1]),b=o?e.data.get(o.dataId).values:new Float32Array([0]),w=new Float32Array(f.length),x=b.length,S=y.length,T=m.length,$=d.length;let E=0,R=0,B=0,N=0;for(let k=0;k<f.length;++k)w[k]=b[E++]+(f[k]-d[R++])*y[B++]/Math.sqrt(m[N++]+c),E>=x&&(E=0),R>=$&&(R=0),B>=S&&(B=0),N>=T&&(N=0);return e.makeTensorInfo(r.shape,r.dtype,w)}const Mlt={kernelName:kw,backendName:"cpu",kernelFunc:Flt};function Llt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,crops:o}=s;ue([r],"batchToSpaceND");const a=i.reduce((S,T)=>S*T),l=nb(r.shape,i,a),c=sb(l.length,i.length),f=rb(r.shape,i,a),d=KA(o,i.length),m=XA(f,o,i.length),y=Gn({inputs:{x:r},backend:e,attrs:{shape:l}}),b=ui({inputs:{x:y},backend:e,attrs:{perm:c}}),w=Gn({inputs:{x:b},backend:e,attrs:{shape:f}}),x=Xh({inputs:{x:w},backend:e,attrs:{begin:d,size:m}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(w),x}const zlt={kernelName:bw,backendName:"cpu",kernelFunc:Llt};function Blt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:o}=s,a=e.data.get(r.dataId).values,l=e.data.get(i.dataId).values,c=Ok(a,l,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,c)}const Plt={kernelName:T2,backendName:"cpu",kernelFunc:Blt};function Vlt(n){const{inputs:t,backend:e}=n,{s0:s,s1:r}=t,i=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,a=Ne(Array.from(i),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const Ult={kernelName:ZB,backendName:"cpu",kernelFunc:Vlt};const Glt=Tn(cy,(n,t)=>{const e=t;return n>e.clipValueMax?e.clipValueMax:n<e.clipValueMin?e.clipValueMin:n}),Wlt={kernelName:cy,backendName:"cpu",kernelFunc:Glt};const jlt=n=>{const{x:t}=n.inputs,e=n.backend,s=new Float32Array(Lt(t.shape)),r=e.data.get(t.dataId),i=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,a=e.data.get(i.dataId).values,l=e.data.get(o.dataId).values;for(let c=0;c<a.length;c++){const f=a[c],d=l[c];s[c]=Math.hypot(f,d)}return e.makeOutput(s,t.shape,"float32")},qlt={kernelName:xw,backendName:"cpu",kernelFunc:jlt};function Yd(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.data.get(s.dataId).complexTensorInfos.imag,i=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,i)}const Hlt={kernelName:U2,backendName:"cpu",kernelFunc:Yd};function Qd(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s,i=Ve(r,t[0].shape)[0],o=t.map(w=>w.shape);jA(o,i);let a=sl(t.map(w=>w.shape),i);if(Lt(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(w=>Lt(w.shape)>0);if(l.length===1)return ml({inputs:{x:l[0]},backend:e});if(l[0].dtype==="complex64"){const w=l.map(E=>Kh({inputs:{input:E},backend:e})),x=l.map(E=>Yd({inputs:{input:E},backend:e})),S=Qd({inputs:w,backend:e,attrs:{axis:i}}),T=Qd({inputs:x,backend:e,attrs:{axis:i}}),$=Ii({inputs:{real:S,imag:T},backend:e});return w.forEach(E=>e.disposeIntermediateTensorInfo(E)),x.forEach(E=>e.disposeIntermediateTensorInfo(E)),e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(T),$}const c=l.map(w=>{const S=[-1,Lt(w.shape.slice(i))];return Gn({inputs:{x:w},backend:e,attrs:{shape:S}})}),f=c.map(w=>({vals:e.data.get(w.dataId).values,shape:w.shape}));a=sl(c.map(w=>w.shape),1);const d=c[0].shape[0]===1,m=XG(f,a,t[0].dtype,d),y=sl(l.map(w=>w.shape),i),b=e.makeTensorInfo(y,t[0].dtype,m);return c.forEach(w=>e.disposeIntermediateTensorInfo(w)),b}const Klt={kernelName:ww,backendName:"cpu",kernelFunc:Qd};function j6(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:f}=s;ue([r,i],"conv2d");const d=lu(l),m=vr(r.shape,i.shape,o,c,a,f,!1,d),y=m.filterHeight,b=m.filterWidth,w=m.dilationHeight,x=m.dilationWidth,S=m.padInfo.left,T=m.padInfo.top,$=m.dataFormat==="channelsLast",E=new br(m.outShape,r.dtype),R=de(r.shape),B=de(i.shape),N=R[0],k=$?R[1]:R[2],_=$?R[2]:1,F=$?1:R[1],A=E.strides[0],P=$?E.strides[1]:E.strides[2],L=$?E.strides[2]:1,tt=$?1:E.strides[1],st=e.data.get(r.dataId).values,j=e.data.get(i.dataId).values,Z=E.values;for(let J=0;J<m.batchSize;++J){const ot=J*N,pt=J*A;for(let q=0;q<m.outHeight;++q){const et=pt+q*P,U=q*m.strideHeight-T;for(let X=0;X<y;++X){const nt=U+X*w;if(nt<0||nt>=m.inHeight)continue;const xt=X*B[0],Ot=ot+nt*k;for(let qt=0;qt<m.outWidth;++qt){const zt=et+qt*L,Wt=qt*m.strideWidth-S;for(let Xt=0;Xt<b;++Xt){const te=Wt+Xt*x;if(te<0||te>=m.inWidth)continue;const oe=xt+Xt*B[1],fe=Ot+te*_;let pe=oe;for(let ie=0;ie<m.inChannels;++ie){const Ae=st[fe+ie*F];for(let Ge=0;Ge<m.outChannels;++Ge)Z[zt+Ge*tt]+=Ae*j[pe+Ge];pe+=m.outChannels}}}}}}return e.makeTensorInfo(E.shape,E.dtype,Z)}const Xlt={kernelName:vw,backendName:"cpu",kernelFunc:j6};function Ylt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:f}=s;ue([r,i],"conv2dBackpropFilter");const d=lu(l),m=vr(r.shape,f,o,1,a,c,!1,d),{strideHeight:y,strideWidth:b,filterHeight:w,filterWidth:x}=m,S=m.dataFormat==="channelsLast",T=new br(m.filterShape,"float32"),$=m.padInfo.left,E=m.padInfo.top,R=e.data.get(r.dataId).values,B=e.data.get(i.dataId).values,N=new br(r.shape,r.dtype,R),k=new br(i.shape,i.dtype,B);for(let _=0;_<w;++_){const F=Math.max(0,Math.ceil((E-_)/y)),A=Math.min(m.outHeight,(m.inHeight+E-_)/y);for(let P=0;P<x;++P){const L=Math.max(0,Math.ceil(($-P)/b)),tt=Math.min(m.outWidth,(m.inWidth+$-P)/b);for(let st=0;st<m.inChannels;++st)for(let j=0;j<m.outChannels;++j){let Z=0;for(let J=0;J<m.batchSize;++J)for(let ot=F;ot<A;++ot){const pt=_+ot*y-E;for(let q=L;q<tt;++q){const et=P+q*b-$;S?Z+=N.get(J,pt,et,st)*k.get(J,ot,q,j):Z+=N.get(J,st,pt,et)*k.get(J,j,ot,q)}}T.set(Z,_,P,st,j)}}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}const Qlt={kernelName:$2,backendName:"cpu",kernelFunc:Ylt};function Zlt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:f}=s;ue([r,i],"conv2dBackpropInput");const d=de(i.shape),m=de(r.shape);let y=lu(c);const b=vr(o,i.shape,a,1,l,f,!1,y),w=new br(b.inShape,"float32"),x=w.values,S=e.data.get(r.dataId).values,T=e.data.get(i.dataId).values,[$,E,R]=d,{batchSize:B,filterHeight:N,filterWidth:k,inChannels:_,inHeight:F,inWidth:A,outChannels:P,outHeight:L,outWidth:tt,strideHeight:st,strideWidth:j}=b;y=b.dataFormat;const Z=N-1-b.padInfo.top,J=k-1-b.padInfo.left,ot=y==="channelsLast",pt=w.strides[0],q=ot?w.strides[1]:w.strides[2],et=ot?w.strides[2]:1,U=ot?1:w.strides[1],X=m[0],nt=ot?m[1]:m[2],xt=ot?m[2]:1,Ot=ot?1:m[1];for(let qt=0;qt<B;++qt)for(let zt=0;zt<_;++zt)for(let Wt=0;Wt<F;++Wt){const Xt=Wt-Z,te=Math.max(0,Math.ceil(Xt/st)),oe=Math.min(L,(N+Xt)/st);for(let fe=0;fe<A;++fe){const pe=fe-J,ie=Math.max(0,Math.ceil(pe/j)),Ae=Math.min(tt,(k+pe)/j);let Ge=0;for(let Ie=te;Ie<oe;++Ie){const wn=Ie*st-Xt;for(let rs=ie;rs<Ae;++rs){const Ns=rs*j-pe,je=X*qt+nt*Ie+xt*rs,Nn=$*(N-1-wn)+E*(k-1-Ns)+R*zt;for(let cr=0;cr<P;++cr){const zr=S[je+Ot*cr],Wn=T[Nn+cr];Ge+=zr*Wn}}}const Nt=pt*qt+q*Wt+et*fe+U*zt;x[Nt]=Ge}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}const Jlt={kernelName:Sw,backendName:"cpu",kernelFunc:Zlt};function tut(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l}=s;ue([r,i],"conv3d");const c=_c(r.shape,i.shape,o,l,a),{filterDepth:f,filterHeight:d,filterWidth:m,dilationDepth:y,dilationHeight:b,dilationWidth:w,padInfo:x}=c,S=x.front,T=x.left,$=x.top,E=new br(c.outShape,r.dtype),R=e.data.get(r.dataId).values,B=e.data.get(i.dataId).values,N=E.values,k=de(r.shape),_=de(i.shape);for(let F=0;F<c.batchSize;++F){const A=F*k[0],P=F*E.strides[0];for(let L=0;L<c.outDepth;++L){const tt=P+L*E.strides[1],st=L*c.strideDepth-S;for(let j=0;j<f;++j){const Z=st+j*y;if(Z<0||Z>=c.inDepth)continue;const J=j*_[0],ot=A+Z*k[1];for(let pt=0;pt<c.outHeight;++pt){const q=tt+pt*E.strides[2],et=pt*c.strideHeight-$;for(let U=0;U<d;++U){const X=et+U*b;if(X<0||X>=c.inHeight)continue;const nt=J+U*_[1],xt=ot+X*k[2];for(let Ot=0;Ot<c.outWidth;++Ot){const qt=q+Ot*c.outChannels,zt=Ot*c.strideWidth-T;for(let Wt=0;Wt<m;++Wt){const Xt=zt+Wt*w;if(Xt<0||Xt>=c.inWidth)continue;const te=nt+Wt*_[2],oe=xt+Xt*c.inChannels;let fe=te;for(let pe=0;pe<c.inChannels;++pe){const ie=R[oe+pe];for(let Ae=0;Ae<c.outChannels;++Ae)N[qt+Ae]+=ie*B[fe+Ae];fe+=c.outChannels}}}}}}}}return e.makeTensorInfo(E.shape,E.dtype,E.values)}const eut={kernelName:Iw,backendName:"cpu",kernelFunc:tut};function nut(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,pad:a,filterShape:l}=s;ue([r,i],"conv3dBackpropFilterV2");const c=de(r.shape),f=de(i.shape),d=_c(r.shape,l,o,1,a),m=d.strideDepth,y=d.strideHeight,b=d.strideWidth,w=d.filterDepth,x=d.filterHeight,S=d.filterWidth,T=new br(d.filterShape,"float32"),$=T.values,[E,R,B,N]=T.strides,k=e.data.get(i.dataId).values,[_,F,A,P]=f,L=e.data.get(r.dataId).values,[tt,st,j,Z]=c,J=d.padInfo.front,ot=d.padInfo.left,pt=d.padInfo.top;for(let q=0;q<w;++q){const et=Math.max(0,Math.ceil((J-q)/m)),U=Math.min(d.outDepth,(d.inDepth+J-q)/m),X=q*E;for(let nt=0;nt<x;++nt){const xt=Math.max(0,Math.ceil((pt-nt)/y)),Ot=Math.min(d.outHeight,(d.inHeight+pt-nt)/y),qt=nt*R+X;for(let zt=0;zt<S;++zt){const Wt=Math.max(0,Math.ceil((ot-zt)/b)),Xt=Math.min(d.outWidth,(d.inWidth+ot-zt)/b),te=zt*B+qt;for(let oe=0;oe<d.inChannels;++oe){const fe=oe*N+te;for(let pe=0;pe<d.outChannels;++pe){let ie=0;for(let Ae=0;Ae<d.batchSize;++Ae){const Ge=Ae*tt,Nt=Ae*_;for(let Ie=et;Ie<U;++Ie){const rs=(q+Ie*m-J)*st+Ge,Ns=Ie*F+Nt;for(let je=xt;je<Ot;++je){const cr=(nt+je*y-pt)*j+rs,zr=je*A+Ns;for(let Wn=Wt;Wn<Xt;++Wn){const G=(zt+Wn*b-ot)*Z+cr,O=Wn*P+zr;ie+=L[G+oe]*k[O+pe]}}}}$[fe+pe]=ie}}}}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}const sut={kernelName:A2,backendName:"cpu",kernelFunc:nut};function rut(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{pad:o,strides:a,inputShape:l}=s;ue([r],"conv3dBackpropInputV2");const c=de(r.shape),f=de(i.shape),d=_c(l,i.shape,a,1,o),m=new br(d.inShape,"float32"),y=m.values,[b,w,x,S]=m.strides,T=e.data.get(r.dataId).values,[$,E,R,B]=c,N=e.data.get(i.dataId).values,[k,_,F,A]=f,{batchSize:P,filterDepth:L,filterHeight:tt,filterWidth:st,inChannels:j,inDepth:Z,inHeight:J,inWidth:ot,outChannels:pt,outDepth:q,outHeight:et,outWidth:U,strideDepth:X,strideHeight:nt,strideWidth:xt}=d,Ot=L-1-d.padInfo.front,qt=tt-1-d.padInfo.top,zt=st-1-d.padInfo.left;for(let Wt=0;Wt<P;++Wt)for(let Xt=0;Xt<j;++Xt)for(let te=0;te<Z;++te){const oe=te-Ot,fe=Math.max(0,Math.ceil(oe/X)),pe=Math.min(q,(L+oe)/X);for(let ie=0;ie<J;++ie){const Ae=ie-qt,Ge=Math.max(0,Math.ceil(Ae/nt)),Nt=Math.min(et,(tt+Ae)/nt);for(let Ie=0;Ie<ot;++Ie){const wn=Ie-zt,rs=Math.max(0,Math.ceil(wn/xt)),Ns=Math.min(U,(st+wn)/xt);let je=0;for(let Nn=fe;Nn<pe;++Nn){const cr=Nn*X-oe;for(let zr=Ge;zr<Nt;++zr){const Wn=zr*nt-Ae;for(let No=rs;No<Ns;++No){const G=No*xt-wn,O=$*Wt+E*Nn+R*zr+B*No,M=k*(L-1-cr)+_*(tt-1-Wn)+F*(st-1-G)+A*Xt;for(let Y=0;Y<pt;++Y){const at=T[O+Y],Ct=N[M+Y];je+=at*Ct}}}}y[b*Wt+w*te+x*ie+S*Ie+Xt]=je}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}const iut={kernelName:k2,backendName:"cpu",kernelFunc:rut};const out=Tn(hy,n=>Math.cos(n)),aut={kernelName:hy,backendName:"cpu",kernelFunc:out};const lut=Tn(fy,n=>Math.cosh(n)),uut={kernelName:fy,backendName:"cpu",kernelFunc:lut};function cut(n){const{inputs:t,backend:e,attrs:s}=n,{image:r,boxes:i,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:c}=s,[f,d,m,y]=r.shape,b=i.shape[0],[w,x]=a,S=Pe([b,w,x,y],"float32"),T=e.data.get(i.dataId).values,$=e.data.get(o.dataId).values,E=e.data.get(r.dataId).values,R=de(r.shape),B=de(S.shape);for(let N=0;N<b;N++){const k=N*4,_=T[k],F=T[k+1],A=T[k+2],P=T[k+3],L=$[N];if(L>=f)continue;const tt=w>1?(A-_)*(d-1)/(w-1):0,st=x>1?(P-F)*(m-1)/(x-1):0;for(let j=0;j<w;j++){const Z=w>1?_*(d-1)+j*tt:.5*(_+A)*(d-1);if(Z<0||Z>d-1){for(let J=0;J<x;J++)for(let ot=0;ot<y;ot++){const pt=ot+J*B[2]+j*B[1]+N*B[0];S.values[pt]=c}continue}if(l==="bilinear"){const J=Math.floor(Z),ot=Math.ceil(Z),pt=Z-J;for(let q=0;q<x;q++){const et=x>1?F*(m-1)+q*st:.5*(F+P)*(m-1);if(et<0||et>m-1){for(let xt=0;xt<y;xt++){const Ot=xt+q*B[2]+j*B[1]+N*B[0];S.values[Ot]=c}continue}const U=Math.floor(et),X=Math.ceil(et),nt=et-U;for(let xt=0;xt<y;xt++){let Ot=xt+U*R[2]+J*R[1]+L*R[0];const qt=E[Ot];Ot=xt+X*R[2]+J*R[1]+L*R[0];const zt=E[Ot];Ot=xt+U*R[2]+ot*R[1]+L*R[0];const Wt=E[Ot];Ot=xt+X*R[2]+ot*R[1]+L*R[0];const Xt=E[Ot],te=qt+(zt-qt)*nt,oe=Wt+(Xt-Wt)*nt;Ot=xt+q*B[2]+j*B[1]+N*B[0],S.values[Ot]=te+(oe-te)*pt}}}else for(let J=0;J<x;++J){const ot=x>1?F*(m-1)+J*st:.5*(F+P)*(m-1);if(ot<0||ot>m-1){for(let et=0;et<y;et++){const U=et+J*B[2]+j*B[1]+N*B[0];S.values[U]=c}continue}const pt=Math.round(ot),q=Math.round(Z);for(let et=0;et<y;et++){const U=et+pt*R[2]+q*R[1]+L*R[0],X=et+J*B[2]+j*B[1]+N*B[0];S.values[X]=E[U]}}}}return e.makeTensorInfo(S.shape,S.dtype,S.values)}const hut={kernelName:N2,backendName:"cpu",kernelFunc:cut};function fut(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:o,reverse:a}=s;ue(r,"cumprod");const l=hs([i],r.shape.length);let c=r;l!=null&&(c=ui({inputs:{x:r},backend:e,attrs:{perm:l}}));const f=xs(1,r.shape.length)[0];if(f!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${f}`);const d=Ei(c.dtype,"int32"),m=g2(Lt(c.shape),d),y=e.data.get(c.dataId).values,b=c.shape[c.shape.length-1],w=a?(S,T)=>S+b-T-1:(S,T)=>S+T;for(let S=0;S<y.length;S+=b)for(let T=0;T<b;T++){const $=w(S,T);if(T===0)m[$]=o?1:y[$];else{const E=w(S,T-1);m[$]=o?y[E]*m[E]:y[$]*m[E]}}const x=e.makeTensorInfo(c.shape,d,m);if(l!=null){const S=Nc(l),T=ui({inputs:{x},backend:e,attrs:{perm:S}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(c),T}return x}const dut={kernelName:_2,backendName:"cpu",kernelFunc:fut};function put(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:o,reverse:a}=s;ue(r,"cumsum");const l=hs([i],r.shape.length);let c=r;l!=null&&(c=ui({inputs:{x:r},backend:e,attrs:{perm:l}}));const f=xs(1,r.shape.length)[0];if(f!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${f}`);const d=Ei(c.dtype,"int32"),m=Rr(Lt(c.shape),d),y=e.data.get(c.dataId).values,b=c.shape[c.shape.length-1],w=a?(S,T)=>S+b-T-1:(S,T)=>S+T;for(let S=0;S<y.length;S+=b)for(let T=0;T<b;T++){const $=w(S,T);if(T===0)m[$]=o?0:y[$];else{const E=w(S,T-1);m[$]=o?y[E]+m[E]:y[$]+m[E]}}const x=e.makeTensorInfo(c.shape,d,m);if(l!=null){const S=Nc(l),T=ui({inputs:{x},backend:e,attrs:{perm:S}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(c),T}return x}const mut={kernelName:Tw,backendName:"cpu",kernelFunc:put};function gut(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:o,binaryOutput:a}=s;if(r.shape.length===1){const l=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,f=Ok(l,c,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,f)}else if(r.shape.length===2){const l=e.bufferSync(r),c=e.bufferSync(i),f=qG(l,c,o,a);return e.makeTensorInfo(f.shape,i.dtype,f.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const yut={kernelName:R2,backendName:"cpu",kernelFunc:gut};function but(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockSize:i,dataFormat:o}=s;H(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=r.shape[0],l=r.shape[1],c=r.shape[2],f=r.shape[3],d=l*i,m=c*i,y=f/(i*i),b=e.data.get(r.dataId).values,w=new Float32Array(a*d*m*y);let x=0;for(let S=0;S<a;++S)for(let T=0;T<d;++T){const $=Math.floor(T/i),E=T%i;for(let R=0;R<m;++R){const B=Math.floor(R/i),N=R%i,k=(E*i+N)*y;for(let _=0;_<y;++_){const A=_+k+f*(B+c*($+l*S));w[x++]=b[A]}}}return e.makeTensorInfo([a,d,m,y],r.dtype,w)}const xut={kernelName:D2,backendName:"cpu",kernelFunc:but};function q6(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=s;ue([r,i],"depthwiseConv2DNative");const f=de(r.shape),d=de(i.shape);let m=l;m==null&&(m=[1,1]),H(Or(o,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${m}'`);const y=vr(r.shape,i.shape,o,m,a,c,!0),{filterHeight:b,filterWidth:w,dilationHeight:x,dilationWidth:S,padInfo:T}=y,$=T.left,E=T.top,R=y.outChannels/y.inChannels,B=new br(y.outShape,r.dtype),N=e.data.get(r.dataId).values,k=e.data.get(i.dataId).values,_=B.values;for(let F=0;F<y.batchSize;++F){const A=F*f[0],P=F*B.strides[0];for(let L=0;L<y.outHeight;++L){const tt=P+L*B.strides[1],st=L*y.strideHeight-E;for(let j=0;j<b;++j){const Z=st+j*x;if(Z<0||Z>=y.inHeight)continue;const J=j*d[0],ot=A+Z*f[1];for(let pt=0;pt<y.outWidth;++pt){const q=tt+pt*B.strides[2],et=pt*y.strideWidth-$;for(let U=0;U<w;++U){const X=et+U*S;if(X<0||X>=y.inWidth)continue;const nt=J+U*d[1],xt=ot+X*y.inChannels;let Ot=q,qt=nt;for(let zt=0;zt<y.inChannels;++zt){const Wt=N[xt+zt];for(let Xt=0;Xt<R;++Xt)_[Ot+Xt]+=Wt*k[qt+Xt];Ot+=R,qt+=R}}}}}}return e.makeTensorInfo(B.shape,B.dtype,B.values)}const wut={kernelName:Cw,backendName:"cpu",kernelFunc:q6};function vut(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:f}=s;ue([r,i],"depthwiseConv2dNativeBackpropFilter");const d=vr(r.shape,f,o,a,l,c,!0),{strideHeight:m,strideWidth:y,filterHeight:b,filterWidth:w}=d,x=new br(d.filterShape,"float32"),S=d.padInfo.left,T=d.padInfo.top,$=d.outChannels/d.inChannels,E=e.data.get(r.dataId).values,R=new br(r.shape,r.dtype,E),B=e.data.get(i.dataId).values,N=new br(i.shape,i.dtype,B);for(let k=0;k<b;++k){const _=Math.max(0,Math.ceil((T-k)/m)),F=Math.min(d.outHeight,(d.inHeight+T-k)/m);for(let A=0;A<w;++A){const P=Math.max(0,Math.ceil((S-A)/y)),L=Math.min(d.outWidth,(d.inWidth+S-A)/y);for(let tt=0;tt<d.outChannels;++tt){const st=Math.trunc(tt/$),j=tt%$;let Z=0;for(let J=0;J<d.batchSize;++J)for(let ot=_;ot<F;++ot){const pt=k+ot*m-T;for(let q=P;q<L;++q){const et=A+q*y-S;Z+=R.get(J,pt,et,st)*N.get(J,ot,q,tt)}}x.set(Z,k,A,st,j)}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}const Sut={kernelName:O2,backendName:"cpu",kernelFunc:vut};function Iut(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:f}=s;ue([r,i],"depthwiseConv2DNativeBackpropInput");const d=de(r.shape),m=de(i.shape),y=vr(f,i.shape,o,a,l,c,!0),b=new br(y.inShape,"float32"),w=b.values,[x,S,T]=b.strides,$=e.data.get(r.dataId).values,[E,R,B]=d,N=e.data.get(i.dataId).values,[k,_,F]=m,{batchSize:A,filterHeight:P,filterWidth:L,inChannels:tt,inHeight:st,inWidth:j,outChannels:Z,outHeight:J,outWidth:ot,strideHeight:pt,strideWidth:q}=y,et=P-1-y.padInfo.top,U=L-1-y.padInfo.left,X=Z/tt;for(let nt=0;nt<A;++nt)for(let xt=0;xt<tt;++xt)for(let Ot=0;Ot<st;++Ot){const qt=Ot-et,zt=Math.max(0,Math.ceil(qt/pt)),Wt=Math.min(J,(P+qt)/pt);for(let Xt=0;Xt<j;++Xt){const te=Xt-U,oe=Math.max(0,Math.ceil(te/q)),fe=Math.min(ot,(L+te)/q);let pe=0;for(let ie=zt;ie<Wt;++ie){const Ae=ie*pt-qt;for(let Ge=oe;Ge<fe;++Ge){const Nt=Ge*q-te,Ie=E*nt+R*ie+B*Ge,wn=k*(P-1-Ae)+_*(L-1-Nt)+F*xt;for(let rs=0;rs<X;++rs){const Ns=xt*X+rs,je=$[Ie+Ns],Nn=N[wn+rs];pe+=je*Nn}}}w[x*nt+S*Ot+T*Xt+xt]=pe}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}const Tut={kernelName:F2,backendName:"cpu",kernelFunc:Iut};function Cut(n){const{inputs:t,backend:e}=n,{x:s}=t,r=Lt(s.shape),i=e.data.get(s.dataId).values,o=Pe([r,r],s.dtype),a=o.values;for(let c=0;c<i.length;c++)a[c*r+c]=i[c];const l=[...s.shape,...s.shape];return e.makeTensorInfo(l,o.dtype,o.values)}const Eut={kernelName:JB,backendName:"cpu",kernelFunc:Cut};const $ut={kernelName:Ew,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r}=n,{strides:i,pad:o,dilations:a}=e,l=t,c=l.data.get(s.dataId).values,f=s.shape.length,d=l.data.get(r.dataId).values,m=r.shape.length,{batchSize:y,inHeight:b,inWidth:w,inChannels:x,outHeight:S,outWidth:T,padInfo:$,strideHeight:E,strideWidth:R,filterHeight:B,filterWidth:N,dilationHeight:k,dilationWidth:_,outShape:F}=Qy(s.shape,r.shape,i,o,"NHWC",a),A=Lt(F),P=F.length,L=gs(s.dtype,A);for(let st=0;st<y;++st)for(let j=0;j<S;++j){const Z=j*E-$.top;for(let J=0;J<T;++J){const ot=J*R-$.left;for(let pt=0;pt<x;++pt){let q=Number.MIN_SAFE_INTEGER;for(let U=0;U<B;++U){const X=Z+U*k;if(X>=0&&X<b)for(let nt=0;nt<N;++nt){const xt=ot+nt*_;if(xt>=0&&xt<w){const Ot=el([st,X,xt,pt],f,de(s.shape)),qt=el([U,nt,pt],m,de(r.shape)),zt=c[Ot]+d[qt];zt>q&&(q=zt)}}}const et=el([st,j,J,pt],P,de(F));L[et]=q}}}return{dataId:l.write(af(L,s.dtype),F,s.dtype),shape:F,dtype:s.dtype}}};const Aut={kernelName:ME,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:a,dilations:l}=e,c=t,f=Jo(s.shape,c.data.get(s.dataId).values),d=Jo(r.shape,c.data.get(r.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:w,outHeight:x,outWidth:S,padInfo:T,strideHeight:$,strideWidth:E,filterHeight:R,filterWidth:B,dilationHeight:N,dilationWidth:k,outShape:_}=Qy(s.shape,r.shape,o,a,"NHWC",l);H(i.rank===_.length,()=>`Error in ${ME}, dy must have the same rank as output ${_.length}, but got ${i.rank}`);const F=Jo(_,c.data.get(i.dataId).values),A=XB(r.shape,r.dtype);for(let L=0;L<m;++L)for(let tt=0;tt<x;++tt){const st=tt*$-T.top;for(let j=0;j<S;++j){const Z=j*E-T.left;for(let J=0;J<w;++J){let ot=Number.MIN_SAFE_INTEGER,pt=0,q=0;for(let et=0;et<R;++et){const U=st+et*N;if(U>=0&&U<y)for(let X=0;X<B;++X){const nt=Z+X*k;if(nt>=0&&nt<b){const xt=f[L][U][nt][J]+d[et][X][J];xt>ot&&(ot=xt,pt=et,q=X)}}}A[pt][q][J]+=F[L][tt][j][J]}}}return{dataId:c.write(af(A,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const kut={kernelName:FE,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:a,dilations:l}=e,c=t,f=Jo(s.shape,c.data.get(s.dataId).values),d=Jo(r.shape,c.data.get(r.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:w,outHeight:x,outWidth:S,padInfo:T,strideHeight:$,strideWidth:E,filterHeight:R,filterWidth:B,dilationHeight:N,dilationWidth:k,outShape:_}=Qy(s.shape,r.shape,o,a,"NHWC",l);H(i.rank===_.length,()=>`Error in ${FE}, dy must have the same rank as output ${_.length}, but got ${i.rank}`);const F=Jo(_,c.data.get(i.dataId).values),A=XB(s.shape,s.dtype);for(let L=0;L<m;++L)for(let tt=0;tt<x;++tt){const st=tt*$-T.top;for(let j=0;j<S;++j){const Z=j*E-T.left;for(let J=0;J<w;++J){let ot=Number.MIN_SAFE_INTEGER,pt=st<0?0:st,q=Z<0?0:Z;for(let et=0;et<R;++et){const U=st+et*N;if(U>=0&&U<y)for(let X=0;X<B;++X){const nt=Z+X*k;if(nt>=0&&nt<b){const xt=f[L][U][nt][J]+d[et][X][J];xt>ot&&(ot=xt,pt=U,q=nt)}}}A[L][pt][q][J]+=F[L][tt][j][J]}}}return{dataId:c.write(af(A,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function _ut(n){const{inputs:t,backend:e,attrs:s}=n,{image:r}=t,{canvas:i,options:o}=s,{contextOptions:a,imageOptions:l}=o||{},c=l?.alpha||1,f=a?.contextType||"2d";if(f!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const d=i.getContext(f,a?.contextAttributes||{});if(d==null)throw new Error(`Could not get the context with ${f} type.`);const[m,y]=r.shape.slice(0,2),b=r.shape.length===2?1:r.shape[2],w=e.data.get(r.dataId).values,x=r.dtype==="float32"?255:1,S=new Uint8ClampedArray(y*m*4);for(let $=0;$<m*y;++$){const E=[0,0,0,255*c];for(let B=0;B<b;B++){const N=w[$*b+B];if(r.dtype==="float32"){if(N<0||N>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${N}.`)}else if(r.dtype==="int32"&&(N<0||N>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${N}.`);b===1?(E[0]=N*x,E[1]=N*x,E[2]=N*x):E[B]=N*x}const R=$*4;S[R+0]=Math.round(E[0]),S[R+1]=Math.round(E[1]),S[R+2]=Math.round(E[2]),S[R+3]=Math.round(E[3])}i.width=y,i.height=m;const T=new ImageData(S,y,m);return d.putImageData(T,0,0),r}const Nut={kernelName:QX,backendName:"cpu",kernelFunc:_ut};function hb(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;ue(r,"sum");let a;r.dtype==="bool"?a=dc({inputs:{x:r},backend:e,attrs:{dtype:"int32"}}):a=ml({inputs:{x:r},backend:e});const l=a.shape.length,c=Ve(i,a.shape),f=hs(c,l);let d=c,m=a;f!=null&&(m=ui({inputs:{x:a},backend:e,attrs:{perm:f}}),d=xs(d.length,l)),Sr("sum",d,m.shape.length);const[y,b]=ur(m.shape,d),w=Ei(m.dtype,"int32");let x=wx(e,y,w);const S=Lt(b),T=e.data.get(x.dataId).values,$=e.data.get(m.dataId).values;for(let E=0;E<T.length;++E){const R=E*S;let B=0;for(let N=0;N<S;++N)B+=$[R+N];T[E]=B}if(o){const E=ks(x.shape,c),R=x;x=Gn({inputs:{x},backend:e,attrs:{shape:E}}),e.disposeIntermediateTensorInfo(R)}return e.disposeIntermediateTensorInfo(a),f!=null&&e.disposeIntermediateTensorInfo(m),x}const Rut={kernelName:iv,backendName:"cpu",kernelFunc:hb};function Dut(n){const{inputs:t,backend:e,attrs:s}=n,{equation:r}=s,i=t,{allDims:o,summedDims:a,idDims:l}=sk(r,i.length);ik(o.length,l,i);const{path:c,steps:f}=ok(a,l),d=f.length;let m=null,y=o.length;const b=[];for(let w=0;w<d;++w){for(const x of f[w]){const{permutationIndices:S,expandDims:T}=rk(y,l[x]);let $;ak(S)?$=i[x]:($=ui({inputs:{x:i[x]},backend:e,attrs:{perm:S}}),b.push($));const E=$.shape.slice();for(let R=0;R<T.length;++R)E.splice(T[R],0,1);mn($.shape,E)||($=Gn({inputs:{x:$},backend:e,attrs:{shape:E}}),b.push($)),m===null?m=$:(m=Mv({inputs:{a:$,b:m},backend:e}),b.push(m))}w<d-1&&(c[w]>=0&&(m=hb({inputs:{x:m},backend:e,attrs:{axis:c[w]-(o.length-y),keepDims:!1}}),b.push(m)),y--)}for(const w of b)w!==m&&e.disposeIntermediateTensorInfo(w);return m}const Out={kernelName:M2,backendName:"cpu",kernelFunc:Dut};function Fut(n){const{inputs:t,backend:e}=n,{dy:s,y:r}=t;ue([s,r],"eluGrad");const i=new Float32Array(Lt(r.shape)),o=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values;for(let l=0;l<o.length;++l){const c=o[l];c>=0?i[l]=a[l]:i[l]=a[l]*(c+1)}return e.makeTensorInfo(r.shape,"float32",i)}const Mut={kernelName:L2,backendName:"cpu",kernelFunc:Fut};const Lut=YA,zut=QA,But=ZA,Put=JA,Vut=tk,Uut=ek,Gut=Tn(my,n=>{const t=Math.sign(n),e=Math.abs(n),s=1/(1+Lut*e);return t*(1-((((Uut*s+Vut)*s+Put)*s+But)*s+zut)*s*Math.exp(-e*e))}),Wut={kernelName:my,backendName:"cpu",kernelFunc:Gut};function Ix(n){const{inputs:t,backend:e,attrs:s}=n,{input:r}=t,{dim:i}=s,o=r.shape.length,a=r.shape.slice();let l=i;return i<0&&(H(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),Gn({inputs:{x:r},backend:e,attrs:{shape:a}})}const jut={kernelName:Aw,backendName:"cpu",kernelFunc:Ix};const qut=vs((n,t)=>n/t),Pk=Js(dy,qut),c$={kernelName:dy,backendName:"cpu",kernelFunc:Pk};function H6(n,t,e){const s=n.shape,r=s[0],i=s[1],o=e.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[r,i],f=Lt(c),d=Nr("float32",f),m=Nr("float32",f);for(let x=0;x<r;x++){const S=Xh({inputs:{x:a},backend:e,attrs:{begin:[x,0],size:[1,i]}}),T=Xh({inputs:{x:l},backend:e,attrs:{begin:[x,0],size:[1,i]}}),$=Ii({inputs:{real:S,imag:T},backend:e}),{real:E,imag:R}=Hut($,t,e),B=Zl(E,R);for(let N=0;N<i;N++){const k=nk(B,N);d[x*i+N]=k.real,m[x*i+N]=k.imag}e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo($)}const y=e.makeTensorInfo(c,"float32",d),b=e.makeTensorInfo(c,"float32",m),w=Ii({inputs:{real:y,imag:b},backend:e});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),w}function Hut(n,t,e){const s=Lt(n.shape),r=e.data.get(n.dataId),i=e.data.get(r.complexTensorInfos.real.dataId).values,o=e.data.get(r.complexTensorInfos.imag.dataId).values;if(Kut(s)){const a=h$(i,o,s,t,e),l=[n.shape[0],n.shape[1]];if(t){const c=e.makeTensorInfo(l,"float32",a.real),f=e.makeTensorInfo(l,"float32",a.imag),d=e.makeTensorInfo([],"float32",kc(s,"float32")),m=ml({inputs:{x:d},backend:e}),y=c$.kernelFunc({inputs:{a:c,b:d},backend:e}),b=c$.kernelFunc({inputs:{a:f,b:m},backend:e}),w=e.data.get(y.dataId).values,x=e.data.get(b.dataId).values;return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),{real:w,imag:x}}return a}else{const a=Zl(i,o),l=Xut(a,s,t);return W4(l)}}function Kut(n){return(n&n-1)===0}function h$(n,t,e,s,r){if(e===1)return{real:n,imag:t};const i=Zl(n,t),o=e/2,a=j4(i),l=a.real,c=a.imag,f=[l.length],d=r.makeTensorInfo(f,"float32",l),m=r.makeTensorInfo(f,"float32",c),y=Ii({inputs:{real:d,imag:m},backend:r}),b=q4(i),w=b.real,x=b.imag,S=[w.length],T=r.makeTensorInfo(S,"float32",w),$=r.makeTensorInfo(S,"float32",x),E=Ii({inputs:{real:T,imag:$},backend:r}),R=h$(l,c,o,s,r),B=R.real,N=R.imag,k=[B.length],_=r.makeTensorInfo(k,"float32",B),F=r.makeTensorInfo(k,"float32",N),A=Ii({inputs:{real:_,imag:F},backend:r}),P=h$(w,x,o,s,r),L=P.real,tt=P.imag,st=[L.length],j=r.makeTensorInfo(st,"float32",L),Z=r.makeTensorInfo(st,"float32",tt),J=Ii({inputs:{real:j,imag:Z},backend:r}),ot=K4(e,s),pt=[ot.real.length],q=r.makeTensorInfo(pt,"float32",ot.real),et=r.makeTensorInfo(pt,"float32",ot.imag),U=Ii({inputs:{real:q,imag:et},backend:r}),X=Mv({inputs:{a:U,b:J},backend:r}),nt=Xd({inputs:{a:A,b:X},backend:r}),xt=zk({inputs:{a:A,b:X},backend:r}),Ot=Kh({inputs:{input:nt},backend:r}),qt=Kh({inputs:{input:xt},backend:r}),zt=Yd({inputs:{input:nt},backend:r}),Wt=Yd({inputs:{input:xt},backend:r}),Xt=Qd({inputs:[Ot,qt],backend:r,attrs:{axis:0}}),te=Qd({inputs:[zt,Wt],backend:r,attrs:{axis:0}}),oe=r.data.get(Xt.dataId).values,fe=r.data.get(te.dataId).values;return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(Z),r.disposeIntermediateTensorInfo(J),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(et),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(X),r.disposeIntermediateTensorInfo(nt),r.disposeIntermediateTensorInfo(xt),r.disposeIntermediateTensorInfo(Ot),r.disposeIntermediateTensorInfo(zt),r.disposeIntermediateTensorInfo(qt),r.disposeIntermediateTensorInfo(Wt),r.disposeIntermediateTensorInfo(Xt),r.disposeIntermediateTensorInfo(te),{real:oe,imag:fe}}function Xut(n,t,e){const s=new Float32Array(t*2);for(let r=0;r<t;r++){let i=0,o=0;for(let a=0;a<t;a++){const l=X4(r*a,t,e),c=nk(n,a);i+=c.real*l.real-c.imag*l.imag,o+=c.real*l.imag+c.imag*l.real}e&&(i/=t,o/=t),H4(s,i,o,r)}return s}function Yut(n){const{inputs:t,backend:e}=n,{input:s}=t,r=Lt(s.shape),i=s.shape[s.shape.length-1],o=r/i,a=Gn({inputs:{x:s},backend:e,attrs:{shape:[o,i]}}),l=H6(a,!1,e),c=Gn({inputs:{x:l},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}const Qut={kernelName:z2,backendName:"cpu",kernelFunc:Yut};function Vk(n){const{backend:t,attrs:e}=n,{shape:s,value:r,dtype:i}=e,o=i||gp(r),a=gs(o,Lt(s));return Jut(a,r,o),t.makeTensorInfo(s,o,a)}const Zut={kernelName:B2,backendName:"cpu",kernelFunc:Vk};function Jut(n,t,e){n.fill(t)}const tct={kernelName:P2,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,r=e,i=Nr(s.dtype,Lt(s.shape)),[o,a,l,c]=s.shape,f=r.data.get(s.dataId).values;for(let m=0;m<o;m++){const y=m*l*a*c;for(let b=0;b<a;b++){const w=b*(l*c);for(let x=0;x<l;x++){const S=x*c;for(let T=0;T<c;T++){const $=Math.round(l-x-1),E=y+w+S+T;let R=f[E];if($>=0&&$<l){const B=$*c,N=y+w+B+T;R=f[N]}i[E]=R}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function ect(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:f,dilations:d,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s;let w=j6({inputs:{x:r,filter:i},backend:e,attrs:{strides:l,pad:c,dataFormat:f,dilations:d,dimRoundingMode:m}});if(o){const x=w;if(f==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const S=Gn({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});w=Xd({inputs:{a:w,b:S},backend:e}),e.disposeIntermediateTensorInfo(S)}else w=Xd({inputs:{a:w,b:o},backend:e});e.disposeIntermediateTensorInfo(x)}if(y){const x=w;if(f==="NCHW"&&y==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const S=Gn({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});w=Sx(e,w,y,S,b),e.disposeIntermediateTensorInfo(S)}else w=Sx(e,w,y,a,b);e.disposeIntermediateTensorInfo(x)}return w}const nct={kernelName:sx,backendName:"cpu",kernelFunc:ect};function sct(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:f,dilations:d,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s;let w=q6({inputs:{x:r,filter:i},backend:e,attrs:{strides:l,pad:c,dataFormat:f,dilations:d,dimRoundingMode:m}});if(o){const x=w;w=Xd({inputs:{a:w,b:o},backend:e}),e.disposeIntermediateTensorInfo(x)}if(y){const x=w;w=Sx(e,w,y,a,b),e.disposeIntermediateTensorInfo(x)}return w}const rct={kernelName:bP,backendName:"cpu",kernelFunc:sct};function ict(n){const{inputs:t,backend:e}=n,{params:s,indices:r}=t,i=Lt(s.shape),o=r.shape,a=o[o.length-1],[l,c,f,d]=BA(s,r);if(c===0)return e.makeTensorInfo(l,s.dtype,[]);const m=e.data.get(r.dataId).values,y=e.bufferSync(s),b=s6(m,y,s.dtype,c,a,f,d,s.shape,i);return e.makeTensorInfo(l,s.dtype,b.values)}const oct={kernelName:tP,backendName:"cpu",kernelFunc:ict};function act(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,indices:i}=t,{axis:o,batchDims:a}=s;ue([r,i],"gatherV2");const l=Ve(o,r.shape)[0],c=e.data.get(i.dataId).values,f=r.shape[l];for(let E=0;E<c.length;++E){const R=c[E];H(R<=f-1&&R>=0,()=>`GatherV2: the index value ${R} is not in [0, ${f-1}]`)}let d=a;a==null&&(d=0);const m=Lt(i.shape),y=uk(r,i,l,d),b=Gn({inputs:{x:r},backend:e,attrs:{shape:[y.batchSize,y.outerSize,y.dimSize,y.sliceSize]}}),w=Gn({inputs:{x:i},backend:e,attrs:{shape:[y.batchSize,m/y.batchSize]}}),x=[y.batchSize,y.outerSize,m/y.batchSize,y.sliceSize],S=e.bufferSync(w),T=e.bufferSync(b),$=r6(T,S,x);return e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(w),e.makeTensorInfo(y.outputShape,$.dtype,$.values)}const lct={kernelName:_w,backendName:"cpu",kernelFunc:act};function uct(n){const{inputs:t,backend:e}=n,{input:s}=t,r=Lt(s.shape),i=s.shape[s.shape.length-1],o=r/i,a=Gn({inputs:{x:s},backend:e,attrs:{shape:[o,i]}}),l=H6(a,!0,e),c=Gn({inputs:{x:l},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}const cct={kernelName:V2,backendName:"cpu",kernelFunc:uct};const hct=Tn(Sy,n=>Number.isFinite(n)?1:0,"bool"),fct={kernelName:Sy,backendName:"cpu",kernelFunc:hct};const dct=Tn(Iy,n=>Math.abs(n)===1/0?1:0,"bool"),pct={kernelName:Iy,backendName:"cpu",kernelFunc:dct};const mct=Tn(Ty,n=>Number.isNaN(n)?1:0,"bool"),gct={kernelName:Ty,backendName:"cpu",kernelFunc:mct};function yct(n){const{backend:t,attrs:e}=n,{start:s,stop:r,num:i}=e,o=u6(s,r,i);return t.makeTensorInfo([o.length],"float32",o)}const bct={kernelName:eP,backendName:"cpu",kernelFunc:yct};const xct=Tn(Ey,n=>Math.log1p(n)),wct={kernelName:Ey,backendName:"cpu",kernelFunc:xct};const vct=vs((n,t)=>n&&t),Sct=Js(Fw,vct,null,"bool"),Ict={kernelName:Fw,backendName:"cpu",kernelFunc:Sct};const Tct=Tn(Mw,n=>n?0:1,"bool"),Cct={kernelName:Mw,backendName:"cpu",kernelFunc:Tct};const Ect=vs((n,t)=>n||t),$ct=Js(Lw,Ect,null,"bool"),Act={kernelName:Lw,backendName:"cpu",kernelFunc:$ct};function kct(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{depthRadius:i,bias:o,alpha:a,beta:l}=s;ue(r,"LRN");const c=r.shape[3],f=c-1,d=e.data.get(r.dataId).values,m=Lt(r.shape),y=new Float32Array(m);function b(w){const x=w%c;let S=w-x+Math.max(0,x-i);const T=w-x+Math.min(x+i,f);let $=0;for(;S<=T;S++){const E=d[S];$+=E*E}return $}for(let w=0;w<m;w++){const x=b(w),S=d[w]*Math.pow(o+a*x,-l);y[w]=S}return e.makeTensorInfo(r.shape,r.dtype,y)}const _ct={kernelName:zw,backendName:"cpu",kernelFunc:kct};function Nct(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,y:i,dy:o}=t,{depthRadius:a,bias:l,alpha:c,beta:f}=s;ue(o,"LRNGrad");const d=Lt(o.shape),m=o.shape[3],y=e.data.get(o.dataId).values,b=e.data.get(r.dataId).values,w=e.data.get(i.dataId).values,x=new Float32Array(d),S=d;for(let T=0;T<S;T++){const $=T%m,E=T-$+Math.max(0,$-a),R=T-$+Math.min(m,$+a+1);let B=0;for(let N=E;N<R;N++)B+=Math.pow(b[N],2);B=c*B+l;for(let N=E;N<R;N++){let k=-2*c*f*b[N]*w[T]/B;T===N&&(k+=Math.pow(B,-f)),k*=y[T],x[N]+=k}}return e.makeTensorInfo(o.shape,r.dtype,x)}const Rct={kernelName:G2,backendName:"cpu",kernelFunc:Nct};function K6(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reductionIndices:i,keepDims:o}=s,a=e;let l=r.shape;const c=l.length,f=Ve(i,l);let d=f;const m=hs(d,c);let y=a.data.get(r.dataId).values;if(m!=null){const E=new Array(c);for(let R=0;R<E.length;R++)E[R]=l[m[R]];y=Mk(y,l,r.dtype,m,E),d=xs(d.length,c),l=E}ue(r,"max"),Sr("max",d,c);const[b,w]=ur(l,d),x=Lt(w),S=h6(y,x,b,r.dtype),T=a.write(S,b,r.dtype);let $=b;return o&&($=ks(b,f)),{dataId:T,shape:$,dtype:r.dtype}}const Dct={kernelName:Bw,backendName:"cpu",kernelFunc:K6};function Oct(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;ue(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,c=1;H(Or(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const f=$o(r.shape,i,o,c,a,l);let d;if(f.filterWidth===1&&f.filterHeight===1&&mn(f.inShape,f.outShape))d=ml({inputs:{x:r},backend:e});else{const m=e.data.get(r.dataId).values,y=de(r.shape),b=Bk(m,r.shape,r.dtype,y,f,"max");d=e.makeTensorInfo(f.outShape,r.dtype,b.values)}return d}const Fct={kernelName:Pw,backendName:"cpu",kernelFunc:Oct};function Mct(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s;ue(r,"maxPool3d");const f=au(r.shape,i,o,1,a,l,c),d=e.data.get(r.dataId).values,m=W6(d,r.shape,r.dtype,de(r.shape),f,"max");return e.makeTensorInfo(m.shape,"float32",m.values)}const Lct={kernelName:Vw,backendName:"cpu",kernelFunc:Mct};function zct(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=s;ue([r,i],"maxPool3DGrad");const f=au(i.shape,o,a,1,l,c),d=e.bufferSync(i),m=Elt(d,f),y=f.strideDepth,b=f.strideHeight,w=f.strideWidth,x=f.dilationDepth,S=f.dilationHeight,T=f.dilationWidth,$=f.effectiveFilterDepth,E=f.effectiveFilterHeight,R=f.effectiveFilterWidth,B=$-1-f.padInfo.front,N=R-1-f.padInfo.left,k=E-1-f.padInfo.top,_=Pe(i.shape,"float32"),F=e.bufferSync(r);for(let A=0;A<f.batchSize;++A)for(let P=0;P<f.inChannels;++P)for(let L=0;L<f.inDepth;++L)for(let tt=0;tt<f.inHeight;++tt)for(let st=0;st<f.inWidth;++st){const j=L-B,Z=tt-k,J=st-N;let ot=0;for(let pt=0;pt<$;pt+=x){const q=(j+pt)/y;if(!(q<0||q>=f.outDepth||Math.floor(q)!==q))for(let et=0;et<E;et+=S){const U=(Z+et)/b;if(!(U<0||U>=f.outHeight||Math.floor(U)!==U))for(let X=0;X<R;X+=T){const nt=(J+X)/w;if(nt<0||nt>=f.outWidth||Math.floor(nt)!==nt)continue;const xt=$*E*R-1-m.get(A,q,U,nt,P),Ot=pt*E*R+et*R+X,qt=xt===Ot?1:0;if(qt===0)continue;const zt=F.get(A,q,U,nt,P);ot+=zt*qt}}}_.set(ot,A,L,tt,st,P)}return e.makeTensorInfo(_.shape,_.dtype,_.values)}const Bct={kernelName:j2,backendName:"cpu",kernelFunc:zct};function Pct(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i,output:o}=t,a=i;ue([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:f,dimRoundingMode:d}=s,m=$o(a.shape,l,c,1,f,d),y=e.data.get(a.dataId).values,b=Pe(m.outShape,a.dtype,G6(y,a.shape,a.dtype,m).values),w=m.strideHeight,x=m.strideWidth,S=m.dilationHeight,T=m.dilationWidth,$=m.effectiveFilterHeight,E=m.effectiveFilterWidth,R=E-1-m.padInfo.left,B=$-1-m.padInfo.top,N=Pe(a.shape,"float32"),k=e.data.get(r.dataId).values,_=Pe(r.shape,"float32",k);for(let F=0;F<m.batchSize;++F)for(let A=0;A<m.inChannels;++A)for(let P=0;P<m.inHeight;++P)for(let L=0;L<m.inWidth;++L){const tt=P-B,st=L-R;let j=0;for(let Z=0;Z<$;Z+=S){const J=(tt+Z)/w;if(!(J<0||J>=m.outHeight||Math.floor(J)!==J))for(let ot=0;ot<E;ot+=T){const pt=(st+ot)/x;if(pt<0||pt>=m.outWidth||Math.floor(pt)!==pt)continue;const q=$*E-1-b.get(F,J,pt,A),et=Z*E+ot,U=q===et?1:0;if(U===0)continue;const X=_.get(F,J,pt,A);j+=X*U}}N.set(j,F,P,L,A)}return e.makeTensorInfo(N.shape,N.dtype,N.values)}const Vct={kernelName:W2,backendName:"cpu",kernelFunc:Pct};function Uct(n,t,e,s,r){const i=de(t),o=Bk(n,t,e,i,r,"max"),a=G6(n,t,e,r,!0,s);return[o.values,a.values]}const Gct={kernelName:nP,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=t,l=e;ue(s,"MaxPoolWithArgmax");const c=l.data.get(s.dataId).values,f=$o(s.shape,r,i,[1,1],o),[d,m]=Uct(c,s.shape,s.dtype,a,f),y=l.write(d,f.outShape,s.dtype),b=l.write(m,f.outShape,s.dtype);return[{dataId:y,shape:f.outShape,dtype:s.dtype},{dataId:b,shape:f.outShape,dtype:"int32"}]}};function Wct(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,a=Ve(i,r.shape),c=ur(r.shape,a)[1],f=Lt(c),d=[],m=e.makeTensorInfo([],"float32",new Float32Array([f]));d.push(m);const y=dc({inputs:{x:r},backend:e,attrs:{dtype:"float32"}});d.push(y);const b=Pk({inputs:{a:y,b:m},backend:e});d.push(b);const w=hb({inputs:{x:b},backend:e,attrs:{axis:i,keepDims:o}});return d.forEach(x=>e.disposeIntermediateTensorInfo(x)),w}const jct={kernelName:Uw,backendName:"cpu",kernelFunc:Wct};function qct(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;ue(r,"min");const a=Ve(i,r.shape);let l=a;const c=hs(l,r.shape.length);let f=r;c!=null&&(f=ui({inputs:{x:r},backend:e,attrs:{perm:c}}),l=xs(l.length,r.shape.length)),Sr("min",l,f.shape.length);const[d,m]=ur(f.shape,l),y=Lt(m),b=Rr(Lt(d),f.dtype),w=e.data.get(f.dataId).values;for(let S=0;S<b.length;++S){const T=S*y;let $=w[T];for(let E=0;E<y;++E){const R=w[T+E];(Number.isNaN(R)||R<$)&&($=R)}b[S]=$}c!=null&&e.disposeIntermediateTensorInfo(f);const x=e.makeTensorInfo(d,f.dtype,b);if(o){const S=ks(d,a),T=Gn({inputs:{x},backend:e,attrs:{shape:S}});return e.disposeIntermediateTensorInfo(x),T}return x}const Hct={kernelName:Gw,backendName:"cpu",kernelFunc:qct};function Kct(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:i,mode:o}=s;ue(r,"mirrorPad");const a=i.map(($,E)=>$[0]+r.shape[E]+$[1]),l=i.map($=>$[0]),c=i.map(($,E)=>$[0]+r.shape[E]),f=o==="reflect"?0:1,d=e.data.get(r.dataId).values,m=r.shape.length,y=de(r.shape),b=Lt(a),w=a.length,x=de(a),S=Nr(r.dtype,b);for(let $=0;$<b;$++){let E=yp($,w,x);for(let B=0;B<w;B++)E[B]<l[B]?E[B]=l[B]*2-E[B]-f:E[B]>=c[B]&&(E[B]=(c[B]-1)*2-E[B]+f);E=E.map((B,N)=>B-l[N]);const R=el(E,m,y);S[$]=d[R]}return{dataId:e.write(S,a,r.dtype),shape:a,dtype:r.dtype}}const Xct={kernelName:Ww,backendName:"cpu",kernelFunc:Kct};const Yct=vs(((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t})),Qct=Js(ky,Yct),Zct={kernelName:ky,backendName:"cpu",kernelFunc:Qct};function X6(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{dim:i}=s,o=r.shape.length;let a=i;if(a===-1&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=Ve([a],r.shape),c=K6({inputs:{x:r},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),f=ks(c.shape,l),d=Gn({inputs:{x:c},backend:e,attrs:{shape:f}}),m=zk({inputs:{a:r,b:d},backend:e}),y=JG({inputs:{x:m},backend:e}),b=hb({inputs:{x:y},backend:e,attrs:{axis:l,keepDims:!1}}),w=Gn({inputs:{x:b},backend:e,attrs:{shape:f}}),x=Pk({inputs:{a:y,b:w},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(w),x}const Jct={kernelName:lv,backendName:"cpu",kernelFunc:X6};function tht(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{numSamples:i,seed:o,normalized:a}=s;ue(r,"multinomial");const l=a?r:X6({inputs:{logits:r},backend:e,attrs:{dim:-1}}),c=l.shape[0],f=l.shape[1],d=e.data.get(l.dataId).values,m=[c,i],y=Rr(Lt(m),"int32");for(let b=0;b<c;++b){const w=b*f,x=new Float32Array(f-1);x[0]=d[w];for(let $=1;$<x.length;++$)x[$]=x[$-1]+d[w+$];const S=uf.alea(o.toString()),T=b*i;for(let $=0;$<i;++$){const E=S();y[T+$]=x.length;for(let R=0;R<x.length;R++)if(E<x[R]){y[T+$]=R;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(m,"int32",y)}const eht={kernelName:sP,backendName:"cpu",kernelFunc:tht};const nht=OA;function sht(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s;ue(r,"NonMaxSuppression");const c=e.data.get(r.dataId).values,f=e.data.get(i.dataId).values,{selectedIndices:d}=nht(c,f,o,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}const rht={kernelName:q2,backendName:"cpu",kernelFunc:sht};const iht=FA;function oht(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=s;ue(r,"NonMaxSuppressionPadded");const f=e.data.get(r.dataId).values,d=e.data.get(i.dataId).values,{selectedIndices:m,validOutputs:y}=iht(f,d,o,a,l,c);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([y]))]}const aht={kernelName:H2,backendName:"cpu",kernelFunc:oht};const lht=MA;function uht(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=s;ue(r,"NonMaxSuppressionWithScore");const f=e.data.get(r.dataId).values,d=e.data.get(i.dataId).values,m=o,y=a,b=l,w=c,{selectedIndices:x,selectedScores:S}=lht(f,d,m,y,b,w);return[e.makeTensorInfo([x.length],"int32",new Int32Array(x)),e.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const cht={kernelName:K2,backendName:"cpu",kernelFunc:uht};function hht(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r}=t,{dtype:i,depth:o,onValue:a,offValue:l}=s;ue(r,"oneHot");const c=Lt(r.shape),f=new Float32Array(c*o);f.fill(l);const d=e.data.get(r.dataId).values;for(let m=0;m<c;++m)d[m]>=0&&d[m]<o&&(f[m*o+d[m]]=a);return e.makeTensorInfo([...r.shape,o],i,f)}const fht={kernelName:Kw,backendName:"cpu",kernelFunc:hht};function Tx(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=Kh({inputs:{input:s},backend:e}),i=Tx({inputs:{x:r},backend:e}),o=Yd({inputs:{input:s},backend:e}),a=Tx({inputs:{x:o},backend:e}),l=Ii({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}else return Vk({backend:e,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const dht={kernelName:hv,backendName:"cpu",kernelFunc:Tx};function Y6(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=Kh({inputs:{input:s},backend:e}),i=Y6({inputs:{x:r},backend:e}),o=Yd({inputs:{input:s},backend:e}),a=Tx({inputs:{x:o},backend:e}),l=Ii({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}else return Vk({backend:e,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const pht={kernelName:Hw,backendName:"cpu",kernelFunc:Y6};function Q6(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s;if(t.length===1)return Ix({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const i=t[0].shape,o=t[0].dtype;t.forEach(f=>{m2(i,f.shape,"All tensors passed to stack must have matching shapes"),H(o===f.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=t.map(f=>{const d=Ix({inputs:{input:f},backend:e,attrs:{dim:r}});return a.push(d),d}),c=Qd({inputs:l,backend:e,attrs:{axis:r}});return a.forEach(f=>e.disposeIntermediateTensorInfo(f)),c}const mht={kernelName:Xw,backendName:"cpu",kernelFunc:Q6};function ght(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:i,constantValue:o}=s;ue(r,"pad");const a=i.map((T,$)=>T[0]+r.shape[$]+T[1]),l=i.map(T=>T[0]),c=e.data.get(r.dataId).values,f=Lt(r.shape),d=r.shape.length,m=de(r.shape),y=Lt(a),b=a.length,w=de(a),x=Nr(r.dtype,y);o!==0&&x.fill(o);for(let T=0;T<f;T++){const E=yp(T,d,m).map((B,N)=>B+l[N]),R=el(E,b,w);x[R]=c[T]}return{dataId:e.write(x,a,r.dtype),shape:a,dtype:r.dtype}}const Z6={kernelName:Yw,backendName:"cpu",kernelFunc:ght};const yht=vs((n,t)=>Math.pow(n,t)),bht=Js(Ny,yht),xht={kernelName:Ny,backendName:"cpu",kernelFunc:bht};function wht(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=t,{outputRaggedRank:a}=s,l=r.map(S=>e.data.get(S.dataId).values),c=r.map(S=>S.shape),f=e.data.get(i.dataId).values,d=e.data.get(o.dataId).values,[m,y,b]=y6(l,c,f,i.shape,i.dtype,d,o.shape),w=m.map(S=>e.makeTensorInfo([S.length],"int32",S)),x=e.makeTensorInfo(b,i.dtype,y);return w.concat([x])}const vht={kernelName:rP,backendName:"cpu",kernelFunc:wht};function Sht(n){const{inputs:t,backend:e}=n,{starts:s,limits:r,deltas:i}=t,o=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values,l=e.data.get(i.dataId).values,[c,f]=b6(o,s.shape,s.dtype,a,r.shape,l,i.shape),d=e.makeTensorInfo([c.length],"int32",c),m=e.makeTensorInfo([f.length],s.dtype,f);return[d,m]}const Iht={kernelName:iP,backendName:"cpu",kernelFunc:Sht};function Tht(n){const{inputs:t,backend:e,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=s,c=e.data.get(r.dataId).values,f=e.data.get(i.dataId).values,d=e.data.get(o.dataId).values,m=a.map(x=>e.data.get(x.dataId).values),y=a.map(x=>x.shape),[b,w]=x6(c,r.shape,f,i.shape,i.dtype,d,o.shape,m,y,l);return e.makeTensorInfo(b,i.dtype,w)}const Cht={kernelName:oP,backendName:"cpu",kernelFunc:Tht};function Eht(n){const{backend:t,attrs:e}=n,{start:s,stop:r,dtype:i,step:o}=e,a=w6(s,r,o,i);return t.makeTensorInfo([a.length],i,a)}const $ht={kernelName:X2,backendName:"cpu",kernelFunc:Eht};const Aht=Tn(Ry,n=>1/n),kht={kernelName:Ry,backendName:"cpu",kernelFunc:Aht};function _ht(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:a}=s;ue(r,"resizeBilinear");const l=de(r.shape),[c,f]=a,[d,m,y,b]=r.shape,w=e.data.get(r.dataId).values,x=new Float32Array(Lt([d,c,f,b])),S=[i&&c>1?m-1:m,i&&f>1?y-1:y],T=[i&&c>1?c-1:c,i&&f>1?f-1:f];let $=0;const E=S[0]/T[0],R=S[1]/T[1];for(let B=0;B<d;B++)for(let N=0;N<c;N++){let k;o?k=E*(N+.5)-.5:k=E*N;const _=Math.max(0,Math.floor(k)),F=k-_,A=Math.min(m-1,Math.ceil(k)),P=B*l[0]+_*l[1],L=B*l[0]+A*l[1];for(let tt=0;tt<f;tt++){let st;o?st=R*(tt+.5)-.5:st=R*tt;const j=Math.max(0,Math.floor(st)),Z=st-j,J=Math.min(y-1,Math.ceil(st)),ot=P+j*l[2],pt=L+j*l[2],q=P+J*l[2],et=L+J*l[2];for(let U=0;U<b;U++){const X=w[ot+U],nt=w[pt+U],xt=w[q+U],Ot=w[et+U],qt=X+(xt-X)*Z,zt=nt+(Ot-nt)*Z,Wt=qt+(zt-qt)*F;x[$++]=Wt}}}return e.makeTensorInfo([d,c,f,b],"float32",x)}const Nht={kernelName:ev,backendName:"cpu",kernelFunc:_ht};function Rht(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:o}=s;ue([i,r],"resizeBilinearGrad");const a=de(r.shape),[l,c,f,d]=r.shape,[,m,y]=i.shape,b=new Float32Array(l*c*f*d),w=[o&&m>1?c-1:c,o&&y>1?f-1:f],x=[o&&m>1?m-1:m,o&&y>1?y-1:y],S=w[0]/x[0],T=w[1]/x[1],$=e.data.get(i.dataId).values;let E=0;for(let R=0;R<l;R++){const B=R*a[0];for(let N=0;N<m;N++){const k=N*S,_=Math.floor(k),F=Math.min(Math.ceil(k),c-1),A=B+_*a[1],P=B+F*a[1],L=k-_,tt=1-L;for(let st=0;st<y;st++){const j=st*T,Z=Math.floor(j),J=Math.min(Math.ceil(j),f-1),ot=j-Z,pt=1-ot,q=A+Z*a[2],et=A+J*a[2],U=P+Z*a[2],X=P+J*a[2],nt=tt*pt,xt=tt*ot,Ot=L*pt,qt=L*ot;for(let zt=0;zt<d;zt++){const Wt=$[E++];b[q+zt]+=Wt*nt,b[et+zt]+=Wt*xt,b[U+zt]+=Wt*Ot,b[X+zt]+=Wt*qt}}}}return e.makeTensorInfo([l,f,c,d],"float32",b)}const Dht={kernelName:Z2,backendName:"cpu",kernelFunc:Rht};function Oht(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:a}=s;ue(r,"resizeNearestNeighbor");const l=de(r.shape),[c,f]=a,[d,m,y,b]=r.shape,w=e.data.get(r.dataId).values,x=new Float32Array(d*c*f*b),S=[i&&c>1?m-1:m,i&&f>1?y-1:y],T=[i&&c>1?c-1:c,i&&f>1?f-1:f],$=S[0]/T[0],E=S[1]/T[1];let R=0;for(let B=0;B<d;B++){const N=B*l[0];for(let k=0;k<c;k++){const _=o?$*(k+.5):$*k;let F=Math.min(m-1,i?Math.round(_):Math.floor(_));o&&(F=Math.max(0,F));const A=N+F*l[1];for(let P=0;P<f;P++){const L=o?E*(P+.5):E*P;let tt=Math.min(y-1,i?Math.round(L):Math.floor(L));o&&(tt=Math.max(0,tt));const st=A+tt*l[2];for(let j=0;j<b;j++){const Z=w[st+j];x[R++]=Z}}}}return e.makeTensorInfo([d,c,f,b],r.dtype,x)}const Fht={kernelName:tv,backendName:"cpu",kernelFunc:Oht};function Mht(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:o}=s;ue([i,r],"resizeNearestNeighborGrad");const a=de(r.shape),l=de(i.shape),[c,f,d,m]=r.shape,[,y,b]=i.shape,w=new Float32Array(c*f*d*m),x=e.data.get(i.dataId).values,S=[o&&y>1?f-1:f,o&&b>1?d-1:d],T=[o&&y>1?y-1:y,o&&b>1?b-1:b],$=S[0]/T[0],E=S[1]/T[1],R=1/$,B=1/E,N=Math.ceil(R)*2+2,k=Math.ceil(B)*2+2;for(let _=0;_<c;_++){const F=_*a[0];for(let A=0;A<f;A++){const P=F+A*a[1],L=Math.floor(A*R),tt=Math.floor(L-N/2);for(let st=0;st<d;st++){const j=P+st*a[2],Z=Math.floor(st*B),J=Math.floor(Z-k/2);for(let ot=0;ot<m;ot++){let pt=0;for(let q=0;q<N;q++){const et=q+tt;if(et<0||et>=y)continue;const U=F+et*l[1],X=et*$,nt=Math.min(f-1,o?Math.round(X):Math.floor(X));if(A===nt)for(let xt=0;xt<k;xt++){const Ot=xt+J;if(Ot<0||Ot>=b)continue;const qt=U+Ot*l[2],zt=Ot*E,Wt=Math.min(d-1,o?Math.round(zt):Math.floor(zt));st===Wt&&(pt+=x[qt+ot])}}w[j+ot]=pt}}}}return e.makeTensorInfo(r.shape,r.dtype,w)}const Lht={kernelName:Q2,backendName:"cpu",kernelFunc:Mht};function zht(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dims:i}=s;ue(r,"reverse");const o=r.shape.length,a=Ve(i,r.shape);if(o===0)return ml({inputs:{x:r},backend:e});const l=new br(r.shape,r.dtype),c=e.bufferSync(r);for(let f=0;f<l.size;f++){const d=l.indexToLoc(f),m=d.slice();a.forEach(y=>m[y]=r.shape[y]-1-m[y]),l.set(c.get(...m),...d)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}const Bht={kernelName:nv,backendName:"cpu",kernelFunc:zht};const Pht={kernelName:iA,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=t,a=e,l=Nr(s.dtype,Lt(s.shape)),[c,f,d,m]=s.shape,[y,b]=HA(o,f,d),w=255,x=Math.sin(r),S=Math.cos(r),T=a.data.get(s.dataId).values;for(let E=0;E<c;E++){const R=E*d*f*m;for(let B=0;B<f;B++){const N=B*(d*m);for(let k=0;k<d;k++){const _=k*m;for(let F=0;F<m;F++){const A=[c,B,k,F],P=A[2],L=A[1];let tt=(P-y)*S-(L-b)*x,st=(P-y)*x+(L-b)*S;tt=Math.round(tt+y),st=Math.round(st+b);let j=i;if(typeof i!="number"&&(F===3?j=w:j=i[F]),tt>=0&&tt<d&&st>=0&&st<f){const J=st*(d*m),ot=tt*m,pt=R+J+ot+F;j=T[pt]}const Z=R+N+_+F;l[Z]=j}}}}return{dataId:a.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const Vht=Tn(Fy,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2===0?t:t+1}),Uht={kernelName:Fy,backendName:"cpu",kernelFunc:Vht};function Ght(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r,updates:i}=t,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:c,strides:f,outputSize:d}=hf(i,r,o),m=!0,y=e.bufferSync(r),b=e.bufferSync(i),w=Th(y,b,o,d,c,l,a,f,0,m);return e.makeTensorInfo(o,w.dtype,w.values)}const Wht={kernelName:aP,backendName:"cpu",kernelFunc:Ght};function jht(n,t){let e=0,s=n.length,r=0;for(;e<s;)r=Math.floor((e+s)/2),n[r]<t?e=r+1:s=r;return s}function qht(n,t){let e=0,s=n.length,r=0;for(;e<s;)r=Math.floor((e+s)/2),n[r]<=t?e=r+1:s=r;return s}function Hht(n,t,e,s,r,i){const o=gs("int32",e*r);for(let a=0;a<e;++a){const l=n.slice(a*s,(a+1)*s),c=a*r;for(let f=0;f<r;++f)o[c+f]=i==="left"?jht(l,t[f+c]):qht(l,t[f+c])}return o}function Kht(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:r,values:i}=t,{side:o}=s,a=e.data.get(r.dataId).values,l=e.data.get(i.dataId).values,c=Hht(a,l,r.shape[0],r.shape[1],i.shape[1],o);return e.makeTensorInfo(i.shape,"int32",c)}const Xht={kernelName:uP,backendName:"cpu",kernelFunc:Kht};function Yht(n){const{inputs:t,backend:e}=n,{condition:s,t:r,e:i}=t;ue([s,r,i],"select");const o=s.shape.length,a=e.data.get(s.dataId).values,l=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,f=Ei(r.dtype,i.dtype),d=Rr(Lt(r.shape),f);let m=0;const y=o===0||o>1||r.shape.length===1?1:Lt(r.shape.slice(1));for(let b=0;b<a.length;b++)for(let w=0;w<y;w++)a[b]===1?d[m++]=l[b]:d[m++]=c[b];return e.makeTensorInfo(r.shape,f,d)}const Qht={kernelName:sv,backendName:"cpu",kernelFunc:Yht};const Zht=Tv,Jht=Cv,tft=Tn(Ly,n=>n>=0?Jht*n:Zht*(Math.exp(n)-1)),eft={kernelName:Ly,backendName:"cpu",kernelFunc:tft};const nft=Tn(Py,n=>n<0?-1:n>0?1:0),sft={kernelName:Py,backendName:"cpu",kernelFunc:nft};const rft=Tn(zy,n=>Math.sin(n)),ift={kernelName:zy,backendName:"cpu",kernelFunc:rft};const oft=Tn(By,n=>Math.sinh(n)),aft={kernelName:By,backendName:"cpu",kernelFunc:oft};const lft=11920928955078125e-23,DM=Math.log(lft)+2,uft=Tn(Uy,n=>{const t=n>-DM,e=n<DM,s=Math.exp(n);let r;return e?r=s:t?r=n:r=Math.log(1+s),r}),cft={kernelName:Uy,backendName:"cpu",kernelFunc:uft};function hft(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,paddings:o}=s;ue([r],"spaceToBatchND");const a=Lt(i),l=[[0,0]];l.push(...o);for(let B=1+i.length;B<r.shape.length;++B)l.push([0,0]);const c=Z6.kernelFunc({inputs:{x:r},backend:e,attrs:{paddings:l,constantValue:0}}),f=nb(c.shape,i,a,!1),d=sb(f.length,i.length,!1),m=rb(c.shape,i,a,!1),w=Gn({inputs:{x:c},backend:e,attrs:{shape:f}}),T=ui({inputs:{x:w},backend:e,attrs:{perm:d}}),R=Gn({inputs:{x:T},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(T),R}const fft={kernelName:ov,backendName:"cpu",kernelFunc:hft};function dft(n){const{inputs:t,backend:e}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=t;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=e.data.get(s.dataId).values,l=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,f=e.data.get(o.dataId).values[0],[d,m,y,b,w]=T6(a,s.shape,s.dtype,l,r.dtype,c,f);return[e.makeTensorInfo(m,s.dtype,d),e.makeTensorInfo([m[0]],r.dtype,y),e.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(x=>Number(x)))),e.makeTensorInfo([w.length],s.dtype,new Int32Array(w))]}const pft={kernelName:cP,backendName:"cpu",kernelFunc:dft};function mft(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:r,newShape:i}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.data.get(r.dataId).values),a=e.data.get(s.dataId).values,l=Array.from(e.data.get(i.dataId).values),[c,f,d]=C6(a,s.shape,s.dtype,o,l);return[e.makeTensorInfo(f,s.dtype,c),e.makeTensorInfo([d.length],i.dtype,new Int32Array(d))]}const gft={kernelName:hP,backendName:"cpu",kernelFunc:mft};function yft(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values,l=e.data.get(i.dataId).values,[c,f]=Lk(o,s.shape,s.dtype,a,l,!0);return e.makeTensorInfo(f,s.dtype,c)}const bft={kernelName:fP,backendName:"cpu",kernelFunc:yft};function xft(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values,l=e.data.get(i.dataId).values,[c,f]=Lk(o,s.shape,s.dtype,a,l);return e.makeTensorInfo(f,s.dtype,c)}const wft={kernelName:dP,backendName:"cpu",kernelFunc:xft};function vft(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=t,{outputShape:a}=s,{sliceRank:l,numUpdates:c,sliceSize:f,strides:d,outputSize:m}=hf(i,r,a),y=!1,b=e.bufferSync(r);let w;switch(i.dtype){case"bool":{const x=e.bufferSync(i),S=!!e.data.get(o.dataId).values[0];w=Th(b,x,a,m,f,c,l,d,S,y);break}case"float32":{const x=e.bufferSync(i),S=e.data.get(o.dataId).values[0];w=Th(b,x,a,m,f,c,l,d,S,y);break}case"int32":{const x=e.bufferSync(i),S=e.data.get(o.dataId).values[0];w=Th(b,x,a,m,f,c,l,d,S,y);break}case"string":{const x=e.bufferSync(i),S=lc(e.data.get(o.dataId).values[0]);w=Th(b,x,a,m,f,c,l,d,S,y);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return e.makeTensorInfo(a,w.dtype,w.values)}const Sft={kernelName:pP,backendName:"cpu",kernelFunc:vft};function Ift(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{numOrSizeSplits:i,axis:o}=s,a=Ve(o,r.shape)[0],l=lk(r,i,a),c=new Array(r.shape.length).fill(0),f=r.shape.slice();return l.map(d=>{const m=[...f];m[a]=d;const y=Xh({inputs:{x:r},backend:e,attrs:{begin:c,size:m}});return c[a]+=d,y})}const Tft={kernelName:av,backendName:"cpu",kernelFunc:Ift};const Cft={kernelName:J2,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,s=t;ue(e,"square");const r=s.data.get(e.dataId).values,i=new Float32Array(r.length);for(let a=0;a<r.length;++a){const l=r[a];i[a]=l*l}return{dataId:s.write(i,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};const Eft=Tn(Xy,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),$ft={kernelName:Xy,backendName:"cpu",kernelFunc:Eft};function Aft(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:f,newAxisMask:d,shrinkAxisMask:m}=s;ue(r,"stridedSlice");const{finalShapeSparse:y,finalShape:b,isIdentity:w,sliceDim0:x,isSimpleSlice:S,begin:T,end:$,strides:E}=WA(r.shape,i,o,a,l,c,f,d,m);let R;if(w)R=Gn({inputs:{x:r},backend:e,attrs:{shape:b}});else if(x||S){H(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const B=VA(T,$,E),N=Xh({inputs:{x:r},backend:e,attrs:{begin:T,size:B}});R=Gn({inputs:{x:N},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(N)}else{const B=e.bufferSync(r),N=A6(y,B,E,T);R=e.makeTensorInfo(b,N.dtype,N.values)}return R}const kft={kernelName:eA,backendName:"cpu",kernelFunc:Aft};function _ft(n){const{inputs:t,backend:e,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=s,{data:f,dataSplits:d}=t,m=e.data.get(f.dataId).values,y=e.data.get(d.dataId).values,[b,w]=k6(m,y,r,i,o,a,l,c);return[e.makeTensorInfo([b.length],"string",b),e.makeTensorInfo(d.shape,"int32",w)]}const Nft={kernelName:mP,backendName:"cpu",kernelFunc:_ft};function Rft(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.data.get(i.dataId).values,l=e.data.get(o.dataId).values[0],[c,f,d]=_6(a,l,r),m=f.length;return[e.makeTensorInfo([m,2],"int32",c),e.makeTensorInfo([m],"string",f),e.makeTensorInfo([2],"int32",new Int32Array(d))]}const Dft={kernelName:gP,backendName:"cpu",kernelFunc:Rft};function Oft(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:r}=s,{input:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=e.data.get(i.dataId).values,a=N6(o,r);return e.makeTensorInfo(i.shape,"int32",a)}const Fft={kernelName:yP,backendName:"cpu",kernelFunc:Oft};const Mft=Tn(qy,n=>Math.tan(n)),Lft={kernelName:qy,backendName:"cpu",kernelFunc:Mft};const zft=Tn(Hy,n=>Math.tanh(n)),Bft={kernelName:Hy,backendName:"cpu",kernelFunc:zft};function Pft(n){const{inputs:t,backend:e}=n,{tensor:s,indices:r,updates:i}=t,{sliceRank:o,numUpdates:a,sliceSize:l,strides:c,outputSize:f}=hf(i,r,s.shape),d=!1,m=e.bufferSync(r),y=e.bufferSync(i),b=e.bufferSync(s),w=Th(m,y,s.shape,f,l,a,o,c,b,d);return e.makeTensorInfo(s.shape,w.dtype,w.values)}const Vft={kernelName:lP,backendName:"cpu",kernelFunc:Pft};function Uft(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reps:i}=s;ue(r,"tile");const o=D6(e.bufferSync(r),i);return e.makeTensorInfo(o.shape,o.dtype,o.values)}const Gft={kernelName:Ky,backendName:"cpu",kernelFunc:Uft};function Wft(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{k:i,sorted:o}=s;ue(r,"topk");const a=e.data.get(r.dataId).values,[l,c]=F6(a,r.shape,r.dtype,i,o);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(c.shape,c.dtype,c.values)]}const jft={kernelName:nA,backendName:"cpu",kernelFunc:Wft};function qft(n){const{inputs:t,attrs:e,backend:s}=n,{image:r,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=e,[f,d,m,y]=r.shape,[b,w]=c??[d,m],x=[f,b,w,y],S=de(r.shape),T=S[0],$=S[1],E=S[2],R=de(x),B=R[0],N=R[1],k=R[2],_=Nr(r.dtype,Lt(x));_.fill(l);const F=s.data.get(r.dataId).values,A=s.data.get(i.dataId).values;for(let L=0;L<f;++L){const tt=i.shape[0]===1?A:A.subarray(L*8,L*8+8);for(let st=0;st<b;++st)for(let j=0;j<w;++j)for(let Z=0;Z<y;++Z){let J;const ot=tt[6]*j+tt[7]*st+1;if(ot===0)continue;const pt=(tt[0]*j+tt[1]*st+tt[2])/ot,q=(tt[3]*j+tt[4]*st+tt[5])/ot,et=OM(pt,m,a),U=OM(q,d,a);switch(o){case"nearest":J=Zft(F,d,m,T,$,E,L,U,et,Z,l);break;case"bilinear":J=Jft(F,d,m,T,$,E,L,U,et,Z,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const X=L*B+st*N+j*k+Z;_[X]=J}return s.makeTensorInfo(x,r.dtype,_)}return{dataId:s.write(_,x,r.dtype),shape:r.shape,dtype:r.dtype}}const Hft={kernelName:sA,backendName:"cpu",kernelFunc:qft};function OM(n,t,e){switch(e){case"reflect":return Kft(n,t);case"wrap":return Xft(n,t);case"nearest":return Qft(n,t);default:return Yft(n)}}function Kft(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=2*t;e<s&&(e=s*Math.trunc(-e/s)+e),e=e<-t?e+s:-e-1}else if(e>t-1)if(t<=1)e=0;else{const s=2*t;e-=s*Math.trunc(e/s),e>=t&&(e=s-e-1)}return Lh(0,e,t-1)}function Xft(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=t-1;e+=t*(Math.trunc(-e/s)+1)}else if(e>t-1)if(t<=1)e=0;else{const s=t-1;e-=t*Math.trunc(e/s)}return Lh(0,e,t-1)}function Yft(n,t){return n}function Qft(n,t){return Lh(0,n,t-1)}function ig(n,t,e,s,r,i,o,a,l,c,f){const d=o*s+a*r+l*i+c;return 0<=a&&a<t&&0<=l&&l<e?n[d]:f}function Zft(n,t,e,s,r,i,o,a,l,c,f){const d=Math.round(a),m=Math.round(l);return ig(n,t,e,s,r,i,o,d,m,c,f)}function Jft(n,t,e,s,r,i,o,a,l,c,f){const d=Math.floor(a),m=Math.floor(l),y=d+1,b=m+1,w=(b-l)*ig(n,t,e,s,r,i,o,d,m,c,f)+(l-m)*ig(n,t,e,s,r,i,o,d,b,c,f),x=(b-l)*ig(n,t,e,s,r,i,o,y,m,c,f)+(l-m)*ig(n,t,e,s,r,i,o,y,b,c,f);return(y-a)*w+(a-d)*x}function tdt(n){const{inputs:t,attrs:e,backend:s}=n,{axis:r}=e,{x:i}=t;ue(i,"unique");const o=s.data.get(i.dataId).values,{outputValues:a,outputShape:l,indices:c}=M6(o,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,a),s.makeTensorInfo([c.length],"int32",c)]}const edt={kernelName:rA,backendName:"cpu",kernelFunc:tdt};function ndt(n){const{inputs:t,backend:e,attrs:s}=n,{value:r}=t;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r.shape.length,a=r.shape[i],l=new Array(o-1);let c=0;for(let y=0;y<o;y++)y!==i&&(l[c++]=r.shape[y]);const f=new Array(o).fill(0),d=r.shape.slice();d[i]=1;const m=new Array(a);for(let y=0;y<m.length;y++){f[i]=y;const b=Xh({inputs:{x:r},backend:e,attrs:{begin:f,size:d}});m[y]=Gn({inputs:{x:b},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(b)}return m}const sdt={kernelName:uv,backendName:"cpu",kernelFunc:ndt};function rdt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,segmentIds:i}=t,{numSegments:o}=s;ue(r,"unsortedSegmentSum");const a=r.shape.length,l=i.shape.length,c=[],f=[],d=a-l;let m=i;for(let b=0;b<d;++b){const w=Ix({inputs:{input:m},backend:e,attrs:{dim:b+1}});m=w,f.push(w)}for(let b=0;b<o;++b){const w=kc(b,"int32"),x=e.makeTensorInfo([],"int32",w),S=QG({inputs:{a:x,b:m},backend:e}),T=dc({inputs:{x:S},backend:e,attrs:{dtype:"float32"}}),$=Mv({inputs:{a:T,b:r},backend:e}),E=hb({inputs:{x:$},backend:e,attrs:{axis:0,keepDims:!1}});c.push(E),f.push(x),f.push(S),f.push(T),f.push($),f.push(E)}const y=Q6({inputs:c,backend:e,attrs:{axis:0}});return f.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}const idt={kernelName:cv,backendName:"cpu",kernelFunc:rdt};const odt=[tlt,Oot,nlt,rlt,Pot,olt,llt,clt,flt,plt,glt,blt,wlt,Ilt,Clt,Alt,_lt,Rlt,Olt,Zat,Mlt,zlt,Plt,Uot,Ult,zot,Wot,Wlt,Fot,qlt,Klt,Xlt,Qlt,Jlt,eut,sut,iut,aut,uut,hut,dut,mut,yut,xut,wut,Sut,Tut,Eut,$ut,Aut,kut,Nut,Out,jat,Mut,jot,Wut,qot,jut,Kot,Qut,Zut,tct,Yot,Zot,nct,rct,oct,lct,tat,nat,Mot,cct,Hlt,fct,pct,gct,qat,rat,oat,bct,lat,wct,Ict,Cct,Act,_ct,Rct,Dct,cat,Fct,Lct,Bct,Vct,Gct,jct,Hct,fat,Xct,Zct,eht,pat,gat,rht,aht,cht,bat,fht,pht,mht,Z6,xht,Kat,vat,vht,Iht,Cht,$ht,Lot,c$,kht,Xat,Yat,Qat,Nht,Dht,Fht,Lht,Bht,Pht,Uht,kat,Wht,Xht,Qht,eft,Nat,sft,ift,aft,Rat,Jct,cft,fft,pft,gft,bft,wft,Sft,Tft,Fat,Cft,Lat,Bat,$ft,kft,Nft,Dft,Fft,Gat,Rut,Lft,Bft,Vft,Gft,jft,Hft,xat,edt,sdt,idt,dht];for(const n of odt)xP(n);const wh={},d1={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function adt(n,t){wh[n]=t}function ua(n,t){if(!(n in wh)||t!=null){const s=udt(n,t);if(s!==null)wh[n]=s;else return console.log("Could not get context for WebGL version",n),null}const e=wh[n];return e==null||e.isContextLost()?(delete wh[n],ua(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),wh[n])}function ldt(n){if(!At().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function udt(n,t){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??ldt(n);return e.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete wh[n]},!1),At().getBool("SOFTWARE_WEBGL_ENABLED")&&(d1.failIfMajorPerformanceCaveat=!1),n===1?e.getContext("webgl",d1)||e.getContext("experimental-webgl",d1):e.getContext("webgl2",d1)}var Dg;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Dg||(Dg={}));var Wi;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Wi||(Wi={}));var mr;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(mr||(mr={}));function fb(n,t){return[t,n]}function cdt(n,t){return n*t}function p1(n){const t=Lt(n),e=Math.ceil(t/4);return NE(e)}function Ep(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function hdt(n,t){const[e,s]=Ep(n,t);return e*s*4}function Uk(n,t){const e=n;let s,r,i,o,a,l,c,f,d,m;return At().getNumber("WEBGL_VERSION")===2?(s=e.R32F,r=e.R16F,i=e.RGBA16F,o=e.RGBA32F,a=e.RED,c=4,f=1,d=e.HALF_FLOAT,m=e.FLOAT,l=e.RGBA8):(s=n.RGBA,r=n.RGBA,i=n.RGBA,o=e.RGBA,a=n.RGBA,c=4,f=4,d=t!=null?t.HALF_FLOAT_OES:null,m=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:f,textureTypeHalfFloat:d,textureTypeFloat:m}}function ee(n,t){const e=t();return At().getBool("DEBUG")&&fdt(n),e}function fdt(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+gdt(n,t))}const ddt=596e-10,pdt=65504;function mdt(n){return!!(At().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||ddt<Math.abs(n)&&Math.abs(n)<pdt)}function gdt(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function m1(n,t){return uu(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function ydt(n,t){const e=uu(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ee(n,()=>n.shaderSource(e,t)),ee(n,()=>n.compileShader(e)),n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function bdt(n,t){const e=uu(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ee(n,()=>n.shaderSource(e,t)),ee(n,()=>n.compileShader(e)),At().get("ENGINE_COMPILE_ONLY"))return e;if(n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw J6(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}const xdt=/ERROR: [0-9]+:([0-9]+):/g;function J6(n,t){const e=xdt.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(n);return}const s=+e[1],r=n.split(`
`),i=r.length.toString().length+2,o=r.map((d,m)=>Dd((m+1).toString(),i)+d);let a=0;for(let d=0;d<o.length;d++)a=Math.max(o[d].length,a);const l=o.slice(0,s-1),c=o.slice(s-1,s),f=o.slice(s);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${Dd(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(f.join(`
`))}function wdt(n){return uu(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function vdt(n,t){if(ee(n,()=>n.linkProgram(t)),!At().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(t,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function QT(n,t){if(ee(n,()=>n.validateProgram(t)),n.getProgramParameter(t,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function Sdt(n,t){const e=uu(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ee(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),ee(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function Idt(n,t){const e=uu(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ee(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),ee(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function Tdt(n){return uu(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function Cdt(n,t){const e=At().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0){const s=`[${n}x${t}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>e||t>e){const s=`[${n}x${t}]`,r=`[${e}x${e}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function Edt(n){return uu(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function FM(n,t,e,s,r,i,o){const a=n.getAttribLocation(t,e);return a===-1?!1:(ee(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),ee(n,()=>n.vertexAttribPointer(a,r,n.FLOAT,!1,i,o)),ee(n,()=>n.enableVertexAttribArray(a)),!0)}function $dt(n,t,e){Rdt(n,e),ee(n,()=>n.activeTexture(n.TEXTURE0+e)),ee(n,()=>n.bindTexture(n.TEXTURE_2D,t))}function Adt(n,t,e){return uu(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function kdt(n,t,e){return n.getUniformLocation(t,e)}function _dt(n,t,e,s){ee(n,()=>$dt(n,t,s)),ee(n,()=>n.uniform1i(e,s))}function ZT(n,t,e){ee(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),ee(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function MM(n,t){ee(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),ee(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function g1(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Ndt(n,t))}function Ndt(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function uu(n,t,e){const s=ee(n,()=>t());if(s==null)throw new Error(e);return s}function Rdt(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=t+n.TEXTURE0;if(s<n.TEXTURE0||s>e){const r=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${r}.`)}}function Zd(n,t=2){return Lt(n.slice(0,n.length-t))}function Jd(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function y1(n){let t=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(t=[Zd(n),...Jd(n)]),t}function Ddt(n,t=!1){let e=At().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=At().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&At().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=e/2),t&&(e=e*2,s=s*2,n=n.map((a,l)=>l>=n.length-2?p2(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Ac(n).newShape);let r=Lt(n),i=null;n.length<=1&&r<=e?i=[1,r]:n.length===2&&n[0]<=e&&n[1]<=e?i=n:n.length===3&&n[0]*n[1]<=e&&n[2]<=e?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=e&&n[1]*n[2]<=e?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=e&&n[3]<=e?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(i=[n[0],n[1]*n[2]*n[3]]);const o=i!=null&&Math.max(...i)>s&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(i==null||o)if(t){const a=Zd(n);let l=2,c=2;n.length&&([l,c]=Jd(n)),r=a*(l/2)*(c/2),i=NE(r).map(f=>f*2)}else i=NE(r);return i}function b1(n){return n%2===0}function Cx(n,t){if(n=n.slice(-2),t=t.slice(-2),mn(n,t)||!n.length||!t.length||n[0]===0||n[1]===0||t[0]===0||t[1]===0)return!0;if(n.length!==t.length){const e=n[n.length-1],s=t[t.length-1];if(e===s||b1(e)&&b1(s)&&(n[0]===1||t[0]===1))return!0}return n[1]===t[1]&&b1(n[0])&&b1(t[0])}let JT,tC;function Odt(n){if(JT==null){const t=ua(n);JT=t.getParameter(t.MAX_TEXTURE_SIZE)}return JT}function Fdt(n){if(tC==null){const t=ua(n);tC=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,tC)}function Mdt(n){if(n===0)return 0;let t;const e=ua(n);return bo(e,"EXT_disjoint_timer_query_webgl2")&&n===2?t=2:bo(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function bo(n,t){return n.getExtension(t)!=null}function LM(n){try{if(ua(n)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Ldt(n){if(n===0)return!1;const t=ua(n);if(n===1){if(!bo(t,"OES_texture_float"))return!1}else if(!bo(t,"EXT_color_buffer_float"))return!1;return f$(t)}function zdt(n){if(n===0)return!1;const t=ua(n);if(n===1){if(!bo(t,"OES_texture_float")||!bo(t,"WEBGL_color_buffer_float"))return!1}else{if(bo(t,"EXT_color_buffer_float"))return f$(t);const s="EXT_color_buffer_half_float";if(bo(t,s)){const r=t.getExtension(s);return Bdt(t,r)}return!1}return f$(t)}function f$(n){const t=Uk(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(i),o}function Bdt(n,t){const e=Uk(n,t),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(o),a}function Pdt(n){return n!==2?!1:ua(n).fenceSync!=null}function db(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&H(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const ce=At();ce.registerFlag("HAS_WEBGL",()=>ce.getNumber("WEBGL_VERSION")>0);ce.registerFlag("WEBGL_VERSION",()=>LM(2)?2:LM(1)?1:0);ce.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ce.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ce.get("WEBGL_VERSION")===2);ce.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ce.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ce.registerFlag("WEBGL_PACK",()=>ce.getBool("HAS_WEBGL"));ce.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_CLIP",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_REDUCE",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_LAZILY_UNPACK",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_CONV_IM2COL",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Odt(ce.getNumber("WEBGL_VERSION")));ce.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Fdt(ce.getNumber("WEBGL_VERSION")));ce.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=ce.getNumber("WEBGL_VERSION");return n===0?0:Mdt(n)});ce.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ce.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!RP());ce.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Ldt(ce.getNumber("WEBGL_VERSION")));ce.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ce.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ce.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ce.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>zdt(ce.getNumber("WEBGL_VERSION")));ce.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Pdt(ce.getNumber("WEBGL_VERSION")));ce.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ce.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ce.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});ce.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>RP()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});ce.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);ce.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);ce.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);ce.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);ce.registerFlag("WEBGL_EXP_CONV",()=>!1);ce.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>ce.getBool("IS_TEST"));ce.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);ce.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);ce.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);ce.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Yr(){let n,t,e,s,r,i,o,a,l,c;return At().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",t="in",e="out",s="in",r="texture",i="outputColor",o="out vec4 outputColor;",a=At().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",t="attribute",e="varying",s="varying",r="texture2D",i="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:t,varyingVs:e,varyingFs:s,texture2D:r,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}function pf(n,t,e="index"){const s=de(t);return s.map((r,i)=>{const o=`int ${n[i]} = ${e} / ${r}`,a=i===s.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * ${r}`:`index -= ${n[i]} * ${r}`;return`${o}; ${a};`}).join("")}function Lv(n,t,e="index"){const s=de(t);return s.map((r,i)=>{const o=`int ${n[i]} = ${e} / outShapeStrides[${i}]`,a=i===s.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${o}; ${a};`}).join("")}function Vdt(n,t){const e=n.length,s=n.map(i=>`${t}[${i}]`),r=new Array(e-1);r[e-2]=s[e-1];for(let i=e-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}function Udt(n,t,e="index"){const s=n.map((i,o)=>o),r=Vdt(s,t);return r.map((i,o)=>{const a=`int ${n[o]} = ${e} / ${r[o]}`,l=o===r.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${r[o]}`:`index -= ${n[o]} * ${r[o]}`;return`${a}; ${l};`}).join("")}function Gk(n){const t=de(n).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function Wk(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const tW=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:eW}=_nt;function Gdt(n,t,e){const s=[];if(n.forEach(y=>{const b=Lt(y.shapeInfo.logicalShape);if(y.shapeInfo.isUniform?s.push(`uniform float ${y.name}${b>1?`[${b}]`:""};`):(s.push(`uniform sampler2D ${y.name};`),s.push(`uniform int offset${y.name};`)),e.enableShapeUniforms){const{uniformShape:w}=jk(e.packedInputs,y.shapeInfo.logicalShape,y.shapeInfo.texShape);switch(w.length){case 1:s.push(`uniform int ${y.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${y.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${y.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${y.name}Shape;`);break}s.push(`uniform ivec2 ${y.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(y=>{s.push(`uniform ${y.type} ${y.name}${y.arrayIndex?`[${y.arrayIndex}]`:""};`)});const r=s.join(`
`),i=n.map(y=>Wdt(y,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),o=t.texShape,a=Yr(),l=Hdt(a);let c,f,d=Ydt(a);return t.isPacked?(c=jdt(t.logicalShape,o,e.enableShapeUniforms),f=Xdt(a)):(c=qdt(t.logicalShape,o,e.enableShapeUniforms),f=Kdt(a)),e.packedInputs&&(d+=tpt),[d,l,f,r,c,i,e.userCode].join(`
`)}function $p(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return fpt(n,t);case 1:return ppt(n,t);case 2:return gpt(n,t);case 3:return bpt(n,t);case 4:return wpt(n,t);case 5:return vpt(n);case 6:return Spt(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function nW(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return hpt(n);case 1:return dpt(n,t);case 2:return mpt(n,t);case 3:return ypt(n,t);default:return xpt(n,t)}}function Wdt(n,t,e=!1,s){let r="";e?r+=nW(n,s):r+=$p(n,s);const i=n.shapeInfo.logicalShape,o=t.logicalShape;return i.length<=o.length&&(e?r+=Ipt(n,t):r+=Tpt(n,t)),r}function jdt(n,t,e){switch(n.length){case 0:return sW();case 1:return ept(n,t,e);case 2:return upt(n,t,e);case 3:return spt(n,t,e);default:return ipt(n,t,e)}}function qdt(n,t,e){switch(n.length){case 0:return sW();case 1:return npt(n,t,e);case 2:return cpt(n,t,e);case 3:return rpt(n,t,e);case 4:return opt(n,t,e);case 5:return apt(n,t);case 6:return lpt(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function Hdt(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function Kdt(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function Xdt(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function Ydt(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Qdt}
    ${Zdt}
    ${Jdt}
  `}const Qdt=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Zdt=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Jdt=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,tpt=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function sW(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function ept(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return s[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function npt(n,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function spt(n,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[2]/2),i=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function rpt(n,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Lv(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=pf(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function ipt(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[n.length-1]/2),i=r*Math.ceil(n[n.length-2]/2);let o=i,a="",l="b, r, c";for(let c=2;c<n.length-1;c++)o*=n[n.length-c-1],a=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+a,l=`b${c}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${a}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${l});
    }
  `}function opt(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Lv(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=pf(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function apt(n,t){const e=pf(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function lpt(n,t){const e=pf(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function upt(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(mn(n,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function cpt(n,t,e){return mn(n,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:n[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function mf(n){return`offset${n}`}function hpt(n){const t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),s=Yr();return`
    vec4 ${e}() {
      return ${s.texture2D}(${t}, halfCR);
    }
  `}function fpt(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${e};}`;const[r,i]=n.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${e}, halfCR);
      }
    `;const o=mf(e);if(t)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${o});
      return sampleTexture(${e}, uv);
    }
  `;const[a,l]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${e}, uv);
    }
  `}function dpt(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=n.shapeInfo.texShape,i=Yr();if(t)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${e}, uv);
    }
  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${e}, uv);
    }
  `}function ppt(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${Ap(n)}
      }
    `;const r=n.shapeInfo.texShape,i=r[0],o=r[1];if(o===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;const a=mf(e);return o===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);
        return sampleTexture(${e}, uv);
      }
    `:i===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});
      return sampleTexture(${e}, uv);
    }
  `}function mpt(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=i[0],a=i[1],l=Yr();if(i!=null&&mn(e,i))return t?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(t)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],f=Math.ceil(e[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${f}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function gpt(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape;if(i!=null&&mn(e,i)){if(t)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const m=i[0],y=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${y}.0, ${m}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:o,keptDims:a}=Ac(e),l=o;if(l.length<e.length){const m=kp(n,l),y=["row","col"];return`
      ${$p(m,t)}
      float ${r}(int row, int col) {
        return ${r}(${_p(y,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${Ap(n)}
      }
    `;const c=i[0],f=i[1],d=mf(s);return f===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${s}, uv);
    }
  `:c===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${f}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:t?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${d};
    vec2 uv = uvFromFlat(${c}, ${f}, index);
    return sampleTexture(${s}, uv);
  }
`}function ypt(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(e[0]===1){const m=e.slice(1),y=[1,2],b=kp(n,m),w=["b","row","col"];return`
        ${nW(b,t)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${_p(w,y)});
        }
      `}const a=Yr();if(t)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;const l=o[0],c=o[1],f=Math.ceil(e[2]/2),d=f*Math.ceil(e[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${d}, ${f}, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `}function bpt(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e[1]*e[2],o=e[2],{newShape:a,keptDims:l}=Ac(e),c=a;if(c.length<e.length){const w=kp(n,c),x=["row","col","depth"];return`
        ${$p(w,t)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${_p(x,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${Ap(n)}
      }
    `;const f=n.shapeInfo.texShape,d=f[0],m=f[1],y=n.shapeInfo.flatOffset;if(m===i&&y==null)return t?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${d}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(m===o&&y==null)return t?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `;const b=mf(s);return t?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${b};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${b};
        vec2 uv = uvFromFlat(${d}, ${m}, index);
        return sampleTexture(${s}, uv);
      }
  `}function xpt(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=Yr();if(t)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${e}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,o=i.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],f=l[1],d=Math.ceil(i[o-1]/2);let m=d*Math.ceil(i[o-2]/2),y="int b, int row, int col",b=`b * ${m} + (row / 2) * ${d} + (col / 2)`;for(let w=2;w<o-1;w++)y=`int b${w}, `+y,m*=i[o-w-1],b=`b${w} * ${m} + `+b;return`
    vec4 ${s}(${y}) {
      int index = ${b};
      int texR = index / ${f};
      int texC = index - texR * ${f};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}, ${c});
      return ${r.texture2D}(${e}, uv);
    }
  `}function wpt(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e[3],o=e[2]*i,a=e[1]*o,{newShape:l,keptDims:c}=Ac(e);if(l.length<e.length){const T=kp(n,l),$=["row","col","depth","depth2"];return`
      ${$p(T,t)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${_p($,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${i}, 1)));
        ${Ap(n)}
      }
    `;const f=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,m=d[0],y=d[1],b=`int stride2 = ${s}Shape[3];`,w=`int stride1 = ${s}Shape[2] * stride2;`,x=`int stride0 = ${s}Shape[1] * stride1;`;if(y===a&&f==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${b}
        ${w}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(y===i&&f==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;const S=mf(s);return t?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${b}
      ${w}
      ${x}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${S});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${m}, ${y}, index + ${S});
      return sampleTexture(${s}, uv);
    }
  `}function vpt(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t[4],i=t[3]*r,o=t[2]*i,a=t[1]*o,{newShape:l,keptDims:c}=Ac(t);if(l.length<t.length){const w=kp(n,l),x=["row","col","depth","depth2","depth3"];return`
      ${$p(w)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${_p(x,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${i}, ${r})) +
          depth3;
        ${Ap(n)}
      }
    `;const f=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,m=d[0],y=d[1];if(y===a&&f==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(y===r&&f==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;const b=mf(e);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${i} +
          depth2 * ${r} + depth3 + ${b};
      vec2 uv = uvFromFlat(${m}, ${y}, index);
      return sampleTexture(${e}, uv);
    }
  `}function Spt(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:r,keptDims:i}=Ac(t);if(r.length<t.length){const x=kp(n,r),S=["row","col","depth","depth2","depth3","depth4"];return`
      ${$p(x)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${_p(S,i)});
      }
    `}const o=t[5],a=t[4]*o,l=t[3]*a,c=t[2]*l,f=t[1]*c;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${f}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Ap(n)}
      }
    `;const d=n.shapeInfo.flatOffset,m=n.shapeInfo.texShape,y=m[0],b=m[1];if(b===f&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${b}.0, ${y}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(b===o&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${b}.0, ${y}.0);
        return sampleTexture(${e}, uv);
      }
    `;const w=mf(e);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${f} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${w};
      vec2 uv = uvFromFlat(${y}, ${b}, index);
      return sampleTexture(${e}, uv);
    }
  `}function Ap(n){const t=n.name,e=Lt(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function Ipt(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),r="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=t.logicalShape.length,a=eW(n.shapeInfo.logicalShape,t.logicalShape),l=_n(o),c=o-i;let f;const d=["x","y","z","w","u","v"];i===0?f="":o<2&&a.length>=1?f="coords = 0;":f=a.map(T=>`coords.${d[T+c]} = 0;`).join(`
`);let m="";o<2&&i>0?m="coords":m=n.shapeInfo.logicalShape.map((T,$)=>`coords.${d[$+c]}`).join(", ");let y="return outputValue;";const w=Lt(n.shapeInfo.logicalShape)===1,S=Lt(t.logicalShape)===1;if(i===1&&!w&&!S)y=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(w&&!S)o===1?y=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:y=`
        return vec4(outputValue.x);
      `;else if(a.length){const T=i-2,$=i-1;a.indexOf(T)>-1&&a.indexOf($)>-1?y="return vec4(outputValue.x);":a.indexOf(T)>-1?y="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf($)>-1&&(y="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${f}
      vec4 outputValue = get${s}(${m});
      ${y}
    }
  `}function Tpt(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),r="get"+s+"AtOutCoords",i=t.texShape,o=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&n.shapeInfo.flatOffset==null&&mn(o,i))return`
      float ${r}() {
        return sampleTexture(${e}, resultUV);
      }
    `;const c=_n(l),f=eW(n.shapeInfo.logicalShape,t.logicalShape),d=l-a;let m;const y=["x","y","z","w","u","v"];a===0?m="":l<2&&f.length>=1?m="coords = 0;":m=f.map(w=>`coords.${y[w+d]} = 0;`).join(`
`);let b="";return l<2&&a>0?b="coords":b=n.shapeInfo.logicalShape.map((w,x)=>`coords.${y[x+d]}`).join(", "),`
    float ${r}() {
      ${c} coords = getOutputCoords();
      ${m}
      return get${s}(${b});
    }
  `}function _n(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function jk(n,t,e){const{newShape:s,keptDims:r}=Ac(t),i=t.length,o=n&&i===3&&t[0]===1,a=o?t.slice(1):s,l=!n&&i>1&&!mn(t,e)&&s.length<i||o;return{useSqueezeShape:l,uniformShape:l?a:t,keptDims:r}}function kp(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function _p(n,t){return t.map(e=>n[e]).join(", ")}function Cpt(n,t,e,s){const r=e.map((f,d)=>{const m={logicalShape:f.shape,texShape:f.isUniform?null:f.texData.texShape,isUniform:f.isUniform,isPacked:f.isUniform?!1:f.texData.isPacked,flatOffset:null};return f.texData!=null&&f.texData.slice!=null&&f.texData.slice.flatOffset>0&&(m.flatOffset=f.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:m}}),i=r.map(f=>f.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},a=Gdt(r,o,t),l=bdt(n.gl,a),c=n.createProgram(l);return At().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(c),Object.assign({program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o},rW(n,t,c)))}function rW(n,t,e){const s=[],r=[];let i,o,a,l=null,c=null;c=n.getUniformLocation(e,"NAN",!1),At().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(e,"INFINITY",!1));const f=!1;for(const d of t.variableNames){const m={name:d,uniform:n.getUniformLocation(e,d,f),offset:n.getUniformLocation(e,`offset${d}`,f)};t.enableShapeUniforms&&(m.shape=n.getUniformLocation(e,`${d}Shape`,f),m.texShape=n.getUniformLocation(e,`${d}TexShape`,f)),s.push(m)}if(t.enableShapeUniforms&&(i=n.getUniformLocation(e,"outShape",f),a=n.getUniformLocation(e,"outShapeStrides",f),o=n.getUniformLocation(e,"outTexShape",f)),t.customUniforms)for(const d of t.customUniforms)r.push(n.getUniformLocation(e,d.name,f));return{variablesLocations:s,customUniformLocations:r,infLoc:l,nanLoc:c,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:o}}function zM(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,s)=>{const r=e.logicalShape,i=t[s],o=i.shape;if(!mn(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(e.isUniform&&i.isUniform)return;const a=e.texShape,l=i.isUniform?null:i.texData.texShape;if(!mn(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function Ept(n,t,e,s,r){t.program.enableShapeUniforms||(zM(t.inShapeInfos,e),zM([t.outShapeInfo],[s]));const i=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(t.webGLProgram),n.bindVertexArray(t.webGLProgram.vao),At().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&n.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&n.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<e.length;++l){const c=e[l],{uniform:f,offset:d,shape:m,texShape:y}=t.variablesLocations[l];if(m){const{uniformShape:b}=jk(t.program.packedInputs,c.shape,c.texData.texShape);switch(b.length){case 1:n.gl.uniform1iv(m,new Int32Array(b));break;case 2:n.gl.uniform2iv(m,new Int32Array(b));break;case 3:n.gl.uniform3iv(m,new Int32Array(b));break;case 4:n.gl.uniform4iv(m,new Int32Array(b));break}}if(y&&n.gl.uniform2i(y,c.texData.texShape[0],c.texData.texShape[1]),f!=null){if(c.isUniform){if(Lt(c.shape)<2)n.gl.uniform1f(f,c.uniformValues[0]);else{let b=c.uniformValues;b instanceof Float32Array||(b=new Float32Array(b)),n.gl.uniform1fv(f,b)}continue}c.texData.slice!=null&&d!=null&&n.gl.uniform1i(d,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture.texture,f,l)}}const a=t.outShapeLocation;if(a)switch(s.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(s.shape));break}if(t.outShapeStridesLocation){const l=de(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),t.program.customUniforms&&r)for(let l=0;l<t.program.customUniforms.length;++l){const c=t.program.customUniforms[l],f=t.customUniformLocations[l],d=r[l];if(c.type==="float")n.gl.uniform1fv(f,d);else if(c.type==="vec2")n.gl.uniform2fv(f,d);else if(c.type==="vec3")n.gl.uniform3fv(f,d);else if(c.type==="vec4")n.gl.uniform4fv(f,d);else if(c.type==="int")n.gl.uniform1iv(f,d);else if(c.type==="ivec2")n.gl.uniform2iv(f,d);else if(c.type==="ivec3")n.gl.uniform3iv(f,d);else if(c.type==="ivec4")n.gl.uniform4iv(f,d);else throw Error(`uniform type ${c.type} is not supported yet.`)}n.executeProgram()}function $pt(n,t,e){let s="";t.concat(e).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:f,keptDims:d}=jk(n.packedInputs,o.shape,l);let m="",y="",b="";if(f.length===1&&n.packedInputs){const R=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];m=`${R[0]>1}_${R[1]>1}`}else if(f.length===2&&!n.packedInputs)y=`${f[0]>1}_${f[1]>1}`;else if(f.length>2&&!n.packedInputs){const R=de(f);b=`${R[0]===l[1]}_${R[R.length-1]===l[1]}`}const w=o.shape.length,x=f.length===2&&mn(o.shape,l),S=Lt(o.shape)===1,T=qd(o.shape,e.shape),$=!n.packedInputs&&w===e.shape.length&&mn(l,e.texData.texShape),E=n.packedInputs||f.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${w}_${$}_${c?d:""}_${f.length}_${S}_${T}_${x}_${m}_${y}_${b}_${E}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${l}_${a}`}});const r=n.userCode;let i=n.constructor.name;return i+="_"+s+"_"+r+`${At().getNumber("WEBGL_VERSION")}`,i}function Mr(n){return At().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class Apt{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Dg.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Yr();this.outputShape=t,this.enableShapeUniforms=Mr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Lv(["r","c","d"],t):pf(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}}class kpt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Dg.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Yr();this.outputShape=t,this.enableShapeUniforms=Mr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Lv(["r","c","d"],t):pf(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}}class _pt{constructor(t){this.variableNames=["A"],this.outTexUsage=Wi.DOWNLOAD;const e=Yr();this.outputShape=t,this.userCode=`
      ${tW}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}}class Npt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Wi.DOWNLOAD;const e=Yr();this.outputShape=t,this.userCode=`
      ${tW}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}}const Rpt={R:0,G:1,B:2,A:3};class BM{constructor(t,e=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Yr();this.outputShape=t,this.enableShapeUniforms=Mr(this.outputShape.length);let i="result";e&&(i="floor(result * 255. + 0.5)");let o="";for(let a=0;a<s.length;a++){const l=s[a];o+=`
          if(offset == ${a}) {
            result = values[${Rpt[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Wk():Gk(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${o}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}class Dpt{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Yr();this.outputShape=t,this.enableShapeUniforms=Mr(this.outputShape.length);let r="",i="result";e&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;r+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Wk():Gk(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${i};
        }
    `}}function Opt(n){const t=Yr(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return ydt(n,e)}function Fpt(n){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Sdt(n,t)}function Mpt(n){const t=new Uint16Array([0,1,2,2,1,3]);return Idt(n,t)}function pb(n,t,e,s,r,i){Cdt(t,e);const o=Tdt(n),a=n.TEXTURE_2D;return ee(n,()=>n.bindTexture(a,o)),ee(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),ee(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),ee(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),ee(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),At().getNumber("WEBGL_VERSION")===1?ee(n,()=>n.texImage2D(a,0,s,t,e,0,r,i,null)):ee(n,()=>n.texStorage2D(a,1,s,t,e)),ee(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[e,t]}}function iW(n){return n.internalFormatFloat}function Lpt(n,t,e,s){const[r,i]=fb(t,e);return pb(n,r,i,iW(s),s.textureFormatFloat,n.FLOAT)}function oW(n){return n.internalFormatHalfFloat}function zpt(n,t,e,s){const[r,i]=fb(t,e);return pb(n,r,i,oW(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function aW(n){return n.downloadTextureFormat}function Bpt(n,t,e,s){const[r,i]=fb(t,e);return pb(n,r,i,aW(s),n.RGBA,n.UNSIGNED_BYTE)}function lW(n){return n.internalFormatPackedFloat}function Ppt(n,t,e,s){const[r,i]=Ep(t,e);return pb(n,r,i,lW(s),n.RGBA,n.FLOAT)}function uW(n){return n.internalFormatPackedHalfFloat}function Vpt(n,t,e,s){const[r,i]=Ep(t,e);return pb(n,r,i,uW(s),n.RGBA,s.textureTypeHalfFloat)}function Upt(n,t,e){return ee(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),FM(n,t,"clipSpacePos",e,3,20,0)&&FM(n,t,"uv",e,2,20,12)}function Gpt(n,t,e,s,r,i){ee(n,()=>n.bindTexture(n.TEXTURE_2D,t));let o,a,l;r instanceof Uint8Array?(o=new Uint8Array(e*s*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(e*s*4),a=n.FLOAT,l=i.internalFormatPackedFloat),o.set(r),At().getNumber("WEBGL_VERSION")===2?ee(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,s,n.RGBA,a,o)):ee(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,e,s,0,n.RGBA,a,o)),ee(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function Wpt(n,t,e){ee(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?At().getNumber("WEBGL_VERSION")===2?ee(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):ee(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):At().getNumber("WEBGL_VERSION")===2?ee(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):ee(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),ee(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function jpt(n,t,e,s){const r=n.createBuffer();ee(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const a=4*4*t*e;return ee(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),ee(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),ee(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function qpt(n,t,e){const s=n,r=new Float32Array(e);return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function Hpt(n,t,e,s){const[r,i]=fb(t,e),o=4,a=new Uint8Array(cdt(t*e,o));return ee(n,()=>n.readPixels(0,0,r,i,s.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function Kpt(n,t,e,s,r,i,o,a){const l=n,c=new Float32Array(hdt(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function Xpt(n,t,e){const s=new Float32Array(t*e*4);return ee(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,s)),s}class eC{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=At().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,adt(e,t)):this.gl=ua(e),t=this.gl,At().getNumber("WEBGL_VERSION")===2){const i=t;this.createVertexArray=()=>ee(i,()=>i.createVertexArray()),this.bindVertexArray=o=>ee(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>ee(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>ee(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(t!=null){const i=t.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ee(t,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>ee(t,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>ee(t,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>ee(t,()=>t.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),At().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=m1(this.gl,i),bo(this.gl,o))this.textureHalfFloatExtension=m1(this.gl,o);else if(At().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),bo(this.gl,r))this.colorBufferHalfFloatExtension=m1(this.gl,r);else if(At().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",bo(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(bo(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Fpt(this.gl),this.indexBuffer=Mpt(this.gl),this.framebuffer=Edt(this.gl),this.textureConfig=Uk(this.gl,this.textureHalfFloatExtension)}get debug(){return At().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;ee(t,()=>t.finish()),ee(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),ee(t,()=>t.deleteFramebuffer(this.framebuffer)),ee(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),ee(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),ee(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),Lpt(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),zpt(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),Bpt(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),Wpt(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,s,r){this.throwIfDisposed(),Gpt(this.gl,t,e,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),Vpt(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),Ppt(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(MM(this.gl,this.framebuffer),this.outputTexture=null),ee(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,s){return this.downloadMatrixDriver(t,()=>Hpt(this.gl,e,s,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,s,r,i,o){return Kpt(this.gl,t,e,s,r,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return qpt(this.gl,t,e)}createBufferFromTexture(t,e,s){this.bindTextureToFrameBuffer(t);const r=jpt(this.gl,e,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,s;if(At().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),s=()=>{const o=r.clientWaitSync(i,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},e=i}else At().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(e,At().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:e,isFencePassed:s}}downloadMatrixFromPackedTexture(t,e,s){return this.downloadMatrixDriver(t,()=>Xpt(this.gl,e,s))}createProgram(t){this.throwIfDisposed();const e=this.gl;this.vertexShader==null&&(this.vertexShader=Opt(e));const s=wdt(e);ee(e,()=>e.attachShader(s,this.vertexShader)),ee(e,()=>e.attachShader(s,t)),vdt(e,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&QT(e,r),r}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;ee(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),Upt(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(ee(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&QT(this.gl,this.program),ee(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,s=!0){return this.throwIfDisposed(),s?Adt(this.gl,t,e):kdt(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),ee(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,s){this.throwIfDisposed(),this.throwIfNoProgram(),_dt(this.gl,t,e,s)}setOutputMatrixTexture(t,e,s){this.setOutputMatrixTextureDriver(t,s,e)}setOutputPackedMatrixTexture(t,e,s){this.throwIfDisposed();const[r,i]=Ep(e,s);this.setOutputMatrixTextureDriver(t,r,i)}setOutputMatrixWriteRegion(t,e,s,r){this.setOutputMatrixWriteRegionDriver(s,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&QT(this.gl,this.program),g1(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ee(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ee(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=m1(this.gl,At().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(At().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(At().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const e=this.gl,s=this.getQueryTimerExtensionWebGL2();e.endQuery(s.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await wF(()=>this.disposed||this.isQueryAvailable(t,At().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,At().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){const s=this.gl;return s.getQueryParameter(t,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(t,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(t,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(t,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=Ypt(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:s}=this.itemsToPoll[e];s()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in At().platform&&(s=At().platform.setTimeoutCustom.bind(At().platform)),wF(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),ZT(this.gl,t,this.framebuffer),this.debug&&g1(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(ZT(this.gl,this.outputTexture,this.framebuffer),this.debug&&g1(this.gl)):MM(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const s=e();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(t,e,s){this.throwIfDisposed();const r=this.gl;ZT(r,t,this.framebuffer),this.debug&&g1(r),this.outputTexture=t,ee(r,()=>r.viewport(0,0,e,s)),ee(r,()=>r.scissor(0,0,e,s))}setOutputMatrixWriteRegionDriver(t,e,s,r){this.throwIfDisposed(),ee(this.gl,()=>this.gl.scissor(t,e,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function Ypt(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}const{addImpl:Qpt,bincountImpl:cW,bincountReduceImpl:Zpt,bitwiseAndImpl:Jpt,castImpl:tmt,ceilImpl:emt,concatImpl:nmt,equalImpl:smt,expImpl:rmt,expm1Impl:imt,floorImpl:omt,gatherNdImpl:amt,gatherV2Impl:lmt,greaterImpl:umt,greaterEqualImpl:cmt,lessImpl:hmt,lessEqualImpl:fmt,linSpaceImpl:dmt,logImpl:pmt,maxImpl:mmt,maximumImpl:gmt,minimumImpl:ymt,multiplyImpl:bmt,negImpl:xmt,notEqualImpl:wmt,prodImpl:vmt,raggedGatherImpl:Smt,raggedRangeImpl:Imt,raggedTensorToTensorImpl:Tmt,rangeImpl:Cmt,rsqrtImpl:Emt,scatterImpl:$mt,sigmoidImpl:Amt,simpleAbsImpl:hW,sliceImpl:kmt,sparseFillEmptyRowsImpl:_mt,sparseReshapeImpl:Nmt,sparseSegmentReductionImpl:fW,sqrtImpl:Rmt,staticRegexReplaceImpl:Dmt,stridedSliceImpl:Omt,stringNGramsImpl:Fmt,stringSplitImpl:Mmt,stringToHashBucketFastImpl:Lmt,subImpl:zmt,tileImpl:Bmt,topKImpl:Pmt,transposeImpl:qk,uniqueImpl:Vmt}=Wat;function dW(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function qr(n,t){return t===1?[n]:dW(n,t)}function Umt(n,t){if(n===1)return"rc";let e="";for(let s=0;s<n;s++)e+=t[s],s<n-1&&(e+=",");return e}class Gmt{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=Mr(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const e=qr("rc",this.rank),s=_n(this.rank),r=this.getOutOfBoundsCondition(e),i=this.getSetup(e),o=this.getOutput(e);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(t){const e=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${t[t.length-1-o]},`+i;e.push(i)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let s=this.rank-2;s<this.rank;s++)e+=`${t[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";const e=t.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(t){const e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}}class pW{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=Mr(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2===1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${Wmt(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Wk():Gk(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${s}

        setOutput(result);
      }
    `}}function Wmt(n,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?Udt(["r","c","d"],"inputShape"):pf(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}class jmt{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,s){const r=VM(e,s),i=UM(t,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=PM(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[i].pop();return this.usedTextures[i].push(l),l}let a;return r===mr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===mr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===mr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===mr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===mr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(t,e,s,r){if(this.freeTextures==null)return;const i=VM(s,r),o=UM(e,i,r);o in this.freeTextures||(this.freeTextures[o]=[]);const a=PM(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=At().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],f=c&&c.indexOf(t);if(f==null||f<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[f]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function qmt(n,t){const e=n;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function PM(n,t,e,s,r){const i=Hmt(t,s);let o;if(r){const[l,c]=Ep(n[0],n[1]);o=l*c}else{const[l,c]=fb(n[0],n[1]);o=l*c}const a=qmt(e,i);return o*a}function Hmt(n,t){switch(n){case mr.PACKED_2X2_FLOAT32:return lW(t);case mr.PACKED_2X2_FLOAT16:return uW(t);case mr.UNPACKED_FLOAT32:return iW(t);case mr.UNPACKED_FLOAT16:return oW(t);case mr.PACKED_4X1_UNSIGNED_BYTE:return aW(t);default:throw new Error(`Unknown physical texture type ${n}`)}}function Kmt(n){return At().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?mr.PACKED_2X2_FLOAT32:mr.UNPACKED_FLOAT32:n?mr.PACKED_2X2_FLOAT16:mr.UNPACKED_FLOAT16}function VM(n,t){if(n===Wi.UPLOAD)return mr.PACKED_2X2_FLOAT32;if(n===Wi.RENDER||n==null)return Kmt(t);if(n===Wi.DOWNLOAD||n===Wi.PIXELS)return mr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function UM(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class Za{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=Mr(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const ko="if (isnan(x)) return x;",Xmt="return x;",GM="return abs(x);",Ymt="return (x >= 0.0) ? x : (exp(x) - 1.0);",Qmt=ko+`
  return (x < 0.0) ? 0.0 : x;
`,Zmt=ko+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ju="return x;",Jmt="return 1.0 / (1.0 + exp(-1.0 * x));";const tgt="return x;",egt=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,ngt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,sgt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,rgt="return 1.0 / (1.0 + exp(-1.0 * x));";class Hu{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=Mr(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class igt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=Mr(this.outputShape.length);const e=t.length,s=qr("rc",e),r=_n(e),i=Umt(e,s),o=s.slice(-2),a=e<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}const ogt=S4,agt=1e-7,lgt=1e-4,x1={};function ugt(n){return n in x1||(x1[n]={}),x1[n]}const cgt=At().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),hgt=600;function fgt(){return At().global.screen==null?1024:At().global.screen.height*At().global.screen.width*window.devicePixelRatio*hgt/1024/1024}class zv extends d2{nextDataId(){return zv.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!At().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(t!=null){if(t instanceof eC)e=t;else{const s=ua(At().getNumber("WEBGL_VERSION"),t);e=new eC(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=ua(At().getNumber("WEBGL_VERSION"));e=new eC(s),this.binaryCache=ugt(At().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new jmt(this.gpgpu),this.numMBBeforeWarning=fgt(),this.texData=new WB(this,Pa())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,e,s,r,i,o){const a=this.makeTensorInfo(e,s),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[r,i]},l.texShape=[r,i];const c=y1(e),f=new BM(c,!1,o),d=this.runWebGLProgram(f,[a],s,[[r,i]]);return d.shape=e,l.texture=null,this.disposeIntermediateTensorInfo(a),d.dataId}write(t,e,s){if((At().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||At().getBool("DEBUG"))&&this.checkNumericalProblems(t),s==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:e,dtype:s,values:t,usage:Wi.UPLOAD,refCount:1}),r}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){const e=this.texData.get(t);e.refCount--}}move(t,e,s,r,i){if(At().getBool("DEBUG")&&this.checkNumericalProblems(e),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:s,dtype:r,values:e,usage:Wi.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:s,dtype:r,complexTensorInfos:i,slice:o,shape:a,isPacked:l}=e;if(o!=null){let m;l?m=new Hu(a,ju):m=new Za(a,ju);const y=this.runWebGLProgram(m,[{dataId:t,shape:a,dtype:r}],r),b=this.readSync(y.dataId);return this.disposeIntermediateTensorInfo(y),b}if(s!=null)return this.convertAndCacheOnCPU(t);if(r==="string")return s;const c=this.activeTimers!=null;let f;c&&(f=ei());let d;if(r==="complex64"){const m=this.readSync(i.real.dataId),y=this.readSync(i.imag.dataId);d=Zl(m,y)}else d=this.getValuesFromTexture(t);return c&&(this.downloadWaitMs+=ei()-f),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){const b=this.pendingRead.get(t);return new Promise(w=>b.push(w))}const e=this.texData.get(t),{values:s,shape:r,slice:i,dtype:o,complexTensorInfos:a,isPacked:l}=e;if(i!=null){let b;l?b=new Hu(r,ju):b=new Za(r,ju);const w=this.runWebGLProgram(b,[{dataId:t,shape:r,dtype:o}],o),x=this.read(w.dataId);return this.disposeIntermediateTensorInfo(w),x}if(s!=null)return this.convertAndCacheOnCPU(t);if(At().getBool("DEBUG")&&!At().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&At().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,f;if(o!=="complex64"&&At().get("WEBGL_BUFFER_SUPPORTED")){f=this.decode(t);const b=this.texData.get(f.dataId);c=this.gpgpu.createBufferFromTexture(b.texture.texture,...p1(r))}this.pendingRead.set(t,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(o==="complex64"){const b=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),w=b[0],x=b[1];d=Zl(w,x)}else if(c==null)d=this.getValuesFromTexture(t);else{const b=Lt(r);d=this.gpgpu.downloadFloat32MatrixFromBuffer(c,b)}if(f!=null&&this.disposeIntermediateTensorInfo(f),c!=null){const b=this.gpgpu.gl;ee(b,()=>b.deleteBuffer(c))}const m=this.convertAndCacheOnCPU(t,d),y=this.pendingRead.get(t);return this.pendingRead.delete(t),y.forEach(b=>b(m)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&Pa().removeDataId(t,this),this.pendingDeletes--),m}readToGPU(t,e={}){const s=this.texData.get(t),{values:r,shape:i,slice:o,dtype:a,isPacked:l,texture:c}=s;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let y;l?y=new Hu(i,ju):y=new Za(i,ju);const b=this.runWebGLProgram(y,[{dataId:t,shape:i,dtype:a}],a),w=this.readToGPU(b,e);return this.disposeIntermediateTensorInfo(b),w}if(c==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const f=this.decode(t,e.customTexShape),d=Pa().makeTensorFromTensorInfo(f),m=this.texData.get(f.dataId);return Object.assign({tensorRef:d},m.texture)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(r=>lc(r));return Pe(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Pe(t.shape,t.dtype,e)}checkNumericalProblems(t){if(t!=null)for(let e=0;e<t.length;e++){const s=t[e];if(!mdt(s))throw At().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:e,dtype:s,isPacked:r}=this.texData.get(t),i=Lt(e);if(At().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const m=this.decode(t),y=this.texData.get(m.dataId),b=this.gpgpu.downloadMatrixFromPackedTexture(y.texture.texture,...p1(e)).subarray(0,i);return this.disposeIntermediateTensorInfo(m),b}const o=At().getBool("WEBGL_PACK")&&r===!0,a=o?y1(e):e,l=o?new Npt(a):new _pt(a),c=this.runWebGLProgram(l,[{shape:a,dtype:s,dataId:t}],"float32"),f=this.texData.get(c.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(f.texture.texture,f.texShape[0],f.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),d}timerAvailable(){return At().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const e=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,t();const i=zh(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=zh(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=e,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(At().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(i);a.kernelMs=zX(l),a.getExtraProfileInfo=()=>l.map((c,f)=>({name:o[f],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return At().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ei(),endMs:null}}endTimer(t){return At().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=ei(),t)}async getQueryTime(t){if(At().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:s}=this.texData.get(t);return s!=null&&(this.disposeData(s.real.dataId,e),this.disposeData(s.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:s,texShape:r,usage:i,isPacked:o,slice:a}=this.texData.get(t),l=a&&a.origDataId||t,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),e!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(e,r,i,o)));const f=this.texData.get(t);f.texture=null,f.texShape=null,f.isPacked=!1,f.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=cgt){return At().getBool("WEBGL_CPU_FORWARD")&&t.every(s=>this.texData.get(s.dataId).texture==null&&Lt(s.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){Ui("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return ogt(t.shape,e)}packedUnaryOp(t,e,s){const r=new Hu(t.shape,e),i=this.compileAndRun(r,[t],s);return Pa().makeTensorFromTensorInfo(i)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const r=hW(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,r)}if(At().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,GM,t.dtype);const e=new Za(t.shape,GM),s=this.compileAndRun(e,[t]);return Pa().makeTensorFromTensorInfo(s)}makeTensorInfo(t,e,s){let r;if(e==="string"&&s!=null&&s.length>0&&ty(s[0])){const i=s.map(o=>Ju(o));r=this.write(i,t,e)}else r=this.write(s,t,e);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:e}}makeOutput(t,e,s){return Pa().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,s),this)}unpackTensor(t){const e=new igt(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new Gmt(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const s=[Zd(t.shape),...Jd(t.shape)],r={dtype:t.dtype,shape:s,dataId:t.dataId},i=[Zd(e),...Jd(e)],o=new pW(i,s),a=!0,l=[s],c=this.runWebGLProgram(o,[r],t.dtype,l,a);return{dataId:c.dataId,shape:e,dtype:c.dtype}}decode(t,e){const s=this.texData.get(t),{isPacked:r,shape:i,dtype:o}=s;if(e!=null){const m=Lt(i),y=e[0]*e[1]*4;H(m<=y,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=y1(i);let l;r?l=new kpt(a):l=new Apt(a);const c=!0,f=[e??p1(a)],d=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:t}],o,f,c,e);return{dtype:o,shape:i,dataId:d.dataId}}runWebGLProgram(t,e,s,r,i=!1,o){const a=this.makeTensorInfo(t.outputShape,s),l=this.texData.get(a.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===Dg.DENSE){const S=o??p1(t.outputShape);l.texShape=S.map(T=>T*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),Lt(a.shape)===0)return l.values=Nr(a.dtype,0),a;const c=[],f=e.map(S=>{if(S.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let T=this.texData.get(S.dataId);if(T.texture==null){if(!t.packedInputs&&Lt(S.shape)<=At().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:S.shape,texData:null,isUniform:!0,uniformValues:T.values};t.packedInputs&&(T.isPacked=!0,T.shape=S.shape)}if(this.uploadToGPU(S.dataId),!!T.isPacked!=!!t.packedInputs)S=T.isPacked?this.unpackTensor(S):this.packTensor(S),c.push(S),T=this.texData.get(S.dataId);else if(T.isPacked&&!Cx(T.shape,S.shape)){const $=S,E=S.shape;S.shape=T.shape,S=this.packedReshape(S,E),c.push(S),T=this.texData.get(S.dataId),$.shape=E}return{shape:S.shape,texData:T,isUniform:!1}});this.uploadToGPU(a.dataId);const d={shape:a.shape,texData:l,isUniform:!1},m=$pt(t,f,d),y=this.getAndSaveBinary(m,()=>Cpt(this.gpgpu,t,f,d)),b=this.activeTimers!=null;let w;b&&(w=this.startTimer()),At().get("ENGINE_COMPILE_ONLY")||Ept(this.gpgpu,y,f,d,r),c.forEach(S=>this.disposeIntermediateTensorInfo(S)),b&&(w=this.endTimer(w),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(w)}));const x=At().getNumber("WEBGL_FLUSH_THRESHOLD");if(x>0){const S=ei();S-this.lastGlFlushTime>x&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=S)}if(!At().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&i===!1){const S=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),S}return a}compileAndRun(t,e,s,r,i=!1){return s=s||e[0].dtype,this.runWebGLProgram(t,e,s,r,i)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(At().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=vt(()=>{if(!At().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=At().getBool("DEBUG");At().set("DEBUG",!1);const e=this.abs(dn(1e-8)).dataSync()[0];if(At().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?agt:lgt}uploadToGPU(t){const e=this.texData.get(t),{shape:s,dtype:r,values:i,texture:o,usage:a,isPacked:l}=e;if(o!=null)return;const c=this.activeTimers!=null;let f;c&&(f=ei());let d=e.texShape;if(d==null&&(d=Ddt(s,l),e.texShape=d),i!=null){const m=y1(s);let y,b=d[1],w=d[0];const x=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!x)&&([b,w]=Ep(d[0],d[1])),l?y=new Dpt(m,x):y=new BM(m,x);const S=x?[w,b]:d,T=this.makeTensorInfo(S,r),$=this.texData.get(T.dataId);x?$.usage=Wi.PIXELS:$.usage=Wi.UPLOAD,$.texShape=S,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(T.dataId),b,w,i);const E=[[w,b]],B=this.runWebGLProgram(y,[T],r,E,!0),N=this.texData.get(B.dataId);e.texShape=N.texShape,e.isPacked=N.isPacked,e.usage=N.usage,At().get("ENGINE_COMPILE_ONLY")?this.disposeData(B.dataId):(e.texture=N.texture,e.values=null,this.texData.delete(B.dataId)),this.disposeIntermediateTensorInfo(T),c&&(this.uploadWaitMs+=ei()-f)}else{const m=this.acquireTexture(d,a,r,l);e.texture=m}}convertAndCacheOnCPU(t,e){const s=this.texData.get(t),{dtype:r}=s;return e!=null&&(s.values=dgt(e,r)),s.values}acquireTexture(t,e,s,r){if(this.numBytesInGPU+=this.computeBytes(t,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,r)}computeBytes(t,e){return t[0]*t[1]*ex(e)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}else{for(const[,e]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(e),r(!0)}catch(i){throw i}});t.push(s)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await B4(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(J6(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:e,customUniformLocations:s,infLoc:r,nanLoc:i,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:l}=rW(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=e,t.customUniformLocations=s,t.infLoc=r,t.nanLoc=i,t.outShapeLocation=o,t.outShapeStridesLocation=a,t.outTexShapeLocation=l}}createTensorFromGPUData(t,e,s){t.channels=t.channels||"RGBA";const{texture:r,height:i,width:o,channels:a}=t,l=Pa().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(r,e,s,i,o,a);return Pa().makeTensorFromDataId(c,e,s,l)}}zv.nextDataId=0;function dgt(n,t){if(t==="float32"||t==="complex64")return n;if(t==="int32"||t==="bool"){const e=t==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<e.length;++s)e[s]=Math.round(n[s]);return e}else throw new Error(`Unknown dtype ${t}`)}DP()&&BP("webgl",()=>new zv,2);const Hk=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Yh{constructor(t,e,s){this.variableNames=["A","B"],this.outputShape=Ne(e,s),this.enableShapeUniforms=Mr(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const gf=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Np{constructor(t,e,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ne(e,s);const i=this.outputShape.length;this.enableShapeUniforms=Mr(i);let o="";if(r)if(i===0||Lt(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${_n(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=qr("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}function Ai(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const pgt={kernelName:vy,backendName:"webgl",kernelFunc:Ai};function Mc(n){const{inputs:t,backend:e}=n,{real:s,imag:r}=t,i=e.makeTensorInfo(s.shape,"complex64"),o=e.texData.get(i.dataId),a=Ai({inputs:{x:s},backend:e}),l=Ai({inputs:{x:r},backend:e});return o.complexTensorInfos={real:a,imag:l},i}const mgt={kernelName:E2,backendName:"webgl",kernelFunc:Mc};const mW="return (a < 0.) ? b * a : a;",gW=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function ggt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{alpha:i}=s,o=e.makeTensorInfo([],"float32",kc(i,"float32")),a=At().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Np(gW,r.shape,o.shape):new Yh(mW,r.shape,o.shape),l=e.runWebGLProgram(a,[r,o],"float32");return e.disposeIntermediateTensorInfo(o),l}const ygt={kernelName:Rw,backendName:"webgl",kernelFunc:ggt};const yW="return (a < 0.) ? b * a : a;",bW=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function bgt(n){const{inputs:t,backend:e}=n,{x:s,alpha:r}=t,i=At().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Np(bW,s.shape,r.shape):new Yh(yW,s.shape,r.shape);return e.runWebGLProgram(i,[s,r],"float32")}const xgt={kernelName:Qw,backendName:"webgl",kernelFunc:bgt};const Rp="if (isnan(x)) return x;";function rn({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:s}){return({inputs:r,backend:i})=>{const{x:o}=r,a=i,l=s||o.dtype;if(a.shouldExecuteOnCPU([o])&&e!=null){const d=a.texData.get(o.dataId),m=e(d.values,l);return a.makeTensorInfo(o.shape,l,m)}const c=At().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let f;return c?f=new Hu(o.shape,t):f=new Za(o.shape,n),a.runWebGLProgram(f,[o],l)}}function Ir({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,f=a;if(s&&l.dtype==="complex64"){const b=f.texData.get(l.dataId),w=f.texData.get(c.dataId),[x,S]=[[b.complexTensorInfos.real,w.complexTensorInfos.real],[b.complexTensorInfos.imag,w.complexTensorInfos.imag]].map($=>{const[E,R]=$,B={dataId:E.dataId,dtype:E.dtype,shape:l.shape},N={dataId:R.dataId,dtype:R.dtype,shape:c.shape},k=new Yh(n,l.shape,c.shape);return f.runWebGLProgram(k,[B,N],Ei(E.dtype,R.dtype))}),T=Mc({inputs:{real:x,imag:S},backend:f});return f.disposeIntermediateTensorInfo(x),f.disposeIntermediateTensorInfo(S),T}const d=i||Ei(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||f.shouldExecuteOnCPU([l,c]))&&r!=null){const b=f.texData.get(l.dataId).values,w=f.texData.get(c.dataId).values,x=l.dtype==="string"?Jl(b):b,S=l.dtype==="string"?Jl(w):w,[T,$]=r(l.shape,c.shape,x,S,d),E=f.makeTensorInfo($,d),R=f.texData.get(E.dataId);return R.values=T,E}const m=At().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let y;return m?y=new Np(t,l.shape,c.shape,e):y=new Yh(n,l.shape,c.shape),f.runWebGLProgram(y,[l,c],d)}}function Og(n,t=!1){if(n==="linear")return t?tgt:Xmt;if(n==="relu")return t?ngt:Qmt;if(n==="elu")return t?egt:Ymt;if(n==="relu6")return t?sgt:Zmt;if(n==="prelu")return t?bW:yW;if(n==="leakyrelu")return t?gW:mW;if(n==="sigmoid")return t?rgt:Jmt;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class xW{constructor(t,e,s,r=!1,i=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Mr(this.outputShape.length);const f=r?t[1]:t[2],d=Math.ceil(f/2),m=r?"i * 2, rc.y":"rc.y, i * 2",y=i?"rc.z, i * 2":"i * 2, rc.z",b=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],w=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let x="",S="";a&&(l?x=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?x=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:x=`vec4 activation(vec4 x) {
          ${a}
        }`,S="result = activation(result);");const T=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let $="rc.x",E="rc.x";t[0]<e[0]?$=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(E=`imod(rc.x, ${e[0]})`),this.userCode=`
      ${x}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${$};
        int batchB = ${E};
        for (int i = 0; i < ${d}; i++) {
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${y});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${b[0]} * ${w[0]});
          result += (${b[1]} * ${w[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${T}

        ${S}

        setOutput(result);
      }
    `}}const WM={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class jM{constructor(t,e,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ne(e,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const qM="return a * b;";function Kk(n){const{inputs:t,backend:e}=n,{a:s,b:r}=t,i=Ei(s.dtype,r.dtype);if(s.dtype==="complex64"){const a=e.texData.get(s.dataId),l=e.texData.get(r.dataId),c=new jM(WM.REAL,s.shape,r.shape),f=new jM(WM.IMAG,s.shape,r.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],m=e.runWebGLProgram(c,d,"float32"),y=e.runWebGLProgram(f,d,"float32"),b=Mc({inputs:{real:m,imag:y},backend:e});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),b}if(e.shouldExecuteOnCPU([s,r])){const a=e.texData.get(s.dataId),l=e.texData.get(r.dataId),[c,f]=bmt(s.shape,r.shape,a.values,l.values,i),d=e.makeTensorInfo(f,i),m=e.texData.get(d.dataId);return m.values=c,d}let o;return At().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new Np(qM,s.shape,r.shape):o=new Yh(qM,s.shape,r.shape),e.runWebGLProgram(o,[s,r],i)}const wgt={kernelName:_y,backendName:"webgl",kernelFunc:Kk};function vgt(n,t,e){const s=[Zd(n.shape),...Jd(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},i=[Zd(t),...Jd(t)],o=new pW(i,s),a=!0,l=[s],c=e.runWebGLProgram(o,[r],n.dtype,l,a);return{dataId:c.dataId,shape:t,dtype:c.dtype}}function Jt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{shape:i}=s,o=e,a=Lt(r.shape),l=qB(i,a),c=Lt(l);H(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const f=o.texData.get(r.dataId);return f.isPacked&&!Cx(r.shape,l)&&!(f.texture!==null&&Cx(f.shape,l))?vgt(r,l,o):(o.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const Sgt={kernelName:Jw,backendName:"webgl",kernelFunc:Jt};class HM{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=t;this.outputShape=[r,o];const a=Math.floor(s/4)*4,l=s%4;let c="sumValue += dot(values, ones);";if(e!=null){const d=1/e;c=`sumValue += dot(values * ${Wd(d)?d.toPrecision(2):d}, ones);`}let f="";i%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}class Igt{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=t;this.outputShape=[r,o];let a="0.0",l="";e==="prod"?a="1.0":e==="min"?(a="1.0 / 1e-20",l="min"):e==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?c="sumValue":e==="prod"?c="prodValue":e==="all"?c="allValue":e==="any"&&(c="anyValue");const f=Math.floor(s/4)*4,d=s%4;let m=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,y="vec4";e==="all"?(a="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,y="bvec4"):e==="any"&&(a="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,y="bvec4");let b="";i%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${b}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${f}; i += 4) {
          int inIdx = inOffset + i;
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${f};
        if (${d===1}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${d===2}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${d===3}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${c});
      }
    `}}function Tgt(n){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const e=t.length?t[t.length-1].outSize:n[1],s=Iv(e);t.push({inSize:e,windowSize:s,outSize:Math.ceil(e/s)})}return t}function yf(n,t,e,s){const r=Tgt(n.shape);let i=n;for(let o=0;o<r.length;o++){const{inSize:a,windowSize:l,outSize:c}=r[o];let f,d;e==="mean"?f=o===0?new HM({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},a):new HM({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c}):f=new Igt({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},e),d=i,i=s.runWebGLProgram(f,[i],t),d.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(d)}return i}class Cgt{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let o=0;o<s.length;o++)s[o]=t[e[o]];this.outputShape=s,this.rank=s.length;const r=_n(this.rank),i=Egt(e);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function Egt(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(t);for(let r=0;r<n.length;r++)s[n[r]]=e[r];return s.join()}class $gt{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(t.length);for(let f=0;f<s.length;f++)s[f]=t[e[f]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=_n(this.rank),i=dW("rc",this.rank),o=new Array(this.rank);for(let f=0;f<e.length;f++)o[e[f]]=i[f];const a=`vec2(${o.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}function Bv(n,t,e){const s=At().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $gt(n.shape,t):new Cgt(n.shape,t);return e.runWebGLProgram(s,[n],n.dtype)}function Agt(n,t,e,s){const r=t,i=n.shape.length,o=Ve(r,n.shape);let a=o;const l=hs(a,i),c=l!=null;let f=n;c&&(f=Bv(n,l,s),a=xs(a.length,i)),Sr("sum",a,i);const[d,m]=ur(f.shape,a);let y=d;e&&(y=ks(d,o));const b=Lt(m),x=Lt(n.shape)/b,S=Jt({inputs:{x:f},attrs:{shape:[x,b]},backend:s}),T=oA(n.dtype),$=yf(S,T,"sum",s),E=Jt({inputs:{x:$},attrs:{shape:y},backend:s});return s.disposeIntermediateTensorInfo(S),s.disposeIntermediateTensorInfo($),c&&s.disposeIntermediateTensorInfo(f),E}function Pv(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;return Agt(r,i,o,e)}const kgt={kernelName:iv,backendName:"webgl",kernelFunc:Pv};function Kr(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{perm:i}=s,o=e,a=r.shape.length,l=new Array(a);for(let f=0;f<l.length;f++)l[f]=r.shape[i[f]];let c;if(o.shouldExecuteOnCPU([r])){const d=o.texData.get(r.dataId).values,m=qk(d,r.shape,r.dtype,i,l);c=o.makeTensorInfo(l,r.dtype);const y=o.texData.get(c.dataId);y.values=m}else c=Bv(r,i,o);return c}const _gt={kernelName:Od,backendName:"webgl",kernelFunc:Kr};const wW=1e3;function Ex({a:n,b:t,transposeA:e,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,f=t.shape.length,d=e?n.shape[c-2]:n.shape[c-1],m=s?t.shape[f-1]:t.shape[f-2],y=e?n.shape[c-1]:n.shape[c-2],b=s?t.shape[f-2]:t.shape[f-1],w=n.shape.slice(0,-2),x=t.shape.slice(0,-2),S=Lt(w),T=Lt(x),E=Ne(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([y,b]);H(d===m,()=>`Error in matMul: inner shapes (${d}) and (${m}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${s} must match.`);const R=e?[S,d,y]:[S,y,d],B=s?[T,b,m]:[T,m,b],N=Jt({inputs:{x:n},backend:r,attrs:{shape:R}}),k=Jt({inputs:{x:t},backend:r,attrs:{shape:B}}),_=[N,k],F=Math.max(S,T),A=e?N.shape[1]:N.shape[2],P=i!=null,L=o!=null,tt=l==="leakyrelu",st=l!=null?Og(l,!0):null,j=P||L||tt||st!=null;let Z;if((y===1||b===1)&&A>wW&&j===!1){let ot=N,pt=k;e&&(ot=Kr({inputs:{x:N},backend:r,attrs:{perm:[0,2,1]}}),_.push(ot)),s&&(pt=Kr({inputs:{x:k},backend:r,attrs:{perm:[0,2,1]}}),_.push(pt));const q=b!==1,et=b===1;let U=ot;q&&(U=Jt({inputs:{x:ot},backend:r,attrs:{shape:[F,A,1]}}),_.push(U));const X=b===1?2:1;let nt=pt;et&&(nt=Jt({inputs:{x:pt},backend:r,attrs:{shape:[F,1,A]}}),_.push(nt));const xt=Kk({inputs:{a:U,b:nt},backend:r});Z=Pv({inputs:{x:xt},backend:r,attrs:{axis:X,keepDims:!0}}),_.push(xt)}else{const ot=Ei(n.dtype,t.dtype),pt=new xW(R,B,[F,y,b],e,s,P,st,L,tt),q=[N,k];if(i!=null&&q.push(i),L&&q.push(o),tt){const et=r.makeTensorInfo([],"float32",kc(a,"float32"));q.push(et),_.push(et)}Z=r.runWebGLProgram(pt,q,ot)}const J=Jt({inputs:{x:Z},backend:r,attrs:{shape:E}});_.push(Z);for(const ot of _)r.disposeIntermediateTensorInfo(ot);return J}function Ngt(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:f,leakyreluAlpha:d}=s;return Ex({a:r,b:i,transposeA:l,transposeB:c,backend:e,bias:o,preluActivationWeights:a,leakyreluAlpha:d,activation:f})}const Rgt={kernelName:nx,backendName:"webgl",kernelFunc:Ngt};const KM="return abs(x);";function Dgt(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=e.texData.get(s.dataId),o=hW(i.values);return e.makeTensorInfo(s.shape,s.dtype,o)}let r;return At().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Hu(s.shape,KM):r=new Za(s.shape,KM),e.runWebGLProgram(r,[s],s.dtype)}const Ogt={kernelName:fw,backendName:"webgl",kernelFunc:Dgt};const Fgt=ko+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Mgt=rn({opSnippet:Fgt}),Lgt={kernelName:ey,backendName:"webgl",kernelFunc:Mgt};const zgt=ko+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Bgt=rn({opSnippet:zgt}),Pgt={kernelName:ny,backendName:"webgl",kernelFunc:Bgt};const XM="return a + b;",Vgt=Ir({opSnippet:XM,packedOpSnippet:XM,supportsComplex:!0,cpuKernelImpl:Qpt}),Ugt={kernelName:bp,backendName:"webgl",kernelFunc:Vgt};class Ggt{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}class Wgt{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}function G1(n){const{inputs:t,backend:e}=n,s=t;if(s.length===1)return Ai({inputs:{x:s[0]},backend:e});if(s.length>At().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),c=G1({inputs:s.slice(0,l),backend:e}),f=G1({inputs:s.slice(l),backend:e});return G1({inputs:[c,f],backend:e})}const r=s.map(l=>l.dtype).reduce((l,c)=>Ei(l,c)),i=s.map(l=>l.shape),a=At().getBool("WEBGL_PACK")?new Wgt(s[0].shape,i):new Ggt(s[0].shape,i);return e.runWebGLProgram(a,s,r)}const jgt={kernelName:x2,backendName:"webgl",kernelFunc:G1};function qgt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,a=r.shape.length,l=Ve(i,r.shape);let c=l;const f=hs(c,a);let d=r;f!=null&&(d=Kr({inputs:{x:r},backend:e,attrs:{perm:f}}),c=xs(c.length,a)),Sr("all",c,a);const[m,y]=ur(d.shape,c),b=Lt(y),w=Jt({inputs:{x:d},backend:e,attrs:{shape:[-1,b]}}),x=yf(w,w.dtype,"all",e);let S;if(o){const T=ks(m,l);S=Jt({inputs:{x},backend:e,attrs:{shape:T}})}else S=Jt({inputs:{x},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(x),f!=null&&e.disposeIntermediateTensorInfo(d),S}const Hgt={kernelName:w2,backendName:"webgl",kernelFunc:qgt};function Kgt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,a=r.shape.length,l=Ve(i,r.shape);let c=l;const f=hs(c,a);let d=r;f!=null&&(d=Kr({inputs:{x:r},backend:e,attrs:{perm:f}}),c=xs(c.length,a)),Sr("any",c,a);const[m,y]=ur(d.shape,c),b=Lt(y),w=Jt({inputs:{x:d},backend:e,attrs:{shape:[-1,b]}}),x=yf(w,w.dtype,"any",e);let S;if(o){const T=ks(m,l);S=Jt({inputs:{x},backend:e,attrs:{shape:T}})}else S=Jt({inputs:{x},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(x),f!=null&&e.disposeIntermediateTensorInfo(d),S}const Xgt={kernelName:v2,backendName:"webgl",kernelFunc:Kgt};class Ygt{constructor(t,e,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:o}=t;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const a=e==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class Qgt{constructor(t,e,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,H(t.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=t[t.length-1],o=Math.ceil(i/e);this.outputShape=t.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=_n(l),f=qr("coords",l);let d,m;if(o===1){m=l+1;const k=_n(m);d=`
        ${k} sourceLocR = ${k}(${f.join()}, 0);
        ++${f[l-1]};
        ${k} sourceLocG = ${k}(${f.join()}, 0);
        ++${f[l-2]};
        ${k} sourceLocA = ${k}(${f.join()}, 0);
        --${f[l-1]};
        ${k} sourceLocB = ${k}(${f.join()}, 0);
        --${f[l-2]};`}else m=l,d=`
        ${c} sourceLocR = coords;
        ++${f[l-1]};
        ${c} sourceLocG = coords;
        ++${f[l-2]};
        ${c} sourceLocA = coords;
        --${f[l-1]};
        ${c} sourceLocB = coords;
        --${f[l-2]};`;const y=["x","y","z","w","u","v"].slice(0,m),b="."+y[m-1],w=y.map(k=>"int "+k),x=qr("sourceLocR",m-1).concat("inIdx.r"),S=qr("sourceLocG",m-1).concat("inIdx.g"),T=qr("sourceLocB",m-1).concat("inIdx.b"),$=qr("sourceLocA",m-1).concat("inIdx.a"),E=s==="max"?"greaterThan":"lessThan",R=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${T.join()}),
                             getBestIndicesAChannel(${$.join()})));`,B=`vec4(
            getAChannel(${x.join()}),
            hasNextCol ? getAChannel(${S.join()}) : 0.,
            hasNextRow ? getAChannel(${T.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${$.join()}) : 0.)`,N=r?"":`
      float getBestIndicesAChannel(${w.join()}) {
        return getChannel(getBestIndicesA(${y.join()}),
                                          vec2(${y.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${w.join()}) {
        return getChannel(getA(${y.join()}),
                               vec2(${y.slice(-2).join()}));
      }
      ${N}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${f[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${f[l-2]} < ${a[l-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${b}, sourceLocG${b},
          sourceLocB${b}, sourceLocA${b}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${B};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${R}
          vec4 candidate = ${B};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${E}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function vW(n,t,e,s=null){let r=t.shape[0],i=t.shape[1];s!=null&&(r=s.shape[0],i=s.shape[1]);const o=Iv(i),a={windowSize:o,inSize:i,batchSize:r,outSize:Math.ceil(i/o)},l=new Ygt(a,e,s==null),c=[t];s!=null&&c.push(s);const f=n.runWebGLProgram(l,c,"int32");if(f.shape[1]===1)return f;const d=vW(n,t,e,f);return n.disposeIntermediateTensorInfo(f),d}function SW(n,t,e,s=null){const r=s!=null?s.shape:t.shape,i=r[r.length-1],o=Iv(i),a=new Qgt(r,o,e,s==null),l=s==null?[t]:[t,s],c=n.runWebGLProgram(a,l,"int32");if(c.shape.length===t.shape.length){const f=SW(n,t,e,c);return n.disposeIntermediateTensorInfo(c),f}return c}function IW(n,t,e,s){const r=[e];if(Sr("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,t.shape.length),!At().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const i=[],o=n.texData.get(t.dataId),a=o!==null&&o.isPacked;let l=t;a&&(l=n.unpackTensor(t),i.push(l));const[c,f]=ur(l.shape,r),d=Lt(f),m=Jt({inputs:{x:l},backend:n,attrs:{shape:[-1,d]}});i.push(m);const y=vW(n,m,s);i.push(y);const b=Jt({inputs:{x:y},backend:n,attrs:{shape:c}});return i.forEach(w=>n.disposeIntermediateTensorInfo(w)),b}return SW(n,t,s)}function Zgt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;let o=Ve(i,r.shape);const a=hs(o,r.shape.length);let l=r;const c=[];a!=null&&(l=Kr({inputs:{x:r},backend:e,attrs:{perm:a}}),c.push(l),o=xs(o.length,l.shape.length)),Sr("argMax",[o[0]],l.shape.length);const f=IW(e,l,o[0],"max");return c.forEach(d=>e.disposeIntermediateTensorInfo(d)),f}const Jgt={kernelName:dw,backendName:"webgl",kernelFunc:Zgt};function tyt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;let o=Ve(i,r.shape);const a=hs(o,r.shape.length);let l=r;const c=[];a!=null&&(l=Kr({inputs:{x:r},backend:e,attrs:{perm:a}}),c.push(l),o=xs(o.length,l.shape.length)),Sr("argMin",[o[0]],l.shape.length);const f=IW(e,l,o[0],"min");return c.forEach(d=>e.disposeIntermediateTensorInfo(d)),f}const eyt={kernelName:pw,backendName:"webgl",kernelFunc:tyt};const nyt=ko+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,syt=rn({opSnippet:nyt}),ryt={kernelName:sy,backendName:"webgl",kernelFunc:syt};const iyt=ko+"return log(x + sqrt(x * x + 1.0));",oyt=rn({opSnippet:iyt}),ayt={kernelName:ry,backendName:"webgl",kernelFunc:oyt};const lyt=ko+`
  return atan(x);
`,uyt=rn({opSnippet:lyt}),cyt={kernelName:iy,backendName:"webgl",kernelFunc:uyt};const hyt=Hk+`
  return atan(a, b);
`,fyt=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+gf+`
  return result;
`,dyt=Ir({opSnippet:hyt,packedOpSnippet:fyt}),pyt={kernelName:ay,backendName:"webgl",kernelFunc:dyt};const myt=ko+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,gyt=rn({opSnippet:myt}),yyt={kernelName:oy,backendName:"webgl",kernelFunc:gyt};class Fg{constructor(t,e,s,r=!1,i=!1){if(this.variableNames=["x"],e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,f=t.dilationWidth,d=t.effectiveFilterHeight,m=t.effectiveFilterWidth,y=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const w=e==="avg",x=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,S=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let T="0.0";if(w||(T="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${y}, ${b});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${f}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?x:S:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const $="max";let E=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(E="avgValue / max(count, 1.0)");const R=Math.floor(o/4)*4,B=o%4,N=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${$}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${y}, ${b});
      const float initializationValue = ${T};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${T});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${R}; wC += 4) {
            int xC = xCCorner + wC * ${f};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${f}, d),
              getValue(batch, xR, xC + 2 * ${f}, d),
              getValue(batch, xR, xC + 3 * ${f}, d)
            );

            ${N}
          }

          int xC = xCCorner + ${R};
          if (${B===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${N}
          } else if (${B===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${f}, d),
              initializationValue,
              initializationValue
            );

            ${N}
          } else if (${B===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${f}, d),
              getValue(batch, xR, xC + 2 * ${f}, d),
              initializationValue
            );

            ${N}
          }
        }
        setOutput(${E});
      }
    `}}class Xk{constructor(t,e,s,r=!1,i=!1){if(this.variableNames=["x"],e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideDepth,l=t.strideHeight,c=t.strideWidth,f=t.dilationDepth,d=t.dilationHeight,m=t.dilationWidth,y=t.effectiveFilterDepth,b=t.effectiveFilterHeight,w=t.effectiveFilterWidth,x=t.padInfo.front,S=t.padInfo.top,T=t.padInfo.left;this.outputShape=t.outShape;const $=e==="avg";let E="0.0";if($||(E="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${x}, ${S}, ${T});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${y};
              wD += ${f}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${b};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${w};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${b} * ${w} +
                      wR * ${w} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const R="max";let B=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(B="avgValue / max(count, 1.0)");const N=Math.floor(o/4)*4,k=o%4,_=`
      if (${$}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${R}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${x}, ${S}, ${T});
      const float initializationValue = ${E};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${E});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${y};
            wD += ${f}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${b};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${N}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${_}
            }

            int xC = xCCorner + ${N};
            if (${k===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${_}
            } else if (${k===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${_}
            } else if (${k===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${_}
            }
          }
        }
        setOutput(${B});
      }
    `}}function byt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;db(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,c=1;H(Or(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const f=$o(r.shape,i,o,c,a,l);if(f.filterWidth===1&&f.filterHeight===1&&mn(f.inShape,f.outShape))return Ai({inputs:{x:r},backend:e});const d=new Fg(f,"avg",!1);return e.runWebGLProgram(d,[r],"float32")}const xyt={kernelName:mw,backendName:"webgl",kernelFunc:byt};function wyt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s,f=[1,1,1],d=au(r.shape,i,o,f,a,l,c),m=new Xk(d,"avg",!1);return e.runWebGLProgram(m,[r],"float32")}const vyt={kernelName:gw,backendName:"webgl",kernelFunc:wyt};class Syt{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,r=t.strideHeight,i=t.strideWidth,o=t.dilationHeight,a=t.dilationWidth,l=t.effectiveFilterHeight,c=t.effectiveFilterWidth,f=l-1-t.padInfo.top,d=c-1-t.padInfo.left,m=1/(e*s);this.userCode=`
      const ivec2 pads = ivec2(${f}, ${d});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class Iyt{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,s=t.filterHeight,r=t.filterWidth,i=t.strideDepth,o=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,f=t.dilationWidth,d=t.effectiveFilterDepth,m=t.effectiveFilterHeight,y=t.effectiveFilterWidth,b=d-1-t.padInfo.front,w=m-1-t.padInfo.top,x=y-1-t.padInfo.left,S=1/(e*s*r);this.userCode=`
      const ivec3 pads = ivec3(${b}, ${w}, ${x});
      const float avgMultiplier = float(${S});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${y};
                wC += ${f}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Tyt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:f}=s,d=[1,1,1],m=au(o.shape,a,l,d,c,f),y=new Iyt(m);return e.runWebGLProgram(y,[r],o.dtype)}const Cyt={kernelName:I2,backendName:"webgl",kernelFunc:Tyt};function Eyt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,o=i;db([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=s,f=$o(o.shape,a,l,1,c),d=new Syt(f);return e.runWebGLProgram(d,[r],o.dtype)}const $yt={kernelName:S2,backendName:"webgl",kernelFunc:Eyt};function Ayt(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i}=t,{transposeA:o,transposeB:a}=s;return Ex({a:r,b:i,transposeA:o,transposeB:a,backend:e})}const kyt={kernelName:yw,backendName:"webgl",kernelFunc:Ayt};class _yt{constructor(t,e,s,r,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Ne(t,e),Ne(t,s);let a="0.0";r!=null&&(Ne(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";i!=null&&(Ne(t,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class Nyt{constructor(t,e,s,r,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ne(t,e),Ne(t,s);let a="vec4(0.0)";r!=null&&(Ne(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";i!=null&&(Ne(t,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const Ryt=({inputs:n,backend:t,attrs:e})=>{const{x:s,mean:r,variance:i,offset:o,scale:a}=n;H(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),H(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),H(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;l==null&&(l=.001);const c=[s,r,i];let f=null;o!=null&&(f=o.shape,c.push(o));let d=null;a!=null&&(d=a.shape,c.push(a));const m=At().getBool("WEBGL_PACK_NORMALIZATION")?new Nyt(s.shape,r.shape,i.shape,f,d,l):new _yt(s.shape,r.shape,i.shape,f,d,l);return t.runWebGLProgram(m,c,c[0].dtype)},Dyt={kernelName:kw,backendName:"webgl",kernelFunc:Ryt};class Oyt{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=_n(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=Fyt(this.rank);let r;const i=t.map((o,a)=>`sourceLoc.${d$[a]} = start[${a}] + coords.${d$[a]};`);r=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const d$=["x","y","z","w","u","v"];function Fyt(n){if(n===1)return"sourceLoc";if(n<=6)return d$.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}class Myt{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=_n(this.rank),s=qr("coords",this.rank),r=qr("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${i})`,a=`
      result.x = ${o};
      if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${o};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${t[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${o};
        if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${o};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((f,d)=>`start[${d}]`).join()});`:t.map((f,d)=>`${r[d]} = ${s[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}function Lyt(n,t,e,s){const r=s.texData.get(n.dataId),i=s.makeTensorInfo(e,n.dtype),o=s.texData.get(i.dataId);Object.assign(o,r),o.refCount=1,o.shape=e,o.dtype=n.dtype;let a=GA(t,de(n.shape));r.slice&&(a+=r.slice.flatOffset),o.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||n.dataId};const l=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,l+1),i}function Dp(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,size:o}=s,[a,l]=Sv(r,i,o);if(PA(r,a,l),Lt(l)===0)return e.makeTensorInfo(l,r.dtype,[]);if(e.shouldExecuteOnCPU([r])||r.dtype==="string"){const d=e.texData.get(r.dataId),m=kmt(d.values,a,l,r.shape,r.dtype);return e.makeTensorInfo(l,r.dtype,m)}const{isPacked:c}=e.texData.get(r.dataId),f=UA(r.shape,a,l);if(c||!f){const d=At().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Myt(l):new Oyt(l),m=[a];return e.runWebGLProgram(d,[r],r.dtype,m)}return e.uploadToGPU(r.dataId),Lyt(r,a,l,e)}const zyt={kernelName:rv,backendName:"webgl",kernelFunc:Dp};const Byt=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,crops:o}=s;H(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((T,$)=>T*$),l=nb(r.shape,i,a),c=sb(l.length,i.length),f=rb(r.shape,i,a),d=KA(o,i.length),m=XA(f,o,i.length),y=[],b=Jt({inputs:{x:r},backend:e,attrs:{shape:l}}),w=Kr({inputs:{x:b},backend:e,attrs:{perm:c}}),x=Jt({inputs:{x:w},backend:e,attrs:{shape:f}}),S=Dp({inputs:{x},backend:e,attrs:{begin:d,size:m}});return y.push(b),y.push(w),y.push(x),y.forEach(T=>e.disposeIntermediateTensorInfo(T)),S},Pyt={kernelName:bw,backendName:"webgl",kernelFunc:Byt};function Vyt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:o}=s,a=e.readSync(r.dataId),l=e.readSync(i.dataId),c=cW(a,l,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,c)}const Uyt={kernelName:T2,backendName:"webgl",kernelFunc:Vyt};const Gyt=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Wyt=`
  return float(int(a.r) & int(b.r));
`;function jyt(n){const{inputs:t,backend:e}=n,{a:s,b:r}=t,i=At().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=At().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([s,r])||o===1){const l=e.texData.get(s.dataId).values,c=e.texData.get(r.dataId).values,[f,d]=Jpt(s.shape,r.shape,l,c,s.dtype),m=e.makeTensorInfo(d,s.dtype),y=e.texData.get(m.dataId);return y.values=f,m}let a;return i?a=new Np(Gyt,s.shape,r.shape,!1):a=new Yh(Wyt,s.shape,r.shape),e.runWebGLProgram(a,[s,r],s.dtype)}const qyt={kernelName:C2,backendName:"webgl",kernelFunc:jyt};function Hyt(n){const{inputs:t,backend:e}=n,{s0:s,s1:r}=t,i=e.readSync(s.dataId),o=e.readSync(r.dataId),a=Ne(Array.from(i),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const Kyt={kernelName:ZB,backendName:"webgl",kernelFunc:Hyt};const Xyt="return float(a != b);",TW=Ir({opSnippet:Xyt,cpuKernelImpl:wmt,dtype:"bool"}),Yyt={kernelName:qw,backendName:"webgl",kernelFunc:TW};function mb(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.texData.get(s.dataId);return Ai({inputs:{x:r.complexTensorInfos.real},backend:e})}const Qyt={kernelName:Y2,backendName:"webgl",kernelFunc:mb};const Zyt="return float(int(x));";function Jyt(n,t){const e=new Za(n.shape,Zyt),s=t.runWebGLProgram(e,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}function p$(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return Ai({inputs:{x:r},backend:e});const o=sr(r.shape),a=p$({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),l=Mc({inputs:{real:a,imag:o},backend:e});return o.dispose(),e.disposeIntermediateTensorInfo(a),l}if(r.dtype==="complex64"){const o=mb({inputs:{input:r},backend:e}),a=p$({inputs:{x:o},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(o),a}if(!HB(r.dtype,i)){const o=Ai({inputs:{x:r},backend:e});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(e.shouldExecuteOnCPU([r])){const o=e.texData.get(r.dataId).values,[a,l,c]=tmt(o,r.shape,r.dtype,i);return e.makeTensorInfo(a,l,c)}if(i==="int32")return Jyt(r,e);if(i==="bool"){const o=e.makeTensorInfo([],"bool",Nr("bool",1)),l=TW({inputs:{a:r,b:o},backend:e});return e.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const tbt={kernelName:ly,backendName:"webgl",kernelFunc:p$};const YM="return ceil(x);",ebt=rn({opSnippet:YM,packedOpSnippet:YM,cpuKernelImpl:emt}),nbt={kernelName:uy,backendName:"webgl",kernelFunc:ebt};class sbt{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class rbt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function ibt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{clipValueMin:i,clipValueMax:o}=s;let a;At().getBool("WEBGL_PACK_CLIP")?a=new rbt(r.shape):a=new sbt(r.shape);const l=[[i],[o]];return e.runWebGLProgram(a,[r],r.dtype,l)}const obt={kernelName:cy,backendName:"webgl",kernelFunc:ibt};class abt{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function QM(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}function lbt(n){const{inputs:t,backend:e}=n,{x:s}=t,r=e.texData.get(s.dataId),i=new abt(s.shape),o=[QM(s,r.complexTensorInfos.real),QM(s,r.complexTensorInfos.imag)];return e.runWebGLProgram(i,o,o[0].dtype)}const ubt={kernelName:xw,backendName:"webgl",kernelFunc:lbt};class cbt{constructor(t){this.outputShape=[],this.outputShape=sl(t,1),this.variableNames=t.map((o,a)=>`T${a}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let o=1;o<e.length;o++)e[o]=e[o-1]+t[o][1];const s=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<e.length;o++){const a=e[o-1];s.push(`else if (yC < ${e[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const r=e.length,i=e[e.length-1];s.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}class hbt{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=sl(t,e);const s=this.outputShape,r=s.length,i=_n(r),o=qr("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((w,x)=>`T${x}`);const l=new Array(t.length-1);l[0]=t[0][e];for(let w=1;w<l.length;w++)l[w]=l[w-1]+t[w][e];const c=a[e],f=a.slice(-2),d=a.join();let m=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${d}), vec2(${f.join()}));
        }`;for(let w=1;w<l.length;w++){const x=l[w-1];m+=`
        if (${c} < ${l[w]}  && ${c} >= ${l[w-1]}) {
          return getChannel(
            getT${w}(${w1(a,c,x)}),
            vec2(${w1(f,c,x)}));
        }`}const y=l.length,b=l[l.length-1];m+=`
        return getChannel(
          getT${y}(${w1(a,c,b)}),
          vec2(${w1(f,c,b)}));`,this.userCode=`
      float getValue(${a.map(w=>"int "+w)}) {
        ${m}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[r-1]} = ${o[r-1]} + 1;
        if (${o[r-1]} < ${s[r-1]}) {
          result.g = getValue(${o});
        }

        ${o[r-2]} = ${o[r-2]} + 1;
        if (${o[r-2]} < ${s[r-2]}) {
          result.a = getValue(${o});
        }

        ${o[r-1]} = ${o[r-1]} - 1;
        if (${o[r-2]} < ${s[r-2]} &&
            ${o[r-1]} < ${s[r-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function w1(n,t,e){const s=n.indexOf(t);return n.map((i,o)=>o===s?`${i} - ${e}`:i).join()}function Vv(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.texData.get(s.dataId);return Ai({inputs:{x:r.complexTensorInfos.imag},backend:e})}const fbt={kernelName:U2,backendName:"webgl",kernelFunc:Vv};function og(n,t,e){const s=n[0].dtype;if(s==="complex64"){const y=n.map(T=>mb({inputs:{input:T},backend:e})),b=n.map(T=>Vv({inputs:{input:T},backend:e})),w=og(y,t,e),x=og(b,t,e),S=Mc({inputs:{real:w,imag:x},backend:e});return y.forEach(T=>e.disposeIntermediateTensorInfo(T)),b.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(x),S}let r=e.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const y=n.map(E=>{const B=[-1,Lt(E.shape.slice(t))];return Jt({inputs:{x:E},backend:e,attrs:{shape:B}})}),b=y.map(E=>({vals:e.readSync(E.dataId),shape:E.shape})),w=sl(y.map(E=>E.shape),1),x=y[0].shape[0]===1,S=nmt(b,w,s,x),T=sl(n.map(E=>E.shape),t),$=e.makeTensorInfo(T,s,S);return y.forEach(E=>e.disposeIntermediateTensorInfo(E)),$}const i=n.filter(y=>Lt(y.shape)>0),o=At().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const y=o?new Za(n[0].shape,ju):new Hu(n[0].shape,ju);return e.runWebGLProgram(y,n,s)}const a=At().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>a){const y=[];for(let w=0;w<i.length;w+=a){const x=i.slice(w,w+a);y.push(og(x,t,e))}const b=og(y,t,e);for(const w of y)e.disposeIntermediateTensorInfo(w);return b}if(o){const y=new hbt(i.map(b=>b.shape),t);return e.runWebGLProgram(y,i,s)}const{tensors2D:l,outShape:c}=dbt(i,t,e),f=new cbt(l.map(y=>y.shape)),d=e.runWebGLProgram(f,l,s);l.forEach(y=>e.disposeIntermediateTensorInfo(y));const m=Jt({inputs:{x:d},attrs:{shape:c},backend:e});return e.disposeIntermediateTensorInfo(d),m}function dbt(n,t,e){const s=sl(n.map(i=>i.shape),t);return{tensors2D:n.map(i=>Jt({inputs:{x:i},attrs:{shape:[-1,Lt(i.shape.slice(t))]},backend:e})),outShape:s}}function CW(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s,i=Ve(r,t[0].shape)[0],o=t.map(c=>c.shape);jA(o,i);const a=sl(t.map(c=>c.shape),i);if(Lt(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(c=>Lt(c.shape)>0);return l.length===1?Ai({inputs:{x:l[0]},backend:e}):og(l,i,e)}const pbt={kernelName:ww,backendName:"webgl",kernelFunc:CW};class EW{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,c=t.strideWidth,f=t.dilationHeight,d=t.dilationWidth,m=t.filterHeight,y=t.filterWidth,b=Math.floor(t.inChannels/4)*4,w=t.inChannels%4,x=t.dataFormat==="channelsLast",S=x?1:2,T=x?2:3,$=x?3:1;let E="",R="";s&&(r?E=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?E=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:E=`
          float activation(float x) {
            ${s}
          }
        `,R="result = activation(result);");const B=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${E}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${$}];

        ivec2 xRCCorner =
            ivec2(coords[${S}], coords[${T}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${f};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${y}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${b}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${x}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${w===1}) {

              if (${x}) {
                dotProd +=
                    getX(batch, xR, xC, ${b}) *
                    getW(wR, wC, ${b}, d2);
              } else {
                dotProd +=
                    getX(batch, ${b}, xR, xC) *
                    getW(wR, wC, ${b}, d2);
              }

            } else if (${w===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2)
              );

              if (${x}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${w===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2),
                getW(wR, wC, ${b} + 2, d2)
              );

              if (${x}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1),
                  getX(batch, xR, xC, ${b} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC),
                  getX(batch, ${b} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${B}
        ${R}
        setOutput(result);
      }
    `}}class mbt{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,s=t.padInfo.top,r=t.padInfo.left,i=t.strideDepth,o=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,f=t.dilationWidth,d=t.filterDepth,m=t.filterHeight,y=t.filterWidth,b=Math.floor(t.inChannels/4)*4,w=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${o}, ${a});
      const ivec3 pads = ivec3(${e}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${y}; wC++) {
              int xC = xCCorner + wC * ${f};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${b}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${w===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${b}) *
                  getW(wF, wR, wC, ${b}, d2);
              } else if (${w===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${w===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1),
                  getX(batch, xF, xR, xC, ${b} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2),
                  getW(wF, wR, wC, ${b} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class $W{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Mr(this.outputShape.length);const o=t.padInfo.left,a=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,f=t.filterWidth,d=f;let m=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<f;x++)m+=`
           vec4 xTexelC${x*2};
           int xTexelC${x*2}Ready;
           vec4 xTexelC${x*2+1};
           int xTexelC${x*2+1}Ready;
           vec4 xC${x};`;m+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let x=0;x<f;x++)m+=`
           xTexelC${x*2} = vec4(0.0);
           xTexelC${x*2}Ready = 0;
           xTexelC${x*2+1} = vec4(0.0);
           xTexelC${x*2+1}Ready = 0;
           xC${x} = vec4(0.0);`;m+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let x=0;x<(d+1)/2;x++){const S=x*2;if(m+=`
           xC = xCCorner + ${S*l};
           `,a===1){if(S<f&&(o%2===1?(m+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }
               `,l===1&&S>0?m+=`
                 xC${S} = vec4(xTexelC${S-2}.zw, xTexelC${S}.xy);
                 `:m+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${S} = vec4(previous.zw, xTexelC${S}.xy);
                   } else {
                     xC${S} = vec4(0.0, 0.0, xTexelC${S}.xy);
                   }
                   `):m+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xC${S} = xTexelC${S};
                 `,S+1<f)){const T=o%2===0?p2(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(m+=`
                   xCOffset = xC + imod(pads[1], 2) + ${T};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                     xTexelC${S+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${S+1}.zw = vec2(0.0);
                     }
                     xTexelC${S+1}Ready = 1;
                   }
                   `,l>1?m+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${S+1} = vec4(previous.zw, xTexelC${S+1}.xy);
                     } else {
                      xC${S+1} = vec4(0.0, 0.0, xTexelC${S+1}.xy);
                     }
                     `:m+=`
                     xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.xy);
                     `):T===1?m+=`
                     xC${S+1} = xTexelC${S};
                     `:m+=`
                     xCOffset = xC + ${T};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                       xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${S+1}.zw = vec2(0.0);
                       }
                       xTexelC${S+1}Ready = 1;
                     }

                     xC${S+1} = xTexelC${S+1};
                     `}}else S<f&&(o%2===1?(m+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.0);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
               `,S+1<f&&(m+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${S+1} = vec4(xTexelC${S+1}.xy, final.xy);
                 `)):(m+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(
                   xTexelC${S}.xy, xTexelC${S+1}.xy);
               `,S+1<f&&(m+=`
                   xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
                 `)));S<f&&(m+=`
             wTexel = getW(r, ${S}, d1, d2);
             dotProd += xC${S}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${S}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,S+1<f&&(m+=`
               wTexel = getW(r, ${S+1}, d1, d2);
               dotProd += xC${S+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${S+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}m+=`
     }
   `,m+=`
     }
   `,m+=`
     }
   `;let y="",b="";s&&(r?y=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:i?y=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:y=`vec4 activation(vec4 x) {
           ${s}
         }`,b="result = activation(result);");const w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${y}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${m}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${w}
         ${b}
         setOutput(result);
       }
     `}}class gbt{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=Mr(this.outputShape.length);const{dataFormat:s}=e,r=Yr(),i=s==="channelsLast",o=i?1:2,a=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let c="";for(let f=0;f<=1;f++)for(let d=0;d<=1;d++)c+=`
          blockIndex = rc.z + ${d};
          pos = rc.y + ${f};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${f*2+d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${f*2+d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${r.output} = result;
      }
    `}}function $x(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&e===1&&n[0]>1?[n[0],1]:null}function AW({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,c=s.texData.get(n.dataId),f=e.inChannels,d=l[0]*l[1]*l[2],m=e.outChannels,y=e.dataFormat==="channelsLast",b=!1,w=!1;let x;const S=[];if(i!=null){const E=$x(i.shape,y);E!=null&&(i=Jt({inputs:{x:i},backend:s,attrs:{shape:E}}),S.push(i))}if(r!=null){const E=$x(r.shape,y);E!=null&&(r=Jt({inputs:{x:r},backend:s,attrs:{shape:E}}),S.push(r))}if(!((d===1||m===1)&&f>wW)&&c.isPacked&&y&&c.texture!=null&&l[2]%2!==0&&mn(c.shape.slice(-3),l.slice(-3))){const E=l[0]*l[1]*(l[2]+1),R={dataId:n.dataId,shape:[1,E,e.inChannels],dtype:n.dtype},B=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,H(Cx(c.shape,R.shape),()=>`packed reshape ${c.shape} to ${R.shape} isn't free`);const N=Jt({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});S.push(N);const k=Ex({a:R,b:N,backend:s,transposeA:b,transposeB:w,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),_=s.texData.get(k.dataId);H(_.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=B,_.shape=e.outShape,x=Ai({inputs:{x:k},backend:s}),x.shape=e.outShape,S.push(k)}else{const E=e.outHeight*e.outWidth,R=Jt({inputs:{x:n},backend:s,attrs:{shape:y?[e.batchSize,E,e.inChannels]:[e.batchSize,e.inChannels,E]}}),B=Jt({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}}),N=Ex({a:y?R:B,b:y?B:R,transposeA:!y,transposeB:w,backend:s,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o});x=Jt({inputs:{x:N},backend:s,attrs:{shape:e.outShape}}),S.push(R),S.push(B),S.push(N)}for(const E of S)s.disposeIntermediateTensorInfo(E);return x}function kW({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:f,outWidth:d,outHeight:m,dataFormat:y}=e,b=y==="channelsLast",w=l*c*f,x=m*d,S=[e.batchSize,w,x],T=!0,$=!1,E=[];if(i!=null){const J=$x(i.shape,b);J!=null&&(i=Jt({inputs:{x:i},backend:s,attrs:{shape:J}}),E.push(i))}if(r!=null){const J=$x(r.shape,b);J!=null&&(r=Jt({inputs:{x:r},backend:s,attrs:{shape:J}}),E.push(r))}const R=Jt({inputs:{x:t},backend:s,attrs:{shape:[1,w,Lt(t.shape)/w]}});E.push(R);const B=new gbt(S,e),N=[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],k=s.runWebGLProgram(B,[n],"float32",N),_=Jt({inputs:{x:k},backend:s,attrs:{shape:S}});E.push(k),E.push(_);const F=r!=null,A=i!=null,P=a==="leakyrelu",L=a?Og(a,!0):null,tt=new xW(b?_.shape:R.shape,b?R.shape:_.shape,b?[e.batchSize,x,e.outChannels]:[e.batchSize,e.outChannels,x],T,$,F,L,A,P),st=b?[_,R]:[R,_];if(r&&st.push(r),A&&st.push(i),P){const J=s.makeTensorInfo([],"float32",kc(o,"float32"));st.push(J),E.push(J)}const j=s.runWebGLProgram(tt,st,"float32"),Z=Jt({inputs:{x:j},backend:s,attrs:{shape:e.outShape}});E.push(j);for(const J of E)s.disposeIntermediateTensorInfo(J);return Z}function ybt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:f}=s,d=lu(l),m=vr(r.shape,i.shape,o,c,a,f,!1,d);let y;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))y=AW({x:r,filter:i,convInfo:m,backend:e});else if(m.strideWidth<=2&&d==="channelsLast"&&At().getBool("WEBGL_EXP_CONV")){const w=new $W(m),x=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];y=e.runWebGLProgram(w,[r,i],"float32",x)}else if(At().getBool("WEBGL_CONV_IM2COL"))y=kW({x:r,filter:i,convInfo:m,backend:e});else{const w=new EW(m);y=e.runWebGLProgram(w,[r,i],"float32")}const b=Jt({inputs:{x:y},backend:e,attrs:{shape:m.outShape}});return e.disposeIntermediateTensorInfo(y),b}const bbt={kernelName:vw,backendName:"webgl",kernelFunc:ybt};class xbt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,s=t.strideWidth,r=t.padInfo.top,i=t.padInfo.left,o=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class wbt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,r=t.strideHeight,i=t.strideWidth,o=t.dataFormat==="channelsLast",a=e-1-t.padInfo.top,l=s-1-t.padInfo.left,c=o?1:2,f=o?2:3,d=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${f}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class vbt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,s=t.strideHeight,r=t.strideWidth,i=t.padInfo.front,o=t.padInfo.top,a=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${i};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${a};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Sbt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,s=t.filterHeight,r=t.filterWidth,i=t.strideDepth,o=t.strideHeight,a=t.strideWidth,l=e-1-t.padInfo.front,c=s-1-t.padInfo.top,f=r-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Ibt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:f}=s,d=lu(l),m=vr(r.shape,f,o,1,a,c,!1,d),y=new xbt(m);return e.runWebGLProgram(y,[r,i],"float32")}const Tbt={kernelName:$2,backendName:"webgl",kernelFunc:Ibt};class Cbt{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=Mr(this.outputShape.length);const e=t.filterHeight,s=t.filterWidth,r=e-1-t.padInfo.top,i=s-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function Ebt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:f}=s,d=lu(c),m=vr(o,i.shape,a,1,l,f,!1,d);if(At().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){const y=[[m.strideHeight,m.strideWidth]],b=new Cbt(m);return e.runWebGLProgram(b,[r,i],"float32",y)}else{const y=new wbt(m);return e.runWebGLProgram(y,[r,i],"float32")}}const $bt={kernelName:Sw,backendName:"webgl",kernelFunc:Ebt};function Abt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l}=s,c=_c(r.shape,i.shape,o,l,a),f=new mbt(c);return e.runWebGLProgram(f,[r,i],"float32")}const kbt={kernelName:Iw,backendName:"webgl",kernelFunc:Abt};function _bt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,pad:a,filterShape:l}=s,c=_c(r.shape,l,o,1,a),f=new vbt(c);return e.runWebGLProgram(f,[r,i],"float32")}const Nbt={kernelName:A2,backendName:"webgl",kernelFunc:_bt};function Rbt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{pad:o,strides:a,inputShape:l}=s,c=_c(l,i.shape,a,1,o),f=new Sbt(c);return e.runWebGLProgram(f,[r,i],"float32")}const Dbt={kernelName:k2,backendName:"webgl",kernelFunc:Rbt};const Obt=Rp+`
  return cos(x);
`,Fbt=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${gf}
  return result;
`,Mbt=rn({opSnippet:Obt,packedOpSnippet:Fbt}),Lbt={kernelName:hy,backendName:"webgl",kernelFunc:Mbt};const zbt=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Bbt=rn({opSnippet:zbt}),Pbt={kernelName:fy,backendName:"webgl",kernelFunc:Bbt};class Vbt{constructor(t,e,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=t,[f]=e,[d,m]=s;this.outputShape=[f,d,m,c];const y=r==="bilinear"?1:0,[b,w]=[`${a-1}.0`,`${l-1}.0`],[x,S,T]=d>1?[`${(a-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${b} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${b}`],[$,E,R]=m>1?[`${(l-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${w} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${w}`];this.userCode=`
      const float height_ratio = float(${x});
      const float width_ratio = float(${$});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${S};
        float width_scale = ${E};

        float in_y = ${T};
        if( in_y < 0.0 || in_y > ${b} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${R};
        if( in_x < 0.0 || in_x > ${w} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${y} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const Ubt=n=>{const{inputs:t,backend:e,attrs:s}=n,{image:r,boxes:i,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:c}=s,f=new Vbt(r.shape,i.shape,a,l,c);return e.runWebGLProgram(f,[r,i,o],"float32")},Gbt={kernelName:N2,backendName:"webgl",kernelFunc:Ubt};var Mg;(function(n){n.Prod="*",n.Sum="+"})(Mg||(Mg={}));class ZM{constructor(t,e,s,r){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,o=this.op===Mg.Prod?"1.0":"0.0",a=s?o:`getX(${JM(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",f="";s?(c=r?`end != ${l-1}`:"end != 0",f=r?"end + 1":"end - 1"):(c=r?`end + pow2 < ${l}`:"end >= pow2",f=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${_n(i)} coords = getOutputCoords();
        int end = ${t3(i,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${f};
          ${t3(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${JM(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function JM(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.x, ${t}.y`;if(n===3)return`${t}.x, ${t}.y, ${t}.z`;if(n===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function t3(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.y`;if(n===3)return`${t}.z`;if(n===4)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function _W(n,t,e,s,r,i){const o=t.shape.length,a=hs([s],o);let l=t;a!=null&&(l=Kr({inputs:{x:t},backend:e,attrs:{perm:a}}));const c=xs(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const f=l.shape[c];let d=Ai({inputs:{x:l},backend:e});for(let m=0;m<=Math.ceil(Math.log2(f))-1;m++){const y=new ZM(n,l.shape,!1,i),b=[[m]],w=d;d=e.runWebGLProgram(y,[d],d.dtype,b),e.disposeIntermediateTensorInfo(w)}if(r){const m=new ZM(n,l.shape,r,i),y=d;d=e.runWebGLProgram(m,[d],d.dtype),e.disposeIntermediateTensorInfo(y)}if(a!=null){const m=Nc(a),y=Kr({inputs:{x:d},backend:e,attrs:{perm:m}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(l),y}return d}function Wbt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:o,reverse:a}=s;return _W(Mg.Prod,r,e,i,o,a)}const jbt={kernelName:_2,backendName:"webgl",kernelFunc:Wbt};function qbt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:o,reverse:a}=s;return _W(Mg.Sum,r,e,i,o,a)}const Hbt={kernelName:Tw,backendName:"webgl",kernelFunc:qbt};function Kbt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:o,binaryOutput:a}=s;if(r.shape.length===1){const l=e.readSync(r.dataId),c=e.readSync(i.dataId),f=cW(l,c,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,f)}else if(r.shape.length===2){const l=e.bufferSync(r),c=e.bufferSync(i),f=Zpt(l,c,o,a);return e.makeTensorInfo(f.shape,i.dtype,f.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const Xbt={kernelName:R2,backendName:"webgl",kernelFunc:Kbt};class Ybt{constructor(t,e,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function Qbt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockSize:i,dataFormat:o}=s,a=r.shape[0],l=o==="NHWC"?r.shape[1]:r.shape[2],c=o==="NHWC"?r.shape[2]:r.shape[3],f=o==="NHWC"?r.shape[3]:r.shape[1],d=l*i,m=c*i,y=f/(i*i),b=o==="NHWC"?[a,d,m,y]:[a,y,d,m],w=new Ybt(b,i,o);return e.runWebGLProgram(w,[r],r.dtype)}const Zbt={kernelName:D2,backendName:"webgl",kernelFunc:Qbt};class NW{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Mr(this.outputShape.length);const o=t.filterHeight,a=t.filterWidth,l=t.outChannels/t.inChannels;let c="",f="";s&&(r?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:c=`
          float activation(float x) {
            ${s}
          }
        `,f="result = activation(result);");const d=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${f}
        setOutput(result);
      }
    `}}class RW{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Mr(this.outputShape.length);const o=t.outChannels/t.inChannels,a=t.padInfo.left,l=t.strideWidth,c=t.dilationWidth,f=t.filterHeight,d=t.filterWidth,m=d;let y=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let S=0;S<d;S++)y+=`
          vec4 xTexelC${S*2};
          int xTexelC${S*2}Ready;
          vec4 xTexelC${S*2+1};
          int xTexelC${S*2+1}Ready;
          vec4 xC${S};`;y+=`
    for (int r = 0; r < ${f}; r++) {
      `;for(let S=0;S<d;S++)y+=`
          xTexelC${S*2} = vec4(0.0);
          xTexelC${S*2}Ready = 0;
          xTexelC${S*2+1} = vec4(0.0);
          xTexelC${S*2+1}Ready = 0;
          xC${S} = vec4(0.0);`;y+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let S=0;S<(m+1)/2;S++){const T=S*2;if(y+=`
          xC = xCCorner + ${T*c};
          `,l===1){if(T<d&&(a%2===1?(y+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }
              `,c===1&&T>0?y+=`
                xC${T} = vec4(xTexelC${T-2}.zw, xTexelC${T}.xy);
                `:y+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${T} = vec4(previous.zw, xTexelC${T}.xy);
                  } else {
                    xC${T} = vec4(0.0, 0.0, xTexelC${T}.xy);
                  }
                  `):y+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xC${T} = xTexelC${T};
                `,T+1<d)){const $=a%2===0?p2(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(y+=`
                  xCOffset = xC + imod(pads[1], 2) + ${$};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                    xTexelC${T+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${T+1}.zw = vec2(0.0);
                    }
                    xTexelC${T+1}Ready = 1;
                  }
                  `,c>1?y+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${T+1} = vec4(previous.zw, xTexelC${T+1}.xy);
                    } else {
                     xC${T+1} = vec4(0.0, 0.0, xTexelC${T+1}.xy);
                    }
                    `:y+=`
                    xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.xy);
                    `):$===1?y+=`
                    xC${T+1} = xTexelC${T};
                    `:y+=`
                    xCOffset = xC + ${$};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                      xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${T+1}.zw = vec2(0.0);
                      }
                      xTexelC${T+1}Ready = 1;
                    }

                    xC${T+1} = xTexelC${T+1};
                    `}}else T<d&&(a%2===1?(y+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.0);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
              `,T+1<d&&(y+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${T+1} = vec4(xTexelC${T+1}.xy, final.xy);
                `)):(y+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(
                  xTexelC${T}.xy, xTexelC${T+1}.xy);
              `,T+1<d&&(y+=`
                  xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
                `)));T<d&&(y+=`
            wTexel = getW(r, ${T}, d1, q);
            dotProd += xC${T} * vec4(wTexel.xz, wTexel.xz);
          `,T+1<d&&(y+=`
              wTexel = getW(r, ${T+1}, d1, q);
              dotProd += xC${T+1} * vec4(wTexel.xz, wTexel.xz);
            `))}y+=`
    }
  `,y+=`
      }
    `;let b="",w="";s&&(r?b=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?b=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:b=`vec4 activation(vec4 x) {
          ${s}
        }`,w="result = activation(result);");const x=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${b}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${y}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${x}
        ${w}
        setOutput(result);
      }
    `}}function Jbt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=s;let f=l;f==null&&(f=[1,1]),H(Or(o,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${f}'`);const d=vr(r.shape,i.shape,o,f,a,c,!0);let m;At().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?m=new RW(d):m=new NW(d);const y=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return e.runWebGLProgram(m,[r,i],"float32",y)}const t0t={kernelName:Cw,backendName:"webgl",kernelFunc:Jbt};class e0t{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,s=t.strideWidth,r=t.padInfo.top,i=t.padInfo.left,o=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class n0t{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,r=t.strideHeight,i=t.strideWidth,o=e-1-t.padInfo.top,a=s-1-t.padInfo.left,l=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function s0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:f}=s,d=vr(r.shape,f,o,a,l,c,!0),m=new e0t(d);return e.runWebGLProgram(m,[r,i],"float32")}const r0t={kernelName:O2,backendName:"webgl",kernelFunc:s0t};function i0t(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:f}=s,d=vr(f,i.shape,o,a,l,c,!0),m=new n0t(d);return e.runWebGLProgram(m,[r,i],"float32")}const o0t={kernelName:F2,backendName:"webgl",kernelFunc:i0t};class a0t{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function l0t(n){const{inputs:t,backend:e}=n,{x:s}=t,r=[...s.shape,...s.shape],i=Lt(s.shape),o=Jt({inputs:{x:s},backend:e,attrs:{shape:[i]}}),a=new a0t(i),l=e.runWebGLProgram(a,[o],o.dtype),c=Jt({inputs:{x:l},backend:e,attrs:{shape:r}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}const u0t={kernelName:JB,backendName:"webgl",kernelFunc:l0t};class c0t{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:s,padInfo:r,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:f}=t,{top:d,left:m}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${d}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${f};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function h0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l}=s,c=Qy(r.shape,i.shape,o,a,"NHWC",l);let f;const d=new c0t(c);f=e.runWebGLProgram(d,[r,i],"float32");const m=Jt({inputs:{x:f},backend:e,attrs:{shape:c.outShape}});return e.disposeIntermediateTensorInfo(f),m}const f0t={kernelName:Ew,backendName:"webgl",kernelFunc:h0t};function d0t(n){const{inputs:t,backend:e,attrs:s}=n,{equation:r}=s,i=t,{allDims:o,summedDims:a,idDims:l}=sk(r,i.length);ik(o.length,l,i);const{path:c,steps:f}=ok(a,l),d=f.length;let m=null,y=o.length;const b=[];for(let w=0;w<d;++w){for(const x of f[w]){const{permutationIndices:S,expandDims:T}=rk(y,l[x]);let $;ak(S)?$=i[x]:($=Kr({inputs:{x:i[x]},backend:e,attrs:{perm:S}}),b.push($));const E=$.shape.slice();for(let R=0;R<T.length;++R)E.splice(T[R],0,1);mn($.shape,E)||($=Jt({inputs:{x:$},backend:e,attrs:{shape:E}}),b.push($)),m===null?m=$:(m=Kk({inputs:{a:$,b:m},backend:e}),b.push(m))}w<d-1&&(c[w]>=0&&(m=Pv({inputs:{x:m},backend:e,attrs:{axis:c[w]-(o.length-y),keepDims:!1}}),b.push(m)),y--)}for(const w of b)w!==m&&e.disposeIntermediateTensorInfo(w);return m}const p0t={kernelName:M2,backendName:"webgl",kernelFunc:d0t};const m0t="return (x >= 0.0) ? x : (exp(x) - 1.0);",g0t=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,y0t=rn({opSnippet:m0t,packedOpSnippet:g0t}),b0t={kernelName:py,backendName:"webgl",kernelFunc:y0t};const x0t="return (b >= 0.0) ? a : a * (b + 1.0);",w0t=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,v0t=n=>{const{inputs:t,backend:e}=n,{dy:s,y:r}=t,i=At().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Np(w0t,s.shape,r.shape):new Yh(x0t,s.shape,r.shape);return e.runWebGLProgram(i,[s,r],s.dtype)},S0t={kernelName:L2,backendName:"webgl",kernelFunc:v0t};const I0t=`
  return vec4(equal(a, b));
`,T0t="return float(a == b);",C0t=Ir({opSnippet:T0t,packedOpSnippet:I0t,dtype:"bool",cpuKernelImpl:smt}),E0t={kernelName:$w,backendName:"webgl",kernelFunc:C0t};const $0t=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${YA};
  float a1 = ${QA};
  float a2 = ${ZA};
  float a3 = ${JA};
  float a4 = ${tk};
  float a5 = ${ek};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,A0t=rn({opSnippet:$0t}),k0t={kernelName:my,backendName:"webgl",kernelFunc:A0t};const _0t=Rp+`
  return exp(x);
`,N0t=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,DW=rn({opSnippet:_0t,packedOpSnippet:N0t,cpuKernelImpl:rmt,dtype:"float32"}),R0t={kernelName:gy,backendName:"webgl",kernelFunc:DW};function m$(n){const{inputs:t,attrs:e,backend:s}=n,{dim:r}=e,{input:i}=t,o=i.shape.length,a=i.shape.slice();let l=r;return r<0&&(H(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+r+1),a.splice(l,0,1),Jt({inputs:{x:i},backend:s,attrs:{shape:a}})}const D0t={kernelName:Aw,backendName:"webgl",kernelFunc:m$};const e3="return exp(x) - 1.0;",O0t=rn({opSnippet:e3,packedOpSnippet:e3,cpuKernelImpl:imt}),F0t={kernelName:yy,backendName:"webgl",kernelFunc:O0t};class n3{constructor(t,e,s){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${r}.0`:"1.0";let a;if(t==="real")a="return real * expR - imag * expI;";else if(t==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function OW(n,t,e){const s=e.texData.get(n.dataId),r=Lt(n.shape),i=n.shape[n.shape.length-1],o=r/i,a=Jt({inputs:{x:n},backend:e,attrs:{shape:[o,i]}}),l=a.shape,c=new n3("real",l,t),f=new n3("imag",l,t),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],m=e.runWebGLProgram(c,d,"float32"),y=e.runWebGLProgram(f,d,"float32"),b=Mc({inputs:{real:m,imag:y},backend:e});e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y);const w=Jt({inputs:{x:b},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(b),w}function M0t(n){const{inputs:t,backend:e}=n,{input:s}=t;return OW(s,!1,e)}const L0t={kernelName:z2,backendName:"webgl",kernelFunc:M0t};class z0t{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function gb(n){const{backend:t,attrs:e}=n,{shape:s,value:r}=e;let{dtype:i}=e;if(i=i||gp(r),i==="string"){const o=gs(i,Lt(s));return o.fill(r),t.makeTensorInfo(s,i,o)}else{const o=new z0t(s,r),a=[[r]];return t.runWebGLProgram(o,[],i,a)}}const B0t={kernelName:B2,backendName:"webgl",kernelFunc:gb};class P0t{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const V0t={kernelName:P2,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,s=t,r=new P0t(e.shape);return s.runWebGLProgram(r,[e],e.dtype)}};const s3="return floor(x);",U0t=rn({opSnippet:s3,packedOpSnippet:s3,cpuKernelImpl:omt}),G0t={kernelName:by,backendName:"webgl",kernelFunc:U0t};const W0t=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,j0t=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,q0t=Ir({opSnippet:W0t,packedOpSnippet:j0t,dtype:"int32"}),H0t={kernelName:xy,backendName:"webgl",kernelFunc:q0t};class K0t{constructor(t){this.variableNames=["A"];const e=Yr(),[s,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class X0t{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=Yr(),[s,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}}const Y0t={kernelName:JX,backendName:"webgl",kernelFunc:Q0t};let gd,nC=At().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Q0t(n){const{inputs:t,backend:e,attrs:s}=n;let{pixels:r}=t;const{numChannels:i}=s,o=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],f=[c,l],d=[c,l,i];if(a||o){const w=At().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(gd==null||w!==nC)&&(nC=w,gd=document.createElement("canvas").getContext("2d",{willReadFrequently:nC})),gd.canvas.width=l,gd.canvas.height=c,gd.drawImage(r,0,0,l,c),r=gd.canvas}const m=e.makeTensorInfo(f,"int32");e.texData.get(m.dataId).usage=Wi.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(m.dataId),r);const y=At().getBool("WEBGL_PACK")?new X0t(d):new K0t(d),b=e.runWebGLProgram(y,[m],"int32");return e.disposeData(m.dataId),b}function Z0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:f,dilations:d,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s,w=lu(f),x=vr(r.shape,i.shape,l,d,c,m,!1,w);let S;const T=[],$=o!=null,E=a!=null,R=y==="leakyrelu",B=()=>{const k=[r,i],_=(F,A)=>{if(A==="NCHW"&&F.shape.length===1&&F.shape[0]!==1){const P=Jt({inputs:{x:F},backend:e,attrs:{shape:[F.shape[0],1,1]}});return T.push(P),P}return F};if($&&k.push(_(o,f)),E&&k.push(_(a,f)),R){const F=e.makeTensorInfo([],"float32",kc(b,"float32"));k.push(F),T.push(F)}return k};if(x.filterHeight===1&&x.filterWidth===1&&x.dilationHeight===1&&x.dilationWidth===1&&x.strideHeight===1&&x.strideWidth===1&&(x.padInfo.type==="SAME"||x.padInfo.type==="VALID"))S=AW({x:r,filter:i,convInfo:x,backend:e,bias:o,activation:y,preluActivationWeights:a,leakyreluAlpha:b});else if(x.strideWidth<=2&&w==="channelsLast"&&At().getBool("WEBGL_EXP_CONV")){const k=y?Og(y,!0):null,_=new $W(x,$,k,E,R),F=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],A=B();S=e.runWebGLProgram(_,A,"float32",F)}else if(At().getBool("WEBGL_CONV_IM2COL"))S=kW({x:r,filter:i,convInfo:x,backend:e,bias:o,activation:y,preluActivationWeights:a,leakyreluAlpha:b});else{const k=y?Og(y,!1):null,_=new EW(x,$,k,E,R),F=B();S=e.runWebGLProgram(_,F,"float32")}const N=Jt({inputs:{x:S},backend:e,attrs:{shape:x.outShape}});return T.push(S),T.forEach(k=>e.disposeIntermediateTensorInfo(k)),N}const J0t={kernelName:sx,backendName:"webgl",kernelFunc:Z0t};function t1t(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dilations:f,dimRoundingMode:d,activation:m,leakyreluAlpha:y}=s,b=[];let w=f;w==null&&(w=[1,1]),H(Or(l,w),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${w}'`);const x=vr(r.shape,i.shape,l,w,c,d,!0),S=At().getBool("WEBGL_PACK_DEPTHWISECONV")&&x.strideWidth<=2&&x.outChannels/x.inChannels===1,T=m?Og(m,S):null,$=[r,i],E=o!=null,R=a!=null,B=m==="leakyrelu";if(E&&$.push(o),R&&$.push(a),B){const F=e.makeTensorInfo([],"float32",kc(y,"float32"));$.push(F),b.push(F)}let N;S?N=new RW(x,E,T,R,B):N=new NW(x,E,T,R,B);const k=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],_=e.runWebGLProgram(N,$,"float32",k);return b.forEach(F=>e.disposeIntermediateTensorInfo(F)),_}const e1t={kernelName:bP,backendName:"webgl",kernelFunc:t1t};class n1t{constructor(t,e,s,r){this.sliceDim=t,this.strides=e,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const i=_n(s.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function s1t(n){const{inputs:t,backend:e}=n,{params:s,indices:r}=t,i=r.shape,o=i[i.length-1],a=Lt(s.shape),[l,c,f,d]=BA(s,r),m=Jt({inputs:{x:r},backend:e,attrs:{shape:[c,o]}}),y=Jt({inputs:{x:s},backend:e,attrs:{shape:[Lt(s.shape)/f,f]}});if(e.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const S=e.readSync(r.dataId),T=e.bufferSync(s),$=amt(S,T,s.dtype,c,o,f,d,s.shape,a);return e.makeTensorInfo(l,s.dtype,$.values)}const b=new n1t(o,d,[c,f],s.shape),w=e.runWebGLProgram(b,[y,m],y.dtype),x=Jt({inputs:{x:w},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(w),x}const r1t={kernelName:tP,backendName:"webgl",kernelFunc:s1t};class i1t{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const s=_n(this.rank),r=o1t(t);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function o1t(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${e[r]}`);return s.join()}function FW(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,indices:i}=t,{axis:o,batchDims:a}=s,l=Ve(o,r.shape)[0];if(At().get("DEBUG")){const T=e.readSync(i.dataId),$=r.shape[l];for(let E=0;E<T.length;++E){const R=T[E];H(R<=$-1&&R>=0,()=>`GatherV2: the index value ${R} is not in [0, ${$-1}]`)}}const c=uk(r,i,l,a),f=Lt(i.shape),d=[],m=Jt({inputs:{x:r},backend:e,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),y=Jt({inputs:{x:i},backend:e,attrs:{shape:[c.batchSize,f/c.batchSize]}});d.push(m),d.push(y);const b=[c.batchSize,c.outerSize,f/c.batchSize,c.sliceSize];if(e.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const T=e.bufferSync(y),$=e.bufferSync(m),E=lmt($,T,b);return d.forEach(R=>e.disposeIntermediateTensorInfo(R)),e.makeTensorInfo(c.outputShape,E.dtype,E.values)}const w=new i1t(m.shape,b),x=e.runWebGLProgram(w,[m,y],m.dtype);d.push(x);const S=Jt({inputs:{x},backend:e,attrs:{shape:c.outputShape}});return d.forEach(T=>e.disposeIntermediateTensorInfo(T)),S}const a1t={kernelName:_w,backendName:"webgl",kernelFunc:FW};const l1t="return float(a > b);",u1t=`
  return vec4(greaterThan(a, b));
`,c1t=Ir({opSnippet:l1t,packedOpSnippet:u1t,cpuKernelImpl:umt,dtype:"bool"}),h1t={kernelName:Nw,backendName:"webgl",kernelFunc:c1t};const f1t="return float(a >= b);",d1t=`
  return vec4(greaterThanEqual(a, b));
`,p1t=Ir({opSnippet:f1t,packedOpSnippet:d1t,dtype:"bool",cpuKernelImpl:cmt}),m1t={kernelName:wy,backendName:"webgl",kernelFunc:p1t};function g1t(n){const{inputs:t,backend:e}=n,{input:s}=t;return OW(s,!0,e)}const y1t={kernelName:V2,backendName:"webgl",kernelFunc:g1t};const b1t="return float(!isnan(x) && !isinf(x));",x1t=rn({opSnippet:b1t,dtype:"bool"}),w1t={kernelName:Sy,backendName:"webgl",kernelFunc:x1t};const v1t="return float(isinf(x));",S1t=rn({opSnippet:v1t,dtype:"bool"}),I1t={kernelName:Iy,backendName:"webgl",kernelFunc:S1t};const T1t="return float(isnan(x));",C1t=rn({opSnippet:T1t,dtype:"bool"}),E1t={kernelName:Ty,backendName:"webgl",kernelFunc:C1t};const $1t="return float(a < b);",A1t=`
  return vec4(lessThan(a, b));
`,k1t=Ir({opSnippet:$1t,packedOpSnippet:A1t,cpuKernelImpl:hmt,dtype:"bool"}),_1t={kernelName:Dw,backendName:"webgl",kernelFunc:k1t};const N1t="return float(a <= b);",R1t=`
  return vec4(lessThanEqual(a, b));
`,D1t=Ir({opSnippet:N1t,packedOpSnippet:R1t,cpuKernelImpl:fmt,dtype:"bool"}),O1t={kernelName:Ow,backendName:"webgl",kernelFunc:D1t};function F1t(n){const{backend:t,attrs:e}=n,{start:s,stop:r,num:i}=e,o=dmt(s,r,i);return t.makeTensorInfo([o.length],"float32",o)}const M1t={kernelName:eP,backendName:"webgl",kernelFunc:F1t};const L1t=Rp+`
  return x < 0.0 ? 0./0. : log(x);
`,z1t=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,B1t=rn({opSnippet:L1t,packedOpSnippet:z1t,cpuKernelImpl:pmt}),P1t={kernelName:Cy,backendName:"webgl",kernelFunc:B1t};const V1t=Rp+`
  return log(1.0 + x);
`,U1t=rn({opSnippet:V1t}),G1t={kernelName:Ey,backendName:"webgl",kernelFunc:U1t};const W1t="return float(a >= 1.0 && b >= 1.0);",j1t=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,q1t=Ir({opSnippet:W1t,packedOpSnippet:j1t,dtype:"bool"}),H1t={kernelName:Fw,backendName:"webgl",kernelFunc:q1t};const K1t="return float(!(x >= 1.0));",X1t=rn({opSnippet:K1t}),Y1t={kernelName:Mw,backendName:"webgl",kernelFunc:X1t};const Q1t="return float(a >= 1.0 || b >= 1.0);",Z1t=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,J1t=Ir({opSnippet:Q1t,packedOpSnippet:Z1t,dtype:"bool"}),txt={kernelName:Lw,backendName:"webgl",kernelFunc:J1t};class ext{constructor(t,e,s,r,i){this.variableNames=["x"],this.outputShape=[];const o=e,a=t[3]-1;this.outputShape=t;let l;const c=`float(${s}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}class nxt{constructor(t,e,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=e,a=t[3]-1;this.outputShape=t;let l;const c=`float(${s}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}const sxt=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{depthRadius:i,bias:o,alpha:a,beta:l}=s,c=At().getBool("WEBGL_PACK_NORMALIZATION")?new nxt(r.shape,i,o,a,l):new ext(r.shape,i,o,a,l);return e.runWebGLProgram(c,[r],r.dtype)},rxt={kernelName:zw,backendName:"webgl",kernelFunc:sxt};class ixt{constructor(t,e,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const oxt=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r,y:i,dy:o}=t,{depthRadius:a,bias:l,alpha:c,beta:f}=s,d=new ixt(r.shape,a,l,c,f);return e.runWebGLProgram(d,[r,i,o],r.dtype)},axt={kernelName:G2,backendName:"webgl",kernelFunc:oxt};function lxt(n,t,e,s){const r=Lt(t),o=Lt(n.shape)/r,a=Jt({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),l=yf(a,n.dtype,"max",s),c=Jt({inputs:{x:l},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),c}function MW(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reductionIndices:i,keepDims:o}=s,a=r.shape.length,l=Ve(i,r.shape);let c=l;const f=hs(c,a),d=f!=null,m=e.shouldExecuteOnCPU([r]);let y=r;if(d){if(m){const $=e.texData.get(y.dataId).values,E=new Array(a);for(let N=0;N<E.length;N++)E[N]=r.shape[f[N]];const R=qk($,r.shape,r.dtype,f,E);y=e.makeTensorInfo(E,r.dtype);const B=e.texData.get(y.dataId);B.values=R}else y=Bv(r,f,e);c=xs(c.length,a)}Sr("max",c,a);const[b,w]=ur(y.shape,c);let x=b;o&&(x=ks(b,l));let S;if(m){const $=e.texData.get(y.dataId).values,E=mmt($,Lt(w),x,r.dtype);S=e.makeTensorInfo(x,r.dtype);const R=e.texData.get(S.dataId);R.values=E}else S=lxt(y,w,x,e);return d&&e.disposeIntermediateTensorInfo(y),S}const uxt={kernelName:Bw,backendName:"webgl",kernelFunc:MW};const cxt=Hk+`
  return max(a, b);
`,hxt=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+gf+`
  return result;
`,fxt=Ir({opSnippet:cxt,packedOpSnippet:hxt,cpuKernelImpl:gmt}),dxt={kernelName:$y,backendName:"webgl",kernelFunc:fxt};function pxt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;db(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,c=1;H(Or(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const f=$o(r.shape,i,o,c,a,l);if(f.filterWidth===1&&f.filterHeight===1&&mn(f.inShape,f.outShape))return Ai({inputs:{x:r},backend:e});const d=new Fg(f,"max",!1);return e.runWebGLProgram(d,[r],r.dtype)}const mxt={kernelName:Pw,backendName:"webgl",kernelFunc:pxt};function gxt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=s,f=[1,1,1],d=au(r.shape,i,o,f,a,c,l),m=new Xk(d,"max",!1);return e.runWebGLProgram(m,[r],r.dtype)}const yxt={kernelName:Vw,backendName:"webgl",kernelFunc:gxt};class bxt{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,s=t.strideWidth,r=t.dilationHeight,i=t.effectiveFilterHeight,o=t.effectiveFilterWidth,a=i-1-t.padInfo.top,l=o-1-t.padInfo.left,c=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class xxt{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,s=t.strideHeight,r=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,a=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,f=t.effectiveFilterWidth,d=l-1-t.padInfo.front,m=c-1-t.padInfo.top,y=f-1-t.padInfo.left,b=l*c*f-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${m}, ${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${b} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${f} +
                  wR * ${f} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function wxt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:f}=s,d=[1,1,1],m=au(o.shape,a,l,d,c,f),y=new Xk(m,"max",!0),b=e.runWebGLProgram(y,[o],o.dtype),w=new xxt(m),x=e.runWebGLProgram(w,[r,b],o.dtype);return e.disposeIntermediateTensorInfo(b),x}const vxt={kernelName:j2,backendName:"webgl",kernelFunc:wxt};function Sxt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i,output:o}=t,a=i;db([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:f,dimRoundingMode:d}=s,m=$o(a.shape,l,c,1,f,d),y=!0,b=new Fg(m,"max",y),w=e.runWebGLProgram(b,[a],a.dtype),x=new bxt(m),S=e.runWebGLProgram(x,[r,w],a.dtype);return e.disposeIntermediateTensorInfo(w),S}const Ixt={kernelName:W2,backendName:"webgl",kernelFunc:Sxt};function Txt(n,t,e,s){let r=new Fg(e,"max",!1);const i=s.runWebGLProgram(r,[n],"float32");r=new Fg(e,"max",!0,!0,t);const o=s.runWebGLProgram(r,[n],"float32");return[i,o]}const Cxt={kernelName:nP,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=t,l=e;H(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];H(Or(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const f=$o(s.shape,r,i,c,o),[d,m]=Txt(s,a,f,l);return[d,m]}};function Ext(n,t,e,s){const r=Lt(t),o=Lt(n.shape)/r,a=Jt({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),l=yf(a,"float32","mean",s),c=Jt({inputs:{x:l},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),c}const $xt={kernelName:Uw,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{keepDims:r,axis:i}=t,o=e,a=s.shape.length,l=Ve(i,s.shape);let c=l;const f=hs(c,a),d=f!=null,m=o.shouldExecuteOnCPU([s]),y=[];let b=s;if(d){if(m){const E=o.texData.get(b.dataId).values,R=new Array(a);for(let k=0;k<R.length;k++)R[k]=s.shape[f[k]];const B=qk(E,s.shape,s.dtype,f,R);b=o.makeTensorInfo(R,s.dtype);const N=o.texData.get(b.dataId);N.values=B}else b=Bv(s,f,o);y.push(b),c=xs(c.length,a)}Sr("sum",c,a);const[w,x]=ur(b.shape,c);let S=w;r&&(S=ks(w,l));const T=Ext(b,x,S,o);for(const $ of y)o.disposeIntermediateTensorInfo($);return T}};function Axt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,a=r.shape.length,l=Ve(i,r.shape);let c=l;const f=hs(c,a);let d=r;f!=null&&(d=Kr({inputs:{x:r},backend:e,attrs:{perm:f}}),c=xs(c.length,r.shape.length)),Sr("min",c,a);const[m,y]=ur(d.shape,c),b=Lt(y),w=Jt({inputs:{x:d},backend:e,attrs:{shape:[-1,b]}}),x=yf(w,w.dtype,"min",e);let S;if(o){const T=ks(m,l);S=Jt({inputs:{x},backend:e,attrs:{shape:T}})}else S=Jt({inputs:{x},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(x),f!=null&&e.disposeIntermediateTensorInfo(d),S}const kxt={kernelName:Gw,backendName:"webgl",kernelFunc:Axt};const _xt=Hk+`
  return min(a, b);
`,Nxt=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+gf+`
  return result;
`,Rxt=Ir({opSnippet:_xt,packedOpSnippet:Nxt,cpuKernelImpl:ymt}),Dxt={kernelName:Ay,backendName:"webgl",kernelFunc:Rxt};class Oxt{constructor(t,e,s){this.variableNames=["x"],this.outputShape=e.map((f,d)=>f[0]+t[d]+f[1]);const r=t.length,i=_n(r),o=e.map(f=>f[0]).join(","),a=e.map((f,d)=>f[0]+t[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}class Fxt{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((b,w)=>b[0]+t[w]+b[1]);const r=t.length,i=_n(r),o=e.map(b=>b[0]).join(","),a=e.map((b,w)=>b[0]+t[w]).join(","),l=qr("rc",r),c=qr("source",r),f=`${l[r-1]} < ${this.outputShape[r-1]}`,d=r===1?"source":`vec2(${c.slice(-2).join()})`,m=s==="reflect"?0:1;let y="";if(r===1){const b=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;y=`
        ${i} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${l[r-1]} += 1;
        if(${f}) {
          ${b}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
      `}else{const b=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;y=`
        ${i} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${l[r-1]} += 1;
        if(${f}) {
          ${b}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${b}
          result[2] = getChannel(getX(${c.join()}), ${d});
          ${l[r-1]} += 1;
          if(${f}) {
            ${b}
            result[3] = getChannel(getX(${c.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${y}
        setOutput(result);
      }
    `}}const Mxt=({inputs:n,backend:t,attrs:e})=>{const{x:s}=n,{paddings:r,mode:i}=e,o=At().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Fxt(s.shape,r,i):new Oxt(s.shape,r,i);return t.runWebGLProgram(o,[s],s.dtype)},Lxt={kernelName:Ww,backendName:"webgl",kernelFunc:Mxt};const zxt=`if (b == 0.0) return NAN;
  return mod(a, b);`,Bxt=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+gf+`
  return result;
`,Pxt=Ir({opSnippet:zxt,packedOpSnippet:Bxt}),Vxt={kernelName:ky,backendName:"webgl",kernelFunc:Pxt};class Uxt{constructor(t,e,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}}const Gxt=`
if (a == b) {
  return 1.0;
};
return a / b;`,Wxt=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,LW=Ir({opSnippet:Gxt,packedOpSnippet:Wxt,checkOutOfBounds:!0}),jxt={kernelName:dy,backendName:"webgl",kernelFunc:LW};const r3="return a - b;",zW=Ir({opSnippet:r3,packedOpSnippet:r3,supportsComplex:!0,cpuKernelImpl:zmt}),qxt={kernelName:jy,backendName:"webgl",kernelFunc:zW};function BW(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{dim:i}=s,o=Ve([i],r.shape),a=MW({inputs:{x:r},backend:e,attrs:{reductionIndices:o,keepDims:!1}}),l=ks(a.shape,o),c=Jt({inputs:{x:a},backend:e,attrs:{shape:l}}),f=zW({inputs:{a:r,b:c},backend:e}),d=DW({inputs:{x:f},backend:e}),m=Pv({inputs:{x:d},backend:e,attrs:{axis:o,keepDims:!1}}),y=Jt({inputs:{x:m},backend:e,attrs:{shape:l}}),b=LW({inputs:{a:d,b:y},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),b}const Hxt={kernelName:lv,backendName:"webgl",kernelFunc:BW};function Kxt(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{numSamples:i,seed:o,normalized:a}=s,l=a?r:BW({inputs:{logits:r},backend:e,attrs:{dim:r.shape.length-1}}),c=l.shape[0],f=l.shape[1],d=new Uxt(c,f,i),m=[[o]],y=e.runWebGLProgram(d,[l],"int32",m);return a||e.disposeIntermediateTensorInfo(l),y}const Xxt={kernelName:sP,backendName:"webgl",kernelFunc:Kxt};const Yxt=ko+`
  return -x;
`,Qxt=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Zxt(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])){const i=e.texData.get(s.dataId),[o,a]=xmt(i.values,s.shape,s.dtype);return e.makeTensorInfo(a,s.dtype,o)}let r;return At().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Hu(s.shape,Qxt):r=new Za(s.shape,Yxt),e.runWebGLProgram(r,[s],s.dtype)}const Jxt={kernelName:jw,backendName:"webgl",kernelFunc:Zxt};const twt=OA;function ewt(n){Ui("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s,c=e.readSync(r.dataId),f=e.readSync(i.dataId),{selectedIndices:d}=twt(c,f,o,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}const nwt={kernelName:q2,backendName:"webgl",kernelFunc:ewt};const swt=FA;function rwt(n){Ui("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=s,f=e.readSync(r.dataId),d=e.readSync(i.dataId),{selectedIndices:m,validOutputs:y}=swt(f,d,o,a,l,c);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([y]))]}const iwt={kernelName:H2,backendName:"webgl",kernelFunc:rwt};const owt=MA;function awt(n){Ui("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=s,f=e.readSync(r.dataId),d=e.readSync(i.dataId),m=o,y=a,b=l,w=c,{selectedIndices:x,selectedScores:S}=owt(f,d,m,y,b,w);return[e.makeTensorInfo([x.length],"int32",new Int32Array(x)),e.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const lwt={kernelName:K2,backendName:"webgl",kernelFunc:awt};class uwt{constructor(t,e,s,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}const cwt=n=>{const{inputs:t,backend:e,attrs:s}=n,{indices:r}=t,{dtype:i,depth:o,onValue:a,offValue:l}=s,c=Lt(r.shape),f=new uwt(c,o,a,l),d=Jt({inputs:{x:r},backend:e,attrs:{shape:[c]}}),m=e.runWebGLProgram(f,[d],i);e.disposeIntermediateTensorInfo(d);const y=[...r.shape,o],b=Jt({inputs:{x:m},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(m),b},hwt={kernelName:Kw,backendName:"webgl",kernelFunc:cwt};function Ax(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="complex64"){const r=mb({inputs:{input:s},backend:e}),i=Ax({inputs:{x:r},backend:e}),o=Vv({inputs:{input:s},backend:e}),a=Ax({inputs:{x:o},backend:e}),l=Mc({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}else return gb({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:e})}const fwt={kernelName:hv,backendName:"webgl",kernelFunc:Ax};function PW(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=mb({inputs:{input:s},backend:e}),i=PW({inputs:{x:r},backend:e}),o=Vv({inputs:{input:s},backend:e}),a=Ax({inputs:{x:o},backend:e}),l=Mc({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}else return gb({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:e})}const dwt={kernelName:Hw,backendName:"webgl",kernelFunc:PW};function pwt(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s;if(t.length===1)return m$({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const i=t[0].shape,o=t[0].dtype;t.forEach(f=>{m2(i,f.shape,"All tensors passed to stack must have matching shapes"),H(o===f.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=t.map(f=>{const d=m$({inputs:{input:f},backend:e,attrs:{dim:r}});return a.push(d),d}),c=CW({inputs:l,backend:e,attrs:{axis:r}});return a.forEach(f=>e.disposeIntermediateTensorInfo(f)),c}const mwt={kernelName:Xw,backendName:"webgl",kernelFunc:pwt};class gwt{constructor(t,e,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((c,f)=>c[0]+t[f]+c[1]);const r=t.length,i=_n(r),o=e.map(c=>c[0]).join(","),a=e.map((c,f)=>c[0]+t[f]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}class ywt{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((w,x)=>w[0]+t[x]+w[1]);const r=t.length,i=_n(r),o=e.map(w=>w[0]).join(","),a=e.map((w,x)=>w[0]+t[x]).join(","),l=qr("rc",r),c=qr("source",r),f=`${l[r-1]} < ${this.outputShape[r-1]}`,d=r===1?"source":`vec2(${c.slice(-2).join()})`,m=[`${i} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${f}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${f}) {`],y=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let b="";for(let w=0,x=r===1?2:4;w<x;w++)b+=`
        ${m[w]}
        if (${y}) {
          result[${w}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${w}] = getChannel(getX(${c.join()}), ${d});
        }
      `;b+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${b}
        setOutput(result);
      }
    `}}const VW=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:i,constantValue:o}=s;if(Lt(r.shape)===0){const c=i.map((f,d)=>f[0]+r.shape[d]+f[1]);return gb({backend:e,attrs:{shape:c,value:o,dtype:r.dtype}})}const a=At().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ywt(r.shape,i,o):new gwt(r.shape,i,o),l=[[o]];return e.runWebGLProgram(a,[r],r.dtype,l)},bwt={kernelName:Yw,backendName:"webgl",kernelFunc:VW};const xwt=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,wwt=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+gf+`
  return result;
`,vwt=Ir({opSnippet:xwt,packedOpSnippet:wwt}),Swt={kernelName:Ny,backendName:"webgl",kernelFunc:vwt};function Iwt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,a=r.shape.length,l=[],c=Ve(i,r.shape);let f=c;const d=hs(f,a);let m=r;d!=null&&(m=Kr({inputs:{x:r},backend:e,attrs:{perm:d}}),f=xs(f.length,a),l.push(m)),Sr("prod",f,a);let y;if(e.shouldExecuteOnCPU([m])){const b=e.texData.get(m.dataId).values,{outVals:w,outShape:x,outDtype:S}=vmt(m.shape,m.dtype,b,f);y=e.makeTensorInfo(x,S,w)}else{const[b,w]=ur(m.shape,f),x=Lt(w),S=Jt({inputs:{x:m},backend:e,attrs:{shape:[-1,x]}}),T=oA(r.dtype),$=yf(S,T,"prod",e);y=Jt({inputs:{x:$},backend:e,attrs:{shape:b}}),l.push(S),l.push($)}if(o){l.push(y);const b=ks(y.shape,c);y=Jt({inputs:{x:y},backend:e,attrs:{shape:b}})}return l.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}const Twt={kernelName:Zw,backendName:"webgl",kernelFunc:Iwt};function Cwt(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=t,{outputRaggedRank:a}=s,l=r.map(S=>e.readSync(S.dataId)),c=r.map(S=>S.shape),f=e.readSync(i.dataId),d=e.readSync(o.dataId),[m,y,b]=Smt(l,c,f,i.shape,i.dtype,d,o.shape,a),w=m.map(S=>e.makeTensorInfo([S.length],"int32",S)),x=e.makeTensorInfo(b,i.dtype,y);return w.concat([x])}const Ewt={kernelName:rP,backendName:"webgl",kernelFunc:Cwt};function $wt(n){const{inputs:t,backend:e}=n,{starts:s,limits:r,deltas:i}=t,o=e.readSync(s.dataId),a=e.readSync(r.dataId),l=e.readSync(i.dataId),[c,f]=Imt(o,s.shape,s.dtype,a,r.shape,l,i.shape),d=e.makeTensorInfo([c.length],"int32",c),m=e.makeTensorInfo([f.length],s.dtype,f);return[d,m]}const Awt={kernelName:iP,backendName:"webgl",kernelFunc:$wt};function kwt(n){const{inputs:t,backend:e,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=s,c=e.readSync(r.dataId),f=e.readSync(i.dataId),d=e.readSync(o.dataId),m=a.map(x=>e.readSync(x.dataId)),y=a.map(x=>x.shape),[b,w]=Tmt(c,r.shape,f,i.shape,i.dtype,d,o.shape,m,y,l);return e.makeTensorInfo(b,i.dtype,w)}const _wt={kernelName:oP,backendName:"webgl",kernelFunc:kwt};const UW=n=>{const{backend:t,attrs:e}=n,{start:s,stop:r,step:i,dtype:o}=e,a=Cmt(s,r,i,o);return t.makeTensorInfo([a.length],o,a)},Nwt={kernelName:X2,backendName:"webgl",kernelFunc:UW};const Rwt="return 1.0 / x;",Dwt=rn({opSnippet:Rwt}),Owt={kernelName:Ry,backendName:"webgl",kernelFunc:Dwt};const Fwt=ko+`
  return (x < 0.0) ? 0.0 : x;
`,Mwt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Lwt=rn({opSnippet:Fwt,packedOpSnippet:Mwt}),zwt={kernelName:Dy,backendName:"webgl",kernelFunc:Lwt};const Bwt=ko+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Pwt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Vwt=rn({opSnippet:Bwt,packedOpSnippet:Pwt}),Uwt={kernelName:Oy,backendName:"webgl",kernelFunc:Vwt};class Gwt{constructor(t,e,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,s,c];const f=[r&&e>1?a-1:a,r&&s>1?l-1:l],d=[r&&e>1?e-1:e,r&&s>1?s-1:s];let m;i?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${f[0]/d[0]},
          ${f[1]/d[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class Wwt{constructor(t,e,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,s,c];const f=[r&&e>1?a-1:a,r&&s>1?l-1:l],d=[r&&e>1?e-1:e,r&&s>1?s-1:s];let m;i?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${f[0]/d[0]},
          ${f[1]/d[1]},
          ${f[1]/d[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function jwt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:a}=s,[l,c]=a,f=At().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Wwt(r.shape,l,c,i,o):new Gwt(r.shape,l,c,i,o);return e.runWebGLProgram(f,[r],"float32")}const qwt={kernelName:ev,backendName:"webgl",kernelFunc:jwt};class Hwt{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,i]=e,[,o,a]=t,l=[s&&o>1?r-1:r,s&&a>1?i-1:i],c=[s&&o>1?o-1:o,s&&a>1?a-1:a],f=l[0]/c[0],d=l[1]/c[1],m=1/f,y=1/d,b=Math.ceil(m)*2+2,w=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${f});
        const float widthScale = float(${d});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${w});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function Kwt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:o}=s,a=new Hwt(i.shape,r.shape,o);return e.runWebGLProgram(a,[i],i.dtype)}const Xwt={kernelName:Z2,backendName:"webgl",kernelFunc:Kwt};class Ywt{constructor(t,e,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,s,c];const f=[r&&e>1?a-1:a,r&&s>1?l-1:l],d=[r&&e>1?e-1:e,r&&s>1?s-1:s],m=r?"0.5":"0.0";let y;i?y="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":y="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${f[0]/d[0]},
          ${f[1]/d[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class Qwt{constructor(t,e,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,s,c];const f=[r&&e>1?a-1:a,r&&s>1?l-1:l],d=[r&&e>1?e-1:e,r&&s>1?s-1:s],m=r?"0.5":"0.0";let y;i?y="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":y="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${f[0]/d[0]},
          ${f[1]/d[1]},
          ${f[1]/d[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function Zwt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:a}=s,[l,c]=a,f=At().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Qwt(r.shape,l,c,i,o):new Ywt(r.shape,l,c,i,o);return e.runWebGLProgram(f,[r],r.dtype)}const Jwt={kernelName:tv,backendName:"webgl",kernelFunc:Zwt};class tvt{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,i]=e,[,o,a]=t,l=[s&&o>1?r-1:r,s&&a>1?i-1:i],c=[s&&o>1?o-1:o,s&&a>1?a-1:a],f=l[0]/c[0],d=l[1]/c[1],m=1/f,y=1/d,b=Math.ceil(m)*2+2,w=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${f});
        const float widthScale = float(${d});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${w});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function evt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:o}=s,a=new tvt(i.shape,r.shape,o);return e.runWebGLProgram(a,[i],i.dtype)}const nvt={kernelName:Q2,backendName:"webgl",kernelFunc:evt};class svt{constructor(t,e){this.variableNames=["x"];const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=t,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const r=a=>e.indexOf(a)!==-1&&t[a]!==1?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`,i=t.map((a,l)=>r(l)).join(","),o=_n(s);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}class rvt{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=t;const r=qr("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,a=_n(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${i}){
            result.g = ${c(r.slice())};
          }
          if(${o}) {
            result.b = ${f(r.slice())};
            if(${i}) {
              result.a = ${d(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(b){return m(b)}function c(b){return b[s-1]="("+b[s-1]+" + 1)",m(b)}function f(b){return b[s-2]="("+b[s-2]+" + 1)",m(b)}function d(b){return b[s-1]="("+b[s-1]+" + 1)",b[s-2]="("+b[s-2]+" + 1)",m(b)}function m(b){const w=t.map((T,$)=>y($,b)),x=w.join(","),S=w.slice(-2).join(",");return`getChannel(getX(${x}), vec2(${S}))`}function y(b,w){return e.indexOf(b)!==-1&&t[b]!==1?`${t[b]} - ${w[b]} - 1`:`${w[b]}`}}}function ivt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dims:i}=s,o=r.shape.length,a=Ve(i,r.shape);if(o===0)return Ai({inputs:{x:r},backend:e});const l=At().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rvt(r.shape,a):new svt(r.shape,a);return e.runWebGLProgram(l,[r],r.dtype)}const ovt={kernelName:nv,backendName:"webgl",kernelFunc:ivt};class avt{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=t[1],r=t[2];this.outputShape=t;let i="";typeof e=="number"?i=`float outputValue = ${e.toFixed(2)};`:i=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const lvt={kernelName:iA,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=t,a=e,l=new avt(s.shape,i),[c,f]=HA(o,s.shape[1],s.shape[2]),d=[[c,f,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(l,[s],s.dtype,d)}};const uvt=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,cvt=rn({opSnippet:uvt}),hvt={kernelName:Fy,backendName:"webgl",kernelFunc:cvt};const fvt="return inversesqrt(x);",dvt=rn({opSnippet:fvt,cpuKernelImpl:Emt}),pvt={kernelName:My,backendName:"webgl",kernelFunc:dvt};class Yk{constructor(t,e,s,r,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const c=_n(i.length),f=_n(o.length);let d="";s===1?d="i":s===2&&(d="i, j");const m=`getIndices(${d})`;let y="";r===1?y="i":r===2&&(y="i, coords[1]");const b=`getUpdates(${y})`;let w="";l&&(w="coords[0], coords[1]");const x=`getDefaultValue(${w})`,S=e>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${f} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${S};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${b};
              found = true;
            }
          }
          setOutput(mix(${x}, sum, float(found)));
        }
      `}}class mvt{constructor(t,e,s,r,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const c=_n(i.length),f=_n(o.length);let d="";s===1?d="i":s===2&&(d="i, j");const m=`getIndices(${d})`;let y="";r===1?y="i":r===2&&(y="i, coords[1]");const b=`getUpdates(${y})`;let w="";l&&(w="coords[0], coords[1]");const x=`getDefaultValue(${w})`,S=e>1?"strides[j]":"strides",T=e>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${f} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${e}; j+=2) {
              ivec4 index = round(${m});
              flattenedIndex += index.xz * ${S};
              if (j + 1 < ${e}) {
                flattenedIndex += index.yw * ${T};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${b};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${x}, sum, found));
        }
      `}}function gvt(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r,updates:i}=t,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:c,strides:f,outputSize:d}=hf(i,r,o),m=[d/c,c];if(d===0)return e.makeTensorInfo(o,r.dtype);const y=Jt({inputs:{x:r},backend:e,attrs:{shape:[l,a]}}),b=Jt({inputs:{x:i},backend:e,attrs:{shape:[l,c]}}),w=e.makeTensorInfo([],"float32",new Float32Array([0]));let x;At().getBool("WEBGL_PACK")?x=new mvt(l,a,y.shape.length,b.shape.length,f,m):x=new Yk(l,a,y.shape.length,b.shape.length,f,m);const S=e.runWebGLProgram(x,[b,y,w],b.dtype),T=Jt({inputs:{x:S},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(w),T}const yvt={kernelName:aP,backendName:"webgl",kernelFunc:gvt};class bvt{constructor(t,e,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,s];const i="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=At().getNumber("WEBGL_VERSION")===2?i:o,l=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function xvt(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:r,values:i}=t,{side:o}=s,a=new bvt(r.shape[0],r.shape[1],i.shape[1],o),l=[[r.shape[1]]];return e.runWebGLProgram(a,[r,i],"int32",l)}const wvt={kernelName:uP,backendName:"webgl",kernelFunc:xvt};class vvt{constructor(t,e,s){this.variableNames=["c","a","b"],this.outputShape=e;let r,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",r="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let f=0;f<e.length;f++)c.push(`${a[f]}`),f<t&&l.push(`${a[f]}`);r=l.join(),i=c.join()}const o=_n(s);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}function Svt(n){const{inputs:t,backend:e}=n,{condition:s,t:r,e:i}=t,o=new vvt(s.shape.length,r.shape,r.shape.length);return e.runWebGLProgram(o,[s,r,i],Ei(r.dtype,i.dtype))}const Ivt={kernelName:sv,backendName:"webgl",kernelFunc:Svt};const Tvt=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${Tv};
  float scale = ${Cv};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Cvt=rn({opSnippet:Tvt}),Evt={kernelName:Ly,backendName:"webgl",kernelFunc:Cvt};const $vt=Rp+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Avt=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,kvt=rn({opSnippet:$vt,packedOpSnippet:Avt,cpuKernelImpl:Amt}),_vt={kernelName:Vy,backendName:"webgl",kernelFunc:kvt};const Nvt=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Rvt=rn({opSnippet:Nvt}),Dvt={kernelName:Py,backendName:"webgl",kernelFunc:Rvt};const Ovt=Rp+`
  return sin(x);
`,Fvt=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${gf}
  return result;
`,Mvt=rn({opSnippet:Ovt,packedOpSnippet:Fvt}),Lvt={kernelName:zy,backendName:"webgl",kernelFunc:Mvt};const zvt=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Bvt=rn({opSnippet:zvt}),Pvt={kernelName:By,backendName:"webgl",kernelFunc:Bvt};const Vvt=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Uvt=rn({opSnippet:Vvt}),Gvt={kernelName:Uy,backendName:"webgl",kernelFunc:Uvt};const Wvt=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,paddings:o}=s;H(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((S,T)=>S*T),l=[[0,0]];l.push(...o);for(let S=1+i.length;S<r.shape.length;++S)l.push([0,0]);const c=[],f=VW({inputs:{x:r},backend:e,attrs:{paddings:l,constantValue:0}}),d=nb(f.shape,i,a,!1),m=sb(d.length,i.length,!1),y=rb(f.shape,i,a,!1),b=Jt({inputs:{x:f},backend:e,attrs:{shape:d}}),w=Kr({inputs:{x:b},backend:e,attrs:{perm:m}}),x=Jt({inputs:{x:w},backend:e,attrs:{shape:y}});return c.push(f),c.push(b),c.push(w),c.forEach(S=>e.disposeIntermediateTensorInfo(S)),x},jvt={kernelName:ov,backendName:"webgl",kernelFunc:Wvt};function qvt(n){const{inputs:t,backend:e}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=t;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=e.readSync(s.dataId),l=e.readSync(r.dataId),c=e.readSync(i.dataId),f=e.readSync(o.dataId)[0],[d,m,y,b,w]=_mt(a,s.shape,s.dtype,l,r.dtype,c,f);return[e.makeTensorInfo(m,s.dtype,d),e.makeTensorInfo([m[0]],r.dtype,y),e.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(x=>Number(x)))),e.makeTensorInfo([w.length],s.dtype,new Int32Array(w))]}const Hvt={kernelName:cP,backendName:"webgl",kernelFunc:qvt};function Kvt(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:r,newShape:i}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.readSync(r.dataId)),a=e.readSync(s.dataId),l=Array.from(e.readSync(i.dataId)),[c,f,d]=Nmt(a,s.shape,s.dtype,o,l);return[e.makeTensorInfo(f,s.dtype,c),e.makeTensorInfo([d.length],i.dtype,new Int32Array(d))]}const Xvt={kernelName:hP,backendName:"webgl",kernelFunc:Kvt};function Yvt(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const o=e.readSync(s.dataId),a=e.readSync(r.dataId),l=e.readSync(i.dataId),[c,f]=fW(o,s.shape,s.dtype,a,l,!0);return e.makeTensorInfo(f,s.dtype,c)}const Qvt={kernelName:fP,backendName:"webgl",kernelFunc:Yvt};function Zvt(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const o=e.readSync(s.dataId),a=e.readSync(r.dataId),l=e.readSync(i.dataId),[c,f]=fW(o,s.shape,s.dtype,a,l);return e.makeTensorInfo(f,s.dtype,c)}const Jvt={kernelName:dP,backendName:"webgl",kernelFunc:Zvt};function tSt(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=t,{outputShape:a}=s,{sliceRank:l,numUpdates:c,sliceSize:f,strides:d,outputSize:m}=hf(i,r,a),y=!1;if(i.dtype==="string"){const S=e.bufferSync(r),T=e.bufferSync(i),$=lc(e.readSync(o.dataId)[0]),E=$mt(S,T,a,m,f,c,l,d,$,y);return e.makeTensorInfo(a,E.dtype,E.values)}const b=new Yk(c,l,r.shape.length,i.shape.length,d,[m,1],y),w=e.runWebGLProgram(b,[i,r,o],i.dtype),x=Jt({inputs:{x:w},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(w),x}const eSt={kernelName:pP,backendName:"webgl",kernelFunc:tSt};function nSt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{numOrSizeSplits:i,axis:o}=s,a=Ve(o,r.shape)[0],l=lk(r,i,a),c=r.shape.length,f=new Array(c).fill(0),d=r.shape.slice();return l.map(m=>{const y=[...d];y[a]=m;const b=Dp({inputs:{x:r},backend:e,attrs:{begin:f,size:y}});return f[a]+=m,b})}const sSt={kernelName:av,backendName:"webgl",kernelFunc:nSt};const i3="return sqrt(x);",rSt=rn({opSnippet:i3,packedOpSnippet:i3,cpuKernelImpl:Rmt}),iSt={kernelName:Gy,backendName:"webgl",kernelFunc:rSt};const oSt="return x * x;",aSt=rn({opSnippet:oSt}),lSt={kernelName:J2,backendName:"webgl",kernelFunc:aSt};const o3="return (a - b) * (a - b);",uSt=Ir({opSnippet:o3,packedOpSnippet:o3}),cSt={kernelName:Wy,backendName:"webgl",kernelFunc:uSt};function hSt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const i=e.readSync(r.dataId),o=Jl(i),a=Dmt(o,"string",s);return e.makeTensorInfo(r.shape,"string",a)}const fSt={kernelName:tA,backendName:"webgl",kernelFunc:hSt};function dSt({inputs:n,attrs:t,backend:e}){const{x:s}=n,r=ko+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,i=new Za(s.shape,r);return e.runWebGLProgram(i,[s],s.dtype)}const pSt={kernelName:Xy,backendName:"webgl",kernelFunc:dSt};class mSt{constructor(t,e,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=_n(s.length),o=_n(s.length);let a="";if(r===1)a="coords * strides + begin";else{let l=0;a=s.map((c,f)=>(l++,s.length===1?`coords * strides[${f}] + begin[${f}]`:`coords[${l-1}] * strides[${f}] + begin[${f}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${t});
      ${i} strides = ${i}(${e});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}function gSt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:f,newAxisMask:d,shrinkAxisMask:m}=s,{finalShapeSparse:y,finalShape:b,isIdentity:w,sliceDim0:x,isSimpleSlice:S,begin:T,end:$,strides:E}=WA(r.shape,i,o,a,l,c,f,d,m);let R;if(w)R=Jt({inputs:{x:r},backend:e,attrs:{shape:b}});else if(x||S){H(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const N=VA(T,$,E),k=Dp({inputs:{x:r},backend:e,attrs:{begin:T,size:N}});R=Jt({inputs:{x:k},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(k)}else if(e.shouldExecuteOnCPU([r])){const k=e.readSync(r.dataId),_=Pe(r.shape,r.dtype,k),F=Omt(y,_,E,T);R=e.makeTensorInfo(b,r.dtype,F.values)}else{const k=new mSt(T,E,y);R=e.runWebGLProgram(k,[r],r.dtype)}const B=Jt({inputs:{x:R},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(R),B}const ySt={kernelName:eA,backendName:"webgl",kernelFunc:gSt};function bSt(n){const{inputs:t,backend:e,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=s,{data:f,dataSplits:d}=t,m=e.readSync(f.dataId),y=e.readSync(d.dataId),[b,w]=Fmt(m,y,r,i,o,a,l,c);return[e.makeTensorInfo([b.length],"string",b),e.makeTensorInfo(d.shape,"int32",w)]}const xSt={kernelName:mP,backendName:"webgl",kernelFunc:bSt};function wSt(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.readSync(i.dataId),l=e.readSync(o.dataId)[0],[c,f,d]=Mmt(a,l,r),m=f.length;return[e.makeTensorInfo([m,2],"int32",c),e.makeTensorInfo([m],"string",f),e.makeTensorInfo([2],"int32",new Int32Array(d))]}const vSt={kernelName:gP,backendName:"webgl",kernelFunc:wSt};function SSt(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:r}=s,{input:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=e.readSync(i.dataId),a=Lmt(o,r);return e.makeTensorInfo(i.shape,"int32",a)}const ISt={kernelName:yP,backendName:"webgl",kernelFunc:SSt};const TSt="return tan(x);",CSt=rn({opSnippet:TSt}),ESt={kernelName:qy,backendName:"webgl",kernelFunc:CSt};const $St=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,ASt=rn({opSnippet:$St}),kSt={kernelName:Hy,backendName:"webgl",kernelFunc:ASt};function _St(n){const{inputs:t,backend:e,attrs:s}=n,{tensor:r,indices:i,updates:o}=t,{sliceRank:a,numUpdates:l,sliceSize:c,strides:f,outputSize:d}=hf(o,i,r.shape),m=[d/c,c];if(d===0)return e.makeTensorInfo(r.shape,i.dtype);const y=Jt({inputs:{x:i},backend:e,attrs:{shape:[l,a]}}),b=Jt({inputs:{x:o},backend:e,attrs:{shape:[l,c]}}),w=Jt({inputs:{x:r},backend:e,attrs:{shape:m}}),x=new Yk(l,a,y.shape.length,b.shape.length,f,m,!1,!0),S=e.runWebGLProgram(x,[b,y,w],w.dtype),T=Jt({inputs:{x:S},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(S),T}const NSt={kernelName:lP,backendName:"webgl",kernelFunc:_St};class RSt{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let o=0;o<s.length;o++)s[o]=t[o]*e[o];this.outputShape=s,this.rank=s.length;const r=_n(this.rank),i=DSt(t);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function DSt(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${e[r]}, ${n[r]})`);return s.join()}function GW(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reps:i}=s;if(r.dtype==="string"||r.shape.length>5){const l=e.readSync(r.dataId),c=r.dtype==="string"?l.map(m=>lc(m)):l,f=Pe(r.shape,r.dtype,c),d=Bmt(f,i);return e.makeTensorInfo(d.shape,d.dtype,d.values)}const o=new RSt(r.shape,i);return e.runWebGLProgram(o,[r],r.dtype)}const OSt={kernelName:Ky,backendName:"webgl",kernelFunc:GW};class FSt{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class MSt{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function dh(n,t){t!==null&&n.disposeIntermediateTensorInfo(t)}function a3(n){let t=1;for(;t<n;)t*=2;return t}function LSt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{k:i,sorted:o}=s,a=At().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=At().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=r.shape,f=c[c.length-1];if(e.shouldExecuteOnCPU([r])||f<a||i>l){const F=e.readSync(r.dataId),[A,P]=Pmt(F,c,r.dtype,i,o);return[e.makeTensorInfo(A.shape,A.dtype,A.values),e.makeTensorInfo(P.shape,P.dtype,P.values)]}if(i===0)return c[c.length-1]=0,[e.makeTensorInfo(c,r.dtype,[]),e.makeTensorInfo(c,"int32",[])];if(f===1)return[r,gb({attrs:{shape:c,dtype:"int32",value:0},backend:e})];const d=e.texData.get(r.dataId),m=d!==null&&d.isPacked,y=m?e.unpackTensor(r):r,w=Lt(c)/f,x=Jt({inputs:{x:y},attrs:{shape:[w,f]},backend:e});m&&dh(e,y);const S=a3(i),T=a3(f);let $=null;const E=()=>$===null?[x,x]:[x,$],R=(F,A,P)=>{const L=E(),tt=new FSt(P),j=[[f],[$===null?1:0],[Number.NEGATIVE_INFINITY],[F],[A]],Z=$;$=e.runWebGLProgram(tt,L,"int32",j),dh(e,Z)};for(let F=1;F<S;F*=2){const A=F*2;for(let P=F;P>=1;P/=2)R(A,P,[w,T])}for(let F=T;F>S;F/=2){const A=E(),P=new MSt([w,F/2]),tt=[[f],[$===null?1:0],[S]],st=$;$=e.runWebGLProgram(P,A,"int32",tt),dh(e,st);const j=S/2,Z=j*2;for(let J=j;J>=1;J/=2)R(Z,J,$.shape)}let B=$;$=Dp({inputs:{x:$},backend:e,attrs:{begin:0,size:[w,i]}}),dh(e,B);let N=FW({inputs:{x,indices:$},backend:e,attrs:{axis:1,batchDims:1}});dh(e,x);const k=c.slice(0,-1);k.push(i),B=$,$=Jt({inputs:{x:$},attrs:{shape:k},backend:e}),dh(e,B);const _=N;return N=Jt({inputs:{x:N},attrs:{shape:k},backend:e}),dh(e,_),[N,$]}const zSt={kernelName:nA,backendName:"webgl",kernelFunc:LSt};class BSt{constructor(t,e,s,r,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=s==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function PSt(n){const{inputs:t,backend:e,attrs:s}=n,{image:r,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=s,[f,d,m,y]=r.shape,[b,w]=c??[d,m],x=[f,b,w,y],S=new BSt(d,m,o,a,l,x);return e.runWebGLProgram(S,[r,i],"float32")}const VSt={kernelName:sA,backendName:"webgl",kernelFunc:PSt};function USt(n){const{inputs:t,attrs:e,backend:s}=n,{axis:r}=e,{x:i}=t;db(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(i.dataId),{outputValues:a,outputShape:l,indices:c}=Vmt(o,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,a),s.makeTensorInfo([c.length],"int32",c)]}const GSt={kernelName:rA,backendName:"webgl",kernelFunc:USt};function WSt(n){const{inputs:t,backend:e,attrs:s}=n,{value:r}=t;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r,a=o.shape.length,l=r.shape[i],c=new Array(a-1);let f=0;for(let w=0;w<a;w++)w!==i&&(c[f++]=o.shape[w]);const d=[],m=new Array(a).fill(0),y=o.shape.slice();y[i]=1;const b=new Array(l);for(let w=0;w<b.length;w++){m[i]=w;const x=Dp({inputs:{x:o},backend:e,attrs:{begin:m,size:y}}),S=Jt({inputs:{x},backend:e,attrs:{shape:c}});b[w]=S,d.push(x)}return d.forEach(w=>e.disposeIntermediateTensorInfo(w)),b}const jSt={kernelName:uv,backendName:"webgl",kernelFunc:WSt};class qSt{constructor(t,e){this.variableNames=["x","segmentIds"];const s=t.windowSize,r=t.batchSize,i=t.inSize,o=t.numSegments,a=o*Math.ceil(i/s);this.outputShape=[r,a];const l="0.0",c="sumValue",f=Math.floor(s/4)*4,d=s%4,m=`
        sumValue += dot(values, segFilter);
    `;let y="";i%s>0&&(y=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let b="";i%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${y}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${b}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${f}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${f};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${c});
      }
    `}}function HSt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,segmentIds:i}=t,{numSegments:o}=s,a=r.shape.length,l=[];let c=0;const f=hs([c],a);let d=r;f!=null&&(d=Kr({inputs:{x:r},backend:e,attrs:{perm:f}}),l.push(d),c=xs(1,a)[0]);const m=lV(d.shape,c,o),y=Lt([d.shape[c]]),b=Jt({inputs:{x:d},backend:e,attrs:{shape:[-1,y]}});l.push(b);const w=oA(r.dtype),x=(E,R,B,N,k)=>{const _=E.shape[0],F=E.shape[1],A=aV(F,k),P={windowSize:A,inSize:F,batchSize:_,numSegments:k},L=new qSt(P,R),tt=e.compileAndRun(L,[E,B],N);if(l.push(tt),tt.shape[1]===k)return tt;const st=UW({backend:e,attrs:{start:0,stop:k,step:1,dtype:"float32"}}),j=GW({inputs:{x:st},backend:e,attrs:{reps:[F/A]}});return l.push(st),l.push(j),x(tt,R,j,N,k)},S=x(b,"unsortedSegmentSum",i,w,o),T=Jt({inputs:{x:S},backend:e,attrs:{shape:m}});let $=T;if(f!=null){l.push(T);const E=Nc(f);$=Kr({inputs:{x:$},backend:e,attrs:{perm:E}})}return l.forEach(E=>e.disposeIntermediateTensorInfo(E)),$}const KSt={kernelName:cv,backendName:"webgl",kernelFunc:HSt};const XSt=[Rgt,Ogt,Lgt,Pgt,Ugt,jgt,Hgt,Xgt,Jgt,eyt,ryt,ayt,cyt,pyt,yyt,xyt,vyt,Cyt,$yt,kyt,Dyt,Pyt,Uyt,qyt,Kyt,tbt,nbt,obt,mgt,ubt,pbt,bbt,Tbt,$bt,kbt,Nbt,Dbt,Lbt,Pbt,Gbt,jbt,Hbt,Xbt,Zbt,t0t,r0t,o0t,u0t,f0t,p0t,b0t,S0t,E0t,k0t,R0t,D0t,F0t,L0t,B0t,V0t,G0t,H0t,Y0t,J0t,e1t,r1t,a1t,h1t,m1t,pgt,y1t,fbt,w1t,I1t,E1t,ygt,_1t,O1t,M1t,P1t,G1t,H1t,Y1t,txt,rxt,axt,uxt,dxt,mxt,yxt,vxt,Ixt,Cxt,$xt,kxt,Dxt,Lxt,Vxt,Xxt,wgt,Jxt,nwt,iwt,lwt,Yyt,hwt,dwt,mwt,bwt,Swt,xgt,Twt,Ewt,Awt,_wt,Nwt,Qyt,jxt,Owt,zwt,Uwt,Sgt,qwt,Xwt,Jwt,nvt,ovt,lvt,hvt,pvt,yvt,wvt,Ivt,Evt,_vt,Dvt,Lvt,Pvt,zyt,Hxt,Gvt,jvt,Hvt,Xvt,Qvt,Jvt,eSt,sSt,iSt,lSt,cSt,fSt,pSt,ySt,xSt,vSt,ISt,qxt,kgt,ESt,kSt,NSt,OSt,zSt,VSt,_gt,GSt,jSt,KSt,fwt];for(const n of XSt)xP(n);const YSt=1e-7,QSt=1e-4;class ZSt{refCount(t){return Vi("refCount")}incRef(t){return Vi("incRef")}timerAvailable(){return!0}time(t){return Vi("time")}read(t){return Vi("read")}readSync(t){return Vi("readSync")}readToGPU(t,e){return Vi("readToGPU")}numDataIds(){return Vi("numDataIds")}disposeData(t,e){return Vi("disposeData")}write(t,e,s){return Vi("write")}move(t,e,s,r,i){return Vi("move")}memory(){return Vi("memory")}floatPrecision(){return Vi("floatPrecision")}epsilon(){return this.floatPrecision()===32?YSt:QSt}dispose(){return Vi("dispose")}}function Vi(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Lg(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,JSt(n,t,e)}function JSt(n,t,e){const s=n[t];n[t]=n[e],n[e]=s}function Q(n,t){if(!n)throw new Error(typeof t=="string"?t:t())}function tIt(n,t,e=""){Q(ci(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function Uv(n){Q(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Gv(n,t=[],e=!1){if(t==null&&(t=[]),Array.isArray(n)||ca(n)&&!e)for(let s=0;s<n.length;++s)Gv(n[s],t,e);else t.push(n);return t}function oi(n){if(n.length===0)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function ci(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function kx(n){return n%1===0}function W1(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function wl(n,t){const e=t.length;return n=n==null?t.map((s,r)=>r):[].concat(n),Q(n.every(s=>s>=-e&&s<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),Q(n.every(s=>kx(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?e+s:s)}function eIt(n,t){const e=[],s=[],r=t!=null&&Array.isArray(t)&&t.length===0,i=t==null||r?null:wl(t,n).sort();let o=0;for(let a=0;a<n.length;++a){if(i!=null){if(i[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(i[o]==null||i[o]>a)&&n[a]===1&&(e.push(n[a]),s.push(a)),i[o]<=a&&o++}n[a]!==1&&(e.push(n[a]),s.push(a))}return{newShape:e,keptDims:s}}function nIt(n,t){let e=null;if(n==null||n==="float32")e=new Float32Array(t);else if(n==="int32")e=new Int32Array(t);else if(n==="bool")e=new Uint8Array(t);else if(n==="string")e=new Array(t);else throw new Error(`Unknown data type ${n}`);return e}function sIt(n,t){for(let e=0;e<n.length;e++){const s=n[e];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}function rIt(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function ca(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}function l3(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function iIt(n){if(n==null)return 0;let t=0;return n.forEach(e=>t+=e.length),t}function Qk(n){return typeof n=="string"||n instanceof String}function oIt(n){return typeof n=="boolean"}function g$(n){return typeof n=="number"}function Zk(n){return Array.isArray(n)?Zk(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":g$(n)?"float32":Qk(n)?"string":oIt(n)?"bool":"float32"}function y$(n){return!!(n&&n.constructor&&n.call&&n.apply)}function Jk(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let s=t-3;s>=0;--s)e[s]=e[s+1]*n[s+1];return e}function WW(n,t,e,s=!1){const r=new Array;if(t.length===1){const i=t[0]*(s?2:1);for(let o=0;o<i;o++)r[o]=e[n+o]}else{const i=t[0],o=t.slice(1),a=o.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<i;l++)r[l]=WW(n+l*a,o,e,s)}return r}function u3(n,t,e=!1){if(n.length===0)return t[0];const s=n.reduce((r,i)=>r*i)*(e?2:1);if(s===0)return[];if(s!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return WW(0,n,t,e)}function jW(n,t){const e=t_(n,t);for(let s=0;s<e.length;s++)e[s]=1;return e}function t_(n,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function qW(n){n.forEach(t=>{Q(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function e_(n){return n&&n.then&&typeof n.then=="function"}const c3="tfjsflags";class aIt{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=lIt,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(bn().getBool("IS_TEST")||bn().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,s){if(this.flagRegistry[t]={evaluationFn:e,setHook:s},this.urlFlags[t]!=null){const r=this.urlFlags[t];bn().getBool("IS_TEST")||bn().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${r}.`),this.set(t,r)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(e_(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);c3 in t&&t[c3].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=cIt(r,i)})}}function lIt(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...s)=>(uIt(t,s[0],s[1]),s.join("="))),t}function uIt(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}function cIt(n,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${n}.`)}function bn(){return HW}let HW=null;function hIt(n){HW=n}let sC;function KW(){if(sC==null){let n;if(typeof window<"u")n=window;else if(typeof oa<"u")n=oa;else if(typeof Un<"u")n=Un;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");sC=n}return sC}function fIt(){const n=KW();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function n_(n,t){const e=fIt();if(e.has(n))return e.get(n);{const s=t();return e.set(n,s),e.get(n)}}const XW="Abs",dIt="Acos",pIt="Acosh",s_="Add",mIt="AddN",gIt="All",yIt="Any",YW="ArgMax",bIt="ArgMin",xIt="Asin",wIt="Asinh",vIt="Atan",SIt="Atanh",IIt="Atan2",QW="AvgPool",TIt="AvgPoolGrad",ZW="AvgPool3D",CIt="AvgPool3DGrad",JW="BatchMatMul",tj="BatchToSpaceND",EIt="Bincount",$It="BroadcastTo",r_="Cast",AIt="Ceil",ej="ClipByValue",kIt="Complex",nj="ComplexAbs",sj="Concat",rj="Conv2D",_It="Conv2DBackpropFilter",ij="Conv2DBackpropInput",oj="Conv3D",NIt="Conv3DBackpropFilterV2",RIt="Conv3DBackpropInputV2",aj="Cos",lj="Cosh",DIt="Cumprod",uj="Cumsum",OIt="CropAndResize",cj="DepthwiseConv2dNative",FIt="DepthwiseConv2dNativeBackpropFilter",MIt="DepthwiseConv2dNativeBackpropInput",LIt="Dilation2D",zIt="Dilation2DBackpropInput",BIt="Dilation2DBackpropFilter",hj="RealDiv",fj="Elu",PIt="EluGrad",VIt="Erf",UIt="Equal",dj="Exp",pj="ExpandDims",GIt="Expm1";const WIt="Fill",jIt="FlipLeftRight",mj="Floor",gj="FloorDiv",yj="FusedBatchNorm",bj="GatherV2",qIt="Greater",xj="GreaterEqual",i_="Identity";const HIt="Imag",KIt="IsFinite",XIt="IsInf",YIt="IsNan",wj="LeakyRelu",QIt="Less",ZIt="LessEqual",vj="Log",Sj="Log1p",JIt="LogicalAnd",tTt="LogicalNot",eTt="LogSoftmax",nTt="LRN",sTt="LRNGrad",Ij="Max",Tj="Maximum",Cj="MaxPool",rTt="MaxPoolGrad",Ej="MaxPool3D",iTt="MaxPool3DGrad",$j="Mean",Aj="Min",kj="Minimum",oTt="MirrorPad",aTt="Mod",_j="Multiply",Nj="Neg",lTt="NotEqual",uTt="NonMaxSuppressionV3",cTt="NonMaxSuppressionV4",hTt="NonMaxSuppressionV5",Rj="OnesLike",Dj="OneHot",Oj="Pack",Fj="PadV2",Mj="Pow",Lj="Prelu",fTt="Prod",dTt="Range",pTt="Real",mTt="Reciprocal",zj="Relu",Bj="Reshape",Pj="ResizeNearestNeighbor",gTt="ResizeNearestNeighborGrad",Vj="ResizeBilinear",yTt="ResizeBilinearGrad",Uj="Relu6",Gj="Reverse",Wj="Round",jj="Rsqrt",qj="Select",Hj="Selu",Kj="Slice",Xj="Sin",Yj="Sinh",bTt="Sign",Qj="Sigmoid",Zj="Softplus",Jj="Sqrt",t5="Sum",e5="SpaceToBatchND",n5="SplitV",s5="Softmax";const xTt="SquaredDifference",wTt="Square";const r5="Sub",vTt="Tan",i5="Tanh",o_="Tile",STt="Transform",j1="Transpose",o5="Unpack",a5="UnsortedSegmentSum",l5="ZerosLike",u5="Step",ITt="RotateWithOffset",h3="_FusedMatMul",f3="FusedConv2D";function Id(...n){bn().getBool("IS_TEST")||bn().getBool("PROD")||console.warn(...n)}const c5=n_("kernelRegistry",()=>new Map),b$=n_("gradRegistry",()=>new Map);function d3(n,t){const e=CTt(n,t);return c5.get(e)}function p3(n){return b$.get(n)}function m3(n){const t=c5.entries(),e=[];for(;;){const{done:s,value:r}=t.next();if(s)break;const[i,o]=r,[a]=i.split("_");a===n&&e.push(o)}return e}function TTt(n){const{kernelName:t}=n;b$.has(t)&&bn().getBool("DEBUG")&&Id(`Overriding the gradient for '${t}'`),b$.set(t,n)}function CTt(n,t){return`${t}_${n}`}function ETt(n,t){return n instanceof Float32Array&&t==="float32"||n instanceof Int32Array&&t==="int32"||n instanceof Uint8Array&&t==="bool"}function h5(n,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Gv(n)),bn().getBool("DEBUG")&&sIt(n,t),ETt(n,t))return n;if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool"){const e=new Uint8Array(n.length);for(let s=0;s<e.length;++s)Math.round(n[s])!==0&&(e[s]=1);return e}else throw new Error(`Unknown data type ${t}`)}function xo(){return bn().platform.now()}function $Tt(n,t="utf-8"){return t=t||"utf-8",bn().platform.encode(n,t)}function g3(n,t="utf-8"){return t=t||"utf-8",bn().platform.decode(n,t)}class ATt{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new _Tt)}profileKernel(t,e,s){let r;const i=()=>{r=s()};let o;const a=xo();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of r)c.dataSync();o=Promise.resolve({kernelMs:xo()-a})}if(bn().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<r.length;c++){const f=r[c];f.data().then(d=>{kTt(d,f.dtype,t)})}return{kernelName:t,outputs:r,inputs:e,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:s,timeMs:r,inputs:i,extraInfo:o}=t;s.forEach(a=>{Promise.all([a.data(),r,o]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],i,l[2])})})}}function kTt(n,t,e){if(t!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${e}'`),!0}return!1}let _Tt=class{logKernelProfile(t,e,s,r,i,o){const a=typeof r=="number"?W1(`${r}ms`,9):r.error,l=W1(t,25),c=e.rank,f=e.size,d=W1(e.shape.toString(),14);let m="";for(const y in i){const b=i[y];if(b!=null){const w=b.shape||e.shape,x=w.length;m+=`${y}: ${x}D ${x>0?w:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${d}	%c${f}	%c${m}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function NTt(n,t,e){const s={},r={};for(let l=0;l<t.length;l++)s[t[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],f=c.inputs;for(const d in f){const m=f[d];let y=!1;for(let b=0;b<t.length;b++)if(s[m.id]){c.outputs.forEach(w=>s[w.id]=!0),y=!0,r[c.id]=!0;break}if(y)break}}const i={};i[e.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],f=c.inputs;for(let d=0;d<c.outputs.length;d++)if(i[c.outputs[d].id]){for(const m in f)i[f[m].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(r[c.id]&&o[c.id]){const f={};for(const m in c.inputs){const y=c.inputs[m];s[y.id]&&(f[m]=y)}const d=Object.assign({},c);d.inputs=f,d.outputs=c.outputs,a.push(d)}}return a}function RTt(n,t,e,s){for(let r=t.length-1;r>=0;r--){const i=t[r],o=[];if(i.outputs.forEach(l=>{const c=n[l.id];c!=null?o.push(c):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=e(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const f=i.inputs[l];if(!ci(c.shape,f.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${f.shape}'`);if(n[f.id]==null)n[f.id]=c;else{const d=n[f.id];n[f.id]=s(d,c),d.dispose()}}}}const y3=20,Jm=3,rC=7;function DTt(n,t,e,s){const r=Jk(t),i=OTt(n,t,e,r),o=t.length,a=q1(n,t,e,r,i),l=["Tensor"];return s&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${o}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function OTt(n,t,e,s){const r=oi(t),i=s[s.length-1],o=new Array(i).fill(0),a=t.length,l=e==="complex64"?lg(n):n;if(a>1)for(let c=0;c<r/i;c++){const f=c*i;for(let d=0;d<i;d++)o[d]=Math.max(o[d],ag(l[f+d],0,e).length)}return o}function ag(n,t,e){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(rC))} + ${parseFloat(n[1].toFixed(rC))}j`:Qk(n)?s=`'${n}'`:e==="bool"?s=f5(n):s=parseFloat(n.toFixed(rC)).toString(),W1(s,t)}function f5(n){return n===0?"false":"true"}function q1(n,t,e,s,r,i=!0){const o=e==="complex64"?2:1,a=t[0],l=t.length;if(l===0){if(e==="complex64"){const w=lg(n);return[ag(w[0],0,e)]}return e==="bool"?[f5(n[0])]:[n[0].toString()]}if(l===1){if(a>y3){const x=Jm*o;let S=Array.from(n.slice(0,x)),T=Array.from(n.slice((a-Jm)*o,a*o));return e==="complex64"&&(S=lg(S),T=lg(T)),["["+S.map(($,E)=>ag($,r[E],e)).join(", ")+", ..., "+T.map(($,E)=>ag($,r[a-Jm+E],e)).join(", ")+"]"]}return["["+(e==="complex64"?lg(n):Array.from(n)).map((x,S)=>ag(x,r[S],e)).join(", ")+"]"]}const c=t.slice(1),f=s.slice(1),d=s[0]*o,m=[];if(a>y3){for(let w=0;w<Jm;w++){const x=w*d,S=x+d;m.push(...q1(n.slice(x,S),c,e,f,r,!1))}m.push("...");for(let w=a-Jm;w<a;w++){const x=w*d,S=x+d;m.push(...q1(n.slice(x,S),c,e,f,r,w===a-1))}}else for(let w=0;w<a;w++){const x=w*d,S=x+d;m.push(...q1(n.slice(x,S),c,e,f,r,w===a-1))}const y=l===2?",":"";m[0]="["+m[0]+y;for(let w=1;w<m.length-1;w++)m[w]=" "+m[w]+y;let b=`,
`;for(let w=2;w<l;w++)b+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(i?"":b),m}function lg(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class FTt{constructor(t,e,s){if(this.dtype=e,this.shape=t.slice(),this.size=oi(t),s!=null){const r=s.length;Q(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||nIt(e,this.size),this.strides=Jk(t)}set(t,...e){e.length===0&&(e=[0]),Q(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const s=this.locToIndex(e);this.values[s]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(const r of t){if(r<0||r>=this.shape[e]){const i=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(i)}e++}let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=this.strides[r]*t[r];return this.values[s]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let s=0;s<t.length-1;++s)e+=this.strides[s]*t[s];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const e=new Array(this.shape.length);for(let s=0;s<e.length-1;++s)e[s]=Math.floor(t/this.strides[s]),t-=e[s]*this.strides[s];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Ko().makeTensor(this.values,this.shape,this.dtype)}}let Ko=null,Td=null;function MTt(n){Ko=n}function LTt(n){Td=n}class Zn{constructor(t,e,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=oi(t),this.strides=Jk(t),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Td.buffer(this.shape,this.dtype,t)}bufferSync(){return Td.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return u3(this.shape,t,this.dtype==="complex64")}arraySync(){return u3(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=Ko().read(this.dataId);if(this.dtype==="string"){const e=await t;try{return e.map(s=>g3(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Ko().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Ko().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>g3(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Ko().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Ko().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Td.print(this,t)}clone(){return this.throwIfDisposed(),Td.clone(this)}toString(t=!1){const e=this.dataSync();return DTt(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Td.cast(this,t)}variable(t=!0,e,s){return this.throwIfDisposed(),Ko().makeVariable(this,t,e,s)}}Object.defineProperty(Zn,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function zTt(){return n_("Tensor",()=>Zn)}zTt();class _x extends Zn{constructor(t,e,s,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!ci(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Ko().disposeTensor(this),this.dataId=t.dataId,Ko().incRef(this,null)}dispose(){Ko().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(_x,Symbol.hasInstance,{value:n=>n instanceof Zn&&n.assign!=null&&n.assign instanceof Function});var b3;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(b3||(b3={}));var x$;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(x$||(x$={}));var w$;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(w$||(w$={}));var v$;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(v$||(v$={}));var S$;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(S$||(S$={}));const BTt={float32:v$,int32:x$,bool:w$,complex64:S$};function PTt(n,t){if(n==="string"||t==="string"){if(n==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return BTt[n][t]}function xr(n,t){if(n.dtype===t.dtype)return[n,t];const e=PTt(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function a_(n,t){return t.some(e=>e.id===n.id)}function pc(n){const t=[];return d5(n,t,new Set),t}function d5(n,t,e){if(n==null)return;if(n instanceof Zn){t.push(n);return}if(!VTt(n))return;const s=n;for(const r in s){const i=s[r];e.has(i)||(e.add(i),d5(i,t,e))}}function VTt(n){return Array.isArray(n)||typeof n=="object"}function iC(n){return n.kernelName!=null}class x3{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class tp{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new x3}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,s=1){return t in this.registryFactory?(Id(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:e,asyncInit:s}=this.initializeBackend(t);if(!(s?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new ATt(this.backendInstance),!0}setupRegisteredKernels(){m3(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){m3(t).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const s=e.factory();if(s&&!(s instanceof ZSt)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(o=>r<this.pendingBackendInitId?!1:(this.registry[t]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Id(`Initialization of backend ${t} failed`),Id(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return Id(`Initialization of backend ${t} failed`),Id(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const s=this.state.tensorInfo.get(e),r=s.backend,i=this.readSync(e),o=r.refCount(e);r.disposeData(e,!0),s.backend=t,t.move(e,i,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let s=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=e(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,e,s){t();try{const r=s();return e(),r}catch(r){throw e(),r}}nextTensorId(){return tp.nextTensorId++}nextVariableId(){return tp.nextVariableId++}clone(t){const e=Et.runKernel(i_,{x:t}),s={x:t},r=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return Et.runKernel(r_,l,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[e],r,i,{}),e}runKernel(t,e,s){if(this.backendName==null&&this.backend,!(d3(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,s){const r=this.backend.numDataIds();let i=0;s.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-e-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)}runKernelFunc(t){let e,s=[];const r=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=iC(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(iC(t)){const{kernelName:b,inputs:w,attrs:x}=t;this.backendName==null&&this.backend;const S=d3(b,this.backendName);Q(S!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),a=()=>{const T=this.backend.numDataIds();l=S.kernelFunc({inputs:w,attrs:x,backend:this.backend});const $=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,T,$);const E=$.map(R=>R.rank!=null?R:this.makeTensorFromTensorInfo(R));if(r){const R=this.getTensorsForGradient(b,w,E);s=this.saveTensorsForBackwardMode(R)}return E}}else{const{forwardFunc:b}=t,w=x=>{r&&(s=x.map(S=>this.keep(this.clone(S))))};a=()=>{const x=this.backend.numDataIds();l=this.tidy(()=>b(this.backend,w));const S=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,x,S),S}}const{inputs:f,attrs:d}=t,m=iC(t)?null:t.backwardsFunc;let y;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=a():(y=this.profiler.profileKernel(c,f,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(y),e=y.outputs)}),r&&this.addTapeNode(c,f,e,m,s,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(f).map(b=>f[b]!=null?f[b].shape:null),outputShapes:e.map(b=>b.shape),kernelTimeMs:y.timeMs,extraInfo:y.extraInfo}),Array.isArray(l)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,e,s){const r=p3(t);if(r!=null){const i=r.inputsToSave||[],o=r.outputsToSave||[];let a;r.saveAllInputs?(Q(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(e).map(c=>e[c])):a=i.map(c=>e[c]);const l=s.filter((c,f)=>o[f]);return a.concat(l)}return[]}makeTensor(t,e,s,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=t;s==="string"&&Qk(t[0])&&(i=t.map(l=>$Tt(l)));const o=r.write(i,e,s),a=new Zn(e,s,o,this.nextTensorId());if(this.trackTensor(a,r),s==="string"){const l=this.state.tensorInfo.get(o),c=iIt(i);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(t,e,s,r){s=s||"float32";const i={dataId:t,shape:e,dtype:s};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(t,e){const{dataId:s,shape:r,dtype:i}=t,o=new Zn(r,i,s,this.nextTensorId());return this.trackTensor(o,e),o}makeVariable(t,e=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));const i=new _x(t,e,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*l3(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof _x||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const s=t.size*l3(t.dtype);this.state.numBytes-=s}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,s,r,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:s,saved:i},l=p3(t);l!=null&&(r=l.gradFunc),r!=null&&(a.gradient=c=>(c=c.map((f,d)=>{if(f==null){const m=s[d],y=t_(m.size,m.dtype);return this.makeTensor(y,m.shape,m.dtype)}return f}),r(c.length>1?c:c[0],i,o))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=pc(t),s=new Set(e.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!s.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(t,e,s,r=!1){if(Q(e.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));Q(i instanceof Zn,()=>"The result y returned by f() must be a tensor.");const o=NTt(this.state.activeTape,e,i);if(!r&&o.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=s??UTt(i.shape),RTt(a,o,c=>this.tidy(c),GTt);const l=e.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const f of c.saved)f.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(t){return Q(y$(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{Q(e.every(a=>a instanceof Zn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};e.forEach((a,l)=>{r[l]=a});const i=(a,l)=>(s=t(...e,l),Q(s.value instanceof Zn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Q(y$(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(a,l)=>{const c=s.gradFunc(a,l),f=Array.isArray(c)?c:[c];Q(f.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Q(f.every(m=>m instanceof Zn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return f.forEach((m,y)=>{d[y]=()=>m}),d};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=xo(),s=await this.backend.time(t);return s.wallMs=xo()-e,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new x3;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}tp.nextTensorId=0;tp.nextVariableId=0;function UTt(n){const t=jW(oi(n),"float32");return Et.makeTensor(t,n,"float32")}function p5(){const n=KW();if(n._tfengine==null){const t=new aIt(n);n._tfengine=new tp(t)}return hIt(n._tfengine.ENV),MTt(()=>n._tfengine),n._tfengine}const Et=p5();function GTt(n,t){const e={a:n,b:t};return Et.runKernel(s_,e)}function WTt(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const ki=bn();ki.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ki.registerFlag("IS_BROWSER",()=>WTt());ki.registerFlag("IS_NODE",()=>typeof Un<"u"&&typeof Un.versions<"u"&&typeof Un.versions.node<"u");ki.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ki.registerFlag("PROD",()=>!1);ki.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ki.getBool("DEBUG"));ki.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ki.registerFlag("IS_TEST",()=>!1);ki.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);ki.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ki.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);ki.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ki.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Op(n,t){let e=n;if(ca(n))return t==="string"?[]:[n.length];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(e)||ca(e)&&t!=="string";)s.push(e.length),e=e[0];return Array.isArray(n)&&bn().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&m5(n,s,[]),s}function m5(n,t,e){if(e=e||[],!Array.isArray(n)&&!ca(n)){Q(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}Q(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),Q(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const s=t.slice(1);for(let r=0;r<n.length;++r)m5(n[r],s,e.concat(r))}function w3(n,t,e,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==t||n==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${s}' must be ${n} tensor, but got ${t} tensor`)}}function dt(n,t,e,s="numeric"){if(n instanceof Zn)return w3(s,n.dtype,t,e),n;let r=Zk(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),w3(s,r,t,e),n==null||!ca(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${l}'`)}const i=Op(n,r);!ca(n)&&!Array.isArray(n)&&(n=[n]);const a=r!=="string"?h5(n,r):Gv(n,[],!0);return Et.makeTensor(a,i,r)}function g5(n,t,e,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>dt(i,`${t}[${o}]`,e,s))}const jTt="__op";function Ft(n){const t=Object.keys(n);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const s=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+jTt;const r=(...i)=>{Et.startScope(e);try{const o=s(...i);return e_(o)&&console.error("Cannot return a Promise inside of tidy."),Et.endScope(o),o}catch(o){throw Et.endScope(null),o}};return Object.defineProperty(r,"name",{value:e,configurable:!0}),r}function qTt(n,t){const e=dt(n,"real","complex"),s=dt(t,"imag","complex");tIt(e.shape,s.shape,`real and imag shapes, ${e.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:e,imag:s};return Et.runKernel(kIt,r)}const Wv=Ft({complex_:qTt});function Fp(n,t,e,s){if(s==null&&(s=Zk(n)),s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!ca(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){qW(t);const r=oi(t),i=oi(e);Q(r===i,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${i}`);for(let o=0;o<e.length;++o){const a=e[o],l=o===e.length-1?a!==oi(t.slice(o)):!0;Q(e[o]===t[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!ca(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n=s!=="string"?h5(n,s):Gv(n,[],!0),Et.makeTensor(n,t,s)}function zd(n,t,e){const s=Op(n,e);return Fp(n,t,s,e)}const v3={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Nx=4;async function S3(n,t){const e=[],s=[],r=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<r.length;++o){const a=r[o],l=Array.isArray(n)?n[o].tensor:n[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const f=new Promise(async d=>{const m=await l.bytes(),y=m.reduce((x,S)=>x+S.length,0)+Nx*m.length,b=new Uint8Array(y);let w=0;for(let x=0;x<m.length;x++){const S=m[x],T=new Uint8Array(new Uint32Array([S.length]).buffer);b.set(T,w),w+=Nx,b.set(S,w),w+=S.length}d(b)});s.push(f)}else s.push(l.data());t!=null&&(c.group=t),e.push(c)}const i=await Promise.all(s);return{data:KTt(i),specs:e}}function HTt(n,t){const e={};let s,r=0;for(const i of t){const o=i.name,a=i.dtype,l=i.shape,c=oi(l);let f;if("quantization"in i){const d=i.quantization;if(d.dtype==="uint8"||d.dtype==="uint16"){if(!("min"in d&&"scale"in d))throw new Error(`Weight ${i.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else if(d.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${i.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${i.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const m=v3[d.dtype],y=n.slice(r,r+c*m),b=d.dtype==="uint8"?new Uint8Array(y):new Uint16Array(y);if(a==="float32")if(d.dtype==="uint8"||d.dtype==="uint16"){f=new Float32Array(b.length);for(let w=0;w<b.length;w++){const x=b[w];f[w]=x*d.scale+d.min}}else if(d.dtype==="float16")s===void 0&&(s=rCt()),f=s(b);else throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);else if(a==="int32"){if(d.dtype!=="uint8"&&d.dtype!=="uint16")throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);f=new Int32Array(b.length);for(let w=0;w<b.length;w++){const x=b[w];f[w]=Math.round(x*d.scale+d.min)}}else throw new Error(`Unsupported dtype in weight '${o}': ${a}`);r+=c*m}else if(a==="string"){const d=oi(i.shape);f=[];for(let m=0;m<d;m++){const y=new Uint32Array(n.slice(r,r+Nx))[0];r+=Nx;const b=new Uint8Array(n.slice(r,r+y));f.push(b),r+=y}}else{const d=v3[a],m=n.slice(r,r+c*d);if(a==="float32")f=new Float32Array(m);else if(a==="int32")f=new Int32Array(m);else if(a==="bool")f=new Uint8Array(m);else if(a==="complex64"){f=new Float32Array(m);const y=new Float32Array(f.length/2),b=new Float32Array(f.length/2);for(let S=0;S<y.length;S++)y[S]=f[S*2],b[S]=f[S*2+1];const w=zd(y,l,"float32"),x=zd(b,l,"float32");e[o]=Wv(w,x),w.dispose(),x.dispose()}else throw new Error(`Unsupported dtype in weight '${o}': ${a}`);r+=c*d}a!=="complex64"&&(e[o]=zd(f,l,a))}return e}function KTt(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(i=>{if(t+=i.byteLength,e.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(t);let r=0;return e.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const l_=typeof ou<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function I3(n){return l_?ou.byteLength(n):new Blob([n]).size}function XTt(n){if(l_)return ou.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let s=0,r=t.length;s<r;s++)e+=String.fromCharCode(t[s]);return btoa(e)}function YTt(n){if(l_){const s=ou.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let s=0;s<t.length;++s)e.set([t.charCodeAt(s)],s);return e.buffer}function y5(n){if(n.length===1)return n[0];let t=0;n.forEach(r=>{t+=r.byteLength});const e=new Uint8Array(t);let s=0;return n.forEach(r=>{e.set(new Uint8Array(r),s),s+=r.byteLength}),e.buffer}function QTt(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return n.signature!=null&&(e.signature=n.signature),n.userDefinedMetadata!=null&&(e.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(e.modelInitializer=n.modelInitializer),n.trainingConfig!=null&&(e.trainingConfig=n.trainingConfig),e}function ZTt(n,t,e){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=t,s.weightData=e}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),s}async function JTt(n,t){let e,s;return n.weightsManifest!=null&&([e,s]=await t(n.weightsManifest)),ZTt(n,e,s)}function u_(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:I3(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:I3(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:n.weightData.byteLength}}function tCt(n){const t=[];for(const e of n)t.push(...e.weights);return t}function eCt(){const n=e=>{let s=e<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function nCt(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}function sCt(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}function rCt(){const n=eCt(),t=nCt(),e=sCt();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let o=0;o<s.length;o++){const a=s[o],l=n[e[a>>10]+(a&1023)]+t[a>>10];i[o]=l}return new Float32Array(r)}}class er{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return er.instance==null&&(er.instance=new er),er.instance}static registerSaveRouter(t){er.getInstance().saveRouters.push(t)}static registerLoadRouter(t){er.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return er.getHandlers(t,"save")}static getLoadHandlers(t,e){return er.getHandlers(t,"load",e)}static getHandlers(t,e,s){const r=[];return(e==="load"?er.getInstance().loadRouters:er.getInstance().saveRouters).forEach(o=>{const a=o(t,s);a!==null&&r.push(a)}),r}}const iCt=n=>er.getSaveHandlers(n),oCt=(n,t)=>er.getLoadHandlers(n,t);const I$="tensorflowjs",T$=1,Ch="models_store",Ku="model_info_store";function b5(){if(!bn().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function C$(n){const t=n.result;t.createObjectStore(Ch,{keyPath:"modelPath"}),t.createObjectStore(Ku,{keyPath:"modelPath"})}class Qh{constructor(t){if(this.indexedDB=b5(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((s,r)=>{const i=this.indexedDB.open(I$,T$);i.onupgradeneeded=()=>C$(i),i.onsuccess=()=>{const o=i.result;if(e==null){const a=o.transaction(Ch,"readonly"),c=a.objectStore(Ch).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=f=>(o.close(),r(c.error)),a.oncomplete=()=>o.close()}else{const a=u_(e),l=o.transaction(Ku,"readwrite");let c=l.objectStore(Ku);const f=c.put({modelPath:this.modelPath,modelArtifactsInfo:a});let d;f.onsuccess=()=>{d=o.transaction(Ch,"readwrite");const y=d.objectStore(Ch).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:a});y.onsuccess=()=>s({modelArtifactsInfo:a}),y.onerror=b=>{c=l.objectStore(Ku);const w=c.delete(this.modelPath);w.onsuccess=()=>(o.close(),r(y.error)),w.onerror=x=>(o.close(),r(y.error))}},f.onerror=m=>(o.close(),r(f.error)),l.oncomplete=()=>{d==null?o.close():d.oncomplete=()=>o.close()}}},i.onerror=o=>r(i.error)})}}Qh.URL_SCHEME="indexeddb://";const x5=n=>bn().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Qh.URL_SCHEME)?aCt(n.slice(Qh.URL_SCHEME.length)):null;er.registerSaveRouter(x5);er.registerLoadRouter(x5);function aCt(n){return new Qh(n)}function lCt(n){return n.startsWith(Qh.URL_SCHEME)?n.slice(Qh.URL_SCHEME.length):n}class uCt{constructor(){this.indexedDB=b5()}async listModels(){return new Promise((t,e)=>{const s=this.indexedDB.open(I$,T$);s.onupgradeneeded=()=>C$(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(Ku,"readonly"),a=i.objectStore(Ku).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;t(l)},a.onerror=l=>(r.close(),e(a.error)),i.oncomplete=()=>r.close()},s.onerror=r=>e(s.error)})}async removeModel(t){return t=lCt(t),new Promise((e,s)=>{const r=this.indexedDB.open(I$,T$);r.onupgradeneeded=()=>C$(r),r.onsuccess=()=>{const i=r.result,o=i.transaction(Ku,"readwrite"),a=o.objectStore(Ku),l=a.get(t);let c;l.onsuccess=()=>{if(l.result==null)return i.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const f=a.delete(t),d=()=>{c=i.transaction(Ch,"readwrite");const y=c.objectStore(Ch).delete(t);y.onsuccess=()=>e(l.result.modelArtifactsInfo),y.onerror=b=>s(l.error)};f.onsuccess=d,f.onerror=m=>(d(),i.close(),s(l.error))}},l.onerror=f=>(i.close(),s(l.error)),o.oncomplete=()=>{c==null?i.close():c.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}}const Gl="/",Cd="tensorflowjs_models",w5="info",cCt="model_topology",hCt="weight_specs",fCt="weight_data",dCt="model_metadata";function v5(n){return{info:[Cd,n,w5].join(Gl),topology:[Cd,n,cCt].join(Gl),weightSpecs:[Cd,n,hCt].join(Gl),weightData:[Cd,n,fCt].join(Gl),modelMetadata:[Cd,n,dCt].join(Gl)}}function S5(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function pCt(n){const t=n.split(Gl);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(Gl)}function mCt(n){return n.startsWith(Zh.URL_SCHEME)?n.slice(Zh.URL_SCHEME.length):n}class Zh{constructor(t){if(!bn().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=v5(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),r=u_(t);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,XTt(t.weightData));const i={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:r}}catch{throw S5(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const a=JSON.parse(i);e.format=a.format,e.generatedBy=a.generatedBy,e.convertedBy=a.convertedBy,a.signature!=null&&(e.signature=a.signature),a.userDefinedMetadata!=null&&(e.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(e.modelInitializer=a.modelInitializer),a.trainingConfig!=null&&(e.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=YTt(o),e}}Zh.URL_SCHEME="localstorage://";const I5=n=>bn().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Zh.URL_SCHEME)?gCt(n.slice(Zh.URL_SCHEME.length)):null;er.registerSaveRouter(I5);er.registerLoadRouter(I5);function gCt(n){return new Zh(n)}class yCt{constructor(){Q(bn().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Q(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=Cd+Gl,s=Gl+w5;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(e)&&i.endsWith(s)){const o=pCt(i);t[o]=JSON.parse(this.LS.getItem(i))}}return t}async removeModel(t){t=mCt(t);const e=v5(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(this.LS.getItem(e.info));return S5(e),s}}const T3="://";class Ga{constructor(){this.managers={}}static getInstance(){return Ga.instance==null&&(Ga.instance=new Ga),Ga.instance}static registerManager(t,e){Q(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(T3)&&(t=t.slice(0,t.indexOf(T3))),Q(t.length>0,()=>"scheme must not be an empty string.");const s=Ga.getInstance();Q(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=e}static getManager(t){const e=Ga.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(Ga.getInstance().managers)}}class bCt{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){if(!window||!bn().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,e);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}}if(bn().get("IS_BROWSER")){bn().setPlatform("browser",new bCt);try{Ga.registerManager(Zh.URL_SCHEME,new yCt)}catch{}try{Ga.registerManager(Qh.URL_SCHEME,new uCt)}catch{}}const xCt={importFetch:()=>require("node-fetch")};let oC;class wCt{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return bn().global.fetch!=null?bn().global.fetch(t,e):(oC==null&&(oC=xCt.importFetch()),oC(t,e))}now(){const t=Un.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}}bn().get("IS_NODE")&&!bn().get("IS_BROWSER")&&bn().setPlatform("node",new wCt);function yb(n,t="float32",e){return t=t||"float32",qW(n),new FTt(n,t,e)}function vCt(n,t){const e=dt(n,"x","cast");if(!rIt(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:e},r={dtype:t};return Et.runKernel(r_,s,r)}const le=Ft({cast_:vCt});function SCt(n){const e={x:dt(n,"x","clone","string_or_numeric")};return Et.runKernel(i_,e)}const Nh=Ft({clone_:SCt});function ICt(n,t=!1){console.log(n.toString(t))}p5();const TCt={buffer:yb,cast:le,clone:Nh,print:ICt};LTt(TCt);function C3(n,t,e,s){o(n),e=e??0,s=s??1,a(e,s);let r=0;const i=l=>(l.then(c=>{const f=e+ ++r/n.length*(s-e);return t(f),c}),l);function o(l){Q(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){Q(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),Q(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),Q(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(n.map(i))}async function CCt(n,t){t==null&&(t={});const e=t.fetchFunc==null?bn().platform.fetch:t.fetchFunc,s=n.map(d=>e(d,t.requestInit,{isBinary:!0})),a=(t.onProgress==null?await Promise.all(s):await C3(s,t.onProgress,0,.5)).map(d=>d.arrayBuffer());return t.onProgress==null?await Promise.all(a):await C3(a,t.onProgress,.5,1)}const ECt="application/octet-stream",$Ct="application/json";class c_{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(Q(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=bn().platform.fetch,Q(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&Q(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r=QTt(t,s);e.body.append("model.json",new Blob([JSON.stringify(r)],{type:$Ct}),"model.json"),t.weightData!=null&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:ECt}),"model.weights.bin");const i=await this.fetch(this.path,e);if(i.ok)return{modelArtifactsInfo:u_(t),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const s=e.modelTopology,r=e.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return JTt(e,i=>this.loadWeights(i))}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=ACt(e),i=this.weightPathPrefix||s,o=tCt(t),a=[],l=[];for(const f of t)for(const d of f.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(d)):a.push(i+d+r);this.weightUrlConverter&&a.push(...await Promise.all(l));const c=await CCt(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,y5(c)]}}c_.URL_SCHEME_REGEX=/^https?:\/\//;function ACt(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?"),s=n.substring(0,t),r=e>t?n.substring(e):"";return[s+"/",r]}function E3(n){return n.match(c_.URL_SCHEME_REGEX)!=null}const T5=(n,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(n)?e=n.every(s=>E3(s)):e=E3(n),e)return C5(n,t)}return null};er.registerSaveRouter(T5);er.registerLoadRouter(T5);function C5(n,t){return new c_(n,t)}function kCt(n,t){return C5(n,t)}class aC{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class _Ct{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function NCt(n,t,e,s){const r=arguments;return new _Ct(RCt(...r))}function RCt(n,t,e,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new aC(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new aC({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new aC({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:s}))}function DCt(n,t,e=!1,s=!1){let r=dt(n,"a","matMul"),i=dt(t,"b","matMul");[r,i]=xr(r,i);const o={a:r,b:i},a={transposeA:e,transposeB:s};return Et.runKernel(JW,o,a)}const Vn=Ft({matMul_:DCt});function OCt(n,t,e=1,s=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:dt(n,"indices","oneHot","int32")},a={dtype:r,depth:t,onValue:e,offValue:s};return Et.runKernel(Dj,o,a)}const H1=Ft({oneHot_:OCt});function $3(){return Et.memory()}function St(n,t){return Et.tidy(n,t)}function Ee(n){pc(n).forEach(e=>e.dispose())}function gl(n){return Et.keep(n)}function h_(){return Et.backend}function FCt(n){const e={input:dt(n,"input","imag")};return Et.runKernel(HIt,e)}const MCt=Ft({imag_:FCt});function LCt(n){const e={x:dt(n,"x","neg")};return Et.runKernel(Nj,e)}const Lr=Ft({neg_:LCt});function zCt(n){const e={input:dt(n,"input","real")};return Et.runKernel(pTt,e)}const BCt=Ft({real_:zCt});function PCt(n,t,e){const s=dt(n,"x","transpose");if(t==null&&(t=s.shape.map((o,a)=>a).reverse()),Q(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`),t.forEach(o=>{Q(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:t};return s.dtype==="complex64"?St(()=>{let o=BCt(s),a=MCt(s);return o=Et.runKernel(j1,{x:o},i),a=Et.runKernel(j1,{x:a},i),e&&(a=Lr(a)),Wv(o,a)}):Et.runKernel(j1,r,i)}const nn=Ft({transpose_:PCt});function lr(n,t){const e=[];for(let s=0;s<t.length;s++){const r=n[n.length-s-1],i=t.length-s-1,o=t[i];(r==null||r===1&&o>1)&&e.unshift(i)}return e}function fs(n,t){const e=[],s=Math.max(n.length,t.length);for(let r=0;r<s;r++){let i=n[n.length-r-1];i==null&&(i=1);let o=t[t.length-r-1];if(o==null&&(o=1),i===1)e.unshift(o);else if(o===1)e.unshift(i);else if(i!==o){const a=`Operands could not be broadcast together with shapes ${n} and ${t}.`;throw Error(a)}else e.unshift(i)}return e}function lC(n,t,e){if(Uv(n),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Op(n,e);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Fp(n,t,s,e)}function VCt(n,t,e){let s;const r=n.shape.length;typeof t=="number"?s=[t,...new Array(r-1).fill(0)]:t.length<r?s=t.concat(new Array(r-t.length).fill(0)):s=t.slice(),s.forEach(o=>{Q(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return e==null?i=new Array(r).fill(-1):typeof e=="number"?i=[e,...new Array(r-1).fill(-1)]:e.length<r?i=e.concat(new Array(r-e.length).fill(-1)):i=e,i=i.map((o,a)=>o>=0?o:(Q(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-s[a])),[s,i]}class Mp{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class go{constructor(){this.classNameMap={}}static getMap(){return go.instance==null&&(go.instance=new go),go.instance}static register(t){go.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function Kt(n){Q(n.className!=null,()=>"Class being registered does not have the static className property defined."),Q(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),Q(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),go.register(n)}function UCt(n,t){let e=dt(n,"a","add"),s=dt(t,"b","add");[e,s]=xr(e,s);const r={a:e,b:s};return Et.runKernel(s_,r)}const Qt=Ft({add_:UCt});function GCt(n,t){let e=dt(n,"a","floorDiv"),s=dt(t,"b","floorDiv");[e,s]=xr(e,s);const r={a:e,b:s};return Et.runKernel(gj,r)}const WCt=Ft({floorDiv_:GCt});function jCt(n,t){let e=dt(n,"a","div"),s=dt(t,"b","div");if([e,s]=xr(e,s),e.dtype==="int32"&&s.dtype==="int32")return WCt(e,s);const r={a:e,b:s},i={};return Et.runKernel(hj,r,i)}const we=Ft({div_:jCt});function qCt(n,t){let e=dt(n,"a","mul"),s=dt(t,"b","mul");[e,s]=xr(e,s);const r={a:e,b:s};return Et.runKernel(_j,r)}const mt=Ft({mul_:qCt});function HCt(n){const t=dt(n,"x","abs");if(t.dtype==="complex64"){const e={x:t};return Et.runKernel(nj,e)}else{const e={x:t};return Et.runKernel(XW,e)}}const Jr=Ft({abs_:HCt});function KCt(n,t=null,e=!1){const r={x:dt(n,"x","all","bool")},i={axis:t,keepDims:e};return Et.runKernel(gIt,r,i)}const XCt=Ft({all_:KCt});function YCt(n,t=null,e=!1){const r={x:dt(n,"x","any","bool")},i={axis:t,keepDims:e};return Et.runKernel(yIt,r,i)}const A3=Ft({any_:YCt});function QCt(n,t=0){const s={x:dt(n,"x","argMax")},r={axis:t};return Et.runKernel(YW,s,r)}const ep=Ft({argMax_:QCt});function ZCt(n,t,e,s,r,i,o=!1,a="channelsLast"){let[l,c,f,d]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,f,d]=n;else if(a==="channelsFirst")[l,d,c,f]=n;else throw new Error(`Unknown dataFormat ${a}`);const[m,y,,b]=t,[w,x]=E$(e),[S,T]=E$(s),$=$$(m,S),E=$$(y,T),{padInfo:R,outHeight:B,outWidth:N}=eEt(r,c,f,w,x,$,E,i,a),k=o?b*d:b;let _;return a==="channelsFirst"?_=[l,k,B,N]:a==="channelsLast"&&(_=[l,B,N,k]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:f,inChannels:d,outHeight:B,outWidth:N,outChannels:k,padInfo:R,strideHeight:w,strideWidth:x,filterHeight:m,filterWidth:y,effectiveFilterHeight:$,effectiveFilterWidth:E,dilationHeight:S,dilationWidth:T,inShape:n,outShape:_,filterShape:t}}function JCt(n,t,e,s,r){s==null&&(s=tEt(n,t,e));const i=n[0],o=n[1],a=Rx((i-t+2*s)/e+1,r),l=Rx((o-t+2*s)/e+1,r);return[a,l]}function tEt(n,t,e,s=1){const r=$$(t,s);return Math.floor((n[0]*(e-1)-e+r)/2)}function E$(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function $$(n,t){return t<=1?n:n+(n-1)*(t-1)}function eEt(n,t,e,s,r,i,o,a,l){let c,f,d;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const y=JCt([t,e],i,s,n,a);f=y[0],d=y[1]}else if(n==="same"){f=Math.ceil(t/s),d=Math.ceil(e/r);const m=Math.max(0,(f-1)*s+i-t),y=Math.max(0,(d-1)*r+o-e),b=Math.floor(m/2),w=m-b,x=Math.floor(y/2),S=y-x;c={top:b,bottom:w,left:x,right:S,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},f=Math.ceil((t-i+1)/s),d=Math.ceil((e-o+1)/r);else if(typeof n=="object"){const m=l==="channelsLast"?n[1][0]:n[2][0],y=l==="channelsLast"?n[1][1]:n[2][1],b=l==="channelsLast"?n[2][0]:n[3][0],w=l==="channelsLast"?n[2][1]:n[3][1];c={top:m,bottom:y,left:b,right:w,type:m===0&&y===0&&b===0&&w===0?"VALID":"EXPLICIT"},f=Rx((t-i+m+y)/s+1,a),d=Rx((e-o+b+w)/r+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:f,outWidth:d}}function Rx(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function np(n){const[t,e,s]=E$(n);return t===1&&e===1&&s===1}function bf(n,t){return np(n)||np(t)}function Ni(n,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")Q(kx(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(s=>{s.forEach(r=>{Q(kx(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${t}`)}}function nEt(n,t){const s={x:dt(n,"x","reshape","string_or_numeric")},r={shape:t};return Et.runKernel(Bj,s,r)}const kt=Ft({reshape_:nEt});function sEt(n,t,e,s,r){const i=dt(n,"x","avgPool","float32"),o=1;Q(bf(e,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);let a=i,l=!1;i.rank===3&&(l=!0,a=kt(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Q(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Ni("avgPool",s,r);const c={x:a},f={filterSize:t,strides:e,pad:s,dimRoundingMode:r};let d=Et.runKernel(QW,c,f);return d=le(d,i.dtype),l?kt(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const rEt=Ft({avgPool_:sEt});function iEt(n,t,e,s,r,i="NDHWC"){const o=dt(n,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=kt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Q(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),Q(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Ni("avgPool3d",s,r);const c={x:a},f={filterSize:t,strides:e,pad:s,dimRoundingMode:r,dataFormat:i};let d=Et.runKernel(ZW,c,f);return d=le(d,a.dtype),l?kt(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const oEt=Ft({avgPool3d_:iEt});function aEt(n,t=0){Q(n.length>=1,()=>"Pass at least one tensor to concat");const e=g5(n,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),e.length===1)return Nh(e[0]);const s=e,r={axis:t};return Et.runKernel(sj,s,r)}const na=Ft({concat_:aEt});function lEt(n){const e={x:dt(n,"x","sigmoid","float32")};return Et.runKernel(Qj,e)}const jv=Ft({sigmoid_:lEt});function uEt(n,t,e){const s=dt(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:t,size:e};return Et.runKernel(Kj,r,i)}const Qn=Ft({slice_:uEt});function cEt(n){const e={x:dt(n,"x","tanh","float32")};return Et.runKernel(i5,e)}const E5=Ft({tanh_:cEt});function hEt(n,t,e){const s=dt(n,"x","batchToSpaceND"),r=t.reduce((a,l)=>a*l);Q(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),Q(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),Q(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);const i={x:s},o={blockShape:t,crops:e};return Et.runKernel(tj,i,o)}const fEt=Ft({batchToSpaceND_:hEt});function dEt(n){let t;return n.rank===0||n.rank===1?t=kt(n,[1,1,1,n.size]):n.rank===2?t=kt(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?t=kt(n,[1,n.shape[0],n.shape[1],n.shape[2]]):t=n,t}function pEt(n,t,e,s,r,i){i==null&&(i=.001);const o=dt(n,"x","batchNorm"),a=dt(t,"mean","batchNorm"),l=dt(e,"variance","batchNorm");let c;r!=null&&(c=dt(r,"scale","batchNorm"));let f;s!=null&&(f=dt(s,"offset","batchNorm")),Q(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Q(f==null||a.rank===f.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Q(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const m={x:dEt(o),scale:c,offset:f,mean:a,variance:l},y={varianceEpsilon:i},b=Et.runKernel(yj,m,y);return kt(b,o.shape)}const f_=Ft({batchNorm_:pEt});function mEt(n,t,e,s,r,i){const o=dt(n,"x","batchNorm"),a=dt(t,"mean","batchNorm"),l=dt(e,"variance","batchNorm");let c;r!=null&&(c=dt(r,"scale","batchNorm"));let f;return s!=null&&(f=dt(s,"offset","batchNorm")),Q(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),Q(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),Q(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&Q(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),f!=null&&Q(f.rank===2||f.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${f.rank}.`),f_(o,a,l,f,c,i)}const gEt=Ft({batchNorm2d_:mEt});function yEt(n,t,e,s,r,i){const o=dt(n,"x","batchNorm"),a=dt(t,"mean","batchNorm"),l=dt(e,"variance","batchNorm");let c;r!=null&&(c=dt(r,"scale","batchNorm"));let f;return s!=null&&(f=dt(s,"offset","batchNorm")),Q(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),Q(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),Q(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&Q(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),f!=null&&Q(f.rank===3||f.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${f.rank}.`),f_(o,a,l,f,c,i)}const bEt=Ft({batchNorm3d_:yEt});function xEt(n,t,e,s,r,i){const o=dt(n,"x","batchNorm"),a=dt(t,"mean","batchNorm"),l=dt(e,"variance","batchNorm");let c;r!=null&&(c=dt(r,"scale","batchNorm"));let f;return s!=null&&(f=dt(s,"offset","batchNorm")),Q(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),Q(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),Q(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&Q(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),f!=null&&Q(f.rank===4||f.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${f.rank}.`),f_(o,a,l,f,c,i)}const wEt=Ft({batchNorm4d_:xEt});function vEt(n,t,e){const s=dt(n,"x","bincount"),r=dt(t,"weights","bincount");Q(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),Q(e>=0,()=>`size must be non-negative, but got ${e}.`),Q(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},o={size:e};return Et.runKernel(EIt,i,o)}const SEt=Ft({bincount_:vEt});function IEt(n,t){let e=dt(n,"broadcastTo","x");const s=e.shape;if(t.some(c=>!(c>0)||c%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const c=e.shape.slice();for(;c.length<t.length;)c.unshift(1);e=kt(e,c)}const r=e.shape,i=Array.from(t);for(let c=t.length-1;c>=0;c--)if(r[c]===t[c])i[c]=1;else if(e.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(i.map((c,f)=>c>1?f:-1).filter(c=>c>=0).length===0)return Nh(e);const a={x:e},l={reps:i};return Et.runKernel(o_,a,l)}const uC=Ft({broadcastTo_:IEt});function qv(n,t,e){const s={shape:n,value:t,dtype:e};return Et.runKernel(WIt,{},s)}function TEt(n,t,e){const s=dt(n,"x","clipByValue");if(Q(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e)return qv(s.shape,t,s.dtype);const r={x:s},i={clipValueMin:t,clipValueMax:e};return Et.runKernel(ej,r,i)}const To=Ft({clipByValue_:TEt});function CEt(n){return na(n,0)}const EEt=Ft({concat1d_:CEt});function $Et(n,t){return na(n,t)}const AEt=Ft({concat2d_:$Et});function kEt(n,t){return na(n,t)}const _Et=Ft({concat3d_:kEt});function NEt(n,t){return na(n,t)}const REt=Ft({concat4d_:NEt});function DEt(n,t,e,s,r="NHWC",i=[1,1],o){const a=dt(n,"x","conv2d","float32"),l=dt(t,"filter","conv2d","float32");let c=a,f=!1;a.rank===3&&(f=!0,c=kt(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Q(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),Q(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Ni("conv2d",s,o);const d=r==="NHWC"?c.shape[3]:c.shape[1];Q(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),Q(bf(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);const m={x:c,filter:l},y={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},b=Et.runKernel(rj,m,y);return f?kt(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const sp=Ft({conv2d_:DEt});function OEt(n,t,e,s,r="NWC",i=1,o){const a=dt(n,"x","conv1d"),l=dt(t,"filter","conv1d");let c=a,f=!1;a.rank===2&&(f=!0,c=kt(a,[1,a.shape[0],a.shape[1]])),Q(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),Q(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Ni("conv1d",s,o),Q(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),Q(bf(e,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${i}'`),Q(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const d=kt(l,[1,l.shape[0],l.shape[1],l.shape[2]]),m=kt(c,[c.shape[0],1,c.shape[1],c.shape[2]]),x=sp(m,d,[1,e],s,"NHWC",[1,i],o);return f?kt(x,[x.shape[2],x.shape[3]]):kt(x,[x.shape[0],x.shape[2],x.shape[3]])}const FEt=Ft({conv1d_:OEt});function MEt(n,t,e,s,r,i="NHWC",o){Q(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let a=n,l=t,c=!1;t.rank===3&&(c=!0,l=kt(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,n[0],n[1],n[2]]),Q(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),Q(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),Q(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const f=i==="NHWC"?a[3]:a[1],d=i==="NHWC"?l.shape[3]:l.shape[1];Q(f===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${f}) must match input depth for filter ${e.shape[2]}.`),Q(d===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`),Ni("conv2dDerInput",r,o);const m={dy:l,filter:e},y={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,inputShape:a},b=Et.runKernel(ij,m,y);return c?kt(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const d_=Ft({conv2DBackpropInput_:MEt});function LEt(n,t,e,s,r,i){const o=dt(n,"x","conv2dTranspose"),a=dt(t,"filter","conv2dTranspose");return d_(e,o,a,s,r,"NHWC",i)}const zEt=Ft({conv2dTranspose_:LEt});function BEt(n,t,e,s,r="NDHWC",i=[1,1,1]){const o=dt(n,"x","conv3d"),a=dt(t,"filter","conv3d");let l=o,c=!1;o.rank===4&&(c=!0,l=kt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Q(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),Q(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),Q(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),Q(bf(e,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),Q(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`);const f={x:l,filter:a},d={strides:e,pad:s,dataFormat:r,dilations:i},m=Et.runKernel(oj,f,d);return c?kt(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const PEt=Ft({conv3d_:BEt});function VEt(n,t,e,s,r){Q(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let i=n,o=t,a=!1;t.rank===4&&(a=!0,o=kt(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const l=i[4],c=o.shape[4];Q(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),Q(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),Q(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),Q(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),Q(c===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${e.shape[4]}.`);const f={dy:o,filter:e},d={pad:r,strides:s,inputShape:i},m=Et.runKernel(RIt,f,d);return a?kt(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const $5=Ft({conv3DBackpropInput_:VEt});function UEt(n,t,e,s,r){const i=dt(n,"x","conv3dTranspose"),o=dt(t,"filter","conv3dTranspose");return $5(e,i,o,s,r)}const GEt=Ft({conv3dTranspose_:UEt});function WEt(n){const e={x:dt(n,"x","cos","float32")};return Et.runKernel(aj,e)}const A5=Ft({cos_:WEt});function jEt(n){const e={x:dt(n,"x","cosh","float32")};return Et.runKernel(lj,e)}const qEt=Ft({cosh_:jEt});function HEt(n,t=0,e=!1,s=!1){const i={x:dt(n,"x","cumprod")},o={axis:t,exclusive:e,reverse:s};return Et.runKernel(DIt,i,o)}const k3=Ft({cumprod_:HEt});function KEt(n,t=0,e=!1,s=!1){const i={x:dt(n,"x","cumsum")},o={axis:t,exclusive:e,reverse:s};return Et.runKernel(uj,i,o)}const XEt=Ft({cumsum_:KEt});function YEt(n,t,e,s,r="NHWC",i=[1,1],o){const a=dt(n,"x","depthwiseConv2d","float32"),l=dt(t,"filter","depthwiseConv2d","float32");let c=a,f=!1;a.rank===3&&(f=!0,c=kt(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Q(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),Q(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d=r==="NHWC"?c.shape[3]:c.shape[1];Q(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),Ni("depthwiseConv2d",s,o);const m={x:c,filter:l},y={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},b=Et.runKernel(cj,m,y);return f?kt(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const k5=Ft({depthwiseConv2d_:YEt});function QEt(n,t){let e=dt(n,"a","equal","string_or_numeric"),s=dt(t,"b","equal","string_or_numeric");[e,s]=xr(e,s),fs(e.shape,s.shape);const r={a:e,b:s};return Et.runKernel(UIt,r)}const mc=Ft({equal_:QEt});function ZEt(n,t,e){const s=dt(t,"a","where"),r=dt(e,"b","where"),i=dt(n,"condition","where","bool"),o=fs(fs(i.shape,s.shape),r.shape),a=uC(i,o),l=uC(s,o),c=uC(r,o),f={condition:a,t:l,e:c};return Et.runKernel(qj,f)}const Co=Ft({where_:ZEt});function JEt(n){const e={x:dt(n,"x","zerosLike")};return Et.runKernel(l5,e)}const pn=Ft({zerosLike_:JEt});function t$t(n){const e={x:dt(n,"x","elu","float32")};return Et.runKernel(fj,e)}const p_=Ft({elu_:t$t});function e$t(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function n$t(n,t,e){const s=n.length+t.length,r=[];let i=0,o=0;for(let a=0;a<s;a++)e.indexOf(a)===-1?r.push(n[i++]):r.push(t[o++]);return r}function s$t(n,t){const e=[],s=n.length;for(let i=0;i<s;i++)t.indexOf(i)===-1&&e.push(n[i]);const r=t.map(i=>n[i]);return[e,r]}function Dx(n,t){const e=t.map(s=>1);return n$t(n,e,t)}function _5(n,t){if(e$t(n,t))return null;const e=[];for(let s=0;s<t;++s)n.indexOf(s)===-1&&e.push(s);return n.forEach(s=>e.push(s)),e}function m_(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function r$t(n,t=null,e=!1){const r={x:dt(n,"x","max")},i={reductionIndices:t,keepDims:e};return Et.runKernel(Ij,r,i)}const Hl=Ft({max_:r$t});function i$t(n,t=null,e=!1){const r={x:dt(n,"x","min")},i={axis:t,keepDims:e};return Et.runKernel(Aj,r,i)}const _3=Ft({min_:i$t});function o$t(n,t){let e=dt(n,"base","pow"),s=dt(t,"exp","pow");[e,s]=xr(e,s);const r={a:e,b:s};return Et.runKernel(Mj,r)}const zg=Ft({pow_:o$t});function xn(n,t){if((ca(n)&&t!=="string"||Array.isArray(n))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&ca(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Fp(n,[],[],t)}function a$t(n){const e={x:dt(n,"x","sqrt","float32")};return Et.runKernel(Jj,e)}const Xr=Ft({sqrt_:a$t});function l$t(n){const t=dt(n,"x","square"),e={};return Et.runKernel("Square",{x:t},e)}const ts=Ft({square_:l$t});function u$t(n,t=null,e=!1){let s=dt(n,"x","sum");s.dtype==="bool"&&(s=le(s,"int32"));const r={x:s},i={axis:t,keepDims:e};return Et.runKernel(t5,r,i)}const xe=Ft({sum_:u$t});function c$t(n,t="euclidean",e=null,s=!1){n=dt(n,"x","norm");const r=N5(n,t,e);let i=r.shape;if(s){const o=wl(e,n.shape);i=Dx(r.shape,o)}return kt(r,i)}function N5(n,t,e=null){if(n.rank===0)return Jr(n);if(n.rank!==1&&e===null)return N5(kt(n,[-1]),t,e);if(n.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return xe(Jr(n),e);if(t===1/0)return Hl(Jr(n),e);if(t===-1/0)return _3(Jr(n),e);if(t==="euclidean"||t===2)return Xr(xe(zg(Jr(n),xn(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return Hl(xe(Jr(n),e[0]),e[1]-1);if(t===1/0)return Hl(xe(Jr(n),e[1]),e[0]);if(t===-1/0)return _3(xe(Jr(n),e[1]),e[0]);if(t==="fro"||t==="euclidean")return Xr(xe(ts(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const R5=Ft({norm_:c$t});function h$t(n){const e={x:dt(n,"x","exp")};return Et.runKernel(dj,e)}const Jh=Ft({exp_:h$t});function f$t(n,t=0){const e=dt(n,"x","expandDims","string_or_numeric");Q(t<=e.rank,()=>"Axis must be <= rank of the tensor");const s={input:e},r={dim:t};return Et.runKernel(pj,s,r)}const Xo=Ft({expandDims_:f$t});function d$t(n,t){const e=dt(n,"x","tile","string_or_numeric");Q(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);const s={x:e},r={reps:t};return Et.runKernel(o_,s,r)}const Ja=Ft({tile_:d$t});function p$t(n,t,e,s="float32"){t==null&&(t=n);const r=yb([n,t],s),i=n<=t?n:t;for(let a=0;a<i;++a)r.set(1,a,a);const o=kt(r.toTensor(),[n,t]);if(e==null)return o;if(e.length===1)return Ja(Xo(o,0),[e[0],1,1]);if(e.length===2)return Ja(Xo(Xo(o,0),0),[e[0],e[1],1,1]);if(e.length===3)return Ja(Xo(Xo(Xo(o,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}const D5=Ft({eye_:p$t});function m$t(n){const e={x:dt(n,"x","floor","float32")};return Et.runKernel(mj,e)}const g_=Ft({floor_:m$t});function g$t(n,t,e=0,s=0){const r=dt(n,"x","gather"),i=dt(t,"indices","gather","int32"),o={x:r,indices:i},a={axis:e,batchDims:s};return Et.runKernel(bj,o,a)}const Nd=Ft({gather_:g$t});function y$t(n,t){let e=dt(n,"a","greater","string_or_numeric"),s=dt(t,"b","greater","string_or_numeric");[e,s]=xr(e,s),fs(e.shape,s.shape);const r={a:e,b:s};return Et.runKernel(qIt,r)}const ga=Ft({greater_:y$t});function b$t(n,t){let e=dt(n,"a","greaterEqual","string_or_numeric"),s=dt(t,"b","greaterEqual","string_or_numeric");[e,s]=xr(e,s),fs(e.shape,s.shape);const r={a:e,b:s};return Et.runKernel(xj,r)}const bb=Ft({greaterEqual_:b$t});function x$t(n,t=.2){const s={x:dt(n,"x","leakyRelu")},r={alpha:t};return Et.runKernel(wj,s,r)}const O5=Ft({leakyRelu_:x$t});function w$t(n,t){let e=dt(n,"a","less","string_or_numeric"),s=dt(t,"b","less","string_or_numeric");[e,s]=xr(e,s),fs(e.shape,s.shape);const r={a:e,b:s};return Et.runKernel(QIt,r)}const v$t=Ft({less_:w$t});function S$t(n,t){let e=dt(n,"a","lessEqual","string_or_numeric"),s=dt(t,"b","lessEqual","string_or_numeric");[e,s]=xr(e,s),fs(e.shape,s.shape);const r={a:e,b:s};return Et.runKernel(ZIt,r)}const xb=Ft({lessEqual_:S$t});function I$t(n){const e={x:dt(n,"x","log","float32")};return Et.runKernel(vj,e)}const gc=Ft({log_:I$t});function T$t(n){const e={x:dt(n,"x","log1p")};return Et.runKernel(Sj,e)}const C$t=Ft({log1p_:T$t});function E$t(n,t){Q(y$(n),()=>"The f passed in variableGrads(f) must be a function"),Q(t==null||Array.isArray(t)&&t.every(c=>c instanceof _x),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=t!=null;if(!e){t=[];for(const c in Et.registeredVariables)t.push(Et.registeredVariables[c])}const s=e?t.filter(c=>!c.trainable):null,r=t.length;t=t.filter(c=>c.trainable),Q(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const i=!0,{value:o,grads:a}=Et.gradients(n,t,null,i);Q(a.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Q(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return t.forEach((c,f)=>{a[f]!=null&&(l[c.name]=a[f])}),s?.forEach(c=>l[c.name]=null),{value:o,grads:l}}function Bg(n){return Et.customGrad(n)}function $$t(n){const e={x:dt(n,"x","softplus")};return Et.runKernel(Zj,e)}const y_=Ft({softplus_:$$t});function A$t(n,t){let e=dt(n,"a","sub"),s=dt(t,"b","sub");[e,s]=xr(e,s);const r={a:e,b:s};return Et.runKernel(r5,r)}const $e=Ft({sub_:A$t});function k$t(n,t=-1){const e=dt(n,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return Bg((r,i)=>{const a=Hl(r,t,!0),l=$e(r,a),c=$e(le(l,"float32"),gc(xe(Jh(l),t,!0)));return i([c]),{value:c,gradFunc:(d,m)=>{const[y]=m,b=!0,w=Jh(y);return $e(d,mt(xe(d,t,b),w))}}})(e)}const _$t=Ft({logSoftmax_:k$t});function N$t(n,t){const e=dt(n,"a","logicalAnd","bool"),s=dt(t,"b","logicalAnd","bool");fs(e.shape,s.shape);const r={a:e,b:s};return Et.runKernel(JIt,r)}const Lp=Ft({logicalAnd_:N$t});function R$t(n){const e={x:dt(n,"x","logicalNot","bool")};return Et.runKernel(tTt,e)}const D$t=Ft({logicalNot_:R$t});function O$t(n,t,e,s,r){const i=dt(n,"x","maxPool"),o=1;let a=i,l=!1;i.rank===3&&(l=!0,a=kt(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Q(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),Q(bf(e,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),Ni("maxPool",s,r);const c={x:a},f={filterSize:t,strides:e,pad:s,dimRoundingMode:r},d=Et.runKernel(Cj,c,f);return l?kt(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const F$t=Ft({maxPool_:O$t});function M$t(n,t=[1,1,1],e,s,r,i="NDHWC"){const o=dt(n,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=kt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Q(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),Q(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Ni("maxPool3d",s,r);const c={x:a},f={filterSize:t,strides:e,pad:s,dimRoundingMode:r,dataFormat:i},d=Et.runKernel(Ej,c,f);return l?kt(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const L$t=Ft({maxPool3d_:M$t});function z$t(n,t){let e=dt(n,"a","maximum"),s=dt(t,"b","maximum");[e,s]=xr(e,s),e.dtype==="bool"&&(e=le(e,"int32"),s=le(s,"int32")),fs(e.shape,s.shape);const r={a:e,b:s};return Et.runKernel(Tj,r)}const xf=Ft({maximum_:z$t});function B$t(n,t=null,e=!1){const r={x:dt(n,"x","mean")},i={axis:t,keepDims:e};return Et.runKernel($j,r,i)}const As=Ft({mean_:B$t});function gr(n,t="float32"){if(t==="complex64"){const s=gr(n,"float32"),r=gr(n,"float32");return Wv(s,r)}const e=t_(oi(n),t);return Et.makeTensor(e,n,t)}function wf(n,t="float32"){if(t==="complex64"){const s=wf(n,"float32"),r=gr(n,"float32");return Wv(s,r)}const e=jW(oi(n),t);return Et.makeTensor(e,n,t)}function P$t(n,t){let e=dt(n,"a","minimum"),s=dt(t,"b","minimum");[e,s]=xr(e,s),e.dtype==="bool"&&(e=le(e,"int32"),s=le(s,"int32")),fs(e.shape,s.shape);const r={a:e,b:s};return Et.runKernel(kj,r)}const F5=Ft({minimum_:P$t});function V$t(n,t=null,e=!1){n=dt(n,"x","moments");const s=wl(t,n.shape),r=As(n,s,e);let i=r.shape;e||(i=Dx(r.shape,s));const o=ts($e(le(n,"float32"),kt(r,i))),a=As(o,s,e);return{mean:r,variance:a}}const wb=Ft({moments_:V$t});function U$t(n,t){let e=dt(n,"a","notEqual","string_or_numeric"),s=dt(t,"b","notEqual","string_or_numeric");[e,s]=xr(e,s),fs(e.shape,s.shape);const r={a:e,b:s};return Et.runKernel(lTt,r)}const A$=Ft({notEqual_:U$t});function G$t(n){const e={x:dt(n,"x","onesLike")};return Et.runKernel(Rj,e)}const ha=Ft({onesLike_:G$t});function W$t(n,t,e=0){const s=dt(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:e},i={x:s};return Et.runKernel(Fj,i,r)}const M5=Ft({pad_:W$t});function j$t(n,t,e){const s=dt(n,"x","spaceToBatchND");Q(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),Q(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),Q(s.shape.reduce((o,a,l)=>l>0&&l<=t.length?o&&(a+e[l-1][0]+e[l-1][1])%t[l-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);const r={x:s},i={blockShape:t,paddings:e};return Et.runKernel(e5,r,i)}const q$t=Ft({spaceToBatchND_:j$t});function H$t(n,t){const e=dt(n,"x","prelu"),s=dt(t,"alpha","prelu"),r={x:e,alpha:s};return Et.runKernel(Lj,r)}const L5=Ft({prelu_:H$t});class z5{constructor(t,e,s,r,i){this.mean=t,this.stdDev=e,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=uf.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let t,e,s=!1;for(;!s;){let r,i,o;do r=2*this.random()-1,i=2*this.random()-1,o=r*r+i*i;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*r*a,e=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(t))&&(s=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class K$t{constructor(t=0,e=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=uf.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function X$t(n,t=0,e=1,s,r){if(s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new z5(t,e,s,!1,r),o=yb(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const Y$t=Ft({randomNormal_:X$t});function Q$t(n,t=0,e=1,s="float32",r){const i=yb(n,s),o=new K$t(t,e,null,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const Hv=Ft({randomUniform_:Q$t});function Ox(n,t,e=1,s="float32"){if(e===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:t,step:e,dtype:s};return Et.runKernel(dTt,{},r)}function Z$t(n){const e={x:dt(n,"x","relu")};return Et.runKernel(zj,e)}const zp=Ft({relu_:Z$t});function J$t(n){const e={x:dt(n,"x","relu6")};return Et.runKernel(Uj,e)}const t2t=Ft({relu6_:J$t});function e2t(n,t){const s={x:dt(n,"x","reverse")},r={dims:t};return Et.runKernel(Gj,s,r)}const Fx=Ft({reverse_:e2t});function n2t(n){const e={x:dt(n,"x","round")};return Et.runKernel(Wj,e)}const s2t=Ft({round_:n2t});function r2t(n){const e={x:dt(n,"x","rsqrt","float32")};return Et.runKernel(jj,e)}const i2t=Ft({rsqrt_:r2t});function o2t(n){const e={x:dt(n,"x","selu")};return Et.runKernel(Hj,e)}const a2t=Ft({selu_:o2t});function l2t(n,t,e,s,r,i=[1,1],o="NHWC"){const a=dt(n,"x","separableConv2d"),l=dt(t,"depthwiseFilter","separableConv2d"),c=dt(e,"pointwiseFilter","separableConv2d");let f=a,d=!1;if(a.rank===3&&(d=!0,f=kt(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Q(f.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${f.rank}.`),Q(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),Q(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),Q(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),Q(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const m=l.shape[2],y=l.shape[3];Q(c.shape[2]===m*y,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*y}, but got ${c.shape[2]}.`);const b=k5(f,l,s,r,o,i),x=sp(b,c,1,"valid",o);return d?kt(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const u2t=Ft({separableConv2d_:l2t});function c2t(n){const e={x:dt(n,"x","sin","float32")};return Et.runKernel(Xj,e)}const h2t=Ft({sin_:c2t});function f2t(n){const e={x:dt(n,"x","sinh")};return Et.runKernel(Yj,e)}const d2t=Ft({sinh_:f2t});function p2t(n,t,e){const s=dt(n,"x","slice1d");return Q(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Qn(s,[t],[e])}const b_=Ft({slice1d_:p2t});function m2t(n,t,e){const s=dt(n,"x","slice2d");return Q(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Qn(s,t,e)}const B5=Ft({slice2d_:m2t});function g2t(n,t,e){const s=dt(n,"x","slice3d");return Q(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Qn(s,t,e)}const x_=Ft({slice3d_:g2t});function y2t(n,t,e){const s=dt(n,"x","slice4d");return Q(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Qn(s,t,e)}const Mx=Ft({slice4d_:y2t});function b2t(n,t=-1){const e=dt(n,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);const s={logits:e},r={dim:t};return Et.runKernel(s5,s,r)}const P5=Ft({softmax_:b2t});function x2t(n,t,e=0){const r={x:dt(n,"x","split")},i={numOrSizeSplits:t,axis:e};return Et.runKernel(n5,r,i)}const ol=Ft({split_:x2t});function w2t(n,t){const e=dt(n,"x","squeeze","string_or_numeric");return kt(e,eIt(e.shape,t).newShape)}const rp=Ft({squeeze_:w2t});function v2t(n,t=0){const e=g5(n,"tensors","stack","string_or_numeric");Q(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&Q(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");const s=e,r={axis:t};return Et.runKernel(Oj,s,r)}const yc=Ft({stack_:v2t});function S2t(n,t=0){const s={x:dt(n,"x","step")},r={alpha:t};return Et.runKernel(u5,s,r)}const Kv=Ft({step_:S2t});function _r(n,t){Uv(n);const e=Op(n,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Fp(n,null,e,t)}function K1(n,t,e){if(Uv(n),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Op(n,e);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Fp(n,t,s,e)}function I2t(n,t,e){if(Uv(n),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=Op(n,e);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Fp(n,t,s,e)}function T2t(n,t=0,e=1,s,r){if(s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new z5(t,e,s,!0,r),o=yb(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const V5=Ft({truncatedNormal_:T2t});function C2t(n,t,e){const s=dt(n,"x","unsortedSegmentSum"),r=dt(t,"segmentIds","unsortedSegmentSum","int32");Q(kx(e),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:r},o={numSegments:e};return Et.runKernel(a5,i,o)}const E2t=Ft({unsortedSegmentSum_:C2t});function $2t(n,t=0){const e=dt(n,"x","unstack","string_or_numeric");Q(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);const s={value:e},r={axis:t};return Et.runKernel(o5,s,r)}const ip=Ft({unstack_:$2t});function A2t(n,t=!0,e,s){return Et.makeVariable(n,t,e,s)}function k2t(n,t){if(t==null)return n.shape.slice();if(ci(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let s=0;s<n.shape.length;s++)t[s]==null&&n.shape[s]!=null?e.push(n.shape[s]):e.push(t[s]);return e}return t}function _2t(n,t,e,s){const r=dt(n,"x","dropout");if(Q(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),Q(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return n instanceof Zn?r.clone():r;const i=k2t(r,e),o=1-t,a=we(g_(Qt(Hv(i,0,1,"float32",s),o)),o);return mt(r,a)}const N2t=Ft({dropout_:_2t});function R2t(n,t,e,s,r,i="NHWC",o){let a=n;n.rank===3&&(a=kt(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;l.rank===3&&(l=kt(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Q(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),Q(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),Q(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const c=i==="NHWC"?a.shape[3]:a.shape[1],f=i==="NHWC"?l.shape[3]:l.shape[1];Q(c===e[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${e[2]}.`),Q(f===e[3],()=>`Error in conv2dDerFilter: depth of dy (${f}) must match output depth for filter (${e[3]}).`),Ni("conv2dDerFilter",r,o);const d={x:a,dy:l},m={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,filterShape:e};return Et.runKernel(_It,d,m)}const w_=Ft({conv2DBackpropFilter_:R2t});function U5(n,t,e){if(e==null||e==="linear")return n;if(e==="relu")return mt(n,Kv(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function G5(n,t){let e=t;const s=lr(n.shape,t.shape);return s.length>0&&(e=xe(e,s)),kt(e,n.shape)}function W5(n,t,e,s){if(t==="linear")return n;if(t==="relu")return zp(n);if(t==="elu")return p_(n);if(t==="relu6")return t2t(n);if(t==="prelu")return L5(n,e);if(t==="leakyrelu")return O5(n,s);if(t==="sigmoid")return jv(n);throw new Error(`Unknown fused activation ${t}.`)}const j5=(n,t)=>!(n>0)||t==="linear";function D2t({x:n,filter:t,strides:e,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:f}){if(l=l||"linear",j5(Et.state.gradientDepth,l)===!1){Q(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let B=sp(n,t,e,s,r,i,o);return a!=null&&(B=Qt(B,a)),W5(B,l,c,f)}const d=dt(n,"x","conv2d","float32"),m=dt(t,"filter","conv2d","float32");let y=d,b=!1;d.rank===3&&(b=!0,y=kt(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Q(y.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${y.rank}.`),Q(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),Ni("fused conv2d",s,o);const w=r==="NHWC"?y.shape[3]:y.shape[1];Q(m.shape[2]===w,()=>`Error in conv2d: depth of input (${w}) must match input depth for filter ${m.shape[2]}.`),Q(bf(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);const x=ZCt(y.shape,m.shape,e,i,s,o);let S;a!=null&&(S=dt(a,"bias","fused conv2d"),[S]=xr(S,d),r==="NHWC"?fs(x.outShape,S.shape):(Q(S.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${S.shape.length}.`),Q(S.shape.length===0||S.shape[0]===x.outChannels||S.shape[0]===1,()=>`Error in fused conv2d: bias shape (${S.shape}) is not compatible with the number of output channels (${x.outChannels})`)));let T;if(c!=null){const B=c.shape;if(Q(B.length<=1||B.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${B.length}.`),B.length===1)Q(B[0]===1||B[0]===x.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${B}) is not compatible with the number of output channels (${x.outChannels}).`);else if(B.length===3)try{fs(B,x.outShape)}catch{const k=`Error in fused conv2d: PReLU activation weights (${B}) is not compatible with the output shape of the conv2d (${x.outShape}).`;throw Error(k)}T=dt(c,"prelu weights","fused conv2d")}const $=(B,N)=>{Q(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[k,_,F,A]=N,P=U5(B,F,l);Q(np(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const L=d_(_.shape,P,k,e,s),tt=w_(_,P,k.shape,e,s),st=[L,tt];if(A!=null){const j=G5(A,P);st.push(j)}return st},E={x:y,filter:m,bias:S,preluActivationWeights:T},R={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:f};return a==null?Bg((N,k,_)=>{let F=Et.runKernel(f3,E,R);return _([k,N,F]),b&&(F=kt(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:$}})(y,m):Bg((N,k,_,F)=>{let A=Et.runKernel(f3,E,R);return F([k,N,A,_]),b&&(A=kt(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:$}})(y,m,S)}const O2t=Ft({fusedConv2d_:D2t});function F2t(n,t,e,s,r,i=[1,1],o){let a=n;n.rank===3&&(a=kt(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;l.rank===3&&(l=kt(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={x:a,dy:l},f={strides:s,pad:r,dimRoundingMode:o,dilations:i,filterShape:e};return Et.runKernel(FIt,c,f)}const M2t=Ft({depthwiseConv2dNativeBackpropFilter_:F2t});function L2t(n,t,e,s,r,i=[1,1],o){let a=t,l=!1;t.rank===3&&(l=!0,a=kt(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={dy:a,filter:e},f={strides:s,pad:r,dimRoundingMode:o,dilations:i,inputShape:n},d=Et.runKernel(MIt,c,f);return l?kt(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const z2t=Ft({depthwiseConv2dNativeBackpropInput_:L2t});function B2t({a:n,b:t,transposeA:e=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(j5(Et.state.gradientDepth,i)===!1){let A=Vn(n,t,e,s);return r!=null&&(A=Qt(A,r)),W5(A,i,o,a)}let l=dt(n,"a","fused matMul"),c=dt(t,"b","fused matMul");[l,c]=xr(l,c);const f=e?l.shape[l.rank-2]:l.shape[l.rank-1],d=s?c.shape[c.rank-1]:c.shape[c.rank-2],m=e?l.shape[l.rank-1]:l.shape[l.rank-2],y=s?c.shape[c.rank-2]:c.shape[c.rank-1],b=l.shape.slice(0,-2),w=c.shape.slice(0,-2),x=oi(b),S=oi(w);Q(f===d,()=>`Error in fused matMul: inner shapes (${f}) and (${d}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${e} and transposeB=${s} must match.`);const $=fs(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([m,y]),E=e?kt(l,[x,f,m]):kt(l,[x,m,f]),R=s?kt(c,[S,y,d]):kt(c,[S,d,y]);let B;r!=null&&(B=dt(r,"bias","fused matMul"),[B]=xr(B,l),fs($,B.shape));let N;o!=null&&(N=dt(o,"prelu weights","fused matMul"));const k=(A,P)=>{const[L,tt,st,j]=P,Z=U5(kt(A,st.shape),st,i);let J,ot;if(!e&&!s?(J=Vn(Z,tt,!1,!0),ot=Vn(L,Z,!0,!1)):!e&&s?(J=Vn(Z,tt,!1,!1),ot=Vn(Z,L,!0,!1)):e&&!s?(J=Vn(tt,Z,!1,!0),ot=Vn(L,Z,!1,!1)):(J=Vn(tt,Z,!0,!0),ot=Vn(Z,L,!0,!0)),r!=null){const pt=G5(j,Z);return[J,ot,pt]}else return[J,ot]},_={a:E,b:R,bias:B,preluActivationWeights:N},F={transposeA:e,transposeB:s,activation:i,leakyreluAlpha:a};return r==null?Bg((P,L,tt)=>{const st=Et.runKernel(h3,_,F);return tt([P,L,st]),{value:kt(st,$),gradFunc:k}})(E,R):Bg((P,L,tt,st)=>{const j=Et.runKernel(h3,_,F);return st([P,L,j,tt]),{value:kt(j,$),gradFunc:k}})(E,R,B)}const N3=Ft({fusedMatMul_:B2t});function P2t(n,t,e,s,r="bilinear",i=0){const o=dt(n,"image","cropAndResize"),a=dt(t,"boxes","cropAndResize","float32"),l=dt(e,"boxInd","cropAndResize","int32"),c=a.shape[0];Q(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),Q(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),Q(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),Q(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),Q(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),Q(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const f={image:o,boxes:a,boxInd:l},d={method:r,extrapolationValue:i,cropSize:s};return Et.runKernel(OIt,f,d)}const V2t=Ft({cropAndResize_:P2t});function U2t(n){const t=dt(n,"image","flipLeftRight","float32");Q(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const e={image:t};return Et.runKernel(jIt,e,{})}const G2t=Ft({flipLeftRight_:U2t});function W2t(n){const t=dt(n,"image","grayscaleToRGB"),e=t.rank-1,s=t.shape[e];Q(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),Q(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(t.rank);return r.fill(1,0,e),r[e]=3,Ja(t,r)}const j2t=Ft({grayscaleToRGB_:W2t});function q2t(n,t,e=0,s=.5){const r=dt(n,"image","rotateWithOffset","float32");Q(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},o={radians:t,fillValue:e,center:s};return Et.runKernel(ITt,i,o)}const H2t=Ft({rotateWithOffset_:q2t});function Bp(n,t,e,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=n.shape[0];return e=Math.min(e,o),Q(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),Q(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),Q(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),Q(t.rank===1,()=>"scores must be a 1D tensor"),Q(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),Q(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:e,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}function K2t(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY){const i=dt(n,"boxes","nonMaxSuppression","float32"),o=dt(t,"scores","nonMaxSuppression","float32"),a=Bp(i,o,e,s,r);e=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l={maxOutputSize:e,iouThreshold:s,scoreThreshold:r};return Et.runKernel(uTt,{boxes:i,scores:o},l)}const X2t=Ft({nonMaxSuppression_:K2t});function Y2t(n,t,e){const s=Q2t(n,t,e),r=s<0?-(s+1):s;n.splice(r,0,t)}function Q2t(n,t,e){return J2t(n,t,e||Z2t)}function Z2t(n,t){return n>t?1:n<t?-1:0}function J2t(n,t,e){let s=0,r=n.length,i=0,o=!1;for(;s<r;){i=s+(r-s>>>1);const a=e(t,n[i]);a>0?s=i+1:(r=i,o=!a)}return o?s:-s-1}function tAt(n,t,e,s,r){return v_(n,t,e,s,r,0)}function eAt(n,t,e,s,r,i){return v_(n,t,e,s,r,0,!1,i,!0)}function nAt(n,t,e,s,r,i){return v_(n,t,e,s,r,i,!0)}function v_(n,t,e,s,r,i,o=!1,a=!1,l=!1){const c=[];for(let x=0;x<t.length;x++)t[x]>r&&c.push({score:t[x],boxIndex:x,suppressBeginIndex:0});c.sort(R3);const f=i>0?-.5/i:0,d=[],m=[];for(;d.length<e&&c.length>0;){const x=c.pop(),{score:S,boxIndex:T,suppressBeginIndex:$}=x;if(S<r)break;let E=!1;for(let R=d.length-1;R>=$;--R){const B=sAt(n,T,d[R]);if(B>=s){E=!0;break}if(x.score=x.score*rAt(s,f,B),x.score<=r)break}x.suppressBeginIndex=d.length,E||(x.score===S?(d.push(T),m.push(x.score)):x.score>r&&Y2t(c,x,R3))}const y=d.length,b=e-y;a&&b>0&&(d.push(...new Array(b).fill(0)),m.push(...new Array(b).fill(0)));const w={selectedIndices:d};return o&&(w.selectedScores=m),l&&(w.validOutputs=y),w}function sAt(n,t,e){const s=n.subarray(t*4,t*4+4),r=n.subarray(e*4,e*4+4),i=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(r[0],r[2]),f=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),m=Math.max(r[1],r[3]),y=(a-i)*(l-o),b=(d-c)*(m-f);if(y<=0||b<=0)return 0;const w=Math.max(i,c),x=Math.max(o,f),S=Math.min(a,d),T=Math.min(l,m),$=Math.max(S-w,0)*Math.max(T-x,0);return $/(y+b-$)}function rAt(n,t,e){const s=Math.exp(t*e*e);return e<=n?s:0}function R3(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}async function iAt(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY){const i=dt(n,"boxes","nonMaxSuppressionAsync"),o=dt(t,"scores","nonMaxSuppressionAsync"),a=Bp(i,o,e,s,r);e=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l=await Promise.all([i.data(),o.data()]),c=l[0],f=l[1],{selectedIndices:d}=tAt(c,f,e,s,r);return i!==n&&i.dispose(),o!==t&&o.dispose(),_r(d,"int32")}const oAt=iAt;function aAt(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=dt(n,"boxes","nonMaxSuppression"),a=dt(t,"scores","nonMaxSuppression"),l=Bp(o,a,e,s,r,i);e=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const c={boxes:o,scores:a},f={maxOutputSize:e,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},d=Et.runKernel(hTt,c,f);return{selectedIndices:d[0],selectedScores:d[1]}}const lAt=Ft({nonMaxSuppressionWithScore_:aAt});async function uAt(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=dt(n,"boxes","nonMaxSuppressionAsync"),a=dt(t,"scores","nonMaxSuppressionAsync"),l=Bp(o,a,e,s,r,i);e=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),f=c[0],d=c[1],{selectedIndices:m,selectedScores:y}=nAt(f,d,e,s,r,i);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:_r(m,"int32"),selectedScores:_r(y)}}const cAt=uAt;function hAt(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=dt(n,"boxes","nonMaxSuppression"),a=dt(t,"scores","nonMaxSuppression"),l=Bp(o,a,e,s,r,null),c=l.maxOutputSize,f=l.iouThreshold,d=l.scoreThreshold,m={boxes:o,scores:a},y={maxOutputSize:c,iouThreshold:f,scoreThreshold:d,padToMaxOutputSize:i},b=Et.runKernel(cTt,m,y);return{selectedIndices:b[0],validOutputs:b[1]}}const fAt=Ft({nonMaxSuppressionPadded_:hAt});async function dAt(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=dt(n,"boxes","nonMaxSuppressionAsync"),a=dt(t,"scores","nonMaxSuppressionAsync"),l=Bp(o,a,e,s,r,null),c=l.maxOutputSize,f=l.iouThreshold,d=l.scoreThreshold,[m,y]=await Promise.all([o.data(),a.data()]),{selectedIndices:b,validOutputs:w}=eAt(m,y,c,f,d,i);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:_r(b,"int32"),validOutputs:xn(w,"int32")}}const pAt=dAt;function mAt(n,t,e=!1,s=!1){const r=dt(n,"images","resizeBilinear");Q(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),Q(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),Q(s===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=kt(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:e,halfPixelCenters:s,size:t},c=Et.runKernel(Vj,a,l);return o?kt(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const gAt=Ft({resizeBilinear_:mAt});function yAt(n,t,e=!1,s=!1){const r=dt(n,"images","resizeNearestNeighbor");Q(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),Q(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),Q(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),Q(s===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=kt(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:e,halfPixelCenters:s,size:t},c=Et.runKernel(Pj,a,l);return o?kt(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const bAt=Ft({resizeNearestNeighbor_:yAt});function xAt(n,t="binary",e=!1,s=.5){const r=dt(n,"image","threshold"),i=.2989,o=.587,a=.114,l=r.shape[0]*r.shape[1];let c=mt(_r([s]),255),f,d,m,y;if(Q(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),Q(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),Q(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),Q(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[f,d,m]=ol(r,[1,1,1],-1);const x=mt(f,i),S=mt(d,o),T=mt(m,a);y=Qt(Qt(x,S),T)}else y=n;if(t==="otsu"){const x=SEt(le(s2t(y),"int32"),zd([]),256);c=wAt(x,l)}const b=e?xb(y,c):ga(y,c);return le(mt(b,255),"int32")}function wAt(n,t){let e=_r([-1]),s=_r([0]),r=_r([0]),i,o,a,l,c,f;for(let d=0;d<n.size-1;d++){i=Qn(n,0,d+1),o=Qn(n,d+1),c=we(xe(i),t),f=we(xe(o),t);const m=xe(mt(i,Ox(0,i.size)));a=we(m,xe(i));const y=qv(o.shape,i.size),b=Qt(Ox(0,o.size),y),w=mt(o,b);l=we(xe(w),xe(o));const x=$e(a,l),S=$e(a,l),T=mt(c,f);r=mt(mt(T,x),S);const $=ga(r,s);s=Co($,r,s),e=Co($,_r([d]),e)}return e}const vAt=Ft({threshold_:xAt});function SAt(n,t,e="nearest",s="constant",r=0,i){const o=dt(n,"image","transform","float32"),a=dt(t,"transforms","transform","float32");Q(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),Q(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),Q(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const l={image:o,transforms:a},c={interpolation:e,fillMode:s,fillValue:r,outputShape:i};return Et.runKernel(STt,l,c)}const IAt=Ft({transform_:SAt});function TAt(n,t,e){Q(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),Q(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);const s=dt(n,"a","bandPart");Q(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,o]=s.shape.slice(-2);if(!(t<=i))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`);if(!(e<=o))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${o}).`);t<0&&(t=i),e<0&&(e=o);const a=kt(Ox(0,i,1,"int32"),[-1,1]),l=Ox(0,o,1,"int32"),c=$e(a,l),f=Lp(xb(c,xn(+t,"int32")),bb(c,xn(-e,"int32"))),d=gr([i,o],s.dtype);return kt(yc(ip(kt(s,[-1,i,o])).map(m=>Co(f,m,d))),r)}const CAt=Ft({bandPart_:TAt});function EAt(n){let t;if(Array.isArray(n)){t=!1,Q(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let i=1;i<n.length;++i)Q(n[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${r})`)}else t=!0,n=ol(n,n.shape[0],0).map(r=>rp(r,[0]));Q(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],s=n;for(let r=0;r<n.length;++r)e.push(Et.tidy(()=>{let i=s[r];if(r>0)for(let o=0;o<r;++o){const a=mt(xe(mt(e[o],i)),e[o]);i=$e(i,a)}return we(i,R5(i,"euclidean"))}));return t?yc(e,0):e}const $At=Ft({gramSchmidt_:EAt});function AAt(n,t=!1){if(Q(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return D3(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),s=ip(kt(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],i=[];s.forEach(l=>{const[c,f]=D3(l,t);r.push(c),i.push(f)});const o=kt(yc(r,0),n.shape),a=kt(yc(i,0),n.shape);return[o,a]}}function D3(n,t=!1){return Et.tidy(()=>{Q(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],s=n.shape[1];let r=D5(e),i=Nh(n);const o=K1([[1]],[1,1]);let a=Nh(o);const l=e>=s?s:e;for(let c=0;c<l;++c){const f=i,d=a,m=r;[a,i,r]=Et.tidy(()=>{const y=Qn(i,[c,c],[e-c,1]),b=R5(y),w=Qn(i,[c,c],[1,1]),x=Co(ga(w,0),K1([[-1]]),K1([[1]])),S=$e(w,mt(x,b)),T=we(y,S);T.shape[0]===1?a=Nh(o):a=na([o,Qn(T,[1,0],[T.shape[0]-1,T.shape[1]])],0);const $=Lr(we(Vn(x,S),b)),E=Qn(i,[c,0],[e-c,s]),R=mt($,a),B=nn(a);if(c===0)i=$e(E,Vn(R,Vn(B,E)));else{const _=$e(E,Vn(R,Vn(B,E)));i=na([Qn(i,[0,0],[c,s]),_],0)}const N=nn(R),k=Qn(r,[0,c],[e,r.shape[1]-c]);if(c===0)r=$e(k,Vn(Vn(k,a),N));else{const _=$e(k,Vn(Vn(k,a),N));r=na([Qn(r,[0,0],[e,c]),_],1)}return[a,i,r]}),Ee([f,d,m])}return!t&&e>s&&(r=Qn(r,[0,0],[e,s]),i=Qn(i,[0,0],[s,s])),[r,i]})}const kAt=Ft({qr_:AAt});const v1={flipLeftRight:G2t,grayscaleToRGB:j2t,resizeNearestNeighbor:bAt,resizeBilinear:gAt,rotateWithOffset:H2t,cropAndResize:V2t,nonMaxSuppression:X2t,nonMaxSuppressionAsync:oAt,nonMaxSuppressionWithScore:lAt,nonMaxSuppressionWithScoreAsync:cAt,nonMaxSuppressionPadded:fAt,nonMaxSuppressionPaddedAsync:pAt,threshold:vAt,transform:IAt},_At={bandPart:CAt,gramSchmidt:$At,qr:kAt};class Lc extends Mp{minimize(t,e=!1,s){const{value:r,grads:i}=this.computeGradients(t,s);if(s!=null){const o=s.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return Ee(i),e?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return E$t(t,e)}dispose(){this.iterations_!=null&&Ee(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:xn(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(Lc,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class S_ extends Lc{constructor(t,e,s=null){super(),this.learningRate=t,this.rho=e,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=Et.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=Et.registeredVariables[s],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:St(()=>pn(i).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:St(()=>pn(i).variable(o))});const a=Array.isArray(t)?t[r].tensor:t[s];if(a==null)return;const l=this.accumulatedGrads[r].variable,c=this.accumulatedUpdates[r].variable;St(()=>{const f=Qt(mt(l,this.rho),mt(ts(a),1-this.rho)),d=mt(we(Xr(Qt(c,this.epsilon)),Xr(Qt(l,this.epsilon))),a),m=Qt(mt(c,this.rho),mt(ts(d),1-this.rho));l.assign(f),c.assign(m);const y=Qt(mt(d,-this.learningRate),i);i.assign(y)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ee(this.accumulatedGrads.map(t=>t.variable)),Ee(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=t.length/2,s=!1;this.accumulatedGrads=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}S_.className="Adadelta";Kt(S_);class I_ extends Lc{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=Et.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:St(()=>qv(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(t)?t[r].tensor:t[s];if(o==null)return;const a=this.accumulatedGrads[r].variable;St(()=>{const l=Qt(a,ts(o));a.assign(l);const c=Qt(mt(we(o,Xr(Qt(l,Et.backend.epsilon()))),-this.learningRate),i);i.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ee(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}I_.className="Adagrad";Kt(I_);class T_ extends Lc{constructor(t,e,s,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],St(()=>{this.accBeta1=xn(e).variable(),this.accBeta2=xn(s).variable()}),r==null&&(this.epsilon=Et.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);St(()=>{const s=$e(1,this.accBeta1),r=$e(1,this.accBeta2);e.forEach((i,o)=>{const a=Et.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:St(()=>pn(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:St(()=>pn(a).variable(l))});const c=Array.isArray(t)?t[o].tensor:t[i];if(c==null)return;const f=this.accumulatedFirstMoment[o].variable,d=this.accumulatedSecondMoment[o].variable,m=Qt(mt(f,this.beta1),mt(c,1-this.beta1)),y=Qt(mt(d,this.beta2),mt(ts(c),1-this.beta2)),b=we(m,s),w=we(y,r);f.assign(m),d.assign(y);const x=Qt(mt(we(b,Qt(Xr(w),this.epsilon)),-this.learningRate),a);a.assign(x)}),this.accBeta1.assign(mt(this.accBeta1,this.beta1)),this.accBeta2.assign(mt(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ee(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&Ee(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),St(()=>{this.accBeta1.assign(zg(this.beta1,this.iterations_+1)),this.accBeta2.assign(zg(this.beta2,this.iterations_+1))});const e=t.length/2,s=!1;this.accumulatedFirstMoment=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}T_.className="Adam";Kt(T_);class C_ extends Lc{constructor(t,e,s,r=null,i=0){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],St(()=>{this.iteration=xn(0).variable(),this.accBeta1=xn(e).variable()}),r==null&&(this.epsilon=Et.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);St(()=>{const s=$e(1,this.accBeta1),r=we(-this.learningRate,Qt(mt(this.iteration,this.decay),1));e.forEach((i,o)=>{const a=Et.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:pn(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:pn(a).variable(l)});const c=Array.isArray(t)?t[o].tensor:t[i];if(c==null)return;const f=this.accumulatedFirstMoment[o].variable,d=this.accumulatedWeightedInfNorm[o].variable,m=Qt(mt(f,this.beta1),mt(c,1-this.beta1)),y=mt(d,this.beta2),b=Jr(c),w=xf(y,b);f.assign(m),d.assign(w);const x=Qt(mt(we(r,s),we(m,Qt(w,this.epsilon))),a);a.assign(x)}),this.iteration.assign(Qt(this.iteration,1)),this.accBeta1.assign(mt(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ee(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&Ee(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}C_.className="Adamax";Kt(C_);class Xv extends Lc{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=Array.isArray(t)?t[r].tensor:t[s];if(i==null)return;const o=Et.registeredVariables[s];St(()=>{const a=Qt(mt(this.c,i),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=gl(xn(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}Xv.className="SGD";Kt(Xv);class E_ extends Xv{constructor(t,e,s=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=s,this.accumulations=[],this.m=xn(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=Et.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:St(()=>pn(i).variable(!1))});const o=this.accumulations[r].variable,a=Array.isArray(t)?t[r].tensor:t[s];a!=null&&St(()=>{let l;const c=Qt(mt(this.m,o),a);this.useNesterov?l=Qt(mt(this.c,Qt(a,mt(c,this.m))),i):l=Qt(mt(this.c,c),i),o.assign(c),i.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ee(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}E_.className="Momentum";Kt(E_);class $_ extends Lc{constructor(t,e=.9,s=0,r=null,i=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=Et.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=Et.registeredVariables[s],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:St(()=>pn(i).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:St(()=>pn(i).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:St(()=>pn(i).variable(o))});const a=Array.isArray(t)?t[r].tensor:t[s];if(a==null)return;const l=this.accumulatedMeanSquares[r].variable,c=this.accumulatedMoments[r].variable;St(()=>{const f=Qt(mt(l,this.decay),mt(ts(a),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[r].variable,m=Qt(mt(d,this.decay),mt(a,1-this.decay)),y=we(mt(a,this.learningRate),Xr($e(f,Qt(ts(m),this.epsilon)))),b=Qt(mt(c,this.momentum),y);l.assign(f),d.assign(m),c.assign(b);const w=$e(i,b);i.assign(w)}else{const d=Qt(mt(l,this.decay),mt(ts(a),1-this.decay)),m=Qt(mt(c,this.momentum),we(mt(a,this.learningRate),Xr(Qt(d,this.epsilon))));l.assign(d),c.assign(m);const y=$e(i,m);i.assign(y)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ee(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ee(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&Ee(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,s=!1;this.accumulatedMeanSquares=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}$_.className="RMSProp";Kt($_);class ph{static sgd(t){return new Xv(t)}static momentum(t,e,s=!1){return new E_(t,e,s)}static rmsprop(t,e=.9,s=0,r=null,i=!1){return new $_(t,e,s,r,i)}static adam(t=.001,e=.9,s=.999,r=null){return new T_(t,e,s,r)}static adadelta(t=.001,e=.95,s=null){return new S_(t,e,s)}static adamax(t=.002,e=.9,s=.999,r=null,i=0){return new C_(t,e,s,r,i)}static adagrad(t,e=.1){return new I_(t,e)}}const yd={sgd:ph.sgd,momentum:ph.momentum,adadelta:ph.adadelta,adagrad:ph.adagrad,rmsprop:ph.rmsprop,adamax:ph.adamax,adam:ph.adam};const NAt=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function RAt(){return new Promise(n=>NAt(()=>n()))}const DAt=1.7580993408473768,OAt=1.0507009873554805;var cC={},hC={},fC,O3;function q5(){return O3||(O3=1,fC=function(){if(typeof Symbol!="function"||typeof Object.getOwnPropertySymbols!="function")return!1;if(typeof Symbol.iterator=="symbol")return!0;var t={},e=Symbol("test"),s=Object(e);if(typeof e=="string"||Object.prototype.toString.call(e)!=="[object Symbol]"||Object.prototype.toString.call(s)!=="[object Symbol]")return!1;var r=42;t[e]=r;for(var i in t)return!1;if(typeof Object.keys=="function"&&Object.keys(t).length!==0||typeof Object.getOwnPropertyNames=="function"&&Object.getOwnPropertyNames(t).length!==0)return!1;var o=Object.getOwnPropertySymbols(t);if(o.length!==1||o[0]!==e||!Object.prototype.propertyIsEnumerable.call(t,e))return!1;if(typeof Object.getOwnPropertyDescriptor=="function"){var a=Object.getOwnPropertyDescriptor(t,e);if(a.value!==r||a.enumerable!==!0)return!1}return!0}),fC}var dC,F3;function Yv(){if(F3)return dC;F3=1;var n=q5();return dC=function(){return n()&&!!Symbol.toStringTag},dC}var pC,M3;function H5(){return M3||(M3=1,pC=Object),pC}var mC,L3;function FAt(){return L3||(L3=1,mC=Error),mC}var gC,z3;function MAt(){return z3||(z3=1,gC=EvalError),gC}var yC,B3;function LAt(){return B3||(B3=1,yC=RangeError),yC}var bC,P3;function zAt(){return P3||(P3=1,bC=ReferenceError),bC}var xC,V3;function K5(){return V3||(V3=1,xC=SyntaxError),xC}var wC,U3;function vb(){return U3||(U3=1,wC=TypeError),wC}var vC,G3;function BAt(){return G3||(G3=1,vC=URIError),vC}var SC,W3;function PAt(){return W3||(W3=1,SC=Math.abs),SC}var IC,j3;function VAt(){return j3||(j3=1,IC=Math.floor),IC}var TC,q3;function UAt(){return q3||(q3=1,TC=Math.max),TC}var CC,H3;function GAt(){return H3||(H3=1,CC=Math.min),CC}var EC,K3;function WAt(){return K3||(K3=1,EC=Math.pow),EC}var $C,X3;function jAt(){return X3||(X3=1,$C=Math.round),$C}var AC,Y3;function qAt(){return Y3||(Y3=1,AC=Number.isNaN||function(t){return t!==t}),AC}var kC,Q3;function HAt(){if(Q3)return kC;Q3=1;var n=qAt();return kC=function(e){return n(e)||e===0?e:e<0?-1:1},kC}var _C,Z3;function KAt(){return Z3||(Z3=1,_C=Object.getOwnPropertyDescriptor),_C}var NC,J3;function Pp(){if(J3)return NC;J3=1;var n=KAt();if(n)try{n([],"length")}catch{n=null}return NC=n,NC}var RC,tL;function Qv(){if(tL)return RC;tL=1;var n=Object.defineProperty||!1;if(n)try{n({},"a",{value:1})}catch{n=!1}return RC=n,RC}var DC,eL;function XAt(){if(eL)return DC;eL=1;var n=typeof Symbol<"u"&&Symbol,t=q5();return DC=function(){return typeof n!="function"||typeof Symbol!="function"||typeof n("foo")!="symbol"||typeof Symbol("bar")!="symbol"?!1:t()},DC}var OC,nL;function X5(){return nL||(nL=1,OC=typeof Reflect<"u"&&Reflect.getPrototypeOf||null),OC}var FC,sL;function Y5(){if(sL)return FC;sL=1;var n=H5();return FC=n.getPrototypeOf||null,FC}var MC,rL;function YAt(){if(rL)return MC;rL=1;var n="Function.prototype.bind called on incompatible ",t=Object.prototype.toString,e=Math.max,s="[object Function]",r=function(l,c){for(var f=[],d=0;d<l.length;d+=1)f[d]=l[d];for(var m=0;m<c.length;m+=1)f[m+l.length]=c[m];return f},i=function(l,c){for(var f=[],d=c,m=0;d<l.length;d+=1,m+=1)f[m]=l[d];return f},o=function(a,l){for(var c="",f=0;f<a.length;f+=1)c+=a[f],f+1<a.length&&(c+=l);return c};return MC=function(l){var c=this;if(typeof c!="function"||t.apply(c)!==s)throw new TypeError(n+c);for(var f=i(arguments,1),d,m=function(){if(this instanceof d){var S=c.apply(this,r(f,arguments));return Object(S)===S?S:this}return c.apply(l,r(f,arguments))},y=e(0,c.length-f.length),b=[],w=0;w<y;w++)b[w]="$"+w;if(d=Function("binder","return function ("+o(b,",")+"){ return binder.apply(this,arguments); }")(m),c.prototype){var x=function(){};x.prototype=c.prototype,d.prototype=new x,x.prototype=null}return d},MC}var LC,iL;function Sb(){if(iL)return LC;iL=1;var n=YAt();return LC=Function.prototype.bind||n,LC}var zC,oL;function A_(){return oL||(oL=1,zC=Function.prototype.call),zC}var BC,aL;function k_(){return aL||(aL=1,BC=Function.prototype.apply),BC}var PC,lL;function QAt(){return lL||(lL=1,PC=typeof Reflect<"u"&&Reflect&&Reflect.apply),PC}var VC,uL;function Q5(){if(uL)return VC;uL=1;var n=Sb(),t=k_(),e=A_(),s=QAt();return VC=s||n.call(e,t),VC}var UC,cL;function __(){if(cL)return UC;cL=1;var n=Sb(),t=vb(),e=A_(),s=Q5();return UC=function(i){if(i.length<1||typeof i[0]!="function")throw new t("a function is required");return s(n,e,i)},UC}var GC,hL;function ZAt(){if(hL)return GC;hL=1;var n=__(),t=Pp(),e;try{e=[].__proto__===Array.prototype}catch(o){if(!o||typeof o!="object"||!("code"in o)||o.code!=="ERR_PROTO_ACCESS")throw o}var s=!!e&&t&&t(Object.prototype,"__proto__"),r=Object,i=r.getPrototypeOf;return GC=s&&typeof s.get=="function"?n([s.get]):typeof i=="function"?function(a){return i(a==null?a:r(a))}:!1,GC}var WC,fL;function N_(){if(fL)return WC;fL=1;var n=X5(),t=Y5(),e=ZAt();return WC=n?function(r){return n(r)}:t?function(r){if(!r||typeof r!="object"&&typeof r!="function")throw new TypeError("getProto: not an object");return t(r)}:e?function(r){return e(r)}:null,WC}var jC,dL;function Z5(){if(dL)return jC;dL=1;var n=Function.prototype.call,t=Object.prototype.hasOwnProperty,e=Sb();return jC=e.call(n,t),jC}var qC,pL;function J5(){if(pL)return qC;pL=1;var n,t=H5(),e=FAt(),s=MAt(),r=LAt(),i=zAt(),o=K5(),a=vb(),l=BAt(),c=PAt(),f=VAt(),d=UAt(),m=GAt(),y=WAt(),b=jAt(),w=HAt(),x=Function,S=function(zt){try{return x('"use strict"; return ('+zt+").constructor;")()}catch{}},T=Pp(),$=Qv(),E=function(){throw new a},R=T?(function(){try{return arguments.callee,E}catch{try{return T(arguments,"callee").get}catch{return E}}})():E,B=XAt()(),N=N_(),k=Y5(),_=X5(),F=k_(),A=A_(),P={},L=typeof Uint8Array>"u"||!N?n:N(Uint8Array),tt={__proto__:null,"%AggregateError%":typeof AggregateError>"u"?n:AggregateError,"%Array%":Array,"%ArrayBuffer%":typeof ArrayBuffer>"u"?n:ArrayBuffer,"%ArrayIteratorPrototype%":B&&N?N([][Symbol.iterator]()):n,"%AsyncFromSyncIteratorPrototype%":n,"%AsyncFunction%":P,"%AsyncGenerator%":P,"%AsyncGeneratorFunction%":P,"%AsyncIteratorPrototype%":P,"%Atomics%":typeof Atomics>"u"?n:Atomics,"%BigInt%":typeof BigInt>"u"?n:BigInt,"%BigInt64Array%":typeof BigInt64Array>"u"?n:BigInt64Array,"%BigUint64Array%":typeof BigUint64Array>"u"?n:BigUint64Array,"%Boolean%":Boolean,"%DataView%":typeof DataView>"u"?n:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":e,"%eval%":eval,"%EvalError%":s,"%Float16Array%":typeof Float16Array>"u"?n:Float16Array,"%Float32Array%":typeof Float32Array>"u"?n:Float32Array,"%Float64Array%":typeof Float64Array>"u"?n:Float64Array,"%FinalizationRegistry%":typeof FinalizationRegistry>"u"?n:FinalizationRegistry,"%Function%":x,"%GeneratorFunction%":P,"%Int8Array%":typeof Int8Array>"u"?n:Int8Array,"%Int16Array%":typeof Int16Array>"u"?n:Int16Array,"%Int32Array%":typeof Int32Array>"u"?n:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":B&&N?N(N([][Symbol.iterator]())):n,"%JSON%":typeof JSON=="object"?JSON:n,"%Map%":typeof Map>"u"?n:Map,"%MapIteratorPrototype%":typeof Map>"u"||!B||!N?n:N(new Map()[Symbol.iterator]()),"%Math%":Math,"%Number%":Number,"%Object%":t,"%Object.getOwnPropertyDescriptor%":T,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":typeof Promise>"u"?n:Promise,"%Proxy%":typeof Proxy>"u"?n:Proxy,"%RangeError%":r,"%ReferenceError%":i,"%Reflect%":typeof Reflect>"u"?n:Reflect,"%RegExp%":RegExp,"%Set%":typeof Set>"u"?n:Set,"%SetIteratorPrototype%":typeof Set>"u"||!B||!N?n:N(new Set()[Symbol.iterator]()),"%SharedArrayBuffer%":typeof SharedArrayBuffer>"u"?n:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":B&&N?N(""[Symbol.iterator]()):n,"%Symbol%":B?Symbol:n,"%SyntaxError%":o,"%ThrowTypeError%":R,"%TypedArray%":L,"%TypeError%":a,"%Uint8Array%":typeof Uint8Array>"u"?n:Uint8Array,"%Uint8ClampedArray%":typeof Uint8ClampedArray>"u"?n:Uint8ClampedArray,"%Uint16Array%":typeof Uint16Array>"u"?n:Uint16Array,"%Uint32Array%":typeof Uint32Array>"u"?n:Uint32Array,"%URIError%":l,"%WeakMap%":typeof WeakMap>"u"?n:WeakMap,"%WeakRef%":typeof WeakRef>"u"?n:WeakRef,"%WeakSet%":typeof WeakSet>"u"?n:WeakSet,"%Function.prototype.call%":A,"%Function.prototype.apply%":F,"%Object.defineProperty%":$,"%Object.getPrototypeOf%":k,"%Math.abs%":c,"%Math.floor%":f,"%Math.max%":d,"%Math.min%":m,"%Math.pow%":y,"%Math.round%":b,"%Math.sign%":w,"%Reflect.getPrototypeOf%":_};if(N)try{null.error}catch(zt){var st=N(N(zt));tt["%Error.prototype%"]=st}var j=function zt(Wt){var Xt;if(Wt==="%AsyncFunction%")Xt=S("async function () {}");else if(Wt==="%GeneratorFunction%")Xt=S("function* () {}");else if(Wt==="%AsyncGeneratorFunction%")Xt=S("async function* () {}");else if(Wt==="%AsyncGenerator%"){var te=zt("%AsyncGeneratorFunction%");te&&(Xt=te.prototype)}else if(Wt==="%AsyncIteratorPrototype%"){var oe=zt("%AsyncGenerator%");oe&&N&&(Xt=N(oe.prototype))}return tt[Wt]=Xt,Xt},Z={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},J=Sb(),ot=Z5(),pt=J.call(A,Array.prototype.concat),q=J.call(F,Array.prototype.splice),et=J.call(A,String.prototype.replace),U=J.call(A,String.prototype.slice),X=J.call(A,RegExp.prototype.exec),nt=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,xt=/\\(\\)?/g,Ot=function(Wt){var Xt=U(Wt,0,1),te=U(Wt,-1);if(Xt==="%"&&te!=="%")throw new o("invalid intrinsic syntax, expected closing `%`");if(te==="%"&&Xt!=="%")throw new o("invalid intrinsic syntax, expected opening `%`");var oe=[];return et(Wt,nt,function(fe,pe,ie,Ae){oe[oe.length]=ie?et(Ae,xt,"$1"):pe||fe}),oe},qt=function(Wt,Xt){var te=Wt,oe;if(ot(Z,te)&&(oe=Z[te],te="%"+oe[0]+"%"),ot(tt,te)){var fe=tt[te];if(fe===P&&(fe=j(te)),typeof fe>"u"&&!Xt)throw new a("intrinsic "+Wt+" exists, but is not available. Please file an issue!");return{alias:oe,name:te,value:fe}}throw new o("intrinsic "+Wt+" does not exist!")};return qC=function(Wt,Xt){if(typeof Wt!="string"||Wt.length===0)throw new a("intrinsic name must be a non-empty string");if(arguments.length>1&&typeof Xt!="boolean")throw new a('"allowMissing" argument must be a boolean');if(X(/^%?[^%]*%?$/,Wt)===null)throw new o("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var te=Ot(Wt),oe=te.length>0?te[0]:"",fe=qt("%"+oe+"%",Xt),pe=fe.name,ie=fe.value,Ae=!1,Ge=fe.alias;Ge&&(oe=Ge[0],q(te,pt([0,1],Ge)));for(var Nt=1,Ie=!0;Nt<te.length;Nt+=1){var wn=te[Nt],rs=U(wn,0,1),Ns=U(wn,-1);if((rs==='"'||rs==="'"||rs==="`"||Ns==='"'||Ns==="'"||Ns==="`")&&rs!==Ns)throw new o("property names with quotes must have matching quotes");if((wn==="constructor"||!Ie)&&(Ae=!0),oe+="."+wn,pe="%"+oe+"%",ot(tt,pe))ie=tt[pe];else if(ie!=null){if(!(wn in ie)){if(!Xt)throw new a("base intrinsic for "+Wt+" exists, but the property is not available.");return}if(T&&Nt+1>=te.length){var je=T(ie,wn);Ie=!!je,Ie&&"get"in je&&!("originalValue"in je.get)?ie=je.get:ie=ie[wn]}else Ie=ot(ie,wn),ie=ie[wn];Ie&&!Ae&&(tt[pe]=ie)}}return ie},qC}var HC,mL;function Ib(){if(mL)return HC;mL=1;var n=J5(),t=__(),e=t([n("%String.prototype.indexOf%")]);return HC=function(r,i){var o=n(r,!!i);return typeof o=="function"&&e(r,".prototype.")>-1?t([o]):o},HC}var KC,gL;function JAt(){if(gL)return KC;gL=1;var n=Yv()(),t=Ib(),e=t("Object.prototype.toString"),s=function(a){return n&&a&&typeof a=="object"&&Symbol.toStringTag in a?!1:e(a)==="[object Arguments]"},r=function(a){return s(a)?!0:a!==null&&typeof a=="object"&&"length"in a&&typeof a.length=="number"&&a.length>=0&&e(a)!=="[object Array]"&&"callee"in a&&e(a.callee)==="[object Function]"},i=(function(){return s(arguments)})();return s.isLegacyArguments=r,KC=i?s:r,KC}var XC,yL;function tkt(){if(yL)return XC;yL=1;var n=Ib(),t=Yv()(),e=Z5(),s=Pp(),r;if(t){var i=n("RegExp.prototype.exec"),o={},a=function(){throw o},l={toString:a,valueOf:a};typeof Symbol.toPrimitive=="symbol"&&(l[Symbol.toPrimitive]=a),r=function(m){if(!m||typeof m!="object")return!1;var y=s(m,"lastIndex"),b=y&&e(y,"value");if(!b)return!1;try{i(m,l)}catch(w){return w===o}}}else{var c=n("Object.prototype.toString"),f="[object RegExp]";r=function(m){return!m||typeof m!="object"&&typeof m!="function"?!1:c(m)===f}}return XC=r,XC}var YC,bL;function ekt(){if(bL)return YC;bL=1;var n=Ib(),t=tkt(),e=n("RegExp.prototype.exec"),s=vb();return YC=function(i){if(!t(i))throw new s("`regex` must be a RegExp");return function(a){return e(i,a)!==null}},YC}var QC,xL;function nkt(){if(xL)return QC;xL=1;const n=(function*(){}).constructor;return QC=()=>n,QC}var ZC,wL;function skt(){if(wL)return ZC;wL=1;var n=Ib(),t=ekt(),e=t(/^\s*(?:function)?\*/),s=Yv()(),r=N_(),i=n("Object.prototype.toString"),o=n("Function.prototype.toString"),a=nkt();return ZC=function(c){if(typeof c!="function")return!1;if(e(o(c)))return!0;if(!s){var f=i(c);return f==="[object GeneratorFunction]"}if(!r)return!1;var d=a();return d&&r(c)===d.prototype},ZC}var JC,vL;function rkt(){if(vL)return JC;vL=1;var n=Function.prototype.toString,t=typeof Reflect=="object"&&Reflect!==null&&Reflect.apply,e,s;if(typeof t=="function"&&typeof Object.defineProperty=="function")try{e=Object.defineProperty({},"length",{get:function(){throw s}}),s={},t(function(){throw 42},null,e)}catch(T){T!==s&&(t=null)}else t=null;var r=/^\s*class\b/,i=function($){try{var E=n.call($);return r.test(E)}catch{return!1}},o=function($){try{return i($)?!1:(n.call($),!0)}catch{return!1}},a=Object.prototype.toString,l="[object Object]",c="[object Function]",f="[object GeneratorFunction]",d="[object HTMLAllCollection]",m="[object HTML document.all class]",y="[object HTMLCollection]",b=typeof Symbol=="function"&&!!Symbol.toStringTag,w=!(0 in[,]),x=function(){return!1};if(typeof document=="object"){var S=document.all;a.call(S)===a.call(document.all)&&(x=function($){if((w||!$)&&(typeof $>"u"||typeof $=="object"))try{var E=a.call($);return(E===d||E===m||E===y||E===l)&&$("")==null}catch{}return!1})}return JC=t?function($){if(x($))return!0;if(!$||typeof $!="function"&&typeof $!="object")return!1;try{t($,null,e)}catch(E){if(E!==s)return!1}return!i($)&&o($)}:function($){if(x($))return!0;if(!$||typeof $!="function"&&typeof $!="object")return!1;if(b)return o($);if(i($))return!1;var E=a.call($);return E!==c&&E!==f&&!/^\[object HTML/.test(E)?!1:o($)},JC}var tE,SL;function ikt(){if(SL)return tE;SL=1;var n=rkt(),t=Object.prototype.toString,e=Object.prototype.hasOwnProperty,s=function(l,c,f){for(var d=0,m=l.length;d<m;d++)e.call(l,d)&&(f==null?c(l[d],d,l):c.call(f,l[d],d,l))},r=function(l,c,f){for(var d=0,m=l.length;d<m;d++)f==null?c(l.charAt(d),d,l):c.call(f,l.charAt(d),d,l)},i=function(l,c,f){for(var d in l)e.call(l,d)&&(f==null?c(l[d],d,l):c.call(f,l[d],d,l))};function o(a){return t.call(a)==="[object Array]"}return tE=function(l,c,f){if(!n(c))throw new TypeError("iterator must be a function");var d;arguments.length>=3&&(d=f),o(l)?s(l,c,d):typeof l=="string"?r(l,c,d):i(l,c,d)},tE}var eE,IL;function okt(){return IL||(IL=1,eE=["Float16Array","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array"]),eE}var nE,TL;function akt(){if(TL)return nE;TL=1;var n=okt(),t=typeof globalThis>"u"?BB:globalThis;return nE=function(){for(var s=[],r=0;r<n.length;r++)typeof t[n[r]]=="function"&&(s[s.length]=n[r]);return s},nE}var sE={exports:{}},rE,CL;function lkt(){if(CL)return rE;CL=1;var n=Qv(),t=K5(),e=vb(),s=Pp();return rE=function(i,o,a){if(!i||typeof i!="object"&&typeof i!="function")throw new e("`obj` must be an object or a function`");if(typeof o!="string"&&typeof o!="symbol")throw new e("`property` must be a string or a symbol`");if(arguments.length>3&&typeof arguments[3]!="boolean"&&arguments[3]!==null)throw new e("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&typeof arguments[4]!="boolean"&&arguments[4]!==null)throw new e("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&typeof arguments[5]!="boolean"&&arguments[5]!==null)throw new e("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&typeof arguments[6]!="boolean")throw new e("`loose`, if provided, must be a boolean");var l=arguments.length>3?arguments[3]:null,c=arguments.length>4?arguments[4]:null,f=arguments.length>5?arguments[5]:null,d=arguments.length>6?arguments[6]:!1,m=!!s&&s(i,o);if(n)n(i,o,{configurable:f===null&&m?m.configurable:!f,enumerable:l===null&&m?m.enumerable:!l,value:a,writable:c===null&&m?m.writable:!c});else if(d||!l&&!c&&!f)i[o]=a;else throw new t("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")},rE}var iE,EL;function ukt(){if(EL)return iE;EL=1;var n=Qv(),t=function(){return!!n};return t.hasArrayLengthDefineBug=function(){if(!n)return null;try{return n([],"length",{value:1}).length!==1}catch{return!0}},iE=t,iE}var oE,$L;function ckt(){if($L)return oE;$L=1;var n=J5(),t=lkt(),e=ukt()(),s=Pp(),r=vb(),i=n("%Math.floor%");return oE=function(a,l){if(typeof a!="function")throw new r("`fn` is not a function");if(typeof l!="number"||l<0||l>4294967295||i(l)!==l)throw new r("`length` must be a positive 32-bit integer");var c=arguments.length>2&&!!arguments[2],f=!0,d=!0;if("length"in a&&s){var m=s(a,"length");m&&!m.configurable&&(f=!1),m&&!m.writable&&(d=!1)}return(f||d||!c)&&(e?t(a,"length",l,!0,!0):t(a,"length",l)),a},oE}var aE,AL;function hkt(){if(AL)return aE;AL=1;var n=Sb(),t=k_(),e=Q5();return aE=function(){return e(n,t,arguments)},aE}var kL;function fkt(){return kL||(kL=1,(function(n){var t=ckt(),e=Qv(),s=__(),r=hkt();n.exports=function(o){var a=s(arguments),l=o.length-(arguments.length-1);return t(a,1+(l>0?l:0),!0)},e?e(n.exports,"apply",{value:r}):n.exports.apply=r})(sE)),sE.exports}var lE,_L;function tq(){if(_L)return lE;_L=1;var n=ikt(),t=akt(),e=fkt(),s=Ib(),r=Pp(),i=N_(),o=s("Object.prototype.toString"),a=Yv()(),l=typeof globalThis>"u"?BB:globalThis,c=t(),f=s("String.prototype.slice"),d=s("Array.prototype.indexOf",!0)||function(x,S){for(var T=0;T<x.length;T+=1)if(x[T]===S)return T;return-1},m={__proto__:null};a&&r&&i?n(c,function(w){var x=new l[w];if(Symbol.toStringTag in x&&i){var S=i(x),T=r(S,Symbol.toStringTag);if(!T&&S){var $=i(S);T=r($,Symbol.toStringTag)}m["$"+w]=e(T.get)}}):n(c,function(w){var x=new l[w],S=x.slice||x.set;S&&(m["$"+w]=e(S))});var y=function(x){var S=!1;return n(m,function(T,$){if(!S)try{"$"+T(x)===$&&(S=f($,1))}catch{}}),S},b=function(x){var S=!1;return n(m,function(T,$){if(!S)try{T(x),S=f($,1)}catch{}}),S};return lE=function(x){if(!x||typeof x!="object")return!1;if(!a){var S=f(o(x),8,-1);return d(c,S)>-1?S:S!=="Object"?!1:b(x)}return r?y(x):null},lE}var uE,NL;function dkt(){if(NL)return uE;NL=1;var n=tq();return uE=function(e){return!!n(e)},uE}var RL;function pkt(){return RL||(RL=1,(function(n){var t=JAt(),e=skt(),s=tq(),r=dkt();function i(Nt){return Nt.call.bind(Nt)}var o=typeof BigInt<"u",a=typeof Symbol<"u",l=i(Object.prototype.toString),c=i(Number.prototype.valueOf),f=i(String.prototype.valueOf),d=i(Boolean.prototype.valueOf);if(o)var m=i(BigInt.prototype.valueOf);if(a)var y=i(Symbol.prototype.valueOf);function b(Nt,Ie){if(typeof Nt!="object")return!1;try{return Ie(Nt),!0}catch{return!1}}n.isArgumentsObject=t,n.isGeneratorFunction=e,n.isTypedArray=r;function w(Nt){return typeof Promise<"u"&&Nt instanceof Promise||Nt!==null&&typeof Nt=="object"&&typeof Nt.then=="function"&&typeof Nt.catch=="function"}n.isPromise=w;function x(Nt){return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?ArrayBuffer.isView(Nt):r(Nt)||U(Nt)}n.isArrayBufferView=x;function S(Nt){return s(Nt)==="Uint8Array"}n.isUint8Array=S;function T(Nt){return s(Nt)==="Uint8ClampedArray"}n.isUint8ClampedArray=T;function $(Nt){return s(Nt)==="Uint16Array"}n.isUint16Array=$;function E(Nt){return s(Nt)==="Uint32Array"}n.isUint32Array=E;function R(Nt){return s(Nt)==="Int8Array"}n.isInt8Array=R;function B(Nt){return s(Nt)==="Int16Array"}n.isInt16Array=B;function N(Nt){return s(Nt)==="Int32Array"}n.isInt32Array=N;function k(Nt){return s(Nt)==="Float32Array"}n.isFloat32Array=k;function _(Nt){return s(Nt)==="Float64Array"}n.isFloat64Array=_;function F(Nt){return s(Nt)==="BigInt64Array"}n.isBigInt64Array=F;function A(Nt){return s(Nt)==="BigUint64Array"}n.isBigUint64Array=A;function P(Nt){return l(Nt)==="[object Map]"}P.working=typeof Map<"u"&&P(new Map);function L(Nt){return typeof Map>"u"?!1:P.working?P(Nt):Nt instanceof Map}n.isMap=L;function tt(Nt){return l(Nt)==="[object Set]"}tt.working=typeof Set<"u"&&tt(new Set);function st(Nt){return typeof Set>"u"?!1:tt.working?tt(Nt):Nt instanceof Set}n.isSet=st;function j(Nt){return l(Nt)==="[object WeakMap]"}j.working=typeof WeakMap<"u"&&j(new WeakMap);function Z(Nt){return typeof WeakMap>"u"?!1:j.working?j(Nt):Nt instanceof WeakMap}n.isWeakMap=Z;function J(Nt){return l(Nt)==="[object WeakSet]"}J.working=typeof WeakSet<"u"&&J(new WeakSet);function ot(Nt){return J(Nt)}n.isWeakSet=ot;function pt(Nt){return l(Nt)==="[object ArrayBuffer]"}pt.working=typeof ArrayBuffer<"u"&&pt(new ArrayBuffer);function q(Nt){return typeof ArrayBuffer>"u"?!1:pt.working?pt(Nt):Nt instanceof ArrayBuffer}n.isArrayBuffer=q;function et(Nt){return l(Nt)==="[object DataView]"}et.working=typeof ArrayBuffer<"u"&&typeof DataView<"u"&&et(new DataView(new ArrayBuffer(1),0,1));function U(Nt){return typeof DataView>"u"?!1:et.working?et(Nt):Nt instanceof DataView}n.isDataView=U;var X=typeof SharedArrayBuffer<"u"?SharedArrayBuffer:void 0;function nt(Nt){return l(Nt)==="[object SharedArrayBuffer]"}function xt(Nt){return typeof X>"u"?!1:(typeof nt.working>"u"&&(nt.working=nt(new X)),nt.working?nt(Nt):Nt instanceof X)}n.isSharedArrayBuffer=xt;function Ot(Nt){return l(Nt)==="[object AsyncFunction]"}n.isAsyncFunction=Ot;function qt(Nt){return l(Nt)==="[object Map Iterator]"}n.isMapIterator=qt;function zt(Nt){return l(Nt)==="[object Set Iterator]"}n.isSetIterator=zt;function Wt(Nt){return l(Nt)==="[object Generator]"}n.isGeneratorObject=Wt;function Xt(Nt){return l(Nt)==="[object WebAssembly.Module]"}n.isWebAssemblyCompiledModule=Xt;function te(Nt){return b(Nt,c)}n.isNumberObject=te;function oe(Nt){return b(Nt,f)}n.isStringObject=oe;function fe(Nt){return b(Nt,d)}n.isBooleanObject=fe;function pe(Nt){return o&&b(Nt,m)}n.isBigIntObject=pe;function ie(Nt){return a&&b(Nt,y)}n.isSymbolObject=ie;function Ae(Nt){return te(Nt)||oe(Nt)||fe(Nt)||pe(Nt)||ie(Nt)}n.isBoxedPrimitive=Ae;function Ge(Nt){return typeof Uint8Array<"u"&&(q(Nt)||xt(Nt))}n.isAnyArrayBuffer=Ge,["isProxy","isExternal","isModuleNamespaceObject"].forEach(function(Nt){Object.defineProperty(n,Nt,{enumerable:!1,value:function(){throw new Error(Nt+" is not supported in userland")}})})})(hC)),hC}var cE,DL;function mkt(){return DL||(DL=1,cE=function(t){return t&&typeof t=="object"&&typeof t.copy=="function"&&typeof t.fill=="function"&&typeof t.readUInt8=="function"}),cE}var S1={exports:{}},OL;function gkt(){return OL||(OL=1,typeof Object.create=="function"?S1.exports=function(t,e){e&&(t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}))}:S1.exports=function(t,e){if(e){t.super_=e;var s=function(){};s.prototype=e.prototype,t.prototype=new s,t.prototype.constructor=t}}),S1.exports}var FL;function ykt(){return FL||(FL=1,(function(n){var t={},e=Object.getOwnPropertyDescriptors||function(X){for(var nt=Object.keys(X),xt={},Ot=0;Ot<nt.length;Ot++)xt[nt[Ot]]=Object.getOwnPropertyDescriptor(X,nt[Ot]);return xt},s=/%[sdj%]/g;n.format=function(U){if(!B(U)){for(var X=[],nt=0;nt<arguments.length;nt++)X.push(a(arguments[nt]));return X.join(" ")}for(var nt=1,xt=arguments,Ot=xt.length,qt=String(U).replace(s,function(Wt){if(Wt==="%%")return"%";if(nt>=Ot)return Wt;switch(Wt){case"%s":return String(xt[nt++]);case"%d":return Number(xt[nt++]);case"%j":try{return JSON.stringify(xt[nt++])}catch{return"[Circular]"}default:return Wt}}),zt=xt[nt];nt<Ot;zt=xt[++nt])$(zt)||!F(zt)?qt+=" "+zt:qt+=" "+a(zt);return qt},n.deprecate=function(U,X){if(typeof Un<"u"&&Un.noDeprecation===!0)return U;if(typeof Un>"u")return function(){return n.deprecate(U,X).apply(this,arguments)};var nt=!1;function xt(){if(!nt){if(Un.throwDeprecation)throw new Error(X);Un.traceDeprecation?console.trace(X):console.error(X),nt=!0}return U.apply(this,arguments)}return xt};var r={},i=/^$/;if(t.NODE_DEBUG){var o=t.NODE_DEBUG;o=o.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".*").replace(/,/g,"$|^").toUpperCase(),i=new RegExp("^"+o+"$","i")}n.debuglog=function(U){if(U=U.toUpperCase(),!r[U])if(i.test(U)){var X=Un.pid;r[U]=function(){var nt=n.format.apply(n,arguments);console.error("%s %d: %s",U,X,nt)}}else r[U]=function(){};return r[U]};function a(U,X){var nt={seen:[],stylize:c};return arguments.length>=3&&(nt.depth=arguments[2]),arguments.length>=4&&(nt.colors=arguments[3]),T(X)?nt.showHidden=X:X&&n._extend(nt,X),k(nt.showHidden)&&(nt.showHidden=!1),k(nt.depth)&&(nt.depth=2),k(nt.colors)&&(nt.colors=!1),k(nt.customInspect)&&(nt.customInspect=!0),nt.colors&&(nt.stylize=l),d(nt,U,nt.depth)}n.inspect=a,a.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},a.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"};function l(U,X){var nt=a.styles[X];return nt?"\x1B["+a.colors[nt][0]+"m"+U+"\x1B["+a.colors[nt][1]+"m":U}function c(U,X){return U}function f(U){var X={};return U.forEach(function(nt,xt){X[nt]=!0}),X}function d(U,X,nt){if(U.customInspect&&X&&L(X.inspect)&&X.inspect!==n.inspect&&!(X.constructor&&X.constructor.prototype===X)){var xt=X.inspect(nt,U);return B(xt)||(xt=d(U,xt,nt)),xt}var Ot=m(U,X);if(Ot)return Ot;var qt=Object.keys(X),zt=f(qt);if(U.showHidden&&(qt=Object.getOwnPropertyNames(X)),P(X)&&(qt.indexOf("message")>=0||qt.indexOf("description")>=0))return y(X);if(qt.length===0){if(L(X)){var Wt=X.name?": "+X.name:"";return U.stylize("[Function"+Wt+"]","special")}if(_(X))return U.stylize(RegExp.prototype.toString.call(X),"regexp");if(A(X))return U.stylize(Date.prototype.toString.call(X),"date");if(P(X))return y(X)}var Xt="",te=!1,oe=["{","}"];if(S(X)&&(te=!0,oe=["[","]"]),L(X)){var fe=X.name?": "+X.name:"";Xt=" [Function"+fe+"]"}if(_(X)&&(Xt=" "+RegExp.prototype.toString.call(X)),A(X)&&(Xt=" "+Date.prototype.toUTCString.call(X)),P(X)&&(Xt=" "+y(X)),qt.length===0&&(!te||X.length==0))return oe[0]+Xt+oe[1];if(nt<0)return _(X)?U.stylize(RegExp.prototype.toString.call(X),"regexp"):U.stylize("[Object]","special");U.seen.push(X);var pe;return te?pe=b(U,X,nt,zt,qt):pe=qt.map(function(ie){return w(U,X,nt,zt,ie,te)}),U.seen.pop(),x(pe,Xt,oe)}function m(U,X){if(k(X))return U.stylize("undefined","undefined");if(B(X)){var nt="'"+JSON.stringify(X).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return U.stylize(nt,"string")}if(R(X))return U.stylize(""+X,"number");if(T(X))return U.stylize(""+X,"boolean");if($(X))return U.stylize("null","null")}function y(U){return"["+Error.prototype.toString.call(U)+"]"}function b(U,X,nt,xt,Ot){for(var qt=[],zt=0,Wt=X.length;zt<Wt;++zt)ot(X,String(zt))?qt.push(w(U,X,nt,xt,String(zt),!0)):qt.push("");return Ot.forEach(function(Xt){Xt.match(/^\d+$/)||qt.push(w(U,X,nt,xt,Xt,!0))}),qt}function w(U,X,nt,xt,Ot,qt){var zt,Wt,Xt;if(Xt=Object.getOwnPropertyDescriptor(X,Ot)||{value:X[Ot]},Xt.get?Xt.set?Wt=U.stylize("[Getter/Setter]","special"):Wt=U.stylize("[Getter]","special"):Xt.set&&(Wt=U.stylize("[Setter]","special")),ot(xt,Ot)||(zt="["+Ot+"]"),Wt||(U.seen.indexOf(Xt.value)<0?($(nt)?Wt=d(U,Xt.value,null):Wt=d(U,Xt.value,nt-1),Wt.indexOf(`
`)>-1&&(qt?Wt=Wt.split(`
`).map(function(te){return"  "+te}).join(`
`).slice(2):Wt=`
`+Wt.split(`
`).map(function(te){return"   "+te}).join(`
`))):Wt=U.stylize("[Circular]","special")),k(zt)){if(qt&&Ot.match(/^\d+$/))return Wt;zt=JSON.stringify(""+Ot),zt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(zt=zt.slice(1,-1),zt=U.stylize(zt,"name")):(zt=zt.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),zt=U.stylize(zt,"string"))}return zt+": "+Wt}function x(U,X,nt){var xt=U.reduce(function(Ot,qt){return qt.indexOf(`
`)>=0,Ot+qt.replace(/\u001b\[\d\d?m/g,"").length+1},0);return xt>60?nt[0]+(X===""?"":X+`
 `)+" "+U.join(`,
  `)+" "+nt[1]:nt[0]+X+" "+U.join(", ")+" "+nt[1]}n.types=pkt();function S(U){return Array.isArray(U)}n.isArray=S;function T(U){return typeof U=="boolean"}n.isBoolean=T;function $(U){return U===null}n.isNull=$;function E(U){return U==null}n.isNullOrUndefined=E;function R(U){return typeof U=="number"}n.isNumber=R;function B(U){return typeof U=="string"}n.isString=B;function N(U){return typeof U=="symbol"}n.isSymbol=N;function k(U){return U===void 0}n.isUndefined=k;function _(U){return F(U)&&st(U)==="[object RegExp]"}n.isRegExp=_,n.types.isRegExp=_;function F(U){return typeof U=="object"&&U!==null}n.isObject=F;function A(U){return F(U)&&st(U)==="[object Date]"}n.isDate=A,n.types.isDate=A;function P(U){return F(U)&&(st(U)==="[object Error]"||U instanceof Error)}n.isError=P,n.types.isNativeError=P;function L(U){return typeof U=="function"}n.isFunction=L;function tt(U){return U===null||typeof U=="boolean"||typeof U=="number"||typeof U=="string"||typeof U=="symbol"||typeof U>"u"}n.isPrimitive=tt,n.isBuffer=mkt();function st(U){return Object.prototype.toString.call(U)}function j(U){return U<10?"0"+U.toString(10):U.toString(10)}var Z=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function J(){var U=new Date,X=[j(U.getHours()),j(U.getMinutes()),j(U.getSeconds())].join(":");return[U.getDate(),Z[U.getMonth()],X].join(" ")}n.log=function(){console.log("%s - %s",J(),n.format.apply(n,arguments))},n.inherits=gkt(),n._extend=function(U,X){if(!X||!F(X))return U;for(var nt=Object.keys(X),xt=nt.length;xt--;)U[nt[xt]]=X[nt[xt]];return U};function ot(U,X){return Object.prototype.hasOwnProperty.call(U,X)}var pt=typeof Symbol<"u"?Symbol("util.promisify.custom"):void 0;n.promisify=function(X){if(typeof X!="function")throw new TypeError('The "original" argument must be of type Function');if(pt&&X[pt]){var nt=X[pt];if(typeof nt!="function")throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(nt,pt,{value:nt,enumerable:!1,writable:!1,configurable:!0}),nt}function nt(){for(var xt,Ot,qt=new Promise(function(Xt,te){xt=Xt,Ot=te}),zt=[],Wt=0;Wt<arguments.length;Wt++)zt.push(arguments[Wt]);zt.push(function(Xt,te){Xt?Ot(Xt):xt(te)});try{X.apply(this,zt)}catch(Xt){Ot(Xt)}return qt}return Object.setPrototypeOf(nt,Object.getPrototypeOf(X)),pt&&Object.defineProperty(nt,pt,{value:nt,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(nt,e(X))},n.promisify.custom=pt;function q(U,X){if(!U){var nt=new Error("Promise was rejected with a falsy value");nt.reason=U,U=nt}return X(U)}function et(U){if(typeof U!="function")throw new TypeError('The "original" argument must be of type Function');function X(){for(var nt=[],xt=0;xt<arguments.length;xt++)nt.push(arguments[xt]);var Ot=nt.pop();if(typeof Ot!="function")throw new TypeError("The last argument must be of type Function");var qt=this,zt=function(){return Ot.apply(qt,arguments)};U.apply(this,nt).then(function(Wt){Un.nextTick(zt.bind(null,null,Wt))},function(Wt){Un.nextTick(q.bind(null,Wt,zt))})}return Object.setPrototypeOf(X,Object.getPrototypeOf(U)),Object.defineProperties(X,e(U)),X}n.callbackify=et})(cC)),cC}var bkt=ykt();function xkt(n,t){return Lx(n,t)}function Lx(n,t,e=new Map,s=new Set){if(n==null)return null;if(typeof Blob=="function"&&n instanceof Blob)return n.slice();if(s.has(n))throw new Error("Circular references are not supported.");if(e.has(n))return e.get(n);const r=t(n);if(r.recurse&&r.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse)if(op(n)){const i=Array.isArray(n)?[]:{};s.add(n);for(const o in n){const a=n[o],l=Lx(a,t,e,s);i[o]=l}return s.delete(n),n.__proto__&&(i.__proto__=n.__proto__),i}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return e.set(n,r.value),r.value}function wkt(n,t=nq){return eq(n,t)}function eq(n,t,e=new Set){const s=n[0];if(e.has(s))throw new Error("Circular references are not supported.");const r=t(n);if(r.recurse&&r.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse)if(op(s)){const i=Array.isArray(s)?[]:{};e.add(s);for(const o in s){const a=n.map(c=>c[o]),l=eq(a,t,e);i[o]=l}return e.delete(s),i}else throw new Error(`Can't recurse into non-iterable type: ${s}`);else return r.value}function nq(n){return n===null?null:op(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}async function sq(n,t){const e=new Map;Lx(n,t,e);for(const r of Array.from(e.keys())){const i=e.get(r);if(e_(i)){const o=await i;e.set(r,o)}}return Lx(n,t,e)}function op(n){let t=!1;if(bn().get("IS_BROWSER"))t=n instanceof TextDecoder;else{const{StringDecoder:e}=require("string_decoder");t=n instanceof e}return n!=null&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||typeof n=="object"&&!(n instanceof Zn)&&!(n instanceof Promise)&&!t)}function vkt(n){return n==null||Skt(n)||Array.isArray(n)||typeof n=="object"&&n instanceof Zn||ca(n)}function Skt(n){return n===null||typeof n!="object"&&typeof n!="function"}function Ikt(n){return xkt(n,Tkt)}function Tkt(n){return n instanceof Zn?{value:n.clone(),recurse:!1}:op(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}class rq{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,t==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),s=this.get(e);return this.set(e,this.pop()),s}}class Zv extends rq{constructor(){super(Zv.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=this.capacity*2,e=new Array(t),s=this.length();for(let r=0;r<s;r++)e[r]=this.get(this.wrap(this.begin+r));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=s}}Zv.INITIAL_CAPACITY=32;function iq(n){return new Akt(n)}function Ckt(n){return new kkt(n)}function Ekt(n,t){return new oq(n,t)}function $kt(n,t=Xu.FAIL){return new Bkt(n,t)}class hi{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let s=await t.next();for(;!s.done;)e.push(s.value),s=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),s=t(e.value);for(;!e.done&&s;)e=await this.next(),s=t(e.value)}handleErrors(t){return new Mkt(this,t)}filter(t){return new Okt(this,t)}map(t){return new Fkt(this,t)}mapAsync(t){return new ML(this,t)}serialMapAsync(t){return new ML(this,t).serial()}flatmap(t){return new zkt(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(e=>e===!0)}rowMajorBatch(t,e=!0){return new Dkt(this,t,e)}columnMajorBatch(t,e=!0,s=nq){return this.rowMajorBatch(t,e).map(i=>wkt(i,s))}concatenate(t,e){return new oq(iq([this,t]),e)}take(t){return t<0||t==null?this:new Rkt(this,t)}skip(t){return t<0||t==null?this:new Nkt(this,t)}prefetch(t){return new aq(this,t)}shuffle(t,e){return new Pkt(this,t,e)}serial(){return new _kt(this)}}class Akt extends hi{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:Ikt(t),done:!1}}}class kkt extends hi{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}}class _kt extends hi{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class Nkt extends hi{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;Ee(t.value)}return this.upstream.next()}}class Rkt extends hi{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class Dkt extends hi{constructor(t,e,s=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=s,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class Okt extends hi{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;Ee(t.value)}}}class Fkt extends hi{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=pc(t.value),s=this.transform(t.value),r=pc(s);for(const i of e)a_(i,r)||i.dispose();return{value:s,done:!1}}}class Mkt extends hi{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}}class ML extends hi{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=pc(t.value),s=await this.transform(t.value),r=pc(s);for(const i of e)a_(i,r)||i.dispose();return{value:s,done:!1}}}class Lkt extends hi{constructor(){super(),this.outputQueue=new Zv,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class zkt extends Lkt{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const t=await this.upstream.next();if(t.done)return!1;const e=pc(t.value),s=this.transform(t.value),r=pc(s);this.outputQueue.pushAll(s);for(const i of e)a_(i,r)||i.dispose();return!0}}class oq extends hi{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,this.iterator==null){const s=await this.moreIterators.next();if(s.done)return{value:null,done:!0};this.iterator=s.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}var Xu;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(Xu||(Xu={}));class Bkt extends hi{constructor(t,e=Xu.FAIL){super(),this.iterators=t,this.mismatchMode=e,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(t){await t;let e=0,s=0;function r(o){return o instanceof hi?{value:o.next().then(l=>(e++,l.done&&s++,l.value)),recurse:!1}:{value:null,recurse:!0}}const i=await sq(this.iterators,r);if(e===s)return{value:null,done:!0};if(s>0)switch(this.mismatchMode){case Xu.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Xu.SHORTEST:return{value:null,done:!0};case Xu.LONGEST:}return this.count++,{value:i,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class aq extends hi{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new rq(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class Pkt extends aq{constructor(t,e,s){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=uf.alea(s||xo().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(e.done)this.upstreamExhausted=!0;else return this.refill(),e}return{value:null,done:!0}}}let R_=class{constructor(){this.size=null}batch(t,e=!0){const s=this;Q(t>0,()=>`batchSize needs to be positive, but it is
      ${t}`);let r;return this.size===1/0||this.size==null?r=this.size:e?r=Math.ceil(this.size/t):r=Math.floor(this.size/t),fo(async()=>(await s.iterator()).columnMajorBatch(t,e,Vkt),r)}concatenate(t){const e=this;let s;return this.size===1/0||t.size===1/0?s=1/0:this.size!=null&&t.size!=null?s=this.size+t.size:s=null,fo(async()=>(await e.iterator()).concatenate(await t.iterator()),s)}filter(t){const e=this;let s;return this.size===1/0?s=1/0:s=null,fo(async()=>(await e.iterator()).filter(r=>St(()=>t(r))),s)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return fo(async()=>(await e.iterator()).map(s=>St(()=>t(s))),this.size)}mapAsync(t){const e=this;return fo(async()=>(await e.iterator()).mapAsync(t),this.size)}prefetch(t){if(t==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return fo(async()=>(await e.iterator()).prefetch(t),this.size)}repeat(t){const e=this;let s;return this.size!=null&&t>0?s=this.size*t:t===0?s=0:this.size!=null&&(t===void 0||t<0)?s=1/0:s=null,fo(async()=>{const r=Ckt(async()=>({value:await e.iterator(),done:!1}));return Ekt(r.take(t))},s)}skip(t){const e=this;let s;return this.size!=null&&t>=0&&this.size>=t?s=this.size-t:this.size!=null&&(this.size<t||t===void 0||t<0)?s=0:s=null,fo(async()=>(await e.iterator()).skip(t),s)}shuffle(t,e,s=!0){if(t==null||t<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,i=uf.alea(e||xo().toString());return fo(async()=>{let o=i.int32();return s&&(o+=i.int32()),(await r.iterator()).shuffle(t,o.toString())},this.size)}take(t){const e=this;let s;return this.size!=null&&this.size>t?s=t:this.size!=null&&this.size<=t?s=this.size:s=null,fo(async()=>(await e.iterator()).take(t),s)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};R_.MAX_BUFFER_SIZE=1e4;function fo(n,t=null){return new class extends R_{constructor(){super(...arguments),this.size=t}async iterator(){return n()}}}function I1(n){return fo(async()=>iq(n),n.length)}function LL(n){if(!op(n))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(n))for(let e=0;e<n.length;e++)t=t==null?n[e].size:Math.min(t,n[e].size);else if(n instanceof Object)for(const e in n)t=t==null?n[e].size:Math.min(t,n[e].size);return fo(async()=>{const e=await sq(n,s=>{if(s instanceof R_)return{value:s.iterator(),recurse:!1};if(op(s))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return $kt(e,Xu.SHORTEST)},t)}function Vkt(n){if(n===null)return null;const t=n[0];return vkt(t)?{value:Ukt(n),recurse:!1}:{value:null,recurse:!0}}function Ukt(n){if(n.length===0)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof Zn?yc(n):zd(n)}class Ha extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Ha.prototype)}}class wo extends Error{constructor(t){super(t),Object.setPrototypeOf(this,wo.prototype)}}class ht extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ht.prototype)}}class Le extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Le.prototype)}}class D_ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,D_.prototype)}}class lq{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=t}}function tf(n,t){if(Array.isArray(n)){let e=[];for(let s=0;s<t;s++)e=e.concat(n);return e}else{const e=new Array(t);return e.fill(n),e}}function Ka(n,t){if(!n)throw new D_(t)}function zL(n,t){let e=0;for(const s of n)s===t&&e++;return e}function ri(n){return n.length===1?n[0]:n}function jn(n){return Array.isArray(n)?n:[n]}function Vl(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function vh(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let ho={};function O_(n){if(n==null)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function k$(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(t=>k$(t));else{const t=Object.keys(n);for(const e of t){const s=n[e];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[e]=s.value:k$(s))}}}function Tb(n,t={},e={},s="object",r=!1){if(typeof n=="string"){const i=n;let o;if(i in e)o=e[i];else if(i in ho)o=ho[i];else if(o=t[i],o==null)throw new ht(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const i=n;if(i.className==null||i.config==null)throw new ht(`${s}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const o=i.className;let a,l;if(o in e?[a,l]=e[o]:o in ho?[a,l]=ho.className:o in t&&([a,l]=t[o]),a==null)throw new ht(`Unknown ${s}: ${o}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const c={};for(const y of Object.keys(ho))c[y]=ho[y];for(const y of Object.keys(e))c[y]=e[y];const f=i.config;f.customObjects=c;const d=Object.assign({},ho);for(const y of Object.keys(e))ho[y]=e[y];k$(i.config);const m=l(a,i.config,e,r);return ho=Object.assign({},d),m}else{const c=Object.assign({},ho);for(const d of Object.keys(e))ho[d]=e[d];const f=new a(i.config);return ho=Object.assign({},c),f}}}function Gkt(n,t){return n<t?-1:n>t?1:0}function T1(n,t){return-1*Gkt(n,t)}function nc(n){if(n==null)return n;const t=[];for(const e of n)t.indexOf(e)===-1&&t.push(e);return t}function Wkt(n){if(n==null)throw new ht(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function vf(n,t,e){if(e!=null&&n.indexOf(e)<0)throw new ht(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function F_(n,t,e=0,s=1/0){return Ka(e>=0),Ka(s>=e),Array.isArray(n)&&n.length>=e&&n.length<=s&&n.every(r=>typeof r===t)}function ir(n,t){Array.isArray(n)?(Q(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,s)=>ir(e,`element ${s+1} of ${t}`))):Q(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${uq(n)}.`)}function uq(n){return n===null?"null":Array.isArray(n)?"["+n.map(t=>uq(t)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function jkt(n,t,e){let s=e!=null?e():xo(),r;return(...o)=>{const a=e!=null?e():xo();return a-s<t||(s=a,r=n(...o)),r}}function cq(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}let qkt=0;function hq(){return qkt++}const C1={};function Jv(n=""){return n in C1||(C1[n]=0),C1[n]+=1,n+C1[n].toString()}const Hkt=["channelsFirst","channelsLast"],Kkt=["nearest","bilinear"],Xkt=["valid","same","causal"],Ykt=["max","avg"],Qkt=["sum","mul","concat","ave"];const bd=new Map;function Ss(n){vf(Hkt,"DataFormat",n)}function Zkt(n){vf(Kkt,"InterpolationFormat",n)}function Yi(n){vf(Xkt,"PaddingMode",n)}function fq(n){vf(Ykt,"PoolMode",n)}const yg=[],BL="/";function Rh(n,t){yg.push(n);try{const e=t();return yg.pop(),e}catch(e){throw yg.pop(),e}}function Jkt(){return yg.length===0?"":yg.join(BL)+BL}function dq(n){if(!mq(n))throw new Error("Not a valid tensor name: '"+n+"'");return Jkt()+n}function pq(n){if(!mq(n))throw new Error("Not a valid tensor name: '"+n+"'");bd.has(n)||bd.set(n,0);const t=bd.get(n);if(bd.set(n,bd.get(n)+1),t>0){const e=`${n}_${t}`;return bd.set(e,1),e}else return n}const t_t=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function mq(n){return!!n.match(t_t)}function e_t(n){return n===parseInt(n.toString(),10)}function sc(n,t,e){t==null&&(t=0),e==null&&(e=n.length);let s=1;for(let r=t;r<e;++r)s*=n[r];return s}function ap(n){if(n.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s<t&&(t=s)}return t}function bc(n){if(n.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s>t&&(t=s)}return t}function fa(n,t){if(t<n)throw new ht(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let s=n;s<t;++s)e.push(s);return e}let hE;function js(){return hE==null&&(hE=h_().epsilon()),hE}function da(){return"channelsLast"}function Cb(n,t){return le(n,t)}function Eb(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),kt(n,e)}function n_t(n,t){return St(()=>{if(n.shape.length!==2)throw new ht(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const e=Eb(n,1);return _$(e,[1,t,1])})}function s_t(n){const t=[sc(n.shape)];return kt(n,t)}function r_t(n){if(n.rank<=1)throw new ht(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],sc(n.shape,1)];return kt(n,t)}function Dh(n,t,e){return St(()=>{switch(n.rank){case 1:return b_(n,t,e);case 2:return B5(n,[t,0],[e,n.shape[1]]);case 3:return x_(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return Mx(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Qn(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Qn(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new ht(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function fE(n,t,e){return St(()=>{switch(n.rank){case 1:return b_(n,t,e);case 2:return B5(n,[0,t],[n.shape[0],e]);case 3:return x_(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return Mx(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new ht(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function E1(n,t,e,s){return St(()=>{switch(n.rank){case 1:return b_(n,t,e);case 2:switch(s){case 1:return Dh(n,t,e);case 2:return fE(n,t,e);default:throw new ht(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Dh(n,t,e);case 2:return x_(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return fE(n,t,e);default:throw new ht(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Dh(n,t,e);case 2:return Mx(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return Mx(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return fE(n,t,e);default:throw new ht(`The axis is not within the rank of the tensor ${s}`)}default:throw new ht(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function M_(n,t=-1){let e;return t<0&&(e=n[0].rank,e!==0?t=e:t=0),t===n[0].rank&&(t=-1),na(n,t)}function PL(n,t){switch(n.rank){case 1:return EEt([n,t]);case 2:return AEt([n,t],0);case 3:return _Et([n,t],0);case 4:return REt([n,t],0);default:throw new ht(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function _$(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new ht(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return Ja(n,t)}function tS(n,t=0,e=1,s,r){return Y$t(n,t,e,s,r)}function al(n,t,e,s){if(n.rank<2||t.rank<2)throw new Le(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3){const r=n.shape.slice(-1)[0],i=t.shape.slice(-2)[0];if(r!==i)throw new Le(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`)}if(n.rank===2&&t.rank===2)return N3({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?N$(n.rank,s,da()):null,activation:e});{const r=n.shape.slice(),i=r.pop();n=kt(n,[-1,i]);const o=t.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],f=Array.from({length:t.rank},(b,w)=>w===0?t.rank-2:w<=t.rank-2?w-1:w);t=kt(nn(t,f),[l,-1]);const d=[...r,...c];return kt(N3({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?N$(n.rank,s,da()):null,activation:e}),d)}}function gq(n,t,e){return St(()=>(Array.isArray(t)?t=_r(t,"int32"):t=le(t,"int32"),Nd(n,t,e)))}function $b(n){return mt(n,n)}function N$(n,t,e){const s=t.shape;if(t.rank!==1&&t.rank!==n)throw new ht(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(n===5){if(e==="channelsFirst")return s.length===1?kt(t,[1,s[0],1,1,1]):kt(t,[1,s[3],s[0],s[1],s[2]]);if(e==="channelsLast")return s.length===1?kt(t,[1,1,1,1,s[0]]):kt(t,[1].concat(s))}else if(n===4){if(e==="channelsFirst")return s.length===1?kt(t,[1,s[0],1,1]):kt(t,[1,s[2],s[0],s[1]]);if(e==="channelsLast")return s.length===1?kt(t,[1,1,1,s[0]]):kt(t,[1].concat(s))}else if(n===3){if(e==="channelsFirst")return s.length===1?kt(t,[1,s[0],1]):kt(t,[1,s[1],s[0]]);if(e==="channelsLast")return s.length===1?kt(t,[1,1,s[0]]):kt(t,[1].concat(s))}else if(n<3)return t;throw new ht(`Unsupported input rank by biasAdd: ${t.rank}`)}function ya(n,t,e){return St(()=>(e==null&&(e=da()),Ss(e),Qt(n,N$(n.rank,t,e))))}function i_t(n,t=1){if(t!==1)throw new Le(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return p_(n)}function o_t(n){return St(()=>we(n,Qt(Jr(n),1)))}function yq(n,t,e,s){return St(()=>N2t(n,t,e,s))}function a_t(n){return St(()=>{const t=Qt(.5,mt(.2,n));return To(t,0,1)})}function Ab(n,t,e=!1){return e?n():t()}const l_t=["fanIn","fanOut","fanAvg"],u_t=["normal","uniform","truncatedNormal"];function c_t(n){vf(l_t,"FanMode",n)}function h_t(n){vf(u_t,"Distribution",n)}class _o extends Mp{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class bq extends _o{apply(t,e){return gr(t,e)}}bq.className="Zeros";Kt(bq);class L_ extends _o{apply(t,e){return wf(t,e)}}L_.className="Ones";Kt(L_);class xq extends _o{constructor(t){if(super(),typeof t!="object")throw new ht(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new ht(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return St(()=>mt(xn(this.value),wf(t,e)))}getConfig(){return{value:this.value}}}xq.className="Constant";Kt(xq);class wq extends _o{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return Hv(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}wq.className="RandomUniform";Kt(wq);class vq extends _o{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Le(`randomNormal does not support dType ${e}.`);return tS(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}vq.className="RandomNormal";Kt(vq);class Sq extends _o{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Le(`truncatedNormal does not support dType ${e}.`);return V5(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Sq.className="TruncatedNormal";Kt(Sq);class Iq extends _o{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,e){return St(()=>{if(t.length!==2||t[0]!==t[1])throw new ht("Identity matrix initializer can only be used for 2D square matrices.");return mt(this.gain,D5(t[0]))})}getConfig(){return{gain:this.gain}}}Iq.className="Identity";Kt(Iq);function f_t(n,t="channelsLast"){let e,s;if(Ss(t),n.length===2)e=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(t==="channelsFirst"){const r=sc(n,2);e=n[1]*r,s=n[0]*r}else if(t==="channelsLast"){const r=sc(n,0,n.length-2);e=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=sc(n);e=Math.sqrt(r),s=Math.sqrt(r)}return[e,s]}class _i extends _o{constructor(t){if(super(),t.scale<0)throw new ht(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,c_t(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,h_t(this.distribution),this.seed=t.seed}apply(t,e){const s=f_t(t),r=s[0],i=s[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,r):this.mode==="fanOut"?o/=Math.max(1,i):o/=Math.max(1,(r+i)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Le(`${this.getClassName()} does not support dType ${e}.`);return V5(t,0,a,e,this.seed)}else{const a=Math.sqrt(3*o);return Hv(t,-a,a,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}_i.className="VarianceScaling";Kt(_i);class z_ extends _i{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return _i.className}}z_.className="GlorotUniform";Kt(z_);class B_ extends _i{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return _i.className}}B_.className="GlorotNormal";Kt(B_);class P_ extends _i{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return _i.className}}P_.className="HeNormal";Kt(P_);class V_ extends _i{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return _i.className}}V_.className="HeUniform";Kt(V_);class U_ extends _i{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return _i.className}}U_.className="LeCunNormal";Kt(U_);class G_ extends _i{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return _i.className}}G_.className="LeCunNormal";Kt(G_);class Tq extends _o{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,this.seed!=null)throw new Le("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return St(()=>{if(t.length<2)throw new Le("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);const s=t[0]>t[1]?[t[1],t[0]]:t,r=tS(s,0,1,"float32");let i=_At.gramSchmidt(r);return t[0]>t[1]&&(i=nn(i)),mt(this.gain,i)})}getConfig(){return{gain:this.gain,seed:this.seed}}}Tq.className="Orthogonal";Kt(Tq);const VL={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function UL(n,t={}){return Tb(n,go.getMap().classNameMap,t,"initializer")}function cs(n){return O_(n)}function es(n){if(typeof n=="string"){const t=n in VL?VL[n]:n;if(t==="GlorotNormal")return new B_;if(t==="GlorotUniform")return new z_;if(t==="HeNormal")return new P_;if(t==="HeUniform")return new V_;if(t==="LeCunNormal")return new U_;if(t==="LeCunUniform")return new G_;{const e={};return e.className=t,e.config={},UL(e)}}else return n instanceof _o?n:UL(n)}function R$(n){return Array.isArray(n)&&Array.isArray(n[0])}function zx(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function Re(n){let t;if(Array.isArray(n)){if(n.length!==1)throw new ht(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function In(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new ht(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function Bx(n){let t=0;for(const e of n)e.shape.length===0?t+=1:t+=e.shape.reduce((s,r)=>s*r);return t}const GL="Variable";class d_t{constructor(t,e="float32",s=GL,r=!0,i=null){this.dtype=e??"float32",this.shape=t.shape,this.id=hq(),s=s??GL,this.originalName=dq(s),this.name=pq(this.originalName),this.trainable_=r,this.constraint=i,this.val=A2t(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),p_t(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function p_t(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}function D$(n){return n.map(t=>t.read())}function W_(n){n.forEach(t=>{t[0].write(t[1])})}class qs{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class tl{constructor(t,e,s,r,i,o,a){this.dtype=t,this.shape=e,this.sourceLayer=s,this.inputs=r,this.callArgs=i,this.outputTensorIndex=a,this.id=hq(),o!=null&&(this.originalName=dq(o),this.name=pq(this.originalName)),this.rank=e.length}}let m_t=0;class eS{constructor(t,e){this.callArgs=e,this.id=m_t++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const s of t.inboundLayers)s?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let g_t=0;class Ze extends Mp{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=g_t++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const s=this.getClassName();e=Vl(s)+"_"+Jv(s)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let s;if(t.batchInputShape!=null)s=t.batchInputShape;else if(t.inputShape!=null){let i=null;t.batchSize!=null&&(i=t.batchSize),s=[i].concat(t.inputShape)}this.batchInputShape=s;let r=t.dtype;r==null&&(r=t.inputDType),r==null&&(r="float32"),this.dtype=r}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new wo(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new ht(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return ri(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return ri(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ha(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Ha(`Layer ${this.name} is not connected, no input to return.`);return ri(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Ha(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ha(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ri(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=jn(t),this.inputSpec==null||this.inputSpec.length===0)return;const e=jn(this.inputSpec);if(t.length!==e.length)throw new ht(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let s=0;s<t.length;s++){const r=t[s],i=e[s];if(i==null)continue;const o=r.rank;if(i.ndim!=null&&o!==i.ndim)throw new ht(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${o}`);if(i.maxNDim!=null&&o>i.maxNDim)throw new ht(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${o}`);if(i.minNDim!=null&&o<i.minNDim)throw new ht(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${o}.`);if(i.dtype!=null&&r.dtype!==i.dtype)throw new ht(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${r.dtype}.`);if(i.axes){const a=r.shape;for(const l in i.axes){const c=Number(l),f=i.axes[l],d=c>=0?a[c]:a[a.length+c];if(f!=null&&[f,null].indexOf(d)===-1)throw new ht(`Input ${s} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${f} but got shape ${a}.`)}}if(i.shape!=null)for(let a=0;a<i.shape.length;++a){const l=i.shape[a],c=r.shape[a];if(l!=null&&c!=null&&l!==c)throw new ht(`Input ${s} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${r.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const s=jn(t);let r=!0;for(const o of s)if(!(o instanceof tl)){r=!1;break}let i=!0;for(const o of s)if(o instanceof tl){i=!1;break}if(r===i)throw new ht("Arguments to apply() must be all SymbolicTensors or all Tensors");return Rh(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const o=[];for(const a of jn(t))o.push(a.shape);this.build(ri(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(t),i){let o=this.call(t,e);const a=jn(o),l=[];for(let c of a)s.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(o=ri(l),this.activityRegularizer!=null)throw new Le("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=y_t(t),a=this.computeOutputShape(o);let l;const c=b_t(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((f,d)=>new tl(c,f,this,jn(t),e,this.name,d)):l=new tl(c,a,this,jn(t),e,this.name),this.addInboundNode(t,l,null,null,o,a,e),this._refCount++,this.activityRegularizer!=null)throw new Le("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&t[r]!=null&&t[r]!==s&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Ha(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const s=JSON.stringify(e.outputShapes);t.indexOf(s)===-1&&t.push(s)}if(t.length===1){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new Ha(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new wo(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Bx(this.weights)}build(t){this.built=!0}getWeights(t=!1){return D$(t?this.trainableWeights:this.weights)}setWeights(t){St(()=>{const e=this.weights;if(e.length!==t.length)throw new ht(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;const s=[],r=D$(e);for(let i=0;i<r.length;++i){const o=r[i],a=e[i],l=t[i];if(!ci(o.shape,l.shape))throw new ht(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);s.push([a,l])}W_(s)})}addWeight(t,e,s,r,i,o,a,l){if(this._addedWeightNames.indexOf(t)!==-1)throw new ht(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=l!=null?l():es("zeros"));const c=r.apply(e,s),f=new d_t(c,s,t,o,a);return c.dispose(),i!=null&&this.addLoss(()=>i.apply(f.read())),o==null&&(o=!0),o?this._trainableWeights.push(f):this._nonTrainableWeights.push(f),f}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=jn(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}addInboundNode(t,e,s,r,i,o,a=null){const l=jn(t);e=jn(e),s=jn(s),r=jn(r),i=zx(i),o=zx(o);const c=[],f=[],d=[];for(const m of l)c.push(m.sourceLayer),f.push(m.nodeIndex),d.push(m.tensorIndex);new eS({outboundLayer:this,inboundLayers:c,nodeIndices:f,tensorIndices:d,inputTensors:l,outputTensors:e,inputMasks:s,outputMasks:r,inputShapes:i,outputShapes:o},a);for(let m=0;m<e.length;m++)e[m].sourceLayer=this,e[m].nodeIndex=this.inboundNodes.length-1,e[m].tensorIndex=m}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function y_t(n){n=jn(n);const t=[];for(const e of n)t.push(e.shape);return ri(t)}function b_t(n){return"float32"}function Cq(n,t,e){if((t==null||e!=null&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),t.inboundNodes.length===0)return[n];{const s=t.inboundNodes[e];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let i=0;i<s.inboundLayers.length;i++){const o=s.inputTensors[i],a=s.inboundLayers[i],l=s.nodeIndices[i],c=Cq(o,a,l);for(const f of c)r.indexOf(f)===-1&&r.push(f)}return r}}}class kb extends Ze{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:Jv("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new ht("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new ht("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new ht("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=t.dtype||"float32";this.batchInputShape=e,this.dtype=s,this.inputSpec=[{shape:e}];const r=new tl(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new eS({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new ht(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}kb.className="InputLayer";Kt(kb);function x_t(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new ht("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;n.shape!=null&&t==null&&(t=[null].concat(n.shape));let e=n.dtype;return e==null&&(e="float32"),new kb({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}function w_t(n,t){if(n.dtype==null||n.dtype===t.dtype)return t;try{return le(t,n.dtype)}catch{throw new ht(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Yu{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Yu)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,s){if(this.id2Value[t.id]==null)this.id2Value[t.id]=w_t(t,e),this.name2Id[t.name]=t.id,s!=null&&(this.id2Mask[t.id]=s);else throw new ht(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof tl){if(this.id2Value[t.id]==null)throw new ht(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const e=this.name2Id[t];if(e==null)throw new ht(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof tl){if(this.id2Value[t.id]==null)throw new ht(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const e=this.name2Id[t];if(e==null)throw new ht(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&Ee(this.id2Mask)}}const Px=new lq,Vx=new lq;function v_t(n){Px?.setMaxEntries(n),Vx?.setMaxEntries(n)}function ug(n,t,e,s){const r=e==null?!1:e.training,i=Array.isArray(n),o=i?n:[n],a=o.map(b=>b.name),l=[],c=t.names();for(const b of a)c.indexOf(b)!==-1?l.push(t.getValue(b)):l.push(null);const f=a.join(",")+"|"+t.names().sort().join(",");let d=Px.get(f),m;if(d==null){const b=S_t(o,t);d=b.sorted,m=b.recipientCounts,Px.put(f,d),Vx.put(f,m)}m={},r||Object.assign(m,Vx.get(f));const y=new Yu(t);for(let b=0;b<d.length;++b){const w=d[b],x=w.sourceLayer;if(x instanceof kb)continue;const S=[],T=[],$=[];let E=!1;for(const _ of w.inputs){const F=y.getValue(_),A=y.getMask(_);S.push(F),T.push(A),A!=null&&(E=!0),r||(m[_.name]--,m[_.name]===0&&!t.hasKey(_)&&a.indexOf(_.name)===-1&&!F.isDisposed&&_.sourceLayer.stateful!==!0&&$.push(F))}E&&(e=e||{},e.mask=T[0]);const R=jn(x.apply(S,e));let B=null;x.supportsMasking&&(B=x.computeMask(S,T));const N=T_t(w),k=Array.isArray(N)?N:[N];for(let _=0;_<k.length;++_){y.hasKey(k[_])||y.add(k[_],R[_],Array.isArray(B)?B[0]:B);const F=a.indexOf(k[_].name);F!==-1&&(l[F]=R[_])}r||Ee($)}return y.disposeMasks(),i?l:l[0]}function S_t(n,t){Q(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],s={};if(n.length===1){const r=WL(n[0],t);e=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of n){const{sorted:o,recipientMap:a}=WL(i,t);for(const l of o)r.has(l.name)||(e.push(l),r.add(l.name));for(const l in a)s[l]==null&&(s[l]=new Set),a[l].forEach(c=>s[l].add(c))}}return{sorted:e,recipientCounts:I_t(s)}}function I_t(n){const t={};for(const e in n)t[e]=n[e].size;return t}function WL(n,t){const e=new Set,s=[],r={};for(const a of t.names())e.add(a);const i=[],o=[];for(i.push(n);i.length>0;){const a=i[i.length-1];if(e.has(a.name)){i.pop();continue}const l=o[o.length-1]===i.length-1;if(a.inputs.length===0||l)i.pop(),s.push(a),e.add(a.name),l&&o.pop();else{o.push(i.length-1);for(const c of a.inputs)r[c.name]==null&&(r[c.name]=new Set),r[c.name].add(a.name),!e.has(c.name)&&i.push(c)}}return{sorted:s,recipientMap:r}}function T_t(n){let t;if(n.sourceLayer.inboundNodes.length===1)t=n.sourceLayer.output;else{let e=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){e=s;break}t=n.sourceLayer.getOutputAt(e)}return t}const C_t=bn();C_t.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,v_t);const Eq={kernelName:XW,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>mt(n,Kv(le(e,"float32"),-1))}}};const E_t={kernelName:dIt,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=ts(le(e,"float32")),r=Xr($e(xn(1),s));return Lr(we(n,r))}}}};const $_t={kernelName:pIt,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Xr($e(ts(le(e,"float32")),1));return we(n,s)}}}};const A_t={kernelName:s_,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=fs(e.shape,s.shape);return{a:()=>{let a=n;const l=lr(e.shape,r);return l.length>0&&(a=xe(a,l)),kt(a,e.shape)},b:()=>{let a=n;const l=lr(s.shape,r);return l.length>0&&(a=xe(a,l)),kt(a,s.shape)}}}};const k_t={kernelName:mIt,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((s,r)=>{e[r]=()=>n.clone()}),e}};const __t={kernelName:YW,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>pn(e)}}};const N_t={kernelName:bIt,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>pn(e)}}};const R_t={kernelName:xIt,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>we(n,Xr($e(xn(1),ts(le(e,"float32")))))}}};const D_t={kernelName:wIt,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Xr(Qt(xn(1),ts(le(e,"float32"))));return we(n,s)}}}};const O_t={kernelName:IIt,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=fs(e.shape,s.shape);return{a:()=>{const a=Qt(ts(e),ts(s));let l=mt(n,we(s,a));const c=lr(e.shape,r);return c.length>0&&(l=xe(l,c)),kt(l,e.shape)},b:()=>{const a=Qt(ts(e),ts(s));let l=Lr(mt(n,we(e,a)));const c=lr(s.shape,r);return c.length>0&&(l=xe(l,c)),kt(l,s.shape)}}}};const F_t={kernelName:vIt,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>we(n,Qt(ts(le(e,"float32")),1))}}};const M_t={kernelName:SIt,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>we(n,$e(xn(1),ts(le(e,"float32"))))}}};function L_t(n,t,e,s,r,i){const o=dt(n,"dy","avgPool3dGrad"),a=dt(t,"input","avgPool3dGrad");let l=o,c=a,f=!1;a.rank===4&&(f=!0,l=kt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=kt(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),Q(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),Q(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),Ni("avgPool3dGrad",r,i);const d={dy:l,input:c},m={filterSize:e,strides:s,pad:r,dimRoundingMode:i},y=Et.runKernel(CIt,d,m);return f?kt(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const z_t=Ft({avgPool3dGrad_:L_t});const B_t={kernelName:ZW,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:a}=e;return{x:()=>z_t(n,s,r,i,o,a)}}};function P_t(n,t,e,s,r){const i=dt(n,"dy","avgPoolGrad"),o=dt(t,"input","avgPoolGrad");Q(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,c=!1;o.rank===3&&(c=!0,a=kt(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=kt(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Q(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),Q(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const f={dy:l,input:a},d={filterSize:e,strides:s,pad:r},m=Et.runKernel(TIt,f,d);return c?kt(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const V_t=Ft({avgPoolGrad_:P_t});const U_t={kernelName:QW,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:r,strides:i,pad:o}=e;return{x:()=>V_t(n,s,r,i,o)}}};const G_t={kernelName:JW,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[s,r]=t,{transposeA:i,transposeB:o}=e;return!i&&!o?{a:()=>Vn(n,r,!1,!0),b:()=>Vn(s,n,!0,!1)}:!i&&o?{a:()=>Vn(n,r,!1,!1),b:()=>Vn(n,s,!0,!1)}:i&&!o?{a:()=>Vn(r,n,!1,!0),b:()=>Vn(s,n,!1,!1)}:{a:()=>Vn(r,n,!0,!0),b:()=>Vn(n,s,!0,!0)}}};const W_t={kernelName:tj,gradFunc:(n,t,e)=>{const{blockShape:s,crops:r}=e;return{x:()=>q$t(n,s,r)}}};const j_t={kernelName:$It,gradFunc:(n,t,e)=>{const s=e,r=s.inputShape,i=s.shape,o=Array.from(i);for(let l=r.length-1;l>=0;l--)if(r[l]===i[l])o[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>xe(n,a,!0)}}};const q_t={kernelName:r_,gradFunc:n=>({x:()=>n.clone()})};const H_t={kernelName:AIt,gradFunc:n=>({x:()=>pn(n)})};const K_t={kernelName:ej,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{clipValueMin:r,clipValueMax:i}=e;return{x:()=>Co(Lp(bb(s,r),xb(s,i)),n,pn(n))}}};const X_t={kernelName:nj,inputsToSave:["x"],gradFunc:Eq.gradFunc};const Y_t={kernelName:sj,saveAllInputs:!0,gradFunc:(n,t,e)=>{const s=t.map(l=>l.shape),{axis:r}=e,i=wl(r,t[0].shape)[0],o=s.map(l=>l[i]);return ol(n,o,i).map(l=>()=>l)}};const Q_t={kernelName:rj,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,{dilations:i,strides:o,pad:a,dataFormat:l}=e;return Q(np(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>d_(s.shape,n,r,o,a,l),filter:()=>w_(s,n,r.shape,o,a,l)}}};const Z_t={kernelName:ij,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>sp(n,r,i,o,a,1,l),filter:()=>w_(n,s,r.shape,i,o,a,l)}}};function J_t(n,t,e,s,r){let i=n;n.rank===4&&(i=kt(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=t;o.rank===4&&(o=kt(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Q(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),Q(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),Q(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),Q(i.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${e[3]}.`),Q(o.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${e[4]}).`);const a={x:i,dy:o},l={strides:s,pad:r,filterShape:e};return Et.runKernel(NIt,a,l)}const tNt=Ft({conv3DBackpropFilter_:J_t});const eNt={kernelName:oj,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:r,pad:i}=e;Q(np(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,a]=t;return{x:()=>$5(o.shape,n,a,r,i),filter:()=>tNt(o,n,a.shape,r,i)}}};const nNt={kernelName:aj,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>mt(Lr(h2t(le(e,"float32"))),n)}}};const sNt={kernelName:lj,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>mt(d2t(le(e,"float32")),n)}}};const rNt={kernelName:uj,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r,exclusive:i,reverse:o}=e;return{x:()=>{const a=_5([r],s.rank);let l=XEt(n,r,i,!o);return a!=null&&(l=nn(l,a)),l}}}};const iNt={kernelName:cj,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:o}=e,a=s??[1,1];Q(np(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=t;return Q(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),Q(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),Q(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),Q(bf(r,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${a}'.`),Ni("depthwiseConv2d",i,o),{x:()=>z2t(l.shape,n,c,r,i,a,o),filter:()=>M2t(l,n,c.shape,r,i,a,o)}}};const oNt={kernelName:LIt,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,i={x:s,filter:r,dy:n},o={x:s,filter:r,dy:n};return{x:()=>Et.runKernel(zIt,i,e),filter:()=>Et.runKernel(BIt,o,e)}}};const aNt={kernelName:fj,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,s={dy:n,y:e};return{x:()=>Et.runKernel(PIt,s)}}};const lNt={kernelName:VIt,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=mt(Jh(Lr(ts(e))),2/Math.sqrt(Math.PI));return{x:()=>mt(n,s)}}};const uNt={kernelName:dj,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>mt(n,e)}}};const cNt={kernelName:pj,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>kt(n,e.shape)}}};const hNt={kernelName:GIt,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>mt(n,Jh(e))}}};const fNt={kernelName:mj,gradFunc:n=>({x:()=>pn(n)})};const dNt={kernelName:gj,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=fs(e.shape,s.shape);return{a:()=>{const a=we(n,le(s,"float32")),l=lr(e.shape,r);return l.length>0?kt(xe(a,l),e.shape):a},b:()=>{let a=mt(n,le(e,"float32"));const l=lr(s.shape,r);l.length>0&&(a=kt(xe(a,l),s.shape));const c=ts(s);return Lr(we(a,le(c,"float32")))}}}};const pNt={kernelName:yj,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:s}=e,[r,i,o,a]=t,l=a??xn(1),c=lr(i.shape,r.shape),f=[];if(i.rank===1){for(let E=0;E<r.shape.length-1;++E)f.push(r.shape[E]);f.push(1)}const d=$e(r,i),m=mt(n,l),y=i2t(Qt(o,xn(s))),b=mt(mt(mt(y,y),y),xn(-.5));return{x:()=>i.rank===1?kt(mt(mt(n,Ja(kt(y,[1,1,1,i.shape[0]]),f)),l),r.shape):kt(mt(mt(n,y),l),r.shape),mean:()=>{let E=mt(mt(y,xn(-1)),m);return i.rank===1&&(E=xe(E,c)),kt(E,i.shape)},variance:()=>{let E=mt(mt(b,d),m);return i.rank===1&&(E=xe(E,c)),kt(E,i.shape)},scale:()=>{const E=mt(d,y);let R=mt(n,E);return i.rank===1&&(R=xe(R,c)),kt(R,i.shape)},offset:()=>{let E=n;return i.rank===1&&(E=xe(E,c)),kt(E,i.shape)}}}};const mNt={kernelName:bj,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[s,r]=t,{axis:i}=e,o=wl(i,s.shape)[0];return{x:()=>{const l=s.shape,c=r.size,f=l.slice(0,o),d=f.length,m=l.slice(i,l.length).slice(1),y=m.length,b=jL(0,d),w=jL(d+1,d+1+y),x=qL([f,[c],m]),S=kt(n,x),T=kt(r,[c]),$=qL([[d],b,w]),E=nn(S,$);let R=E2t(E,T,s.shape[o]);const B=m_($);return R=nn(R,B),R},indices:()=>r}}};function jL(n,t){const e=[];for(let s=n;s<t;++s)e.push(s);return e}function qL(n){const t=[];for(let e=0;e<n.length;++e)for(let s=0;s<n[e].length;++s)t.push(n[e][s]);return t}const gNt={kernelName:xj,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>pn(e),b:()=>pn(s)}}};const yNt={kernelName:i_,gradFunc:n=>({x:()=>le(n,"float32")})};const bNt={kernelName:KIt,gradFunc:n=>({x:()=>pn(n)})};const xNt={kernelName:XIt,gradFunc:n=>({x:()=>pn(n)})};const wNt={kernelName:YIt,gradFunc:n=>({x:()=>pn(n)})};const vNt={kernelName:wj,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{alpha:r}=e,i=ga(s,0);return{x:()=>Co(i,n,mt(n,r))}}};const SNt={kernelName:Sj,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>we(n,Qt(e,1))}}};const INt={kernelName:vj,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>we(n,le(e,"float32"))}}};const TNt={kernelName:eTt,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e;return{logits:()=>{const o=Jh(s);return $e(n,mt(xe(n,r,!0),o))}}}};function CNt(n,t,e,s=5,r=1,i=1,o=.5){const a={x:n,y:t,dy:e},l={depthRadius:s,bias:r,alpha:i,beta:o};return Et.runKernel(sTt,a,l)}const ENt=Ft({localResponseNormalizationBackprop_:CNt});const $Nt={kernelName:nTt,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{depthRadius:i,bias:o,alpha:a,beta:l}=e;return{x:()=>ENt(s,r,n,i,o,a,l)}}};function $q(n,t,e,s){return t.rank<e.rank&&(t=kt(t,Dx(t.shape,s))),n.rank<e.rank&&(n=kt(n,Dx(n.shape,s))),{x:()=>mt(n,le(mc(e,t),n.dtype))}}const HL={kernelName:Ij,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{reductionIndices:r}=s,i=t[0],o=t[1],a=wl(r,i.shape),l=$q(n,o,i,a);return{x:()=>l.x()}}};const ANt={kernelName:Tj,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>mt(n,le(bb(e,s),"float32")),b:()=>mt(n,le(v$t(e,s),"float32"))}}};function kNt(n,t,e,s,r,i,o){const a=dt(n,"dy","maxPool3dGrad"),l=dt(t,"input","maxPool3dGrad"),c=dt(e,"output","maxPool3dGrad");let f=a,d=l,m=c,y=!1;l.rank===4&&(y=!0,f=kt(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=kt(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),m=kt(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),Q(f.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${f.rank}.`),Q(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),Q(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),Ni("maxPool3dGrad",i,o);const b={dy:f,input:d,output:m},w={filterSize:s,strides:r,pad:i,dimRoundingMode:o},x=Et.runKernel(iTt,b,w);return y?kt(x,[x.shape[1],x.shape[2],x.shape[3],x.shape[4]]):x}const _Nt=Ft({maxPool3dGrad_:kNt});const NNt={kernelName:Ej,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=e;return{x:()=>_Nt(n,s,r,i,o,a,l)}}};function RNt(n,t,e,s,r,i,o){const a=dt(n,"dy","maxPoolGrad"),l=dt(t,"input","maxPoolGrad"),c=dt(e,"output","maxPoolGrad");Q(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),Q(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),Q(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Ni("maxPoolGrad",i,o);const f={dy:a,input:l,output:c},d={filterSize:s,strides:r,pad:i,dimRoundingMode:o};return Et.runKernel(rTt,f,d)}const DNt=Ft({maxPoolGrad_:RNt});const ONt={kernelName:Cj,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{filterSize:i,strides:o,pad:a}=e;return{x:()=>DNt(n,s,r,i,o,a)}}};const FNt={kernelName:$j,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e,i=wl(r,s.shape),a=s$t(s.shape,i)[1],l=oi(a);return{x:()=>{const f=s.shape.slice();i.forEach(y=>{f[y]=1});const d=kt(n,f);return we(mt(d,wf(s.shape,"float32")),l)}}}};const MNt={kernelName:Aj,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{axis:r}=s,[i,o]=t,a=wl(r,i.shape),l=$q(n,o,i,a);return{x:()=>l.x()}}};const LNt={kernelName:kj,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>mt(n,le(xb(e,s),"float32")),b:()=>mt(n,le(ga(e,s),"float32"))}}};const zNt={kernelName:oTt,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:r}=e,i=r.map(o=>o[0]);return{x:()=>Qn(n,i,s.shape)}}};const BNt={kernelName:aTt,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=fs(e.shape,s.shape);return{a:()=>{const a=lr(e.shape,r);return a.length>0?kt(xe(n,a),e.shape):n},b:()=>{const a=mt(n,Lr(g_(we(e,s)))),l=lr(s.shape,r);return l.length>0?kt(xe(a,l),s.shape):a}}}};const PNt={kernelName:_j,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=fs(e.shape,s.shape);return{a:()=>{const a=mt(n,le(s,"float32")),l=lr(e.shape,r);return l.length>0?kt(xe(a,l),e.shape):a},b:()=>{const a=mt(n,le(e,"float32")),l=lr(s.shape,r);return l.length>0?kt(xe(a,l),s.shape):a}}}};const VNt={kernelName:Nj,gradFunc:n=>({x:()=>Lr(n)})};const UNt={kernelName:Dj,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>gr(e.shape,"float32")}}};const GNt={kernelName:Rj,gradFunc:n=>({x:()=>pn(n)})};const WNt={kernelName:Oj,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:s}=e;return ip(n,s).map(i=>()=>i)}};const KL={kernelName:Fj,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:r}=e,i=r.map(o=>o[0]);return{x:()=>Qn(n,i,s.shape)}}};const jNt={kernelName:Mj,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,s,r]=t,i=e,o=s,a=fs(i.shape,o.shape);return{a:()=>{const f=le(o,"float32");let d=mt(n,mt(f,zg(i,$e(f,xn(1)))));const m=lr(i.shape,a);return m.length>0&&(d=xe(d,m)),kt(d,i.shape)},b:()=>{const f=ga(i,0),d=Co(f,gc(i),pn(i));let m=mt(n,mt(r,d));const y=lr(o.shape,a);return y.length>0&&(m=xe(m,y)),kt(m,o.shape)}}}};const qNt={kernelName:Lj,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,s]=t,r=ga(e,0);return{x:()=>Co(r,n,mt(n,s)),alpha:()=>{let i=Co(r,pn(n),mt(n,e));const o=lr(s.shape,n.shape);return o.length>0&&(i=xe(i,o)),kt(i,s.shape)}}}};function HNt(n,t,e){const s=n.shape.slice();s[e]=1;const r=kt(t,s),i=k3(n,e,!0,!1),o=k3(n,e,!0,!0),a=mt(i,o);return mt(r,a)}function KNt(n,t,e){const s=n.shape.length,r=s-e.length,i=_5(e,s);let o=n;i!=null&&(o=nn(n,i));const a=o.shape.slice(),c=a.splice(s-e.length,e.length).reduce((m,y)=>m*y,1);a.push(c);const f=o.reshape(a);let d=HNt(f,t,r);if(d=d.reshape(o.shape),i!=null){const m=m_(i);d=nn(d,m)}return d}const XNt={kernelName:fTt,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e;let i=[];return r==null?i=s.shape.map((o,a)=>a):typeof r=="number"?i=[r]:i=r,{x:()=>KNt(s,n,i)}}};const YNt={kernelName:hj,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=fs(e.shape,s.shape);return{a:()=>{const a=we(n,le(s,"float32")),l=lr(e.shape,r);return l.length>0?kt(xe(a,l),e.shape):a},b:()=>{let a=mt(n,le(e,"float32"));const l=lr(s.shape,r);l.length>0&&(a=kt(xe(a,l),s.shape));const c=ts(s);return Lr(we(a,le(c,"float32")))}}}};const QNt={kernelName:mTt,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>we(n,Lr(ts(e)))}}};const ZNt={kernelName:Uj,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=mt(xb(e,6),Kv(e));return{x:()=>mt(n,le(s,"float32"))}}};const JNt={kernelName:zj,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>mt(n,le(Kv(e),"float32"))}}};const tRt={kernelName:Bj,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>kt(n,e.shape)}}};const eRt={kernelName:Vj,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,r={dy:n,images:s};return{images:()=>Et.runKernel(yTt,r,e)}}};const nRt={kernelName:Pj,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,r={dy:n,images:s};return{images:()=>Et.runKernel(gTt,r,e)}}};const sRt={kernelName:Gj,gradFunc:(n,t,e)=>{const{dims:s}=e,r=wl(s,n.shape);return{x:()=>Fx(n,r)}}};const rRt={kernelName:Wj,gradFunc:n=>({x:()=>pn(n)})};const iRt={kernelName:jj,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lr(we(n,mt(zg(e,1.5),2)))}}};const oRt={kernelName:qj,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>le(pn(e),"float32"),t:()=>mt(n,le(e,n.dtype)),e:()=>mt(n,le(D$t(e),n.dtype))}}};const aRt={kernelName:Hj,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=ga(e,xn(0)),r=xn(DAt),i=xn(OAt),o=mt(n,i),a=mt(mt(n,r),Jh(le(e,"float32")));return Co(s,o,a)}}}};const lRt={kernelName:Qj,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>mt(n,mt(e,$e(xn(1),e)))}}};const uRt={kernelName:bTt,gradFunc:n=>({x:()=>pn(n)})};const cRt={kernelName:Xj,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>mt(A5(le(e,"float32")),n)}}};const hRt={kernelName:Yj,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>mt(qEt(le(e,"float32")),n)}}};const fRt={kernelName:Kj,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{begin:r,size:i}=e,o=s.shape,[a,l]=VCt(s,r,i),c=[];for(let f=0;f<n.rank;f++)c.push([a[f],o[f]-a[f]-l[f]]);return{x:()=>M5(n,c)}}};const dRt={kernelName:s5,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{dim:r}=e,i=!0,o=mt(n,s);return{logits:()=>$e(o,mt(xe(o,[r],i),s))}}};const pRt={kernelName:Zj,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>mt(n,jv(e))}}};const XL={kernelName:e5,gradFunc:(n,t,e)=>{const{blockShape:s,paddings:r}=e;return{x:()=>fEt(n,s,r)}}};const YL={kernelName:n5,gradFunc:(n,t,e)=>{const{axis:s}=e;return{x:()=>na(n,s)}}};const mRt={kernelName:Jj,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>we(n,mt(Xr(le(e,"float32")),2))}}};const gRt={kernelName:wTt,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>mt(n,mt(le(e,"float32"),2))}}};const yRt={kernelName:xTt,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=xn(2);return{a:()=>mt(n,mt(r,$e(e,s))),b:()=>mt(n,mt(r,$e(s,e)))}}};const bRt={kernelName:u5,gradFunc:n=>({x:()=>pn(n)})};const xRt={kernelName:r5,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=fs(e.shape,s.shape);return{a:()=>{let a=n;const l=lr(e.shape,r);return l.length>0&&(a=xe(a,l)),kt(a,e.shape)},b:()=>{let a=n;const l=lr(s.shape,r);return l.length>0&&(a=xe(a,l)),kt(Lr(a),s.shape)}}}};const wRt={kernelName:t5,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,r=s.shape.slice(),{axis:i}=e;wl(i,s.shape).forEach(c=>{r[c]=1});const a=kt(n,r),l=mt(a,wf(s.shape,"float32"));return{x:()=>l}}};const vRt={kernelName:vTt,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>we(n,ts(A5(e)))}}};const SRt={kernelName:i5,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>mt($e(xn(1),ts(e)),n)}}};const IRt={kernelName:o_,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{reps:r}=e;return{x:()=>{let o=pn(s);if(s.rank===1)for(let a=0;a<r[0];++a)o=Qt(o,Qn(n,[a*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)o=Qt(o,Qn(n,[a*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)o=Qt(o,Qn(n,[a*s.shape[0],l*s.shape[1],c*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)for(let f=0;f<r[3];++f)o=Qt(o,Qn(n,[a*s.shape[0],l*s.shape[1],c*s.shape[2],f*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return o}}}};const TRt={kernelName:j1,gradFunc:(n,t,e)=>{const s=e,{perm:r}=s,i=m_(r);return{x:()=>nn(n,i)}}};const CRt={kernelName:o5,gradFunc:(n,t,e)=>{const s=e,{axis:r}=s;return{value:()=>yc(n,r)}}};const ERt={kernelName:a5,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$Rt(n,e)}}};function $Rt(n,t){const e=xf(t,pn(t)),s=Nd(n,e);let r=bb(t,xn(0,"int32"));const i=s.rank-r.rank;for(let a=0;a<i;++a)r=Xo(r,a+1);r=Lp(r,wf(s.shape,"bool"));const o=pn(s);return Co(r,s,o)}const ARt={kernelName:l5,gradFunc:n=>({x:()=>pn(n)})};const kRt=[Eq,E_t,$_t,A_t,k_t,__t,N_t,R_t,D_t,O_t,F_t,M_t,B_t,U_t,G_t,W_t,j_t,q_t,H_t,K_t,X_t,Y_t,Z_t,Q_t,eNt,nNt,sNt,rNt,iNt,oNt,YNt,aNt,lNt,uNt,cNt,hNt,dNt,fNt,pNt,mNt,gNt,yNt,bNt,xNt,wNt,vNt,SNt,INt,TNt,$Nt,HL,HL,ANt,NNt,ONt,FNt,MNt,LNt,zNt,BNt,PNt,VNt,UNt,GNt,WNt,KL,KL,jNt,qNt,XNt,QNt,ZNt,JNt,tRt,eRt,nRt,sRt,rRt,iRt,oRt,aRt,lRt,uRt,cRt,hRt,fRt,dRt,pRt,XL,XL,YL,YL,mRt,yRt,gRt,bRt,xRt,wRt,vRt,SRt,IRt,TRt,CRt,ERt,ARt];for(const n of kRt)TTt(n);function j_(n,t){return St(()=>Xr(xe(mt(n,n),t,!0)))}class _b extends Mp{getConfig(){return{}}}class Aq extends _b{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return St(()=>{const e=j_(t,this.axis),s=To(e,0,this.maxValue);return mt(t,we(s,Qt(js(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Aq.className="MaxNorm";Kt(Aq);class kq extends _b{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return St(()=>we(t,Qt(js(),j_(t,this.axis))))}getConfig(){return{axis:this.axis}}}kq.className="UnitNorm";Kt(kq);class _q extends _b{apply(t){return zp(t)}}_q.className="NonNeg";Kt(_q);class Nq extends _b{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return St(()=>{const e=j_(t,this.axis),s=Qt(mt(this.rate,To(e,this.minValue,this.maxValue)),mt(1-this.rate,e));return mt(t,we(s,Qt(js(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Nq.className="MinMaxNorm";Kt(Nq);const QL={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Ys(n){return O_(n)}function ZL(n,t={}){return Tb(n,go.getMap().classNameMap,t,"constraint")}function Qs(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in QL?QL[n]:n,config:{}};return ZL(e)}else return n instanceof _b?n:ZL(n)}async function mh(n){if(n==null)return;const t=[],e=[],s=[];for(const r in n){const i=n[r];if(typeof i!="number"){const o=i;t.push(o.data()),e.push(r),s.push(o)}}if(t.length>0){const r=await Promise.all(t);for(let i=0;i<r.length;++i)n[e[i]]=r[i][0];Ee(s)}}function Rq(n){if(n!=null)for(const t in n){const e=n[t];typeof e!="number"&&e.dispose()}}var JL;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(JL||(JL={}));const _Rt=125;class Pg{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class NRt{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class RRt extends Pg{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});const s=e.size==null?0:e.size;this.seen+=s;for(const r in e){const i=e[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*s;else{let o;r in this.totals?o=this.totals[r]:this.totals[r]=0;const a=St(()=>Qt(this.totals[r],mt(i,s)));this.totals[r]=a,o?.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?e[s]=this.totals[s]/this.seen:St(()=>{const r=mt(we(1,this.seen),this.totals[s]);e[s]=r,this.totals[s].dispose(),gl(e[s])}))}}class DRt extends Pg{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(const s in e)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(e[s])}async syncData(){const t=[],e=[],s=[];for(const i in this.history){const o=this.history[i];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const l=o[a];t.push(l.data()),e.push(i),s.push(a)}}const r=await Promise.all(t);for(let i=0;i<r.length;++i)this.history[e[i]][s[i]].dispose(),this.history[e[i]][s[i]]=r[i][0]}}class ORt extends Pg{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||RAt,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=_Rt),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");g$(this.yieldEvery)&&(this.maybeWait=jkt(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,s){const r=[];this.yield!=null&&(await mh(s),r.push(this.yield(t,e,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await mh(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const s=[];this.epochEnd!=null&&(await mh(e),s.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(t,e){this.batchBegin!=null&&(await mh(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const s=[];this.batchEnd!=null&&(await mh(e),s.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):g$(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(s)}async onTrainBegin(t){this.trainBegin!=null&&(await mh(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await mh(t),await this.trainEnd(t))}}function Dq(n,t){return n==null&&(n={}),n instanceof Pg?[n]:Array.isArray(n)&&n[0]instanceof Pg?n:jn(n).map(s=>new ORt(s,t))}class mo{constructor(){}static registerCallbackConstructor(t,e){Q(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),mo.checkForDuplicate(e),mo.constructors[t]==null&&(mo.constructors[t]=[]),mo.constructors[t].push(e)}static checkForDuplicate(t){for(const e in mo.constructors)mo.constructors[+e].forEach(r=>{if(r===t)throw new ht("Duplicate callback constructor.")})}static clear(){mo.constructors={}}static createCallbacks(t){const e=[];for(const s in mo.constructors){const r=+s;t>=r&&e.push(...mo.constructors[r])}return e.map(s=>new s)}}mo.constructors={};function Oq(n,t,e,s,r,i,o,a,l){const c=new DRt,f=[new RRt,...mo.createCallbacks(t)];n!=null&&f.push(...n),f.push(c);const d=new NRt(f);return d.setParams({epochs:e,initialEpoch:s,samples:r,steps:i,batchSize:o,verbose:t,doValidation:a,metrics:l}),{callbackList:d,history:c}}function ll(n,t={},e=!1){return Tb(n,go.getMap().classNameMap,t,"layer",e)}function Ux(n,t){return St(()=>{n.dtype!=="float32"&&(n=le(n,"float32"));const e=xe($b(n),t,!0),s=qv(e.shape,js()),r=Xr(xf(e,s));return we(n,r)})}function nS(n,t){return St(()=>As($b($e(t,n)),-1))}function q_(n,t){return St(()=>As(Jr($e(t,n)),-1))}function H_(n,t){return St(()=>{const e=$e(n,t),s=To(Jr(n),js(),Number.MAX_VALUE),r=Jr(we(e,s));return mt(100,As(r,-1))})}function FRt(n,t){return St(()=>{const e=To(t,js(),Number.MAX_VALUE),s=gc(Qt(1,e)),r=To(n,js(),Number.MAX_VALUE),i=gc(Qt(1,r));return As($b($e(s,i)),-1)})}function MRt(n,t){return St(()=>{const e=xf(0,$e(1,mt(n,t)));return As($b(e),-1)})}function LRt(n,t){return St(()=>{const e=xf(0,$e(1,mt(n,t)));return As(e,-1)})}function zRt(n,t){return St(()=>{const e=xe(mt(n,t),-1),s=Hl(mt($e(1,n),t),-1);return xf(0,Qt(1,$e(s,e)))})}function BRt(n,t){return St(()=>{const e=Math.log(2),s=$e(t,n),r=$e(Qt(s,y_(mt(-2,s))),e);return As(r,-1)})}function Vg(n,t,e=!1){return St(()=>{if(e)t=P5(t);else{const s=xe(t,t.shape.length-1,!0);t=we(t,s)}return t=To(t,js(),1-js()),Lr(xe(mt(le(n,"float32"),gc(t)),t.shape.length-1))})}function Gx(n,t,e=!1){return St(()=>{const s=le(g_(s_t(n)),"int32");t=To(t,js(),1-js());const r=t.shape,i=kt(H1(s,r[r.length-1]),r);return Vg(i,t,e)})}function PRt(n,t){if(!ci(n.shape,t.shape))throw new ht(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return St(()=>{const e=zp(t),s=Lr(Jr(t));return Qt($e(e,mt(t,n)),C$t(Jh(s)))})}function sS(n,t){return St(()=>{let e;return e=To(t,js(),1-js()),e=gc(we(e,$e(1,e))),As(PRt(n,e),-1)})}function VRt(n,t){return St(()=>{const e=To(n,js(),1),s=To(t,js(),1);return xe(mt(n,gc(we(e,s))),-1)})}function URt(n,t){return St(()=>{const e=gc(Qt(js(),t));return As($e(t,mt(n,e)),-1)})}function Fq(n,t){return St(()=>{const e=Ux(n,-1),s=Ux(t,-1),r=mt(e,s);return Lr(xe(r,-1))})}const Wx={meanSquaredError:nS,meanAbsoluteError:q_,meanAbsolutePercentageError:H_,meanSquaredLogarithmicError:FRt,squaredHinge:MRt,hinge:LRt,categoricalHinge:zRt,logcosh:BRt,categoricalCrossentropy:Vg,sparseCategoricalCrossentropy:Gx,binaryCrossentropy:sS,kullbackLeiblerDivergence:VRt,poisson:URt,cosineProximity:Fq};function dE(n){if(typeof n=="string"){if(n in Wx)return Wx[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ht(t)}else return n}function Mq(n,t){return St(()=>{const e=mt(.5,ha(t)),s=Cb(ga(t,e),n.dtype);return As(mc(n,s),-1)})}function Lq(n,t){return St(()=>Cb(mc(ep(n,-1),ep(t,-1)),"float32"))}function GRt(n,t){return St(()=>le(xe(Lp(mc(n,1),mc(t,1))),"float32"))}function WRt(n,t){return St(()=>le(xe(Lp(mc(n,0),mc(t,1))),"float32"))}function jRt(n,t){return St(()=>{const e=GRt(n,t),s=WRt(n,t),r=Qt(e,s);return le(Co(ga(r,0),we(e,r),0),"float32")})}function qRt(n,t){return sS(n,t)}function HRt(n,t){return n.rank===t.rank&&(n=rp(n,[n.rank-1])),t=ep(t,-1),t.dtype!==n.dtype&&(t=le(t,n.dtype)),le(mc(n,t),"float32")}const KRt=nS,XRt=nS,YRt=q_,QRt=q_,ZRt=H_,JRt=H_,zq=Vg,tDt=Fq,Bq=Gx,jx={binaryAccuracy:Mq,categoricalAccuracy:Lq,precision:jRt,categoricalCrossentropy:zq,sparseCategoricalCrossentropy:Bq,mse:KRt,MSE:XRt,mae:YRt,MAE:QRt,mape:ZRt,MAPE:JRt,cosine:tDt};function eDt(n){if(typeof n=="string"&&n in jx)return jx[n];if(typeof n!="string"&&n!=null)return n;throw new ht(`Unknown metric ${n}`)}function $1(n){if(Ka(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let t;for(const e of Object.keys(Wx))if(Wx[e]===n){t=e;break}if(t!==void 0)return t;for(const e of Object.keys(jx))if(jx[e]===n){t=e;break}return t!==void 0?t:n.name}}function nDt(n){const t={Adagrad:()=>yd.adagrad(.01),Adadelta:()=>yd.adadelta(1,.95,js()),Adam:()=>yd.adam(.001,.9,.999,js()),Adamax:()=>yd.adamax(.002,.9,.999,js(),0),RMSProp:()=>yd.rmsprop(.001,.9,0,js()),SGD:()=>yd.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new ht(`Unknown Optimizer ${n}`)}const tz=1*1024*1024;function ez(n,t,e=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!O$(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const s=JSON.stringify(n);s.length>tz&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${tz}.`)}}function O$(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if(typeof e!="string"||!O$(n[e]))return!1;return!0}else if(Array.isArray(n)){for(const t of n)if(!O$(t))return!1;return!0}else return!1;else{const t=typeof n;return t==="string"||t==="number"||t==="boolean"}}function sDt(n,t,e,s=console.log){const r=iDt(n),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(f=>Math.floor(t*f)));let o;if(!r){i.push("Receives inputs"),o=[];for(const f in n.nodesByDepth)o.push(...n.nodesByDepth[f])}s("_".repeat(t)),qx(i,e,s),s("=".repeat(t));const a=n.layers;for(let f=0;f<a.length;++f)r?oDt(a[f],e,s):aDt(a[f],e,o,s),s((f===a.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const l=rDt(n),c=Bx(n.nonTrainableWeights);s(`Total params: ${l+c}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${c}`),s("_".repeat(t))}function rDt(n){let t;return n.collectedTrainableWeights!=null?t=Bx(n.collectedTrainableWeights):t=Bx(n.trainableWeights),t}function iDt(n){let t=!0;const e=[],s=[];for(const r in n.nodesByDepth)e.push(n.nodesByDepth[r]);for(const r of e){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){t=!1;break}s.push(...r)}if(t)for(const r of n.layers){let i=!1;for(const o of r.inboundNodes)if(s.indexOf(o)!==-1)if(i){t=!1;break}else i=!0;if(!t)break}return t}function qx(n,t,e=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,t[r]),s+=" ".repeat(t[r]-s.length);e(s)}function oDt(n,t,e){let s,r;try{r=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const i=n.name,o=n.getClassName(),a=[`${i} (${o})`,r,s,n.countParams().toString()];qx(a,t,e)}function aDt(n,t,e,s){let r,i;try{i=n.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const o=[];for(const d of n.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(d)===-1))for(let m=0;m<d.inboundLayers.length;++m){const y=d.inboundLayers[m].name,b=d.nodeIndices[m],w=d.tensorIndices[m];o.push(`${y}[${b}][${w}]`)}const a=n.name,l=n.getClassName(),c=o.length===0?"":o[0],f=[`${a} (${l})`,i,r,n.countParams().toString(),c];qx(f,t,s);for(let d=1;d<o.length;++d)qx(["","","","",o[d]],t,s)}function Pq(n,t,e){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&t===0&&typeof e=="string"}function Hx(n,t){if(n===null)return null;if(typeof n=="string")return vh(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];Pq(t,r,i)?e.push(i):e.push(Hx(i,t))}return e}else{const e={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")e[s]=r;else{const i=vh(s);e[i]=Hx(r,i)}}return e}}function F$(n,t){if(n==null)return null;if(typeof n=="string")return Vl(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];Pq(t,r,i)?e.push(i):e.push(F$(i,t))}return e}else{const e={};for(const s of Object.keys(n)){const r=n[s],i=Vl(s);(s==="name"||s==="className")&&typeof r=="string"?e[i]=r:e[i]=F$(r,s)}return e}}const Vq="3.21.0";class jo extends Ze{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){const T=this.getClassName().toLowerCase();this.name=Jv(T)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],nc(this.inputs).length!==this.inputs.length)throw new ht(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(T=>T.name)}`);nc(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(T=>T.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const T of this.outputs){const $=T.sourceLayer,E=T.nodeIndex,R=T.tensorIndex;this.outputLayers.push($),this.outputLayersNodeIndices.push(E),this.outputLayersTensorIndices.push(R)}for(const T of this.inputs){const $=T.sourceLayer,E=T.nodeIndex,R=T.tensorIndex;Ka(E===0,"input layer has >1 nodes"),Ka(R===0,"input layer has >1 tensors"),this.inputLayers.push($),this.inputLayersNodeIndices.push(E),this.inputLayersTensorIndices.push(R)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let T=0;T<this.inputLayers.length;T++){const $=this.inputLayers[T];if(!($ instanceof kb))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${T} (0-based) originates from layer type ${$.getClassName()}.`);this.inputNames.push($.name),this.feedInputShapes.push($.batchInputShape),this.feedInputNames.push($.name)}for(const T of this.outputLayers)this.outputNames.push(T.name);this.internalInputShapes=this.inputs.map(T=>T.shape),this.internalOutputShapes=this.outputs.map(T=>T.shape);const e={},s={},r={},i={},o={},a=[],l=(T,$,E,R,B,N)=>{(R==null||B==null||N==null)&&(R=T.sourceLayer,B=T.nodeIndex,N=T.tensorIndex);const k=R.inboundNodes[B];if(E.indexOf(k)!==-1)throw new wo(`The tensor ${T.name} at layer "${R.name}" is part of a cycle.`);if($.indexOf(k)!==-1)return;this.containerNodes.add(jo.nodeKey(R,B)),R.id in o||(o[R.id]=Object.keys(o).length),E.indexOf(k)===-1&&E.push(k);const _=k.inboundLayers.length;for(let F=0;F<_;F++){const A=k.inputTensors[F],P=k.inboundLayers[F],L=k.nodeIndices[F],tt=k.tensorIndices[F];l(A,$,E,P,L,tt)}for($.push(k);E.indexOf(k)>=0;)E.splice(E.indexOf(k),1);a.push(k)},c=[],f=[];for(const T of this.outputs)l(T,c,f);const d=a.slice().reverse();for(const T of d){s[T.id]=T,T.id in e||(e[T.id]=0);let $=e[T.id];const E=r[T.outboundLayer.id]==null?0:r[T.outboundLayer.id];$=Math.max($,E),r[T.outboundLayer.id]=$,i[T.outboundLayer.id]=T.outboundLayer,e[T.id]=$;for(let R=0;R<T.inboundLayers.length;R++){const B=T.inboundLayers[R],N=T.nodeIndices[R],k=B.inboundNodes[N],_=e[k.id]==null?0:e[k.id];e[k.id]=Math.max($+1,_),s[k.id]=k}}const m={};for(const T in e){const $=e[T];$ in m||(m[$]=[]),m[$].push(s[T])}const y={};for(const T in r){const $=r[T];$ in y||(y[$]=[]),y[$].push(i[T])}let b=Object.keys(y).map(T=>parseInt(T,10)).sort(T1);this.layers=[];for(const T of b){const $=y[T];$.sort((E,R)=>{const B=o[E.id],N=o[R.id];return B<N?-1:B>N?1:0});for(const E of $)E instanceof jo&&this.internalContainerRefs.push(E),this.layers.push(E)}this.layersByDepth=y,b=Object.keys(m).map(T=>parseInt(T,10)).sort(T1);const w=this.inputs.slice(),x=[];for(const T of b)for(const $ of m[T]){const E=$.outboundLayer;if(E!=null){for(const R of $.inputTensors)if(w.indexOf(R)===-1)throw new wo(`Graph disconnected: cannot obtain value for tensor ${R} at layer "${E.name}". The following previous layers were accessed without issue: ${x}`);for(const R of $.outputTensors)w.push(R);x.push(E.name)}}this.nodesByDepth=m;const S=this.layers.map(T=>T.name);for(const T of S){const $=S.filter(E=>E===T).length;if($!==1)throw new wo(`The name "${T}" is used ${$} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(S))}this.outboundNodes=[],this.inboundNodes=[],new eS({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(T=>null),outputMasks:this.outputs.map(T=>null),inputShapes:this.inputs.map(T=>T.shape),outputShapes:this.outputs.map(T=>T.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(s=>s.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new ht("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.layers)e.push(...s.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const s={};let r=0;for(const o of this.layers)for(const a of o.weights){if(s[a.originalName]!=null)throw new ht(`Duplicate weight name: ${a.originalName}`);s[a.originalName]=a,r++}const i=[];for(const o in t){let a=o;if(s[o]==null){const l=o.split("/");a=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(s[a]!=null)i.push([s[a],t[o]]);else if(e)throw new ht(`Provided weight data has no target variable: ${o}`);delete s[a]}if(e){const o=[];for(const a in s)o.push(a);if(o.length>0)throw new ht(`${o.length} of ${r} weights are not set: ${o}`)}W_(i)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${Vq}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){const s=F$(this.updatedConfig());return e?JSON.stringify(s):s}call(t,e){return St(()=>{t=jn(t);const s=new Yu;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],t[r]);return ug(this.outputs,s,e)})}computeMask(t,e){return St(()=>{t=jn(t);let s;return e==null?s=tf(null,t.length):s=jn(e),this.runInternalGraph(t,s)[1]})}computeOutputShape(t){const e=zx(t);if(e.length!==this.inputLayers.length)throw new ht(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let a=0;a<e.length;a++){const l=this.inputLayers[a],c=e[a],f=l.name+"_0_0";s[f]=c}const r=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(T1);if(r.length>1)for(const a of r){const l=this.nodesByDepth[a];for(const c of l){const f=c.outboundLayer;if(this.inputLayers.map(w=>w.id).indexOf(f.id)!==-1)continue;const d=[];for(let w=0;w<c.inboundLayers.length;w++){const x=c.inboundLayers[w],S=c.nodeIndices[w],T=c.tensorIndices[w],$=`${x.name}_${S}_${T}`,E=s[$];d.push(E)}const m=f.computeOutputShape(ri(d)),y=zx(m),b=f.inboundNodes.indexOf(c);for(let w=0;w<y.length;w++){const x=`${f.name}_${b}_${w}`;s[x]=y[w]}}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],c=this.outputLayersNodeIndices[a],f=this.outputLayersTensorIndices[a],d=`${l.name}_${c}_${f}`;o.push(d)}for(let a=0;a<o.length;a++){const l=o[a];Ka(l in s),i.push(s[l])}return ri(i)}runInternalGraph(t,e){e==null&&(e=tf(null,t.length));const s={};for(let l=0;l<this.inputs.length;++l){const c=this.inputs[l],f=t[l],d=e[l];s[c.id]=[f,d]}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(T1);for(const l of r){const c=this.nodesByDepth[l];for(const f of c){const d=f.outboundLayer,m=f.inputTensors,y=f.outputTensors,b=new Array;for(const w of m)w.id in s&&b.push(s[w.id]);if(b.length===m.length){let w={},x,S,T,$;if(f.callArgs!=null&&(w=f.callArgs),b.length===1){const[E,R]=b[0];w.mask==null&&(w.mask=R),T=jn(d.call(E,w)),$=jn(d.computeMask(E,R)),x=[E],S=[R]}else x=b.map(E=>E[0]),S=b.map(E=>E[1]),w.mask==null&&(w.mask=S),T=jn(d.call(x,w)),$=jn(d.computeMask(x,S));if(d.activityRegularizer)throw new Le("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let E=0;E<y.length;++E){const R=y[E],B=T[E],N=$[E];s[R.id]=[B,N]}}}}const i=[],o=[],a=[];for(const l of this.outputs){Ka(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[c,f]=s[l.id];a.push(c.shape),i.push(c),o.push(f)}return[i,o,a]}buildNodeConversionMap(t){const e={};let s;for(const r of this.layers){s=r instanceof jo?1:0;for(let i=0;i<r.inboundNodes.length;i++){const o=jo.nodeKey(r,i);this.containerNodes.has(o)&&(e[o]=s,s+=1)}}return e}getLayer(t,e){if(e!=null){if(this.layers.length<=e)throw new ht(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}else if(t==null)throw new ht("Provide either a layer name or layer index");for(const s of this.layers)if(s.name===t)return s;throw new ht(`No such layer: ${t}`)}calculateLosses(){return St(()=>{const t=[];for(const e of this.layers)for(let s=0;s<e.inboundNodes.length;++s){const r=jo.nodeKey(e,s);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),s=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),c=[];for(let d=0;d<o.inboundNodes.length;d++){const m=o.inboundNodes[d],y=jo.nodeKey(o,d);let b={};if(this.containerNodes.has(y)){if(m.callArgs)try{JSON.stringify(m.callArgs),b=m.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),b={}}if(m.inboundLayers.length>0){const w=[];for(let x=0;x<m.inboundLayers.length;x++){const S=m.inboundLayers[x],T=m.nodeIndices[x],$=m.tensorIndices[x],E=jo.nodeKey(S,T);let R=e[E];R==null&&(R=0),w.push([S.name,R,$,b])}c.push(w)}}}const f={};f.name=o.name,f.className=a,f.config=l,f.inboundNodes=c,s.push(f)}t.layers=s;const r=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],l=this.inputLayersNodeIndices[o],c=jo.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let f=e[c];f==null&&(f=0);const d=this.inputLayersTensorIndices[o];r.push([a.name,f,d])}t.inputLayers=r;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],l=this.outputLayersNodeIndices[o],c=jo.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let f=e[c];f==null&&(f=0);const d=this.outputLayersTensorIndices[o];i.push([a.name,f,d])}return t.outputLayers=i,t}static fromConfig(t,e,s={},r=!1){const i={},o={};function a(x,S){x.name in o?o[x.name].push(S):o[x.name]=[S]}function l(x,S){const T=[];let $;for(const E of S){const R=E[0],B=E[1],N=E[2];if($=E[3]==null?{}:E[3],!(R in i)){a(x,S);return}const k=i[R];if(k.inboundNodes.length<=B){a(x,S);return}const _=k.inboundNodes[B];T.push(_.outputTensors[N])}T.length>0&&x.apply(ri(T),$)}function c(x){const S=x.name,T=ll(x,e.customObjects!=null?e.customObjects:{});T.setFastWeightInitDuringBuild(r),i[S]=T,x.inboundNodes.forEach(E=>{if(!(E instanceof Array))throw new ht(`Corrupted configuration, expected array for nodeData: ${E}`);a(T,E)})}const f=e.name,d=e.layers;for(const x of d)c(x);for(;!Wkt(o);)for(const x of d){const S=i[x.name];if(S.name in o){const T=o[S.name];delete o[S.name];for(const $ of T)l(S,$)}}const m=[],y=[],b=e.inputLayers;for(const x of b){const S=x[0],T=x[1],$=x[2];Ka(S in i);const R=i[S].inboundNodes[T].outputTensors;m.push(R[$])}const w=e.outputLayers;for(const x of w){const S=x[0],T=x[1],$=x[2];Ka(S in i);const R=i[S].inboundNodes[T].outputTensors;y.push(R[$])}return new t({inputs:m,outputs:y,name:f})}get stateful(){if(this._stateful)throw new ht("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){St(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function lDt(n,t,e){const s=t.length;if(n==null||Array.isArray(n)&&n.length===0)return t.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return t.forEach(i=>{i in n?r.push(n[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${e} must be either an array with ${s} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}function Uq(n,t){return lDt(n,t,"classWeight")}async function Gq(n,t,e,s){if(e!=null){const r=St(()=>{if(n.shape.length===1)return Nh(n);if(n.shape.length===2){if(n.shape[1]>1)return ep(n,1);if(n.shape[1]===1)return kt(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());Ee(r);const o=[];return i.forEach(a=>{if(e[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(e[a])}),_r(o,"float32")}else return null}function uDt(n,t){return mt(n,t)}const cDt=32;function Wq(n,t){let e,s;const r=t;e=r.xs,s=r.ys,Q(e!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const i=nz("input",n.inputNames,e),o=nz("output",n.outputNames,s),a=i[0].shape[0];Q(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),Q(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<i.length;l++)Q(i[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)Q(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function nz(n,t,e){if(e instanceof Zn)return[e];if(Array.isArray(e))return Q(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const s=[];for(const r of t){if(e[r]==null)throw new ht(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(e[r])}return s}}function hDt(n){if(n.length===3)throw new Le("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function fDt(n,t,e){const s=e.batchesPerEpoch!=null;if(Q(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),Q(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),Q(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),Q(!s||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),Q(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=e.validationData!=null;let i,o;if(r)if(sz(e.validationData))Q(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const x=hDt(e.validationData);i=x.xs,o=x.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;r?c=l.slice().concat(l.map(x=>"val_"+x)):c=l.slice();const f=Dq(e.callbacks,e.yieldEvery),d=e.verbose==null?1:e.verbose,{callbackList:m,history:y}=Oq(f,d,e.epochs,null,null,dDt(t,e),null,r,c);m.setModel(n),n.history=y,await m.onTrainBegin(),n.stopTraining_=!1;let b=e.initialEpoch==null?0:e.initialEpoch,w=await t.iterator();for(;b<e.epochs;){const x={};await m.onEpochBegin(b);let S=0,T=0;for(s||(w=await t.iterator());!s||S<e.batchesPerEpoch;){const $=await w.next();if(s&&$.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${S} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if($.value!=null){const{xs:E,ys:R}=Wq(n,$.value),B={};B.batch=T,B.size=E[0].shape[0],await m.onBatchBegin(T,B);const N=[];if(e.classWeight!=null){const F=Uq(e.classWeight,n.outputNames);for(let A=0;A<F.length;++A)N.push(await Gq(R[A],null,F[A]))}const k=E.concat(R).concat(N),_=a(k);Ee(k);for(let F=0;F<l.length;++F){const A=l[F],P=_[F];B[A]=P,gl(P)}await m.onBatchEnd(T,B),Rq(B),T++,S++}if(s?S>=e.batchesPerEpoch:$.done){if(r){let E;sz(e.validationData)?E=jn(await n.evaluateDataset(e.validationData,{batches:e.validationBatches})):E=jn(n.evaluate(i,o,{batchSize:e.validationBatchSize==null?cDt:e.validationBatchSize,verbose:0}));for(let R=0;R<n.metricsNames.length;++R)x[`val_${n.metricsNames[R]}`]=E[R]}break}if(n.stopTraining_)break}if(await m.onEpochEnd(b,x),b++,n.stopTraining_)break}return await m.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function dDt(n,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function sz(n){return typeof n.iterator=="function"}function pDt(n){return typeof n.next=="function"}async function mDt(n,t,e){e=e||{};const s=e.batches!=null,r=n.testFunction;let i=[];if(e.verbose>0)throw new Le("Verbose mode is not implemented yet.");Q(!s||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const o=pDt(t)?t:await t.iterator();let a=0,l=0;for(;!s||l<e.batches;){const c=await o.next();if(i=St(()=>{if(c.value){const{xs:f,ys:d}=Wq(n,c.value),m=f.concat(d),y=St(()=>r(m));if(Ee(m),l===0)for(let w=0;w<y.length;++w)i.push(xn(0));const b=m[0].shape[0];for(let w=0;w<y.length;++w){const x=y[w],S=i[w];i[w]=St(()=>Qt(i[w],mt(b,x))),l>0&&Ee(S)}Ee(y),a+=b,++l}return i}),c.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<i.length;++c){const f=i[c];i[c]=we(i[c],a),Ee(f)}return ri(i)}function M$(n){Q(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function cg(n,t,e){return n==null?[null]:Array.isArray(n)?n.map(s=>Dh(s,t,e-t)):Dh(n,t,e-t)}function K_(n,t){return St(()=>n==null?null:Array.isArray(n)?n.map(e=>K_(e,t)):gq(n,t.dtype==="int32"?t:le(t,"int32")))}function L$(n,t){const e=[];let s=0,r=null;for(;s<n;)r=s+t,r>=n&&(r=n),e.push([s,r]),s=r;return e}async function gDt(n,t,e,s,r,i,o,a,l,c,f,d,m,y,b){r==null&&(r=32),i==null&&(i=1),f==null&&(f=!0),m==null&&(m=0);let w=!1;l!=null&&c!=null&&(w=!0);const x=n.checkNumSamples(e,r,y,"steps_per_epoch");let S;x!=null&&(S=fa(0,x)),o==null&&(o=1);const{callbackList:T,history:$}=Oq(a,o,i,m,x,y,r,w,d);T.setModel(n),n.history=$,await T.onTrainBegin(),n.stopTraining_=!1;for(let E=m;E<i;++E){await T.onEpochBegin(E);const R={};{if(f==="batch")throw new Le("batch shuffling is not implemneted yet");f&&Lg(S);const B=_r(S),N=L$(x,r);for(let k=0;k<N.length;++k){const _={};if(await T.onBatchBegin(k,_),St(()=>{const F=N[k][0],A=N[k][1],P=Dh(B,F,A-F);_.batch=k,_.size=A-F;const L=K_(e,P),tt=t(L);for(let st=0;st<s.length;++st){const j=s[st],Z=tt[st];_[j]=Z,gl(Z)}if(k===N.length-1&&w){const st=n.testLoop(l,c,r);for(let j=0;j<s.length;++j){const Z=s[j],J=st[j];gl(J),R["val_"+Z]=J}}}),await T.onBatchEnd(k,_),Rq(_),n.stopTraining_)break}B.dispose()}if(await T.onEpochEnd(E,R),n.stopTraining_)break}return await T.onTrainEnd(),await n.history.syncData(),n.history}async function yDt(n,t,e,s={}){if(n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;let r,i,o,a,l,c,f,d,m;try{const y=s.batchSize==null?32:s.batchSize;M$(y);const w=await n.standardizeUserData(t,e,s.sampleWeight,s.classWeight,!1,y);r=w[0],i=w[1],m=w[2];let x=!1,S;if(s.validationData!=null&&s.validationData.length>0){if(x=!0,s.validationData.length===2)l=s.validationData[0],c=s.validationData[1];else throw s.validationData.length===3?new Le("validationData including sample weights is not supported yet."):new ht(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const F=await n.standardizeUserData(l,c,null,null,!0,y);f=F[0],d=F[1],S=f.concat(d)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){x=!0;const _=Math.floor(r[0].shape[0]*(1-s.validationSplit)),F=r[0].shape[0];f=cg(r,_,F),o=r,r=cg(r,0,_),d=cg(i,_,F),a=i,i=cg(i,0,_),S=f.concat(d)}else s.validationSteps!=null&&(x=!0);const T=r.concat(i).concat(m);n.checkTrainableWeightsConsistency();const $=n.makeTrainFunction(),E=n.getDedupedMetricsNames();let R,B;x?(n.makeTestFunction(),R=n.testFunction,B=E.slice().concat(E.map(_=>"val_"+_))):(R=null,S=[],B=E.slice());const N=Dq(s.callbacks,s.yieldEvery);return await gDt(n,$,T,E,y,s.epochs,s.verbose,N,R,S,s.shuffle,B,s.initialEpoch,null,null)}finally{n.isTraining=!1,Yo(r,t),Yo(i,e),Yo(o,t),Yo(a,e),Yo(f,l),Yo(d,c),m!=null&&Ee(m)}}function jq(n){const t=[];n instanceof Zn&&(n=[n]);for(let e=0;e<n.length;++e){const s=n[e];if(s.rank===1)t.push(Eb(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function Yo(n,t){if(n==null)return;const e=[];if(t instanceof Zn)e.push(t.id);else if(Array.isArray(t))t.forEach(r=>e.push(r.id));else if(t!=null)for(const r in t){const i=t[r];e.push(i.id)}const s=[];if(n instanceof Zn)e.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{e.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const i=n[r];e.indexOf(i.id)===-1&&s.push(i)}s.forEach(r=>{r.isDisposed||r.dispose()})}function bDt(n){return n instanceof Zn}function z$(n){return Array.isArray(n)}function rz(n){return!bDt(n)&&!z$(n)}function iz(n,t,e,s=!0,r=""){if(t==null||t.length===0){if(n!=null){let o=!1;if(z$(n)&&n.length>0)o=!0;else if(rz(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new ht(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return t.map(o=>null);let i;if(rz(n)){n=n,i=[];for(const o of t){if(n[o]==null)throw new ht(`No data provided for "${o}". Need data for each key in: ${t}`);i.push(n[o])}}else if(z$(n)){if(n=n,n.length!==t.length)throw new ht(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,t.length>1)throw new ht(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=jq(i),e!=null)for(let o=0;o<t.length;++o){if(e[o]==null)continue;const a=i[o];if(a.shape.length!==e[o].length)throw new ht(`Error when checking ${r}: expected ${t[o]} to have ${e[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[o].length;++l){if(l===0&&!s)continue;const c=a.shape[l],f=e[o][l];if(f!=null&&f>=0&&c!==f)throw new ht(`${r} expected a batch of elements where each example has shape [${e[o].slice(1,e[o].length)}] (i.e.,tensor shape [*,${e[o].slice(1,e[o].length)}]) but the ${r} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function xDt(n,t,e){const s=nc(n.map(i=>i.shape[0]));s.sort();const r=nc(t.map(i=>i.shape[0]));if(r.sort(),s.length>1)throw new ht(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(r.length>1)throw new ht(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(i=>i.shape))}`);if(s.length>0&&r.length>0&&!ci(s,r))throw new ht(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function wDt(n,t,e){const s=[nS,sS,Vg];for(let r=0;r<n.length;++r){const i=n[r],o=t[r],a=e[r];if(o!=null){if(o===Vg&&i.shape[i.shape.length-1]===1)throw new ht(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(o)!==-1){const l=i.shape.slice(1),c=a.slice(1);for(let f=0;f<l.length;++f){const d=l[f],m=c[f];if(m!=null&&d!==m)throw new ht(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function oz(n,t,e,s=!0,r=""){let i;if(Array.isArray(n)){if(n.length!==t.length)throw new ht(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(t.length>1)throw new ht(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(e!=null)for(let o=0;o<t.length;++o){if(e[o]==null)continue;const a=i[o];if(a.shape.length!==e[o].length)throw new ht(`Error when checking ${r}: expected ${t[o]} to have ${e[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[o].length;++l){if(l===0&&!s)continue;const c=a.shape[l],f=e[o][l];if(f!=null&&f!==c)throw new ht(`Error when checking ${r}: expected ${t[o]} to have shape ${JSON.stringify(e[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function vDt(n,t){if(n==null||Array.isArray(n)&&n.length===0)return t.map(s=>[]);let e;if(typeof n=="string"||typeof n=="function")e=[n];else if(Array.isArray(n)||typeof n=="object")e=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(e))return t.map(s=>e);{const s=[];for(const r of t){let i=e.hasOwnProperty(r)?e[r]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}const SDt="layers-model";class Oh extends jo{constructor(t){super(t),this.isTraining=!1}summary(t,e,s=console.log){if(!this.built)throw new ht("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");sDt(this,t,e,s)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=nDt(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Lc))throw new ht("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const o in t.loss)if(this.outputNames.indexOf(o)===-1)throw new ht(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)t.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),e.push(dE(t.loss[o]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new ht(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(a=>dE(a))}else{const o=dE(t.loss);this.outputs.forEach(a=>{e.push(o)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],l=this.outputNames[o];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const s=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Rh("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const r=vDt(t.metrics,this.outputNames),i=(o,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,o])};Rh("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=r[o];(c=>{let d,m,y;for(const b of c){if(typeof b=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(b)!==-1){const x=this.internalOutputShapes[o];x[x.length-1]===1||this.lossFunctions[o]===sS?["accuracy","acc"].indexOf(b)!==-1?m=Mq:["crossentropy","ce"].indexOf(b)!==-1&&(m=qRt):this.lossFunctions[o]===Gx?["accuracy","acc"].indexOf(b)!==-1?m=HRt:["crossentropy","ce"].indexOf(b)!==-1&&(m=Bq):["accuracy","acc"].indexOf(b)!==-1?m=Lq:["crossentropy","ce"].indexOf(b)!==-1&&(m=zq);let S;["accuracy","acc"].indexOf(b)!==-1?S="acc":["crossentropy","ce"].indexOf(b)!==-1&&(S="ce"),y=m,d=""+S}else y=eDt(b),d=""+$1(b);let w;Rh(d,()=>{w=y}),i(o,d,w)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,s={}){const r=s.batchSize==null?32:s.batchSize;M$(r);const o=this.standardizeUserDataXY(t,e,!0,r);try{const a=o[0].concat(o[1]);this.makeTestFunction();const l=this.testFunction,c=this.testLoop(l,a,r,s.verbose,s.steps);return ri(c)}finally{Yo(o[0],t),Yo(o[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),mDt(this,t,e)}checkNumSamples(t,e,s,r="steps"){let i;if(s!=null){if(i=null,e!=null)throw new ht(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?i=t[0].shape[0]:i=t.shape[0];else throw new ht(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new ht("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(e),r=s?e:[e],i=this.retrieveSymbolicTensors(r),o=new Yu;if(t instanceof Zn&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new ht(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],t[l])}else for(const l of this.inputs){const c=t[l.name];if(c==null)throw new ht(`No value is provided for the model's input ${l.name}`);o.add(l,c)}const a=ug(i,o);return s?a:a[0]}retrieveSymbolicTensors(t){const e=tf(null,t.length);let s=t.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],o=i.map(a=>a.name);for(let a=0;a<t.length;++a){const l=o.indexOf(t[a]);if(l!==-1&&(e[a]=i[l],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw e.forEach((i,o)=>{i==null&&r.push(t[o])}),new ht(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return e}predictLoop(t,e=32,s=!1){return St(()=>{const r=this.checkNumSamples(t);if(s)throw new Le("Verbose predictLoop() is not implemented yet.");const i=L$(r,e),o=this.outputs.map(a=>[]);for(let a=0;a<i.length;++a)St(()=>{const c=i[a][0],f=i[a][1],d=cg(t,c,f),m=[];if(Array.isArray(d))for(let b=0;b<d.length;++b)m.push({key:this.inputs[b],value:d[b]});else m.push({key:this.inputs[0],value:d});const y=new Yu(m);return ug(this.outputs,y)}).forEach((c,f)=>o[f].push(c));return ri(o.map(a=>na(a,0)))})}predict(t,e={}){const s=jq(t);oz(s,this.inputNames,this.feedInputShapes,!1);try{const r=e.batchSize==null?32:e.batchSize;return M$(r),this.predictLoop(s,r)}finally{Yo(s,t)}}predictOnBatch(t){oz(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,s=!0,r){if(this.optimizer_==null)throw new wo("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===Gx?i.push(a.slice(0,a.length-1).concat([1])):i.push(a)}if(t=iz(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=iz(e,this.feedOutputNames,i,!1,"target"),xDt(t,e),wDt(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&t[0].shape[0]%r!==0)throw new ht(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,s,r,i=!0,o){const[a,l]=this.standardizeUserDataXY(t,e,i,o);if(s!=null)throw new Error("sample weight is not supported yet.");let c=null;if(r!=null){const f=Uq(r,this.outputNames);c=[];for(let d=0;d<f.length;++d)c.push(await Gq(l[d],null,f[d]))}return[a,l,c]}testLoop(t,e,s,r=0,i){return St(()=>{const o=this.checkNumSamples(e,s,i,"steps"),a=[];if(r>0)throw new Le("Verbose mode is not implemented yet.");if(i!=null)throw new Le("steps mode in testLoop() is not implemented yet");{const l=L$(o,s),c=_r(fa(0,o));for(let f=0;f<l.length;++f){const d=l[f][0],m=l[f][1],y=Dh(c,d,m-d),b=K_(e,y),w=t(b);if(f===0)for(let x=0;x<w.length;++x)a.push(xn(0));for(let x=0;x<w.length;++x){const S=w[x];a[x]=Qt(a[x],mt(m-d,S))}}for(let f=0;f<a.length;++f)a[f]=we(a[f],o)}return a})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let s=0;s<t.length;++s){const r=t[s];let i=r;if(zL(t,r)>1){const o=zL(t.slice(0,s),r);i+=`_${o}`}e.push(i)}return e}makeTrainFunction(){return t=>{const e=[],s=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const d=[];for(let w=0;w<this.inputs.length;++w)d.push({key:this.inputs[w],value:s[w]});const m=new Yu(d),y=ug(this.outputs,m,{training:!0});let b;for(let w=0;w<this.lossFunctions.length;++w){const x=this.lossFunctions[w];let S=x(r[w],y[w]);i[w]!=null&&(S=uDt(S,i[w]));const T=As(S);e.push(T),w===0?b=S:b=Qt(b,S)}for(let w=0;w<this.metricsTensors.length;++w){let x;if(this.outputs.length>1&&w<this.outputs.length)x=e[w];else{const S=this.metricsTensors[w][0],T=this.metricsTensors[w][1];x=As(S(r[T],y[T]))}gl(x),o.push(x)}return b=As(b),this.calculateLosses().forEach(w=>{b=Qt(b,w)}),b},l=this.collectedTrainableWeights.map(d=>d.read());return[this.optimizer_.minimize(a,!0,l)].concat(o)}}makeTestFunction(){this.testFunction=t=>St(()=>{const e=[];let s;const r=t.slice(0,this.inputs.length),i=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let c=0;c<this.inputs.length;++c)o.push({key:this.inputs[c],value:r[c]});const a=new Yu(o),l=ug(this.outputs,a);for(let c=0;c<this.lossFunctions.length;++c){const f=this.lossFunctions[c],d=As(f(i[c],l[c]));c===0?s=d:s=Qt(s,d),e.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const f=this.metricsTensors[c][0],d=this.metricsTensors[c][1],m=As(f(i[d],l[d]));e.push(m)}return e})}async fit(t,e,s={}){return yDt(this,t,e,s)}async fitDataset(t,e){return fDt(this,t,e)}async trainOnBatch(t,e){const s=await this.standardizeUserData(t,e),r=s[0],i=s[1],a=this.makeTrainFunction()(r.concat(i)),l=[];for(const c of a){const f=await c.data();l.push(f[0])}return Ee(a),Yo(s[0],t),Yo(s[1],e),ri(l)}getNamedWeights(t){const e=[],s=t!=null&&t.trainableOnly,r=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let o=0;o<r.length;++o)s&&!r[o].trainable||e.push({name:r[o].originalName,tensor:i[o]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const e=$3().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-$3().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=Vl(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>Vl(e))}else{const e=Object.keys(this.loss);t={};const s=this.loss;for(const r of e)if(typeof s[r]=="string")t[r]=Vl(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Vl($1(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>Vl($1(t)));{const t={};for(const e in this.metrics)t[e]=Vl($1(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const e=Hx(t.optimizer_config),s=ll(e);let r;if(typeof t.loss=="string")r=vh(t.loss);else if(Array.isArray(t.loss))r=t.loss.map(o=>vh(o));else if(t.loss!=null){r={};for(const o in t.loss)r[o]=vh(t.loss[o])}let i;if(Array.isArray(t.metrics))i=t.metrics.map(o=>vh(o));else if(t.metrics!=null){i={};for(const o in t.metrics)i[o]=vh(t.metrics[o])}this.compile({loss:r,metrics:i,optimizer:s})}async save(t,e){if(typeof t=="string"){const c=iCt(t);if(c.length===0)throw new ht(`Cannot find any save handlers for URL '${t}'`);if(c.length>1)throw new ht(`Found more than one (${c.length}) save handlers for URL '${t}'`);t=c[0]}if(t.save==null)throw new ht("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await S3(this.getNamedWeights(e)),a={modelTopology:this.toJSON(null,!1),format:SDt,generatedBy:`TensorFlow.js tfjs-layers v${Vq}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:f,specs:d}=await S3(await this.optimizer.getWeights(),c);s.specs.push(...d),s.data=y5([s.data,f])}return this.userDefinedMetadata!=null&&(ez(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=s.data,a.weightSpecs=s.specs,t.save(a)}setUserDefinedMetadata(t){ez(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Oh.className="Model";Kt(Oh);class qq extends Oh{}qq.className="Functional";Kt(qq);async function IDt(n,t){if(t==null&&(t={}),typeof n=="string"){const e=oCt(n,t);if(e.length===0)e.push(kCt(n,t));else if(e.length>1)throw new ht(`Found more than one (${e.length}) load handlers for URL '${n}'`);n=e[0]}return TDt(n,void 0,t)}async function TDt(n,t,e){if(e==null&&(e={}),n.load==null)throw new ht("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await n.load();let r=s.modelTopology;r.model_config!=null&&(r=r.model_config);const i=e.strict==null?!0:e.strict,o=s.weightData!=null&&s.weightSpecs!=null&&i,a=ll(Hx(r),t,o),l=s.trainingConfig;if(l!=null&&a.loadTrainingConfig(l),s.userDefinedMetadata!=null&&a.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new ht("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:c,optimizerWeights:f}=CDt(s.weightData,s.weightSpecs);a.loadWeights(c,i),a.optimizer!=null&&f.length>0&&await a.optimizer.setWeights(f),Ee(c),Ee(f.map(d=>d.tensor))}return a}function CDt(n,t){const e=HTt(n,t),s={},r=[];return t.forEach(i=>{i.group==="optimizer"?r.push({name:i.name,tensor:e[i.name]}):s[i.name]=e[i.name]}),{modelWeights:s,optimizerWeights:r}}class lp extends Oh{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:Jv("sequential_"),t.layers!=null)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new ht(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof lp||t instanceof Oh;let s;if(e){if(s=t,s.outputs.length!==1)throw new ht("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new ht("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new ht("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=x_t({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(r)}if(e)this.outputs=s.outputs,this.inputs=s.inputs;else{if(t.inboundNodes.length!==1)throw new ht(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new ht("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=Cq(this.outputs[0])}this.inboundNodes=[],new eS({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:tf(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=t.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(In(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Oh({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,s=console.log){this.built||this.build(),super.summary(t,e,s)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,s={}){if(!this.built)throw new wo("The model needs to be compiled before being used.");return this.model.evaluate(t,e,s)}async evaluateDataset(t,e){if(!this.built)throw new wo("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,s={}){if(!this.built)throw new wo("The model needs to be compiled before being used.");return this.model.fit(t,e,s)}async fitDataset(t,e){if(!this.built)throw new wo("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,s={},r=!1){let i,o={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new ht("Legacy serialization format not supported yet.");i=e}else Q(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=e.layers,delete e.layers,o=e;const a=new t(o);if(!(a instanceof lp))throw new Le(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of i){const f=ll(l,void 0,r);r&&f.setFastWeightInitDuringBuild(!0),a.add(f)}return a}set stopTraining(t){if(this.model==null)throw new ht("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new ht("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const s={};s.className=e.getClassName(),s.config=e.getConfig(),t.push(s)}return{name:this.name,layers:t}}}lp.className="Sequential";Kt(lp);function Hq(n){return new Oh(n)}function EDt(n){return new lp(n)}function B$(n,t){return t==null&&(t={}),IDt(n,t)}let di=class extends Mp{getConfig(){return{}}};class Kq extends di{apply(t,e=1){return i_t(t,e)}}Kq.className="elu";Kt(Kq);class Xq extends di{apply(t){return a2t(t)}}Xq.className="selu";Kt(Xq);class Yq extends di{apply(t){return zp(t)}}Yq.className="relu";Kt(Yq);class Qq extends di{apply(t){return St(()=>F5(6,zp(t)))}}Qq.className="relu6";Kt(Qq);class Zq extends di{apply(t){return t}}Zq.className="linear";Kt(Zq);class Jq extends di{apply(t){return jv(t)}}Jq.className="sigmoid";Kt(Jq);class tH extends di{apply(t){return a_t(t)}}tH.className="hardSigmoid";Kt(tH);class eH extends di{apply(t){return y_(t)}}eH.className="softplus";Kt(eH);class nH extends di{apply(t){return o_t(t)}}nH.className="softsign";Kt(nH);class sH extends di{apply(t){return E5(t)}}sH.className="tanh";Kt(sH);let X_=class extends di{apply(t,e=-1){return P5(t,e)}};X_.className="softmax";Kt(X_);class rH extends di{apply(t,e=-1){return _$t(t,e)}}rH.className="logSoftmax";Kt(rH);class iH extends di{apply(t,e=1){return St(()=>mt(jv(mt(t,e)),t))}}iH.className="swish";Kt(iH);class oH extends di{apply(t){return St(()=>mt(t,E5(y_(t))))}}oH.className="mish";Kt(oH);function xc(n){return n.getClassName()}function pE(n,t={}){return Tb(n,go.getMap().classNameMap,t,"activation")}function wc(n){if(n==null){const t={};return t.className="linear",t.config={},pE(t)}if(typeof n=="string"){const t={};return t.className=n,t.config={},pE(t)}else return n instanceof di?n:pE(n)}function $Dt(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class aH extends Mp{}class lH extends aH{constructor(t){super(),$Dt(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return St(()=>{let e=gr([1]);return this.hasL1&&(e=Qt(e,xe(mt(this.l1,Jr(t))))),this.hasL2&&(e=Qt(e,xe(mt(this.l2,$b(t))))),kt(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}lH.className="L1L2";Kt(lH);const az={l1l2:"L1L2"};function Ln(n){return O_(n)}function lz(n,t={}){return Tb(n,go.getMap().classNameMap,t,"regularizer")}function ss(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in az?az[n]:n,config:{}};return lz(e)}else return n instanceof aH?n:lz(n)}class uH extends Ze{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=Re(t);let s=zp(t);return this.maxValue!=null&&(s=To(s,0,this.maxValue)),s}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}uH.className="ReLU";Kt(uH);class cH extends Ze{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=Re(t);return O5(s,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}cH.className="LeakyReLU";Kt(cH);class hH extends Ze{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=es(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=ss(t.alphaRegularizer),this.alphaConstraint=Qs(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new ht(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=In(t);const e=t.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)e[r-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<t.length;++r)s[r]=t[r];this.inputSpec=[new qs({ndim:t.length,axes:s})],this.built=!0}call(t,e){return t=Re(t),L5(t,this.alpha.read())}getConfig(){const t={alphaInitializer:cs(this.alphaInitializer),alphaRegularizer:Ln(this.alphaRegularizer),alphaConstraint:Ys(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}hH.className="PReLU";Kt(hH);class fH extends Ze{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new Le(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=Re(t);return p_(s)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}fH.className="ELU";Kt(fH);class dH extends Ze{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){const s=Re(t);return mt(s,le(ga(s,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}dH.className="ThresholdedReLU";Kt(dH);class pH extends Ze{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new X_().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){const s=Re(t);return this.softmax(s,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}pH.className="Softmax";Kt(pH);function Bd(n,t,e){if(typeof n=="number")return tf(n,t);if(n.length!==t)throw new ht(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let s=0;s<t;++s){const r=n[s];if(!e_t(r))throw new ht(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function sa(n,t,e,s,r=1){if(n==null)return n;const i=t+(t-1)*(r-1);let o;return e==="same"?o=n:o=n-i+1,Math.floor((o+s-1)/s)}function Xa(n,t,e,s){if(n==null)return null;if(s==="valid")n=n*t+bc([e-t,0]);else if(s==="same")n=n*t;else throw new ht(`Unsupport padding mode: ${s}.`);return n}function Y_(n,t){return St(()=>(Ss(t),t==="channelsFirst"?nn(n,[0,2,3,1]):n))}function mH(n,t){return St(()=>(Ss(t),t==="channelsFirst"?nn(n,[0,2,3,4,1]):n))}function ADt(n,t,e,s=1,r="valid",i,o=1){return St(()=>{if(i==null&&(i=da()),Ss(i),n.shape.length!==3)throw new ht(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(t.shape.length!==3)throw new ht(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new ht(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(i==="channelsFirst"&&(n=nn(n,[0,2,1])),r==="causal")throw new Le("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=FEt(n,t,s,r==="same"?"same":"valid","NWC",o);return e!=null&&(a=ya(a,e)),a})}function uz(n,t,e,s=[1,1],r="valid",i,o,a=null){return St(()=>{if(i==null&&(i=da()),Ss(i),n.rank!==3&&n.rank!==4)throw new ht(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(t.rank!==3&&t.rank!==4)throw new ht(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=Y_(n,i);if(r==="causal")throw new Le("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=O2t({x:l,filter:t,strides:s,pad:r==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:e,activation:a}),i==="channelsFirst"&&(l=nn(l,[0,3,1,2])),l})}function kDt(n,t,e,s=[1,1,1],r="valid",i,o){return St(()=>{if(i==null&&(i=da()),Ss(i),n.rank!==4&&n.rank!==5)throw new ht(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(t.rank!==4&&t.rank!==5)throw new ht(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=mH(n,i);if(r==="causal")throw new Le("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=PEt(a,t,s,r==="same"?"same":"valid","NDHWC",o),e!=null&&(a=ya(a,e)),i==="channelsFirst"&&(a=nn(a,[0,4,1,2,3])),a})}class rS extends Ze{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",rS.verifyArgs(e),this.rank=t,ir(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Le(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Bd(e.kernelSize,t,"kernelSize"),this.strides=Bd(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,Yi(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ss(this.dataFormat),this.activation=wc(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=es(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Qs(e.biasConstraint),this.biasRegularizer=ss(e.biasRegularizer),this.activityRegularizer=ss(e.activityRegularizer),this.dilationRate=Bd(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ht(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ht(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ht(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Ka("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!F_(t.kernelSize,"number",1,3))throw new ht(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:xc(this.activation),useBias:this.useBias,biasInitializer:cs(this.biasInitializer),biasRegularizer:Ln(this.biasRegularizer),activityRegularizer:Ln(this.activityRegularizer),biasConstraint:Ys(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Vp extends rS{constructor(t,e){super(t,e),this.kernel=null,Vp.verifyArgs(e),this.filters=e.filters,ir(this.filters,"filters"),this.kernelInitializer=es(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Qs(e.kernelConstraint),this.kernelRegularizer=ss(e.kernelRegularizer)}build(t){t=In(t);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new ht(`The channel dimension of the input should be defined. Found ${t[e]}`);const s=t[e],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:s}}],this.built=!0}call(t,e){return St(()=>{t=Re(t);let s;const r=this.bias==null?null:this.bias.read(),i=cq(this.activation.getClassName());if(i!=null&&this.rank===2)s=uz(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)s=ADt(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=uz(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=kDt(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Le("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(t){t=In(t);const e=[],s=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let i=0;i<s.length;++i){const o=sa(s[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);e.push(o)}let r=[t[0]];return this.dataFormat==="channelsLast"?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:cs(this.kernelInitializer),kernelRegularizer:Ln(this.kernelRegularizer),kernelConstraint:Ys(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new ht(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class Nb extends Vp{constructor(t){super(2,t),Nb.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!F_(t.kernelSize,"number",1,2))throw new ht(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}Nb.className="Conv2D";Kt(Nb);class Rb extends Vp{constructor(t){super(3,t),Rb.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new ht(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}Rb.className="Conv3D";Kt(Rb);class gH extends Nb{constructor(t){if(super(t),this.inputSpec=[new qs({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ht(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=In(t),t.length!==4)throw new ht("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new ht("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new qs({ndim:4,axes:{[e]:s}})],this.built=!0}call(t,e){return St(()=>{let s=Re(t);if(s.shape.length!==4)throw new ht(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const l=r[o],c=r[a],f=this.kernelSize[0],d=this.kernelSize[1],m=this.strides[0],y=this.strides[1],b=Xa(l,m,f,this.padding),w=Xa(c,y,d,this.padding),x=[i,b,w,this.filters];this.dataFormat!=="channelsLast"&&(s=nn(s,[0,2,3,1]));let S=zEt(s,this.kernel.read(),x,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(S=nn(S,[0,3,1,2])),this.bias!=null&&(S=ya(S,this.bias.read(),this.dataFormat)),this.activation!=null&&(S=this.activation.apply(S)),S})}computeOutputShape(t){t=In(t);const e=t.slice();let s,r,i;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3):(s=3,r=1,i=2);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return e[s]=this.filters,e[r]=Xa(e[r],l,o,this.padding),e[i]=Xa(e[i],c,a,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}gH.className="Conv2DTranspose";Kt(gH);class yH extends Rb{constructor(t){if(super(t),this.inputSpec=[new qs({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new ht(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=In(t),t.length!==5)throw new ht("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new ht("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new qs({ndim:5,axes:{[e]:s}})],this.built=!0}call(t,e){return St(()=>{let s=Re(t);if(s.shape.length!==5)throw new ht(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,a,l;this.dataFormat==="channelsFirst"?(l=2,o=3,a=4):(l=1,o=2,a=3);const c=r[l],f=r[o],d=r[a],m=this.kernelSize[0],y=this.kernelSize[1],b=this.kernelSize[2],w=this.strides[0],x=this.strides[1],S=this.strides[2],T=Xa(c,w,m,this.padding),$=Xa(f,x,y,this.padding),E=Xa(d,S,b,this.padding),R=[i,T,$,E,this.filters];this.dataFormat!=="channelsLast"&&(s=nn(s,[0,2,3,4,1]));let B=GEt(s,this.kernel.read(),R,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(B=nn(B,[0,4,1,2,3])),this.bias!==null&&(B=ya(B,this.bias.read(),this.dataFormat)),this.activation!==null&&(B=this.activation.apply(B)),B})}computeOutputShape(t){t=In(t);const e=t.slice();let s,r,i,o;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3,o=4):(s=4,r=1,i=2,o=3);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],f=this.strides[0],d=this.strides[1],m=this.strides[2];return e[s]=this.filters,e[r]=Xa(e[r],f,a,this.padding),e[i]=Xa(e[i],d,l,this.padding),e[o]=Xa(e[o],m,c,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}yH.className="Conv3DTranspose";Kt(yH);class bH extends Vp{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new ht("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new ht("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new ht(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=es(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=ss(e.depthwiseRegularizer),this.depthwiseConstraint=Qs(e.depthwiseConstraint),this.pointwiseInitializer=es(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=ss(e.pointwiseRegularizer),this.pointwiseConstraint=Qs(e.pointwiseConstraint)}build(t){if(t=In(t),t.length<this.rank+2)throw new ht(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new ht(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const s=t[e],r=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let a=0;a<this.rank;++a)i.push(1);i.push(s*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new qs({ndim:this.rank+2,axes:{[e]:s}})],this.built=!0}call(t,e){return St(()=>{t=Re(t);let s;if(this.rank===1)throw new Le("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=nn(t,[0,2,3,1])),s=u2t(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=ya(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=nn(s,[0,3,1,2])),s})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=cs(this.depthwiseInitializer),t.pointwiseInitializer=cs(this.pointwiseInitializer),t.depthwiseRegularizer=Ln(this.depthwiseRegularizer),t.pointwiseRegularizer=Ln(this.pointwiseRegularizer),t.depthwiseConstraint=Ys(this.depthwiseConstraint),t.pointwiseConstraint=Ys(this.pointwiseConstraint),t}}bH.className="SeparableConv";class xH extends bH{constructor(t){super(2,t)}}xH.className="SeparableConv2D";Kt(xH);class iS extends Vp{constructor(t){super(1,t),iS.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!F_(t.kernelSize,"number",1,1))throw new ht(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}iS.className="Conv1D";Kt(iS);class wH extends Ze{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return St(()=>{if(t=Re(t),this.dataFormat==="channelsLast"){const s=E1(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return E1(s,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=E1(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return E1(s,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}wH.className="Cropping2D";Kt(wH);class vH extends Ze{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Ss(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,Zkt(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const e=t[2]==null?null:this.size[0]*t[2],s=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,s]}else{const e=t[1]==null?null:this.size[0]*t[1],s=t[2]==null?null:this.size[1]*t[2];return[t[0],e,s,t[3]]}}call(t,e){return St(()=>{let s=Re(t);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=nn(s,[0,2,3,1]);const i=this.size[0]*r[2],o=this.size[1]*r[3],a=this.interpolation==="nearest"?v1.resizeNearestNeighbor(s,[i,o]):v1.resizeBilinear(s,[i,o]);return nn(a,[0,3,1,2])}else{const i=this.size[0]*r[1],o=this.size[1]*r[2];return this.interpolation==="nearest"?v1.resizeNearestNeighbor(s,[i,o]):v1.resizeBilinear(s,[i,o])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}vH.className="UpSampling2D";Kt(vH);function _Dt(n,t,e=[1,1],s="valid",r,i){return St(()=>{r==null&&(r=da()),Ss(r);let o=Y_(n,r);if(n.rank!==4)throw new ht(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(t.rank!==4)throw new ht(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=k5(o,t,e,s==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(o=nn(o,[0,3,1,2])),o})}class SH extends rS{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=es(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Qs(t.depthwiseConstraint),this.depthwiseRegularizer=ss(t.depthwiseRegularizer)}build(t){if(t=In(t),t.length<4)throw new ht(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new ht(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const s=t[e],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return St(()=>{t=Re(t);let s=_Dt(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=ya(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(t){t=In(t);const e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,i=sa(e,this.kernelSize[0],this.padding,this.strides[0]),o=sa(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],r,i,o]:[t[0],i,o,r]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=cs(this.depthwiseInitializer),t.depthwiseRegularizer=Ln(this.depthwiseRegularizer),t.depthwiseConstraint=Ys(this.depthwiseRegularizer),t}}SH.className="DepthwiseConv2D";Kt(SH);function IH(n,t,e,s){if(Array.isArray(n)){if(t!=null||e!=null)throw new ht("When inputs is an array, neither initialState or constants should be provided");s!=null&&(e=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return t=r(t),e=r(e),{inputs:n,initialState:t,constants:e}}function TH(n,t,e,s=!1,r,i,o=!1,a=!1){return St(()=>{const l=t.shape.length;if(l<3)throw new ht(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(fa(2,l));t=nn(t,c),o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=le(le(r,"bool"),"float32"),r.rank===l-1&&(r=Xo(r,-1)),r=nn(r,c)),s&&(t=Fx(t,0),r!=null&&(r=Fx(r,0)));const f=[];let d,m=e;const y=t.shape[0],b=ip(t);let w;r!=null&&(w=ip(r));for(let S=0;S<y;++S){const T=b[S],$=St(()=>n(T,m));if(r==null)d=$[0],m=$[1];else{const E=St(()=>{const R=w[S],B=$e(ha(R),R),N=Qt(mt($[0],R),mt(m[0],B)),k=m.map((_,F)=>Qt(mt($[1][F],R),mt(_,B)));return{output:N,newStates:k}});d=E.output,m=E.newStates}a&&f.push(d)}let x;return a&&(x=yc(f,1)),[d,x,m]})}class zc extends Ze{constructor(t){super(t);let e;if(t.cell==null)throw new ht("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new J_({cells:t.cell}):e=t.cell,e.stateSize==null)throw new ht("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new qs({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return fa(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){R$(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const s=e[0];let r;if(this.returnSequences?r=[t[0],t[1],s]:r=[t[0],s],this.returnState){const i=[];for(const o of e)i.push([t[0],o]);return[r].concat(i)}else return r}computeMask(t,e){return St(()=>{Array.isArray(e)&&(e=e[0]);const s=this.returnSequences?e:null;if(this.returnState){const r=this.states.map(i=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let s=0;s<t;++s)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Le("Constants support is not implemented in RNN yet.");R$(t)&&(t=t[0]),t=t;const e=this.stateful?t[0]:null,s=t.slice(2);this.inputSpec[0]=new qs({shape:[e,null,...s]});const r=[t[0]].concat(t.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!ci(this.stateSpec.map(o=>o.shape[o.shape.length-1]),i))throw new ht(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(o=>new qs({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){St(()=>{if(!this.stateful)throw new Ha("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new ht("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>gr([s,r])):this.states_=[gr([s,this.cell.stateSize])];else if(t==null)Ee(this.states_),this.keptStates!=null&&(Ee(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>gr([s,r])):this.states_[0]=gr([s,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new ht(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):Ee(this.states_);for(let r=0;r<this.states_.length;++r){const i=t[r],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,a=[s,o];if(!ci(i.shape,a))throw new ht(`State ${r} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>gl(r.clone()))})}apply(t,e){let s=e==null?null:e.initialState,r=e==null?null:e.constants;e==null&&(e={});const i=IH(t,s,r,this.numConstants);t=i.inputs,s=i.initialState,r=i.constants;let o=[],a=[];if(s!=null){e.initialState=s,o=o.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new qs({shape:c.shape}));a=a.concat(this.stateSpec)}if(r!=null&&(e.constants=r,o=o.concat(r),this.numConstants=r.length),o[0]instanceof tl){const c=[t].concat(o),f=this.inputSpec.concat(a),d=this.inputSpec;this.inputSpec=f;const m=super.apply(c,e);return this.inputSpec=d,m}else return super.apply(t,e)}call(t,e){return St(()=>{const s=e==null?null:e.mask,r=e==null?null:e.training;let i=e==null?null:e.initialState;t=Re(t),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(t));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new ht(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:r},c=TH((b,w)=>{const x=this.cell.call([b].concat(w),a);return[x[0],x.slice(1)]},t,i,this.goBackwards,s,null,this.unroll,this.returnSequences),f=c[0],d=c[1],m=c[2];this.stateful&&this.resetStates(m,r);const y=this.returnSequences?d:f;return this.returnState?[y].concat(m):y})}getInitialState(t){return St(()=>{let e=gr(t.shape);return e=xe(e,[1,2]),e=Eb(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?_$(e,[1,s]):e):this.cell.stateSize>1?[_$(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===zc.className&&(e.cell={className:this.cell.getClassName(),config:s}),Object.assign({},s,t,e)}static fromConfig(t,e,s={}){const r=e.cell,i=ll(r,s);return new t(Object.assign(e,{cell:i}))}}zc.className="RNN";Kt(zc);class oS extends Ze{}class Q_ extends oS{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,ir(this.units,"units"),this.activation=wc(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=es(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=es(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=es(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ss(t.kernelRegularizer),this.recurrentRegularizer=ss(t.recurrentRegularizer),this.biasRegularizer=ss(t.biasRegularizer),this.kernelConstraint=Qs(t.kernelConstraint),this.recurrentConstraint=Qs(t.recurrentConstraint),this.biasConstraint=Qs(t.biasConstraint),this.dropout=ap([1,bc([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=ap([1,bc([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=In(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return St(()=>{if(t=t,t.length!==2)throw new ht(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let s=t[1];t=t[0];const r=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=vc({ones:()=>ha(t),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=vc({ones:()=>ha(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?i=al(mt(t,o),this.kernel.read()):i=al(t,this.kernel.read()),this.bias!=null&&(i=ya(i,this.bias.read())),a!=null&&(s=mt(s,a));let l=Qt(i,al(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:xc(this.activation),useBias:this.useBias,kernelInitializer:cs(this.kernelInitializer),recurrentInitializer:cs(this.recurrentInitializer),biasInitializer:cs(this.biasInitializer),kernelRegularizer:Ln(this.kernelRegularizer),recurrentRegularizer:Ln(this.recurrentRegularizer),biasRegularizer:Ln(this.biasRegularizer),activityRegularizer:Ln(this.activityRegularizer),kernelConstraint:Ys(this.kernelConstraint),recurrentConstraint:Ys(this.recurrentConstraint),biasConstraint:Ys(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}}Q_.className="SimpleRNNCell";Kt(Q_);class CH extends zc{constructor(t){t.cell=new Q_(t),super(t)}call(t,e){return St(()=>{this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}static fromConfig(t,e){return new t(e)}}CH.className="SimpleRNN";Kt(CH);class Z_ extends oS{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new ht("GRUCell does not support reset_after parameter set to true.");this.units=t.units,ir(this.units,"units"),this.activation=wc(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=wc(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=es(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=es(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=es(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ss(t.kernelRegularizer),this.recurrentRegularizer=ss(t.recurrentRegularizer),this.biasRegularizer=ss(t.biasRegularizer),this.kernelConstraint=Qs(t.kernelConstraint),this.recurrentConstraint=Qs(t.recurrentConstraint),this.biasConstraint=Qs(t.biasConstraint),this.dropout=ap([1,bc([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=ap([1,bc([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=In(t);const e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return St(()=>{if(t=t,t.length!==2)throw new ht(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training==null?!1:e.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=vc({ones:()=>ha(t),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=vc({ones:()=>ha(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,c;0<this.dropout&&this.dropout<1&&(t=mt(t,i[0]));let f=al(t,this.kernel.read());this.useBias&&(f=ya(f,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=mt(r,o[0]));const d=this.recurrentKernel.read(),[m,y]=ol(d,[2*this.units,this.units],d.rank-1),b=al(r,m),[w,x,S]=ol(f,3,f.rank-1),[T,$]=ol(b,2,b.rank-1);a=this.recurrentActivation.apply(Qt(w,T)),l=this.recurrentActivation.apply(Qt(x,$));const E=al(mt(l,r),y);c=this.activation.apply(Qt(S,E));const R=Qt(mt(a,r),mt(Qt(1,Lr(a)),c));return[R,R]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:xc(this.activation),recurrentActivation:xc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:cs(this.kernelInitializer),recurrentInitializer:cs(this.recurrentInitializer),biasInitializer:cs(this.biasInitializer),kernelRegularizer:Ln(this.kernelRegularizer),recurrentRegularizer:Ln(this.recurrentRegularizer),biasRegularizer:Ln(this.biasRegularizer),activityRegularizer:Ln(this.activityRegularizer),kernelConstraint:Ys(this.kernelConstraint),recurrentConstraint:Ys(this.recurrentConstraint),biasConstraint:Ys(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}}Z_.className="GRUCell";Kt(Z_);class EH extends zc{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new Z_(t),super(t)}call(t,e){return St(()=>{this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}EH.className="GRU";Kt(EH);class aS extends oS{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,ir(this.units,"units"),this.activation=wc(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=wc(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=es(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=es(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=es(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=ss(t.kernelRegularizer),this.recurrentRegularizer=ss(t.recurrentRegularizer),this.biasRegularizer=ss(t.biasRegularizer),this.kernelConstraint=Qs(t.kernelConstraint),this.recurrentConstraint=Qs(t.recurrentConstraint),this.biasConstraint=Qs(t.biasConstraint),this.dropout=ap([1,bc([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=ap([1,bc([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=In(t);const s=t[t.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;r=new(e=class extends _o{apply(l,c){const f=i.apply([o]),d=new L_().apply([o]),m=i.apply([o*2]);return PL(PL(f,d),m)}},e.className="CustomInit",e)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return St(()=>{const s=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new ht(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let r=t[1];const i=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=vc({ones:()=>ha(t),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=vc({ones:()=>ha(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let l,c,f,d;0<this.dropout&&this.dropout<1&&(t=mt(t,o[0]));let m=al(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=mt(r,a[0])),m=Qt(m,al(r,this.recurrentKernel.read())),this.useBias&&(m=ya(m,this.bias.read()));const[y,b,w,x]=ol(m,4,m.rank-1);l=this.recurrentActivation.apply(y),c=this.recurrentActivation.apply(b),f=Qt(mt(c,i),mt(l,this.activation.apply(w))),d=this.recurrentActivation.apply(x);const S=mt(d,this.activation.apply(f));return[S,S,f]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:xc(this.activation),recurrentActivation:xc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:cs(this.kernelInitializer),recurrentInitializer:cs(this.recurrentInitializer),biasInitializer:cs(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Ln(this.kernelRegularizer),recurrentRegularizer:Ln(this.recurrentRegularizer),biasRegularizer:Ln(this.biasRegularizer),activityRegularizer:Ln(this.activityRegularizer),kernelConstraint:Ys(this.kernelConstraint),recurrentConstraint:Ys(this.recurrentConstraint),biasConstraint:Ys(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}}aS.className="LSTMCell";Kt(aS);class $H extends zc{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new aS(t),super(t)}call(t,e){return St(()=>{this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}$H.className="LSTM";Kt($H);class J_ extends oS{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return St(()=>{t=t;let s=t.slice(1);const r=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?r.push(s.splice(0,a.stateSize.length)):r.push(s.splice(0,1));r.reverse();const i=[];let o;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];s=r[a],a===0?o=[t[0]].concat(s):o=[o[0]].concat(s),o=l.call(o,e),i.push(o.slice(1))}s=[];for(const a of i.slice().reverse())s.push(...a);return[o[0]].concat(s)})}build(t){R$(t)&&(t=t[0]),t=t;let e;this.cells.forEach((s,r)=>{Rh(`RNNCell_${r}`,()=>{s.build(t),Array.isArray(s.stateSize)?e=s.stateSize[0]:e=s.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e=i=>({className:i.getClassName(),config:i.getConfig()}),r={cells:this.cells.map(e)};return Object.assign({},t,r)}static fromConfig(t,e,s={}){const r=[];for(const i of e.cells)r.push(ll(i,s));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.cells)e.push(...s.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return D$(t)}setWeights(t){const e=[];for(const s of this.cells){const r=s.weights.length,i=t.splice(r);for(let o=0;o<s.weights.length;++o)e.push([s.weights[o],i[o]])}W_(e)}}J_.className="StackedRNNCells";Kt(J_);function vc(n){const{ones:t,rate:e,training:s=!1,count:r=1,dropoutFunc:i}=n,o=()=>i!=null?i(t(),e):yq(t(),e),a=()=>Ab(o,t,s);return!r||r<=1?gl(a().clone()):Array(r).fill(void 0).map(a).map(c=>gl(c.clone()))}var NDt=function(n,t){var e={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&t.indexOf(s)<0&&(e[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)t.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(e[s[r]]=n[s[r]]);return e};class AH extends zc{constructor(t){if(t.unroll)throw new Le("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new Le("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new qs({ndim:5})]}call(t,e){return St(()=>{if(this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new ht("ConvRNN2D cell does not support constants");const s=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return St(()=>{const{stateSize:e}=this.cell,s=t.shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)],o=gr(i);return Array.isArray(e)?Array(e.length).fill(o):[o]})}resetStates(t,e=!1){St(()=>{if(!this.stateful)throw new Ha("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)];if(s[0]==null)throw new ht("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>gr(i)):this.states_=[gr(i)];else if(t==null)Ee(this.states_),this.keptStates!=null&&(Ee(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>gr(i)):this.states_[0]=gr(i);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new ht(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):Ee(this.states_);for(let a=0;a<this.states_.length;++a){const l=t[a],c=i;if(!ci(l.shape,c))throw new ht(`State ${a} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>gl(a.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:s,kernelSize:r,padding:i,strides:o,dilationRate:a}=this.cell,l=e==="channelsFirst",c=t[l?3:2],f=t[l?4:3],d=sa(c,r[0],i,o[0],a[0]),m=sa(f,r[1],i,o[1],a[1]);return[...t.slice(0,2),...l?[s,d,m]:[d,m,s]]}}AH.className="ConvRNN2D";class tN extends aS{constructor(t){const{filters:e,kernelSize:s,strides:r,padding:i,dataFormat:o,dilationRate:a}=t;super(Object.assign({},t,{units:e})),this.filters=e,ir(this.filters,"filters"),this.kernelSize=Bd(s,2,"kernelSize"),this.kernelSize.forEach(l=>ir(l,"kernelSize")),this.strides=Bd(r||1,2,"strides"),this.strides.forEach(l=>ir(l,"strides")),this.padding=i||"valid",Yi(this.padding),this.dataFormat=o||"channelsLast",Ss(this.dataFormat),this.dilationRate=Bd(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>ir(l,"dilationRate"))}build(t){var e;t=In(t);const s=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[s]==null)throw new ht(`The channel dimension of the input should be defined. Found ${t[s]}`);const r=t[s],i=4,o=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const c=this.biasInitializer,f=this.filters;l=new(e=class extends _o{apply(m,y){const b=c.apply([f]),w=wf([f]),x=c.apply([f*2]);return M_([b,w,x])}},e.className="CustomInit",e)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return St(()=>{if(t.length!==3)throw new ht(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training||!1,r=t[0],i=t[1],o=t[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=vc({ones:()=>ha(r),rate:this.dropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=(pt,q,et)=>!q||!q[et]?pt:mt(q[et],pt);let f=c(r,l,0),d=c(r,l,1),m=c(r,l,2),y=c(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=vc({ones:()=>ha(i),rate:this.recurrentDropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const b=this.recurrentDropoutMask;let w=c(i,b,0),x=c(i,b,1),S=c(i,b,2),T=c(i,b,3);const $=3,[E,R,B,N]=ol(this.kernel.read(),a,$),[k,_,F,A]=this.useBias?ol(this.bias.read(),a):[null,null,null,null];f=this.inputConv(f,E,k,this.padding),d=this.inputConv(d,R,_,this.padding),m=this.inputConv(m,B,F,this.padding),y=this.inputConv(y,N,A,this.padding);const[P,L,tt,st]=ol(this.recurrentKernel.read(),a,$);w=this.recurrentConv(w,P),x=this.recurrentConv(x,L),S=this.recurrentConv(S,tt),T=this.recurrentConv(T,st);const j=this.recurrentActivation.apply(Qt(f,w)),Z=this.recurrentActivation.apply(Qt(d,x)),J=Qt(mt(Z,o),mt(j,this.activation.apply(Qt(m,S)))),ot=mt(this.recurrentActivation.apply(Qt(y,T)),this.activation.apply(J));return[ot,ot,J]})}getConfig(){const t=super.getConfig(),{units:e}=t,s=NDt(t,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},s,r)}inputConv(t,e,s,r){const i=sp(t,e,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?ya(i,s,this.dataFormat):i}recurrentConv(t,e){return sp(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}tN.className="ConvLSTM2DCell";Kt(tN);class kH extends AH{constructor(t){const e=new tN(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}}kH.className="ConvLSTM2D";Kt(kH);class eN extends Ze{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const e=t.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?e[r]:this.noiseShape[r]);return s}call(t,e){return St(()=>{this.invokeCallHook(t,e);const s=Re(t);if(0<this.rate&&this.rate<1){const r=e.training==null?!1:e.training,i=this.getNoiseShape(s);return Ab(()=>yq(s,this.rate,i,this.seed),()=>s,r)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}eN.className="Dropout";Kt(eN);class _H extends eN{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}_H.className="SpatialDropout1D";Kt(_H);class nN extends Ze{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,ir(this.units,"units"),this.activation=wc(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=es(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=es(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Qs(t.kernelConstraint),this.biasConstraint=Qs(t.biasConstraint),this.kernelRegularizer=ss(t.kernelRegularizer),this.biasRegularizer=ss(t.biasRegularizer),this.activityRegularizer=ss(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=In(t);const e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=In(t);const e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return St(()=>{this.invokeCallHook(t,e);const s=Re(t),r=cq(this.activation.getClassName());let i;return r!=null?i=al(s,this.kernel.read(),r,this.bias?this.bias.read():null):(i=al(s,this.kernel.read()),this.bias!=null&&(i=ya(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const t={units:this.units,activation:xc(this.activation),useBias:this.useBias,kernelInitializer:cs(this.kernelInitializer),biasInitializer:cs(this.biasInitializer),kernelRegularizer:Ln(this.kernelRegularizer),biasRegularizer:Ln(this.biasRegularizer),activityRegularizer:Ln(this.activityRegularizer),kernelConstraint:Ys(this.kernelConstraint),biasConstraint:Ys(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}nN.className="Dense";Kt(nN);class NH extends Ze{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=In(t);for(const e of t.slice(1))if(e==null)throw new ht(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],sc(t,1)]}call(t,e){return St(()=>{this.invokeCallHook(t,e);let s=Re(t);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let i=2;i<s.rank;++i)r.push(i);r.push(1),s=nn(s,r)}return r_t(s)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}NH.className="Flatten";Kt(NH);class RH extends Ze{constructor(t){super(t),this.supportsMasking=!0,this.activation=wc(t.activation)}call(t,e){return St(()=>{this.invokeCallHook(t,e);const s=Re(t);return this.activation.apply(s)})}getConfig(){const t={activation:xc(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}RH.className="Activation";Kt(RH);class DH extends Ze{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return St(()=>(t=Re(t),n_t(t,this.n)))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}DH.className="RepeatVector";Kt(DH);class OH extends Ze{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){const s="Total size of new array must be unchanged.",r=e.slice();let i=1,o=null;for(let l=0;l<r.length;++l){const c=r[l];if(this.isUnknown(c))if(o===null)o=l;else throw new ht("Can only specifiy one unknown dimension.");else i*=c}const a=sc(t);if(o!==null){if(i===0||a%i!==0)throw new ht(s);r[o]=a/i}else if(a!==i)throw new ht(s);return r}computeOutputShape(t){let e=!1;for(let s=0;s<t.length;++s)if(this.isUnknown(t[s])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return St(()=>{this.invokeCallHook(t,e);const s=Re(t),r=s.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return kt(s,i)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}OH.className="Reshape";Kt(OH);class FH extends Ze{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=fa(1,t.dims.length+1);if(!ci(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new qs({ndim:this.dims.length+1})]}computeOutputShape(t){t=In(t);const e=t.slice();return this.dims.forEach((s,r)=>{e[r+1]=t[s]}),e}call(t,e){return nn(Re(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}FH.className="Permute";Kt(FH);class MH extends Ze{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const s=Re(t);return A3(A$(s,this.maskValue),-1)}call(t,e){return St(()=>{this.invokeCallHook(t,e);const s=Re(t),o=A3(A$(s,this.maskValue),-1,!0);return mt(s,le(o,s.dtype))})}}MH.className="Masking";Kt(MH);class LH extends Ze{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(jn(t.inputLength))}this.inputDim=t.inputDim,ir(this.inputDim,"inputDim"),this.outputDim=t.outputDim,ir(this.outputDim,"outputDim"),this.embeddingsInitializer=es(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=ss(t.embeddingsRegularizer),this.activityRegularizer=ss(t.activityRegularizer),this.embeddingsConstraint=Qs(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return St(()=>this.maskZero?(t=Re(t),A$(t,pn(t))):null)}computeOutputShape(t){if(t=In(t),this.inputLength==null)return[...t,this.outputDim];const e=jn(this.inputLength);if(e.length!==t.length-1)throw new ht(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let s=0;for(let r=0;r<e.length;++r){const i=e[r],o=t[r+1];if(i!=null&&o!=null&&i!==o)throw new ht(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);i==null&&(e[s]=o),s++}}return[t[0],...e,this.outputDim]}call(t,e){return St(()=>{this.invokeCallHook(t,e);let s=Re(t);s.dtype!=="int32"&&(s=Cb(s,"int32"));const r=gq(this.embeddings.read(),kt(s,[s.size]));return kt(r,In(this.computeOutputShape(s.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:cs(this.embeddingsInitializer),embeddingsRegularizer:Ln(this.embeddingsRegularizer),activityRegularizer:Ln(this.activityRegularizer),embeddingsConstraint:Ys(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}LH.className="Embedding";Kt(LH);class Sf extends Ze{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Le}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;const s=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const i=t[t.length-e.length+r],o=e[r];if(i==null||o==null||i<0||o<0)s.push(null);else if(i===1)s.push(o);else if(o===1)s.push(i);else{if(i!==o)throw new ht("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));s.push(i)}}return s}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[In(t)]),t=t,t.length<2)throw new ht(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const i of t)i!=null&&i[0]!==null&&e.push(i[0]);if(e=nc(e),e.length>1)throw new ht(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let s=t[0]==null?null:t[0].slice(1);for(let i=1;i<t.length;++i){const o=t[i]==null?null:t[i].slice(1);s=this.computeElementwiseOpOutputShape(s,o)}const r=t.map(i=>i.length);t.indexOf(null)===-1&&nc(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return St(()=>{if(t=t,this.reshapeRequired){const s=[],r=t.map(i=>i.rank);if(r.indexOf(null)===-1){const i=bc(r);for(let o of t){const a=o.rank;for(let l=0;l<i-a;++l)o=Eb(o,1);s.push(o)}return this.mergeFunction(s)}else{let i=!1;for(const l of t){const c=l.rank;if(c==null){const f=l.shape,d=f[0],m=f.slice(1).concat([d]);let y=kt(l,[d].concat(sc(f.slice(1))));y=nn(y,[1,0]),y=kt(y,m),s.push(y),i=!0}else if(c>1){const f=fa(1,c).concat([0]);s.push(nn(l,f)),i=!0}else s.push(l)}let o=this.mergeFunction(s);const a=o.rank;if(i){if(a==null){const l=o.shape,c=l.length,f=l[c-1],d=[f].concat(l.slice(0,l.length-1));o=kt(nn(kt(o,[-1,f]),[1,0]),d)}else if(a>1){const l=[a-1].concat(fa(0,a-1));o=nn(o,l)}}return o}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let r=1;r<t.length;++r){const i=t[r]==null?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,i)}let s=[];for(const r of t)r!=null&&r[0]!==null&&s.push(r[0]);return s=nc(s),s.length===1?e=s.concat(e):e=[null].concat(e),e}computeMask(t,e){return St(()=>{if(e==null)return null;if(!Array.isArray(e))throw new ht("`mask` should be an Array");if(!Array.isArray(t))throw new ht("`inputs` should be an Array");if(e.length!==t.length)throw new ht(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(r=>r==null))return null;e=e.map(r=>r==null?r:Xo(r,0));let s=e[0];for(let r=1;r<e.length-1;++r)s=Lp(s,e[r]);return s})}}class zH extends Sf{constructor(t){super(t)}mergeFunction(t){return St(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=Qt(e,t[s]);return e})}}zH.className="Add";Kt(zH);class BH extends Sf{constructor(t){super(t)}mergeFunction(t){return St(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=mt(e,t[s]);return e})}}BH.className="Multiply";Kt(BH);class PH extends Sf{constructor(t){super(t)}mergeFunction(t){return St(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=Qt(e,t[s]);return mt(1/t.length,e)})}}PH.className="Average";Kt(PH);class VH extends Sf{constructor(t){super(t)}mergeFunction(t){return St(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=xf(e,t[s]);return e})}}VH.className="Maximum";Kt(VH);class UH extends Sf{constructor(t){super(t)}mergeFunction(t){return St(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=F5(e,t[s]);return e})}}UH.className="Minimum";Kt(UH);class GH extends Sf{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new ht("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const r of t)if(r!=null){e=!1;break}if(e)return;const s=[];for(let r=0;r<t.length;++r){const i=t[r].slice();i.splice(this.axis,1);let o=!1;for(const a of s)if(ci(a,i)){o=!0;break}o||s.push(i)}if(s.length>1)throw new ht("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return St(()=>M_(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new ht("A `Concatenate` layer should be called on a list of inputs.");const e=t,s=e[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const i of e.slice(1)){if(s[r]==null||i[r]==null){s[r]=null;break}s[r]+=i[r]}return s}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new ht("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new ht("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new ht(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return St(()=>{let s=!0;if(e.forEach(o=>{if(o!=null){s=!1;return}}),s)return null;const r=[];for(let o=0;o<t.length;++o)e[o]==null?r.push(le(ha(t[o]),"bool")):e[o].rank<t[o].rank?r.push(Xo(e[o],-1)):r.push(e[o]);const i=na(r,this.axis);return XCt(i,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}GH.className="Concatenate";Kt(GH);function tg(n,t){for(;n<0;)n+=t;return n}function RDt(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new Le("batchDot is not implemented for tensors of 4D or higher rank yet");if(Q(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),Q(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),n.dtype==="complex64"||t.dtype==="complex64")throw new Le("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=t.shape.length;e==null&&(e=[s-1,r-2]);const i=e;return St(()=>{let o;if(s>r){o=s-r;const l=[];for(let c=0;c<o;++c)l.push(1);t=kt(t,t.shape.concat(l))}else if(r>s){o=r-s;const l=[];for(let c=0;c<o;++c)l.push(1);n=kt(n,n.shape.concat(l))}else o=0;let a;if(n.shape.length===2&&t.shape.length===2)i[0]===i[1]?a=xe(mt(n,t),i[0]):a=xe(mt(nn(n,[1,0]),t),i[1]);else{const l=i[0]!==n.shape.length-1,c=i[1]===t.shape.length-1;a=Vn(n,t,l,c)}if(o>0){let l;s>r?l=s+r-3:l=s-1;const c=[];for(let f=l;f<l+o;++f)c.push(f);a=rp(a,c)}return a.shape.length===1&&(a=Xo(a,1)),a})}class WH extends Sf{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){Q(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],s=t[1];if(e.length>3||s.length>3)throw new Le("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,s);if(e[r[0]]!==s[r[1]])throw new ht(`Dimension incompatibility: ${e[r[0]]} !== ${s[r[1]]}`)}mergeFunction(t){if(t.length!==2)throw new ht(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],s=t[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,o)=>tg(i,t[o].shape.length)):r=[tg(this.axes,e.shape.length),tg(this.axes,s.shape.length)],this.normalize&&(e=Ux(e,r[0]),s=Ux(s,r[1])),RDt(e,s,r)}interpretAxes(t,e){let s;return Array.isArray(this.axes)?s=this.axes:s=[tg(this.axes,t.length),tg(this.axes,e.length)],s}computeOutputShape(t){Q(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),s=t[1].slice();if(e.length>3||s.length>3)throw new Le("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,s);e.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const i=e.concat(s);return i.length===1&&i.push(1),i}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}WH.className="Dot";Kt(WH);class jH extends Ze{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return St(()=>{this.invokeCallHook(t,e);const s=Re(t);return Ab(()=>Qt(tS(s.shape,0,this.stddev),s),()=>s,e.training||!1)})}}jH.className="GaussianNoise";Kt(jH);class qH extends Ze{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return St(()=>{this.invokeCallHook(t,e);const s=Re(t);return this.rate>0&&this.rate<1?Ab(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return mt(s,tS(s.shape,1,i))},()=>s,e.training||!1):s})}}qH.className="GaussianDropout";Kt(qH);class HH extends Ze{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||Re(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return St(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(t);return Ab(()=>{const i=Re(t),a=-1.6732632423543772*1.0507009873554805;let l=bb(Hv(s),this.rate);l=Cb(l,"float32");const c=((1-this.rate)*(1+this.rate*a**2))**-.5,f=-c*a*this.rate,d=Qt(mt(i,l),mt(Qt(l,-1),a));return Qt(mt(d,c),f)},()=>Re(t),e.training||!1)}return t})}}HH.className="AlphaDropout";Kt(HH);function Ug(n,t,e,s,r,i=.001){let o;if(n.rank===2)o=gEt(n,t,e,s,r,i);else if(n.rank===3)o=bEt(n,t,e,s,r,i);else if(n.rank===4)o=wEt(n,t,e,s,r,i);else throw new Le(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function DDt(n,t,e,s,r=.001){return St(()=>{const i=wb(n,s),o=i.mean,a=i.variance;return[Ug(n,o,a,e,t,r),o,a]})}function ODt(n,t,e,s,r=.001){return St(()=>{const i=wb(n,s),o=i.mean,a=i.variance,l=[];for(const b of fa(0,n.rank))s.indexOf(b)!==-1?l.push(1):l.push(n.shape[b]);const c=kt(o,l),f=kt(a,l),d=t==null?null:kt(t,l),m=e==null?null:kt(e,l);return[Ug(n,c,f,m,d,r),o,a]})}function FDt(n,t,e,s,r=.001){return ci(s.slice().sort(),fa(0,n.rank-1))?DDt(n,t,e,s,r):ODt(n,t,e,s,r)}class KH extends Ze{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=es(t.betaInitializer||"zeros"),this.gammaInitializer=es(t.gammaInitializer||"ones"),this.movingMeanInitializer=es(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=es(t.movingVarianceInitializer||"ones"),this.betaConstraint=Qs(t.betaConstraint),this.gammaConstraint=Qs(t.gammaConstraint),this.betaRegularizer=ss(t.betaRegularizer),this.gammaRegularizer=ss(t.gammaRegularizer)}build(t){t=In(t);const e=this.axis>=0?this.axis:this.axis+t.length,s=t[e];if(s==null)throw new ht(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new qs({ndim:t.length,axes:{[e]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return St(()=>{const s=e.training==null?!1:e.training,r=Re(t),i=r.shape,o=i.length,a=fa(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const c=tf(1,o);c[l]=i[l];const f=a.slice();f.sort();const d=!ci(f,fa(0,o).slice(0,o-1)),m=()=>{if(d){const T=kt(this.movingMean.read(),c),$=kt(this.movingVariance.read(),c),E=this.center?kt(this.beta.read(),c):null,R=this.scale?kt(this.gamma.read(),c):null;return Ug(r,T,$,E,R,this.epsilon)}else return Ug(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return m();const[y,b,w]=FDt(r,this.gamma.read(),this.beta.read(),a,this.epsilon),x=(T,$,E)=>{St(()=>{const R=1-E,B=T.read(),N=mt($e(B,$),R);T.write($e(B,N))})};return x(this.movingMean,b,this.momentum),x(this.movingVariance,w,this.momentum),y})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:cs(this.betaInitializer),gammaInitializer:cs(this.gammaInitializer),movingMeanInitializer:cs(this.movingMeanInitializer),movingVarianceInitializer:cs(this.movingVarianceInitializer),betaRegularizer:Ln(this.betaRegularizer),gammaRegularizer:Ln(this.gammaRegularizer),betaConstraint:Ys(this.betaConstraint),gammaConstraint:Ys(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}KH.className="BatchNormalization";Kt(KH);class XH extends Ze{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=es(t.betaInitializer||"zeros"),this.gammaInitializer=es(t.gammaInitializer||"ones"),this.betaRegularizer=ss(t.betaRegularizer),this.gammaRegularizer=ss(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=In(t);const e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=e);for(const i of this.axis)if(i<0||i>=e)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==nc(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>t[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(t,e){const s=Re(t),r=s.shape,i=r.length;return St(()=>{let{mean:a,variance:l}=wb(s,this.axis,!0);const c=tf(1,i);for(const w of this.axis)c[w]=r[w];const f=w=>w!=null&&w.shape.length!==i?kt(w,c):w;let d=this.scale?f(this.gamma.read()):null,m=this.center?f(this.beta.read()):null;const y=[],b=[];for(let w=0;w<i;++w)this.axis.indexOf(w)!==-1?(y.push(r[w]),b.push(1)):(y.push(1),b.push(r[w]));return a=Ja(a,y),l=Ja(l,y),d!=null&&(d=Ja(d,b)),m!=null&&(m=Ja(m,b)),Ug(s,a,l,m,d,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:cs(this.betaInitializer),gammaInitializer:cs(this.gammaInitializer),betaRegularizer:Ln(this.betaRegularizer),gammaRegularizer:Ln(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}XH.className="LayerNormalization";Kt(XH);function MDt(n,t,e){return St(()=>{if(n.rank!==4)throw new ht(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new ht("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=da()),e!=="channelsLast"&&e!=="channelsFirst")throw new ht(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return e==="channelsFirst"?s=[[0,0],[0,0],t[0],t[1]]:s=[[0,0],t[0],t[1],[0,0]],M5(n,s)})}class YH extends Ze{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?da():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new ht(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,s;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],s=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new ht(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new ht(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);s=t.padding[1]}this.padding=[e,s]}this.inputSpec=[new qs({ndim:4})]}computeOutputShape(t){t=In(t);let e,s;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?s=t[3]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],t[1],e,s]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?s=t[2]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],e,s,t[3]])}call(t,e){return St(()=>MDt(Re(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}YH.className="ZeroPadding2D";Kt(YH);function lS(n,t,e,s,r,i){return St(()=>{Ss(r),fq(i),Yi(s),e==null&&(e=[1,1]),s==null&&(s="valid"),r==null&&(r=da()),i==null&&(i="max"),n=Y_(n,r);let o;const a=s==="same"?"same":"valid";return i==="max"?o=F$t(n,t,e,a):o=rEt(n,t,e,a),r==="channelsFirst"&&(o=nn(o,[0,3,1,2])),o})}function QH(n,t,e,s,r,i){return St(()=>{Ss(r),fq(i),Yi(s),e==null&&(e=[1,1,1]),s==null&&(s="valid"),r==null&&(r=da()),i==null&&(i="max"),n=mH(n,r);let o;const a=s==="same"?"same":"valid";return i==="max"?o=L$t(n,t,e,a):o=oEt(n,t,e,a),r==="channelsFirst"&&(o=nn(o,[0,4,1,2,3])),o})}class ZH extends Ze{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new ht(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(ir(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new ht(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);ir(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,Yi(this.padding),this.inputSpec=[new qs({ndim:3})]}computeOutputShape(t){t=In(t);const e=sa(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return St(()=>{this.invokeCallHook(t,e),t=Eb(Re(t),2);const s=this.poolingFunction(Re(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return rp(s,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class JH extends ZH{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return Ss(i),Yi(r),lS(t,e,s,r,i,"max")}}JH.className="MaxPooling1D";Kt(JH);class t8 extends ZH{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return Ss(i),Yi(r),lS(t,e,s,r,i,"avg")}}t8.className="AveragePooling1D";Kt(t8);class e8 extends Ze{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new ht(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];ir(this.poolSize,"poolSize"),ir(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Ss(this.dataFormat),Yi(this.padding),this.inputSpec=[new qs({ndim:4})]}computeOutputShape(t){t=In(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=sa(e,this.poolSize[0],this.padding,this.strides[0]),s=sa(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s]:[t[0],e,s,t[3]]}call(t,e){return St(()=>(this.invokeCallHook(t,e),this.poolingFunction(Re(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class n8 extends e8{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return Ss(i),Yi(r),lS(t,e,s,r,i,"max")}}n8.className="MaxPooling2D";Kt(n8);class s8 extends e8{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return Ss(i),Yi(r),lS(t,e,s,r,i,"avg")}}s8.className="AveragePooling2D";Kt(s8);class r8 extends Ze{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new ht(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];ir(this.poolSize,"poolSize"),ir(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Ss(this.dataFormat),Yi(this.padding),this.inputSpec=[new qs({ndim:5})]}computeOutputShape(t){t=In(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=sa(e,this.poolSize[0],this.padding,this.strides[0]),s=sa(s,this.poolSize[1],this.padding,this.strides[1]),r=sa(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s,r]:[t[0],e,s,r,t[4]]}call(t,e){return St(()=>(this.invokeCallHook(t,e),this.poolingFunction(Re(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class i8 extends r8{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return Ss(i),Yi(r),QH(t,e,s,r,i,"max")}}i8.className="MaxPooling3D";Kt(i8);class o8 extends r8{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return Ss(i),Yi(r),QH(t,e,s,r,i,"avg")}}o8.className="AveragePooling3D";Kt(o8);class a8 extends Ze{constructor(t){super(t),this.inputSpec=[new qs({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Le}}class l8 extends a8{constructor(t){super(t||{})}call(t,e){return St(()=>{const s=Re(t);return As(s,1)})}}l8.className="GlobalAveragePooling1D";Kt(l8);class u8 extends a8{constructor(t){super(t||{})}call(t,e){return St(()=>{const s=Re(t);return Hl(s,1)})}}u8.className="GlobalMaxPooling1D";Kt(u8);class c8 extends Ze{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Ss(this.dataFormat),this.inputSpec=[new qs({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new Le}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class h8 extends c8{call(t,e){return St(()=>{const s=Re(t);return this.dataFormat==="channelsLast"?As(s,[1,2]):As(s,[2,3])})}}h8.className="GlobalAveragePooling2D";Kt(h8);class f8 extends c8{call(t,e){return St(()=>{const s=Re(t);return this.dataFormat==="channelsLast"?Hl(s,[1,2]):Hl(s,[2,3])})}}f8.className="GlobalMaxPooling2D";Kt(f8);class d8 extends Ze{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,s={}){const r=e.layer,i=ll(r,s);delete e.layer;const o={layer:i};return Object.assign(o,e),new t(o)}}class p8 extends d8{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=In(t),t.length<3)throw new ht(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=In(t);const e=[t[0]].concat(t.slice(2)),s=this.layer.computeOutputShape(e),r=t[1];return[s[0],r].concat(s.slice(1))}call(t,e){return St(()=>(t=Re(t),TH((o,a)=>[Re(this.layer.call(o,e)),[]],t,[],!1,null,null,!1,!0)[1]))}}p8.className="TimeDistributed";Kt(p8);function LDt(n){vf(Qkt,"BidirectionalMergeMode",n)}const zDt="concat";class m8 extends d8{constructor(t){super(t);const e=t.layer.getConfig(),s={};s.className=t.layer.getClassName(),s.config=e,this.forwardLayer=ll(s),e.goBackwards=e.goBackwards!==!0;const r={};if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=ll(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?zDt:t.mergeMode,LDt(this.mergeMode),t.weights)throw new Le("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,s=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,s)),this.backwardLayer.setWeights(t.slice(s))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let s,r,i;return this.returnState&&(i=e.slice(1)),s=e[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):ri(r)}apply(t,e){let s=e==null?null:e.initialState,r=e==null?null:e.constants;e==null&&(e={});const i=IH(t,s,r,this.numConstants);if(t=i.inputs,s=i.initialState,r=i.constants,Array.isArray(t)&&(s=t.slice(1),t=t[0]),(s==null||s.length===0)&&r==null)return super.apply(t,e);const o=[],a=[];if(s!=null){const c=s.length;if(c%2>0)throw new ht("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=s,o.push(...s);const f=s.map(d=>new qs({shape:d.shape}));this.forwardLayer.stateSpec=f.slice(0,c/2),this.backwardLayer.stateSpec=f.slice(c/2),a.push(...f)}if(r!=null)throw new Le("Support for constants in Bidirectional layers is not implemented yet.");const l=o[0]instanceof tl;for(const c of o)if(c instanceof tl!==l)throw new ht("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const c=[t].concat(o),f=this.inputSpec.concat(a),d=this.inputSpec;this.inputSpec=f;const m=super.apply(c,e);return this.inputSpec=d,m}else return super.apply(t,e)}call(t,e){return St(()=>{const s=e.initialState;let r,i;if(s==null)r=this.forwardLayer.call(t,e),i=this.backwardLayer.call(t,e);else{const l=s.slice(0,s.length/2),c=s.slice(s.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:l})),i=this.backwardLayer.call(t,Object.assign(e,{initialState:c}))}let o;this.returnState&&(Array.isArray(r)&&(o=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=Fx(i,1));let a;return this.mergeMode==="concat"?a=M_([r,i]):this.mergeMode==="sum"?a=Qt(r,i):this.mergeMode==="ave"?a=mt(.5,Qt(r,i)):this.mergeMode==="mul"?a=mt(r,i):this.mergeMode==null&&(a=[r,i]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Rh(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Rh(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[e,e]:s=e:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const s=ll(e.layer);if(delete e.layer,e.numConstants!=null)throw new Le("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=e;return r.layer=s,new t(r)}}m8.className="Bidirectional";Kt(m8);class g8 extends Ze{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return St(()=>(t=Re(t),t.dtype!=="float32"&&(t=Cb(t,"float32")),Qt(mt(t,this.scale),this.offset)))}}g8.className="Rescaling";Kt(g8);function BDt(n){return new nN(n)}var y8=function(n,t){return(y8=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,s){e.__proto__=s}||function(e,s){for(var r in s)s.hasOwnProperty(r)&&(e[r]=s[r])})(n,t)};function PDt(n,t){function e(){this.constructor=n}y8(n,t),n.prototype=t===null?Object.create(t):(e.prototype=t.prototype,new e)}var P$=function(){return(P$=Object.assign||function(n){for(var t,e=1,s=arguments.length;e<s;e++)for(var r in t=arguments[e])Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n}).apply(this,arguments)};function as(n,t,e,s){return new(e||(e=Promise))(function(r,i){function o(c){try{l(s.next(c))}catch(f){i(f)}}function a(c){try{l(s.throw(c))}catch(f){i(f)}}function l(c){var f;c.done?r(c.value):(f=c.value,f instanceof e?f:new e(function(d){d(f)})).then(o,a)}l((s=s.apply(n,[])).next())})}function ls(n,t){var e,s,r,i,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function a(l){return function(c){return(function(f){if(e)throw new TypeError("Generator is already executing.");for(;o;)try{if(e=1,s&&(r=2&f[0]?s.return:f[0]?s.throw||((r=s.return)&&r.call(s),0):s.next)&&!(r=r.call(s,f[1])).done)return r;switch(s=0,r&&(f=[2&f[0],r.value]),f[0]){case 0:case 1:r=f;break;case 4:return o.label++,{value:f[1],done:!1};case 5:o.label++,s=f[1],f=[0];continue;case 7:f=o.ops.pop(),o.trys.pop();continue;default:if(!(r=(r=o.trys).length>0&&r[r.length-1])&&(f[0]===6||f[0]===2)){o=0;continue}if(f[0]===3&&(!r||f[1]>r[0]&&f[1]<r[3])){o.label=f[1];break}if(f[0]===6&&o.label<r[1]){o.label=r[1],r=f;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(f);break}r[2]&&o.ops.pop(),o.trys.pop();continue}f=t.call(n,o)}catch(d){f=[6,d],s=0}finally{e=r=0}if(5&f[0])throw f[1];return{value:f[0]?f[1]:void 0,done:!0}})([l,c])}}}function ti(n){var t=typeof Symbol=="function"&&Symbol.iterator,e=t&&n[t],s=0;if(e)return e.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&s>=n.length&&(n=void 0),{value:n&&n[s++],done:!n}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function sN(n,t){var e=typeof Symbol=="function"&&n[Symbol.iterator];if(!e)return n;var s,r,i=e.call(n),o=[];try{for(;(t===void 0||t-- >0)&&!(s=i.next()).done;)o.push(s.value)}catch(a){r={error:a}}finally{try{s&&!s.done&&(e=i.return)&&e.call(i)}finally{if(r)throw r.error}}return o}function bg(){for(var n=[],t=0;t<arguments.length;t++)n=n.concat(sN(arguments[t]));return n}function VDt(n){return as(this,void 0,void 0,function(){var t,e,s,r,i,o,a;return ls(this,function(l){switch(l.label){case 0:return t="http://",e="https://",s="file://",n.indexOf(t)!==0&&n.indexOf(e)!==0?[3,3]:[4,fetch(n)];case 1:return[4,l.sent().json()];case 2:return[2,l.sent()];case 3:return n.indexOf(s)!==0?[3,5]:(r=require("fs"),i=bkt.promisify(r.readFile),a=(o=JSON).parse,[4,i(n.slice(s.length),{encoding:"utf-8"})]);case 4:return[2,a.apply(o,[l.sent()])];case 5:throw new Error("Unsupported URL scheme in metadata URL: "+n+". Supported schemes are: http://, https://, and (node.js-only) file://")}})})}var Pd=null;function Gg(n){return Pd==null&&(Pd=h_().epsilon()),St(function(){var t=wb(n),e=t.mean,s=t.variance;return we($e(n,e),Qt(Xr(s),Pd))})}function UDt(n){if(n.length<2)throw new Error("Cannot normalize a Float32Array with fewer than 2 elements.");return Pd==null&&(Pd=h_().epsilon()),St(function(){var t=wb(_r(n)),e=t.mean,s=t.variance,r=e.arraySync(),i=Math.sqrt(s.arraySync()),o=Array.from(n).map(function(a){return(a-r)/(i+Pd)});return new Float32Array(o)})}function GDt(){return window.AudioContext||window.webkitAudioContext}function WDt(n){return as(this,void 0,void 0,function(){return ls(this,function(t){return[2,navigator.mediaDevices.getUserMedia({audio:n==null||n,video:!1})]})})}var V$=(function(){function n(t){var e=this;if(t==null)throw new Error("Required configuration object is missing for BrowserFftFeatureExtractor constructor");if(t.spectrogramCallback==null)throw new Error("spectrogramCallback cannot be null or undefined");if(!(t.numFramesPerSpectrogram>0))throw new Error("Invalid value in numFramesPerSpectrogram: "+t.numFramesPerSpectrogram);if(t.suppressionTimeMillis<0)throw new Error("Expected suppressionTimeMillis to be >= 0, but got "+t.suppressionTimeMillis);if(this.suppressionTimeMillis=t.suppressionTimeMillis,this.spectrogramCallback=t.spectrogramCallback,this.numFrames=t.numFramesPerSpectrogram,this.sampleRateHz=t.sampleRateHz||44100,this.fftSize=t.fftSize||1024,this.frameDurationMillis=this.fftSize/this.sampleRateHz*1e3,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.overlapFactor=t.overlapFactor,this.includeRawAudio=t.includeRawAudio,Q(this.overlapFactor>=0&&this.overlapFactor<1,function(){return"Expected overlapFactor to be >= 0 and < 1, but got "+e.overlapFactor}),this.columnTruncateLength>this.fftSize)throw new Error("columnTruncateLength "+this.columnTruncateLength+" exceeds fftSize ("+this.fftSize+").");this.audioContextConstructor=GDt()}return n.prototype.start=function(t){return as(this,void 0,void 0,function(){var e,s,r;return ls(this,function(i){switch(i.label){case 0:if(this.frameIntervalTask!=null)throw new Error("Cannot start already-started BrowserFftFeatureExtractor");return e=this,[4,WDt(t)];case 1:return e.stream=i.sent(),this.audioContext=new this.audioContextConstructor({sampleRate:this.sampleRateHz}),s=this.audioContext.createMediaStreamSource(this.stream),this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=0,s.connect(this.analyser),this.freqDataQueue=[],this.freqData=new Float32Array(this.fftSize),this.includeRawAudio&&(this.timeDataQueue=[],this.timeData=new Float32Array(this.fftSize)),r=Math.max(1,Math.round(this.numFrames*(1-this.overlapFactor))),this.tracker=new jDt(r,Math.round(this.suppressionTimeMillis/this.frameDurationMillis)),this.frameIntervalTask=setInterval(this.onAudioFrame.bind(this),this.fftSize/this.sampleRateHz*1e3),[2]}})})},n.prototype.onAudioFrame=function(){return as(this,void 0,void 0,function(){var t,e,s,r;return ls(this,function(i){switch(i.label){case 0:return this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0?[2]:(this.freqDataQueue.push(this.freqData.slice(0,this.columnTruncateLength)),this.includeRawAudio&&(this.analyser.getFloatTimeDomainData(this.timeData),this.timeDataQueue.push(this.timeData.slice())),this.freqDataQueue.length>this.numFrames&&this.freqDataQueue.shift(),this.tracker.tick()?(t=cz(this.freqDataQueue),e=hz(t,[1,this.numFrames,this.columnTruncateLength,1]),s=void 0,this.includeRawAudio&&(r=cz(this.timeDataQueue),s=hz(r,[1,this.numFrames*this.fftSize])),[4,this.spectrogramCallback(e,s)]):[3,2]);case 1:i.sent()&&this.tracker.suppress(),Ee([e,s]),i.label=2;case 2:return[2]}})})},n.prototype.stop=function(){return as(this,void 0,void 0,function(){return ls(this,function(t){if(this.frameIntervalTask==null)throw new Error("Cannot stop because there is no ongoing streaming activity.");return clearInterval(this.frameIntervalTask),this.frameIntervalTask=null,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop(),[2]})})},n.prototype.setConfig=function(t){throw new Error("setConfig() is not implemented for BrowserFftFeatureExtractor.")},n.prototype.getFeatures=function(){throw new Error("getFeatures() is not implemented for BrowserFftFeatureExtractor. Use the spectrogramCallback field of the constructor config instead.")},n})();function cz(n){var t=n[0].length,e=new Float32Array(n.length*t);return n.forEach(function(s,r){return e.set(s,r*t)}),e}function hz(n,t){var e=new Float32Array(oi(t));return e.set(n,e.length-n.length),zd(e,t)}var jDt=(function(){function n(t,e){var s=this;this.period=t,this.suppressionTime=e??0,this.counter=0,Q(this.period>0,function(){return"Expected period to be positive, but got "+s.period})}return n.prototype.tick=function(){return this.counter++,this.counter%this.period==0&&(this.suppressionOnset==null||this.counter-this.suppressionOnset>this.suppressionTime)},n.prototype.suppress=function(){this.suppressionOnset=this.counter},n})();function Kx(n){var t=0;n.forEach(function(r){t+=r.byteLength});var e=new Uint8Array(t),s=0;return n.forEach(function(r){e.set(new Uint8Array(r),s),s+=r.byteLength}),e.buffer}function qDt(n){var t=0;n.forEach(function(r){return t+=r.length});var e=new Float32Array(t),s=0;return n.forEach(function(r){e.set(r,s),s+=r.length}),e}function fz(n){if(n==null)throw new Error("Received null or undefind string");for(var t=unescape(encodeURIComponent(n)),e=new Uint8Array(t.length),s=0;s<t.length;++s)e[s]=t.charCodeAt(s);return e.buffer}function dz(n){if(n==null)throw new Error("Received null or undefind buffer");var t=new Uint8Array(n);return decodeURIComponent(escape(String.fromCharCode.apply(String,bg(t))))}function HDt(){function n(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)}return n()+n()+"-"+n()+"-"+n()+"-"+n()+"-"+n()+n()+n()}function KDt(n,t){return Math.floor((t-n)*Math.random())+n}function XDt(n,t,e){return Q(e>0&&e<1,function(){return"validationSplit is expected to be >0 and <1, but got "+e}),St(function(){for(var s=ep(t,-1).dataSync(),r=[],i=0;i<s.length;++i){var o=s[i];r[o]==null&&(r[o]=[]),r[o].push(i)}var a=r.length,l=[],c=[];for(r.map(function(y){return Lg(y)}),i=0;i<a;++i)for(var f=r[i],d=Math.round(f.length*(1-e)),m=0;m<f.length;++m)m<d?l.push(f[m]):c.push(f[m]);return{trainXs:Nd(n,l),trainYs:Nd(t,l),valXs:Nd(n,c),valYs:Nd(t,c)}})}function YDt(n,t,e){var s,r,i,o,a,l,c,f;Q(e>0&&e<1,function(){return"validationSplit is expected to be >0 and <1, but got "+e});for(var d=!Array.isArray(n[0]),m=t,y=[],b=0;b<m.length;++b){var w=m[b];y[w]==null&&(y[w]=[]),y[w].push(b)}var x=y.length,S=[],T=[];for(y.map(function(ot){return Lg(ot)}),b=0;b<x;++b)for(var $=y[b],E=Math.round($.length*(1-e)),R=0;R<$.length;++R)R<E?S.push($[R]):T.push($[R]);if(d){var B=[],N=[],k=[],_=[];try{for(var F=ti(S),A=F.next();!A.done;A=F.next()){var P=A.value;B.push(n[P]),N.push(t[P])}}catch(ot){s={error:ot}}finally{try{A&&!A.done&&(r=F.return)&&r.call(F)}finally{if(s)throw s.error}}try{for(var L=ti(T),tt=L.next();!tt.done;tt=L.next())P=tt.value,k.push(n[P]),_.push(t[P])}catch(ot){i={error:ot}}finally{try{tt&&!tt.done&&(o=L.return)&&o.call(L)}finally{if(i)throw i.error}}return{trainXs:B,trainYs:N,valXs:k,valYs:_}}B=[],N=[],k=[],_=[];try{for(var st=ti(S),j=st.next();!j.done;j=st.next())P=j.value,B.push(n[P]),N.push(t[P])}catch(ot){a={error:ot}}finally{try{j&&!j.done&&(l=st.return)&&l.call(st)}finally{if(a)throw a.error}}try{for(var Z=ti(T),J=Z.next();!J.done;J=Z.next())P=J.value,k.push(n[P]),_.push(t[P])}catch(ot){c={error:ot}}finally{try{J&&!J.done&&(f=Z.return)&&f.call(Z)}finally{if(c)throw c.error}}return{trainXs:B,trainYs:N,valXs:k,valYs:_}}var X1="TFJSSCDS",QDt=1,Vd="_background_noise_",pz=(function(){function n(t){if(this.examples={},this.label2Ids={},t!=null)for(var e=eOt(t),s=0,r=0;r<e.manifest.length;++r){var i=e.manifest[r],o=i.spectrogramNumFrames*i.spectrogramFrameSize;i.rawAudioNumSamples!=null&&(o+=i.rawAudioNumSamples),o*=4,this.addExample(JDt({spec:i,data:e.data.slice(s,s+o)})),s+=o}}return n.prototype.addExample=function(t){Q(t!=null,function(){return"Got null or undefined example"}),Q(t.label!=null&&t.label.length>0,function(){return"Expected label to be a non-empty string, but got "+JSON.stringify(t.label)});var e=HDt();return this.examples[e]=t,t.label in this.label2Ids||(this.label2Ids[t.label]=[]),this.label2Ids[t.label].push(e),e},n.prototype.merge=function(t){var e,s,r,i;Q(t!==this,function(){return"Cannot merge a dataset into itself"});var o=t.getVocabulary();try{for(var a=ti(o),l=a.next();!l.done;l=a.next()){var c=l.value,f=t.getExamples(c);try{for(var d=(r=void 0,ti(f)),m=d.next();!m.done;m=d.next()){var y=m.value;this.addExample(y.example)}}catch(b){r={error:b}}finally{try{m&&!m.done&&(i=d.return)&&i.call(d)}finally{if(r)throw r.error}}}}catch(b){e={error:b}}finally{try{l&&!l.done&&(s=a.return)&&s.call(a)}finally{if(e)throw e.error}}},n.prototype.getExampleCounts=function(){var t={};for(var e in this.examples){var s=this.examples[e];s.label in t||(t[s.label]=0),t[s.label]++}return t},n.prototype.getExamples=function(t){var e=this;Q(t!=null,function(){return"Expected label to be a string, but got "+JSON.stringify(t)}),Q(t in this.label2Ids,function(){return'No example of label "'+t+'" exists in dataset'});var s=[];return this.label2Ids[t].forEach(function(r){s.push({uid:r,example:e.examples[r]})}),s},n.prototype.getData=function(t,e){var s=this;Q(this.size()>0,function(){return"Cannot get spectrograms as tensors because the dataset is empty"});var r=this.getVocabulary();t!=null?Q(r.indexOf(t)!==-1,function(){return"Label "+t+" is not in the vocabulary ("+JSON.stringify(r)+")"}):Q(r.length>1,function(){return"One-hot encoding of labels requires the vocabulary to have at least two words, but it has only "+r.length+" word."}),e==null&&(e={});var i,o,a=this.getSortedUniqueNumFrames();a.length===1?(i=e.numFrames==null?a[0]:e.numFrames,o=e.hopFrames==null?1:e.hopFrames):(i=e.numFrames,Q(i!=null&&Number.isInteger(i)&&i>0,function(){return"There are "+a.length+" unique lengths among the "+s.size()+" examples of this Dataset, hence numFrames is required. But it is not provided."}),Q(i<=a[0],function(){return"numFrames ("+i+") exceeds the minimum numFrames ("+a[0]+") among the examples of the Dataset."}),o=e.hopFrames,Q(o!=null&&Number.isInteger(o)&&o>0,function(){return"There are "+a.length+" unique lengths among the "+s.size()+" examples of this Dataset, hence hopFrames is required. But it is not provided."}));var l=e.normalize==null||e.normalize;return St(function(){for(var c,f,d,m=[],y=[],b=[],w=0;w<r.length;++w){var x=r[w];if(t==null||x===t){var S=s.label2Ids[x],T=function(U){var X,nt,xt=s.examples[U].spectrogram,Ot=xt.frameSize;d==null?d=Ot:Q(Ot===d,function(){return"Mismatch in frameSize  ("+Ot+" vs "+d+")"});var qt=xt.data.length/Ot,zt=null;x!==Vd&&(zt=xt.keyFrameIndex==null?rOt(xt).dataSync()[0]:xt.keyFrameIndex);var Wt=lC(xt.data,[qt,Ot,1]),Xt=nOt(qt,zt,i,o),te=function(pe){var ie=St(function(){var Ae=Qn(Wt,[pe[0],0,0],[pe[1]-pe[0],-1,-1]);return l?Gg(Ae):Ae});e.getDataset?y.push(ie.dataSync()):m.push(ie),t==null&&b.push(w)};try{for(var oe=(X=void 0,ti(Xt)),fe=oe.next();!fe.done;fe=oe.next())te(fe.value)}catch(pe){X={error:pe}}finally{try{fe&&!fe.done&&(nt=oe.return)&&nt.call(oe)}finally{if(X)throw X.error}}Ee(Wt)};try{for(var $=(c=void 0,ti(S)),E=$.next();!E.done;E=$.next())T(E.value)}catch(U){c={error:U}}finally{try{E&&!E.done&&(f=$.return)&&f.call($)}finally{if(c)throw c.error}}}}e.augmentByMixingNoiseRatio!=null&&s.augmentByMixingNoise(e.getDataset?y:m,b,e.augmentByMixingNoiseRatio);var R=e.shuffle==null||e.shuffle;if(e.getDataset){var B=e.datasetBatchSize==null?32:e.datasetBatchSize,N=e.datasetValidationSplit==null?.15:e.datasetValidationSplit;Q(N>0&&N<1,function(){return"Invalid dataset validation split: "+N});var k=y.map(function(U,X){return[U,b[X]]});Lg(k),y=k.map(function(U){return U[0]});var _=k.map(function(U){return U[1]}),F=YDt(y,_,N),A=F.trainXs,P=F.trainYs,L=F.valXs,tt=F.valYs,st=I1(A).map(function(U){return lC(U,[i,d,1])}),j=I1(P).map(function(U){return rp(H1([U],r.length),[0])}),Z=LL({xs:st,ys:j});R&&(Z=Z.shuffle(y.length)),Z=Z.batch(B).prefetch(4);var J=I1(L).map(function(U){return lC(U,[i,d,1])}),ot=I1(tt).map(function(U){return rp(H1([U],r.length),[0])}),pt=LL({xs:J,ys:ot});return[Z,pt=pt.batch(B).prefetch(4)]}if(R){var q=[];m.forEach(function(U,X){q.push({x:U,y:b[X]})}),Lg(q),m=q.map(function(U){return U.x}),b=q.map(function(U){return U.y})}var et=t==null?le(H1(_r(b,"int32"),r.length),"float32"):void 0;return{xs:yc(m),ys:et}})},n.prototype.augmentByMixingNoise=function(t,e,s){var r,i;if(t==null||t.length===0)throw new Error("Cannot perform augmentation because data is null or empty");for(var o=t[0]instanceof Float32Array,a=this.getVocabulary(),l=[],c=[],f=0;f<e.length;++f)a[e[f]]===Vd?l.push(f):c.push(f);if(l.length===0)throw new Error("Cannot perform augmentation by mixing with noise when there is no example with label "+Vd);var d=[],m=[],y=function(x){var S=l[KDt(0,l.length)],T=o?_r(t[x]):t[x],$=o?_r(t[S]):t[S],E=St(function(){return Gg(Qt(T,mt($,s)))});o?d.push(E.dataSync()):d.push(E),m.push(e[x])};try{for(var b=ti(c),w=b.next();!w.done;w=b.next())y(w.value)}catch(x){r={error:x}}finally{try{w&&!w.done&&(i=b.return)&&i.call(b)}finally{if(r)throw r.error}}console.log("Data augmentation: mixing noise: added "+d.length+" examples"),d.forEach(function(x){return t.push(x)}),e.push.apply(e,bg(m))},n.prototype.getSortedUniqueNumFrames=function(){for(var t,e,s=new Set,r=this.getVocabulary(),i=0;i<r.length;++i){var o=r[i],a=this.label2Ids[o];try{for(var l=(t=void 0,ti(a)),c=l.next();!c.done;c=l.next()){var f=c.value,d=this.examples[f].spectrogram,m=d.data.length/d.frameSize;s.add(m)}}catch(b){t={error:b}}finally{try{c&&!c.done&&(e=l.return)&&e.call(l)}finally{if(t)throw t.error}}}var y=bg(s);return y.sort(),y},n.prototype.removeExample=function(t){if(!(t in this.examples))throw new Error("Nonexistent example UID: "+t);var e=this.examples[t].label;delete this.examples[t];var s=this.label2Ids[e].indexOf(t);this.label2Ids[e].splice(s,1),this.label2Ids[e].length===0&&delete this.label2Ids[e]},n.prototype.setExampleKeyFrameIndex=function(t,e){if(!(t in this.examples))throw new Error("Nonexistent example UID: "+t);var s=this.examples[t].spectrogram,r=s.data.length/s.frameSize;Q(e>=0&&e<r&&Number.isInteger(e),function(){return"Invalid keyFrameIndex: "+e+". Must be >= 0, < "+r+", and an integer."}),s.keyFrameIndex=e},n.prototype.size=function(){return Object.keys(this.examples).length},n.prototype.durationMillis=function(){var t=0;for(var e in this.examples){var s=this.examples[e].spectrogram,r=23.22|s.frameDurationMillis;t+=s.data.length/s.frameSize*r}return t},n.prototype.empty=function(){return this.size()===0},n.prototype.clear=function(){this.examples={}},n.prototype.getVocabulary=function(){var t=new Set;for(var e in this.examples){var s=this.examples[e];t.add(s.label)}var r=bg(t);return r.sort(),r},n.prototype.serialize=function(t){var e,s,r,i,o=this.getVocabulary();Q(!this.empty(),function(){return"Cannot serialize empty Dataset"}),t!=null&&(Array.isArray(t)||(t=[t]),t.forEach(function(S){if(o.indexOf(S)===-1)throw new Error('Word label "'+S+'" does not exist in the vocabulary of this dataset. The vocabulary is: '+JSON.stringify(o)+".")}));var a=[],l=[];try{for(var c=ti(o),f=c.next();!f.done;f=c.next()){var d=f.value;if(t==null||t.indexOf(d)!==-1){var m=this.label2Ids[d];try{for(var y=(r=void 0,ti(m)),b=y.next();!b.done;b=y.next()){var w=b.value,x=ZDt(this.examples[w]);a.push(x.spec),l.push(x.data)}}catch(S){r={error:S}}finally{try{b&&!b.done&&(i=y.return)&&i.call(y)}finally{if(r)throw r.error}}}}}catch(S){e={error:S}}finally{try{f&&!f.done&&(s=c.return)&&s.call(c)}finally{if(e)throw e.error}}return tOt({manifest:a,data:Kx(l)})},n})();function ZDt(n){var t=n.rawAudio!=null,e={label:n.label,spectrogramNumFrames:n.spectrogram.data.length/n.spectrogram.frameSize,spectrogramFrameSize:n.spectrogram.frameSize};n.spectrogram.keyFrameIndex!=null&&(e.spectrogramKeyFrameIndex=n.spectrogram.keyFrameIndex);var s=n.spectrogram.data.buffer.slice(0);return t&&(e.rawAudioNumSamples=n.rawAudio.data.length,e.rawAudioSampleRateHz=n.rawAudio.sampleRateHz,s=Kx([s,n.rawAudio.data.buffer])),{spec:e,data:s}}function JDt(n){var t={frameSize:n.spec.spectrogramFrameSize,data:new Float32Array(n.data.slice(0,4*n.spec.spectrogramFrameSize*n.spec.spectrogramNumFrames))};n.spec.spectrogramKeyFrameIndex!=null&&(t.keyFrameIndex=n.spec.spectrogramKeyFrameIndex);var e={label:n.spec.label,spectrogram:t};return n.spec.rawAudioNumSamples!=null&&(e.rawAudio={sampleRateHz:n.spec.rawAudioSampleRateHz,data:new Float32Array(n.data.slice(4*n.spec.spectrogramFrameSize*n.spec.spectrogramNumFrames))}),e}function tOt(n){var t=fz(JSON.stringify(n.manifest)),e=fz(X1),s=new Uint32Array([QDt]),r=new Uint32Array([t.byteLength]);return Kx([Kx([e,s.buffer,r.buffer]),t,n.data])}function eOt(n){Q(n!=null,function(){return"Received null or undefined buffer"});var t=0,e=dz(n.slice(t,X1.length));Q(e===X1,function(){return"Deserialization error: Invalid descriptor"}),t+=X1.length,t+=4;var s=new Uint32Array(n,t,1),r=t+=4;t=r+s[0];var i=dz(n.slice(r,t));return{manifest:JSON.parse(i),data:n.slice(t)}}function nOt(n,t,e,s){if(Q(Number.isInteger(n)&&n>0,function(){return"snippetLength must be a positive integer, but got "+n}),t!=null&&Q(Number.isInteger(t)&&t>=0,function(){return"focusIndex must be a non-negative integer, but got "+t}),Q(Number.isInteger(e)&&e>0,function(){return"windowLength must be a positive integer, but got "+e}),Q(Number.isInteger(s)&&s>0,function(){return"windowHop must be a positive integer, but got "+s}),Q(e<=n,function(){return"windowLength ("+e+") exceeds snippetLength ("+n+")"}),Q(t<n,function(){return"focusIndex ("+t+") equals or exceeds snippetLength ("+n+")"}),e===n)return[[0,n]];var r=[];if(t==null){for(var i=0;i+e<=n;)r.push([i,i+e]),i+=s;return r}var o=Math.floor(e/2),a=t-o;for(a<0?a=0:a+e>n&&(a=n-e);!(a-s<0||t>=a-s+e);)a-=s;for(;a+e<=n&&!(t<a);)r.push([a,a+e]),a+=s;return r}function sOt(n){return St(function(){var t=n.data.length/n.frameSize,e=K1(n.data,[t,n.frameSize]);return As(e,-1)})}function rOt(n){return St(function(){return ep(sOt(n))})}var b8="0.5.4",iOt="_unknown_",mE="tfjs-speech-commands-saved-model-metadata",oOt="indexeddb://tfjs-speech-commands-model/",gE={localStorage:typeof window>"u"?null:window.localStorage};function aOt(n){return n.split(".").slice(0,2).join(".")}var A1=.25,x8=(function(){function n(t,e,s){this.MODEL_URL_PREFIX="https://storage.googleapis.com/tfjs-models/tfjs/speech-commands/v"+aOt(b8)+"/browser_fft",this.SAMPLE_RATE_HZ=44100,this.FFT_SIZE=1024,this.DEFAULT_SUPPRESSION_TIME_MILLIS=0,this.streaming=!1,this.transferRecognizers={},Q(e==null&&s==null||e!=null&&s!=null,function(){return"modelURL and metadataURL must be both provided or both not provided."}),e==null?(t==null?t=n.DEFAULT_VOCABULARY_NAME:Q(n.VALID_VOCABULARY_NAMES.indexOf(t)!==-1,function(){return"Invalid vocabulary name: '"+t+"'"}),this.vocabulary=t,this.modelArtifactsOrURL=this.MODEL_URL_PREFIX+"/"+this.vocabulary+"/model.json",this.metadataOrURL=this.MODEL_URL_PREFIX+"/"+this.vocabulary+"/metadata.json"):(Q(t==null,function(){return"vocabulary name must be null or undefined when modelURL is provided"}),this.modelArtifactsOrURL=e,this.metadataOrURL=s),this.parameters={sampleRateHz:this.SAMPLE_RATE_HZ,fftSize:this.FFT_SIZE}}return n.prototype.listen=function(t,e){return as(this,void 0,void 0,function(){var s,r,i,o,a,l=this;return ls(this,function(c){switch(c.label){case 0:if(this.streaming)throw new Error("Cannot start streaming again when streaming is ongoing.");return[4,this.ensureModelLoaded()];case 1:if(c.sent(),e==null&&(e={}),s=e.probabilityThreshold==null?0:e.probabilityThreshold,e.includeEmbedding&&(s=0),Q(s>=0&&s<=1,function(){return"Invalid probabilityThreshold value: "+s}),r=e.invokeCallbackOnNoiseAndUnknown!=null&&e.invokeCallbackOnNoiseAndUnknown,e.includeEmbedding&&(r=!0),e.suppressionTimeMillis<0)throw new Error("suppressionTimeMillis is expected to be >= 0, but got "+e.suppressionTimeMillis);return i=e.overlapFactor==null?.5:e.overlapFactor,Q(i>=0&&i<1,function(){return"Expected overlapFactor to be >= 0 and < 1, but got "+i}),o=function(f,d){return as(l,void 0,void 0,function(){var m,y,b,w,x,S,T,$,E,R,B;return ls(this,function(N){switch(N.label){case 0:return m=Gg(f),e.includeEmbedding?[4,this.ensureModelWithEmbeddingOutputCreated()]:[3,2];case 1:return N.sent(),B=sN(this.modelWithEmbeddingOutput.predict(m),2),y=B[0],b=B[1],[3,3];case 2:y=this.model.predict(m),N.label=3;case 3:return[4,y.data()];case 4:return w=N.sent(),[4,(x=y.argMax(-1)).data()];case 5:return S=N.sent()[0],T=Math.max.apply(Math,bg(w)),Ee([y,x,m]),T<s?[2,!1]:[3,6];case 6:return $=void 0,e.includeSpectrogram?(E={},[4,f.data()]):[3,8];case 7:E.data=N.sent(),E.frameSize=this.nonBatchInputShape[1],$=E,N.label=8;case 8:return R=!0,r||this.words[S]!==Vd&&this.words[S]!==iOt||(R=!1),R&&t({scores:w,spectrogram:$,embedding:b}),[2,R]}})})},a=e.suppressionTimeMillis==null?this.DEFAULT_SUPPRESSION_TIME_MILLIS:e.suppressionTimeMillis,this.audioDataExtractor=new V$({sampleRateHz:this.parameters.sampleRateHz,numFramesPerSpectrogram:this.nonBatchInputShape[0],columnTruncateLength:this.nonBatchInputShape[1],suppressionTimeMillis:a,spectrogramCallback:o,overlapFactor:i}),[4,this.audioDataExtractor.start(e.audioTrackConstraints)];case 2:return c.sent(),this.streaming=!0,[2]}})})},n.prototype.ensureModelLoaded=function(){return as(this,void 0,void 0,function(){var t,e,s,r,i=this;return ls(this,function(o){switch(o.label){case 0:return this.model!=null?[2]:[4,this.ensureMetadataLoaded()];case 1:return o.sent(),typeof this.modelArtifactsOrURL!="string"?[3,3]:[4,B$(this.modelArtifactsOrURL)];case 2:return t=o.sent(),[3,5];case 3:return[4,B$(NCt(this.modelArtifactsOrURL.modelTopology,this.modelArtifactsOrURL.weightSpecs,this.modelArtifactsOrURL.weightData))];case 4:t=o.sent(),o.label=5;case 5:if(t.inputs.length!==1)throw new Error("Expected model to have 1 input, but got a model with "+t.inputs.length+" inputs");if(t.inputs[0].shape.length!==4)throw new Error("Expected model to have an input shape of rank 4, but got an input shape of rank "+t.inputs[0].shape.length);if(t.inputs[0].shape[3]!==1)throw new Error("Expected model to have an input shape with 1 as the last dimension, but got input shape"+JSON.stringify(t.inputs[0].shape[3])+"}");if((e=t.outputShape).length!==2)throw new Error("Expected loaded model to have an output shape of rank 2,but received shape "+JSON.stringify(e));if(e[1]!==this.words.length)throw new Error("Mismatch between the last dimension of model's output shape ("+e[1]+") and number of words ("+this.words.length+").");return this.model=t,this.freezeModel(),this.nonBatchInputShape=t.inputs[0].shape.slice(1),this.elementsPerExample=1,t.inputs[0].shape.slice(1).forEach(function(a){return i.elementsPerExample*=a}),this.warmUpModel(),s=this.parameters.fftSize/this.parameters.sampleRateHz*1e3,r=t.inputs[0].shape[1],this.parameters.spectrogramDurationMillis=r*s,[2]}})})},n.prototype.ensureModelWithEmbeddingOutputCreated=function(){return as(this,void 0,void 0,function(){var t,e;return ls(this,function(s){switch(s.label){case 0:return this.modelWithEmbeddingOutput!=null?[2]:[4,this.ensureModelLoaded()];case 1:for(s.sent(),e=this.model.layers.length-2;e>=0;--e)if(this.model.layers[e].getClassName()==="Dense"){t=this.model.layers[e];break}if(t==null)throw new Error("Failed to find second last dense layer in the original model.");return this.modelWithEmbeddingOutput=Hq({inputs:this.model.inputs,outputs:[this.model.outputs[0],t.output]}),[2]}})})},n.prototype.warmUpModel=function(){var t=this;St(function(){for(var e=gr([1].concat(t.nonBatchInputShape)),s=0;s<3;++s)t.model.predict(e)})},n.prototype.ensureMetadataLoaded=function(){return as(this,void 0,void 0,function(){var t,e,s;return ls(this,function(r){switch(r.label){case 0:return this.words!=null?[2]:typeof this.metadataOrURL!="string"?[3,2]:[4,VDt(this.metadataOrURL)];case 1:return e=r.sent(),[3,3];case 2:e=this.metadataOrURL,r.label=3;case 3:if((t=e).wordLabels==null){if((s=t.words)==null)throw new Error('Cannot find field "words" or "wordLabels" in metadata JSON file');this.words=s}else this.words=t.wordLabels;return[2]}})})},n.prototype.stopListening=function(){return as(this,void 0,void 0,function(){return ls(this,function(t){switch(t.label){case 0:if(!this.streaming)throw new Error("Cannot stop streaming when streaming is not ongoing.");return[4,this.audioDataExtractor.stop()];case 1:return t.sent(),this.streaming=!1,[2]}})})},n.prototype.isListening=function(){return this.streaming},n.prototype.wordLabels=function(){return this.words},n.prototype.params=function(){return this.parameters},n.prototype.modelInputShape=function(){if(this.model==null)throw new Error("Model has not been loaded yet. Load model by calling ensureModelLoaded(), recognize(), or listen().");return this.model.inputs[0].shape},n.prototype.recognize=function(t,e){return as(this,void 0,void 0,function(){var s,r,i,o,a,l,c,f,d,m,y,b,w;return ls(this,function(x){switch(x.label){case 0:return e==null&&(e={}),[4,this.ensureModelLoaded()];case 1:return x.sent(),t!=null?[3,3]:[4,this.recognizeOnline()];case 2:s=x.sent(),t=s.data,x.label=3;case 3:if(t instanceof Zn)this.checkInputTensorShape(t),i=t,r=t.shape[0];else{if(t.length%this.elementsPerExample)throw new Error("The length of the input Float32Array "+t.length+" is not divisible by the number of tensor elements per per example expected by the model "+this.elementsPerExample+".");r=t.length/this.elementsPerExample,i=I2t(t,[r].concat(this.nonBatchInputShape))}return a={scores:null},e.includeEmbedding?[4,this.ensureModelWithEmbeddingOutputCreated()]:[3,5];case 4:return x.sent(),l=this.modelWithEmbeddingOutput.predict(i),o=l[0],a.embedding=l[1],[3,6];case 5:o=this.model.predict(i),x.label=6;case 6:return r!==1?[3,8]:(c=a,[4,o.data()]);case 7:return c.scores=x.sent(),[3,10];case 8:return f=ip(o),d=f.map(function(S){return S.data()}),m=a,[4,Promise.all(d)];case 9:m.scores=x.sent(),Ee(f),x.label=10;case 10:return e.includeSpectrogram?(y=a,b={},t instanceof Zn?[4,t.data()]:[3,12]):[3,14];case 11:return w=x.sent(),[3,13];case 12:w=t,x.label=13;case 13:y.spectrogram=(b.data=w,b.frameSize=this.nonBatchInputShape[1],b),x.label=14;case 14:return Ee(o),[2,a]}})})},n.prototype.recognizeOnline=function(){return as(this,void 0,void 0,function(){var t=this;return ls(this,function(e){return[2,new Promise(function(s,r){t.audioDataExtractor=new V$({sampleRateHz:t.parameters.sampleRateHz,numFramesPerSpectrogram:t.nonBatchInputShape[0],columnTruncateLength:t.nonBatchInputShape[1],suppressionTimeMillis:0,spectrogramCallback:function(i){return as(t,void 0,void 0,function(){var o,a,l;return ls(this,function(c){switch(c.label){case 0:return o=Gg(i),[4,this.audioDataExtractor.stop()];case 1:return c.sent(),a=s,l={},[4,o.data()];case 2:return a.apply(void 0,[(l.data=c.sent(),l.frameSize=this.nonBatchInputShape[1],l)]),o.dispose(),[2,!1]}})})},overlapFactor:0}),t.audioDataExtractor.start()})]})})},n.prototype.createTransfer=function(t){if(this.model==null)throw new Error("Model has not been loaded yet. Load model by calling ensureModelLoaded(), recognizer(), or listen().");Q(t!=null&&typeof t=="string"&&t.length>1,function(){return"Expected the name for a transfer-learning recognized to be a non-empty string, but got "+JSON.stringify(t)}),Q(this.transferRecognizers[t]==null,function(){return"There is already a transfer-learning model named '"+t+"'"});var e=new lOt(t,this.parameters,this.model);return this.transferRecognizers[t]=e,e},n.prototype.freezeModel=function(){var t,e;try{for(var s=ti(this.model.layers),r=s.next();!r.done;r=s.next())r.value.trainable=!1}catch(i){t={error:i}}finally{try{r&&!r.done&&(e=s.return)&&e.call(s)}finally{if(t)throw t.error}}},n.prototype.checkInputTensorShape=function(t){var e=this.model.inputs[0].shape.length;if(t.shape.length!==e)throw new Error("Expected input Tensor to have rank "+e+", but got rank "+t.shape.length+" that differs ");var s=t.shape.slice(1),r=this.model.inputs[0].shape.slice(1);if(!ci(s,r))throw new Error("Expected input to have shape [null,"+r+"], but got shape [null,"+s+"]")},n.VALID_VOCABULARY_NAMES=["18w","directional4w"],n.DEFAULT_VOCABULARY_NAME="18w",n})(),lOt=(function(n){function t(e,s,r){var i=n.call(this)||this;return i.name=e,i.parameters=s,i.baseModel=r,Q(e!=null&&typeof e=="string"&&e.length>0,function(){return"The name of a transfer model must be a non-empty string, but got "+JSON.stringify(e)}),i.nonBatchInputShape=i.baseModel.inputs[0].shape.slice(1),i.words=null,i.dataset=new pz,i}return PDt(t,n),t.prototype.collectExample=function(e,s){return as(this,void 0,void 0,function(){var r,i,o,a,l=this;return ls(this,function(c){if(Q(!this.streaming,function(){return"Cannot start collection of transfer-learning example because a streaming recognition or transfer-learning example collection is ongoing"}),Q(e!=null&&typeof e=="string"&&e.length>0,function(){return"Must provide a non-empty string when collecting transfer-learning example"}),s==null&&(s={}),s.durationMultiplier!=null&&s.durationSec!=null)throw new Error("durationMultiplier and durationSec are mutually exclusive, but are both specified.");return s.durationSec!=null?(Q(s.durationSec>0,function(){return"Expected durationSec to be > 0, but got "+s.durationSec}),i=this.parameters.fftSize/this.parameters.sampleRateHz,r=Math.ceil(s.durationSec/i)):s.durationMultiplier!=null?(Q(s.durationMultiplier>=1,function(){return"Expected duration multiplier to be >= 1, but got "+s.durationMultiplier}),r=Math.round(this.nonBatchInputShape[0]*s.durationMultiplier)):r=this.nonBatchInputShape[0],s.snippetDurationSec!=null&&(Q(s.snippetDurationSec>0,function(){return"snippetDurationSec is expected to be > 0, but got "+s.snippetDurationSec}),Q(s.onSnippet!=null,function(){return"onSnippet must be provided if snippetDurationSec is provided."})),s.onSnippet!=null&&Q(s.snippetDurationSec!=null,function(){return"snippetDurationSec must be provided if onSnippet is provided."}),o=this.parameters.fftSize/this.parameters.sampleRateHz,a=o*r,this.streaming=!0,[2,new Promise(function(f){var d=s.snippetDurationSec==null?1:s.snippetDurationSec/a,m=1-d,y=Math.round(1/d),b=0,w=-1,x=[];l.audioDataExtractor=new V$({sampleRateHz:l.parameters.sampleRateHz,numFramesPerSpectrogram:r,columnTruncateLength:l.nonBatchInputShape[1],suppressionTimeMillis:0,spectrogramCallback:function(S,T){return as(l,void 0,void 0,function(){var $,E,R,B,N,k,_,F,A,P,L,tt,st,j,Z,J,ot,pt,q,et;return ls(this,function(U){switch(U.label){case 0:return s.onSnippet!=null?[3,7]:($=Gg(S),R=(E=this.dataset).addExample,B={label:e},N={},[4,$.data()]);case 1:return B.spectrogram=(N.data=U.sent(),N.frameSize=this.nonBatchInputShape[1],N),s.includeRawAudio?(_={},[4,T.data()]):[3,3];case 2:return _.data=U.sent(),_.sampleRateHz=this.audioDataExtractor.sampleRateHz,k=_,[3,4];case 3:k=void 0,U.label=4;case 4:return R.apply(E,[(B.rawAudio=k,B)]),$.dispose(),[4,this.audioDataExtractor.stop()];case 5:return U.sent(),this.streaming=!1,this.collateTransferWords(),F=f,A={},[4,S.data()];case 6:return F.apply(void 0,[(A.data=U.sent(),A.frameSize=this.nonBatchInputShape[1],A)]),[3,13];case 7:return[4,S.data()];case 8:for(P=U.sent(),w===-1&&(w=P.length),L=w-1;P[L]!==0&&L>=0;)L--;return tt=w-L-1,w=L+1,st=P.slice(P.length-tt,P.length),x.push(st),s.onSnippet!=null&&s.onSnippet({data:st,frameSize:this.nonBatchInputShape[1]}),b++!==y?[3,13]:[4,this.audioDataExtractor.stop()];case 9:return U.sent(),this.streaming=!1,this.collateTransferWords(),j=UDt(qDt(x)),Z={data:j,frameSize:this.nonBatchInputShape[1]},ot=(J=this.dataset).addExample,pt={label:e,spectrogram:Z},s.includeRawAudio?(et={},[4,T.data()]):[3,11];case 10:return et.data=U.sent(),et.sampleRateHz=this.audioDataExtractor.sampleRateHz,q=et,[3,12];case 11:q=void 0,U.label=12;case 12:ot.apply(J,[(pt.rawAudio=q,pt)]),f(Z),U.label=13;case 13:return[2,!1]}})})},overlapFactor:m,includeRawAudio:s.includeRawAudio}),l.audioDataExtractor.start(s.audioTrackConstraints)})]})})},t.prototype.clearExamples=function(){var e=this;Q(this.words!=null&&this.words.length>0&&!this.dataset.empty(),function(){return"No transfer learning examples exist for model name "+e.name}),this.dataset.clear(),this.words=null},t.prototype.countExamples=function(){if(this.dataset.empty())throw new Error("No examples have been collected for transfer-learning model named '"+this.name+"' yet.");return this.dataset.getExampleCounts()},t.prototype.getExamples=function(e){return this.dataset.getExamples(e)},t.prototype.setExampleKeyFrameIndex=function(e,s){this.dataset.setExampleKeyFrameIndex(e,s)},t.prototype.removeExample=function(e){this.dataset.removeExample(e),this.collateTransferWords()},t.prototype.isDatasetEmpty=function(){return this.dataset.empty()},t.prototype.loadExamples=function(e,s){var r,i,o,a;s===void 0&&(s=!1);var l=new pz(e);s&&this.clearExamples();var c=l.getVocabulary();try{for(var f=ti(c),d=f.next();!d.done;d=f.next()){var m=d.value,y=l.getExamples(m);try{for(var b=(o=void 0,ti(y)),w=b.next();!w.done;w=b.next()){var x=w.value;this.dataset.addExample(x.example)}}catch(S){o={error:S}}finally{try{w&&!w.done&&(a=b.return)&&a.call(b)}finally{if(o)throw o.error}}}}catch(S){r={error:S}}finally{try{d&&!d.done&&(i=f.return)&&i.call(f)}finally{if(r)throw r.error}}this.collateTransferWords()},t.prototype.serializeExamples=function(e){return this.dataset.serialize(e)},t.prototype.collateTransferWords=function(){this.words=this.dataset.getVocabulary()},t.prototype.collectTransferDataAsTensors=function(e,s){var r=this.nonBatchInputShape[0];e=e||A1;var i=Math.round(e*r),o=this.dataset.getData(null,P$({numFrames:r,hopFrames:i},s));return{xs:o.xs,ys:o.ys}},t.prototype.collectTransferDataAsTfDataset=function(e,s,r,i){s===void 0&&(s=.15),r===void 0&&(r=32);var o=this.nonBatchInputShape[0];e=e||A1;var a=Math.round(e*o);return this.dataset.getData(null,P$({numFrames:o,hopFrames:a,getDataset:!0,datasetBatchSize:r,datasetValidationSplit:s},i))},t.prototype.train=function(e){return as(this,void 0,void 0,function(){var s,r=this;return ls(this,function(i){return Q(this.words!=null&&this.words.length>0,function(){return"Cannot train transfer-learning model '"+r.name+"' because no transfer learning example has been collected."}),Q(this.words.length>1,function(){return"Cannot train transfer-learning model '"+r.name+"' because only 1 word label ('"+JSON.stringify(r.words)+"') has been collected for transfer learning. Requires at least 2."}),e.fineTuningEpochs!=null&&Q(e.fineTuningEpochs>=0&&Number.isInteger(e.fineTuningEpochs),function(){return"If specified, fineTuningEpochs must be a non-negative integer, but received "+e.fineTuningEpochs}),e==null&&(e={}),this.model==null&&this.createTransferModelFromBaseModel(),this.secondLastBaseDenseLayer.trainable=!1,this.model.compile({loss:"categoricalCrossentropy",optimizer:e.optimizer||"sgd",metrics:["acc"]}),s=e.fitDatasetDurationMillisThreshold==null?6e4:e.fitDatasetDurationMillisThreshold,this.dataset.durationMillis()>s?(console.log("Detected large dataset: total duration = "+this.dataset.durationMillis()+" ms > "+s+" ms. Training transfer model using fitDataset() instead of fit()"),[2,this.trainOnDataset(e)]):[2,this.trainOnTensors(e)]})})},t.prototype.trainOnDataset=function(e){return as(this,void 0,void 0,function(){var s,r,i,o,a,l,c,f,d;return ls(this,function(m){switch(m.label){case 0:return Q(e.epochs>0,function(){return"Invalid config.epochs"}),s=e.batchSize==null?32:e.batchSize,r=e.windowHopRatio||A1,i=sN(this.collectTransferDataAsTfDataset(r,e.validationSplit,s,{augmentByMixingNoiseRatio:e.augmentByMixingNoiseRatio}),2),o=i[0],a=i[1],l=xo(),[4,this.model.fitDataset(o,{epochs:e.epochs,validationData:e.validationSplit>0?a:null,callbacks:e.callback==null?null:[e.callback]})];case 1:return c=m.sent(),console.log("fitDataset() took "+(xo()-l).toFixed(2)+" ms"),e.fineTuningEpochs!=null&&e.fineTuningEpochs>0?(f=xo(),[4,this.fineTuningUsingTfDatasets(e,o,a)]):[3,3];case 2:return d=m.sent(),console.log("fitDataset() (fine-tuning) took "+(xo()-f).toFixed(2)+" ms"),[2,[c,d]];case 3:return[2,c]}})})},t.prototype.trainOnTensors=function(e){return as(this,void 0,void 0,function(){var s,r,i,o,a,l,c,f,d,m;return ls(this,function(y){switch(y.label){case 0:s=e.windowHopRatio||A1,r=this.collectTransferDataAsTensors(s,{augmentByMixingNoiseRatio:e.augmentByMixingNoiseRatio}),i=r.xs,o=r.ys,console.log("Training data: xs.shape = "+i.shape+", ys.shape = "+o.shape),y.label=1;case 1:return y.trys.push([1,,6,7]),e.validationSplit!=null?(f=XDt(i,o,e.validationSplit),a=f.trainXs,l=f.trainYs,c=[f.valXs,f.valYs]):(a=i,l=o),[4,this.model.fit(a,l,{epochs:e.epochs==null?20:e.epochs,validationData:c,batchSize:e.batchSize,callbacks:e.callback==null?null:[e.callback]})];case 2:return d=y.sent(),e.fineTuningEpochs!=null&&e.fineTuningEpochs>0?[4,this.fineTuningUsingTensors(e,a,l,c)]:[3,4];case 3:return m=y.sent(),[2,[d,m]];case 4:return[2,d];case 5:return[3,7];case 6:return Ee([i,o,a,l,c]),[7];case 7:return[2]}})})},t.prototype.fineTuningUsingTfDatasets=function(e,s,r){return as(this,void 0,void 0,function(){var i,o,a;return ls(this,function(l){switch(l.label){case 0:return i=this.secondLastBaseDenseLayer.trainable,this.secondLastBaseDenseLayer.trainable=!0,o=e.fineTuningOptimizer==null?"sgd":e.fineTuningOptimizer,this.model.compile({loss:"categoricalCrossentropy",optimizer:o,metrics:["acc"]}),[4,this.model.fitDataset(s,{epochs:e.fineTuningEpochs,validationData:r,callbacks:e.callback==null?null:[e.callback]})];case 1:return a=l.sent(),this.secondLastBaseDenseLayer.trainable=i,[2,a]}})})},t.prototype.fineTuningUsingTensors=function(e,s,r,i){return as(this,void 0,void 0,function(){var o,a,l;return ls(this,function(c){switch(c.label){case 0:return o=this.secondLastBaseDenseLayer.trainable,this.secondLastBaseDenseLayer.trainable=!0,a=e.fineTuningOptimizer==null?"sgd":e.fineTuningOptimizer,this.model.compile({loss:"categoricalCrossentropy",optimizer:a,metrics:["acc"]}),[4,this.model.fit(s,r,{epochs:e.fineTuningEpochs,validationData:i,batchSize:e.batchSize,callbacks:e.fineTuningCallback==null?null:[e.fineTuningCallback]})];case 1:return l=c.sent(),this.secondLastBaseDenseLayer.trainable=o,[2,l]}})})},t.prototype.evaluate=function(e){return as(this,void 0,void 0,function(){var s,r=this;return ls(this,function(i){return Q(e.wordProbThresholds!=null&&e.wordProbThresholds.length>0,function(){return"Received null or empty wordProbThresholds"}),s=0,Q(this.words[s]===Vd,function(){return"Cannot perform evaluation when the first tag is not "+Vd}),[2,St(function(){for(var o=[],a=0,l=r.collectTransferDataAsTensors(e.windowHopRatio),c=l.xs,f=l.ys.argMax(-1).dataSync(),d=r.model.predict(c),m=Hl(Qn(d,[0,1],[d.shape[0],d.shape[1]-1]),-1),y=d.shape[0],b=0;b<e.wordProbThresholds.length;++b){for(var w=e.wordProbThresholds[b],x=m.greater(xn(w)).dataSync(),S=0,T=0,$=0,E=0,R=0;R<y;++R)f[R]===s?(S++,x[R]&&$++):(T++,x[R]&&E++);var B=$/S,N=E/T;o.push({probThreshold:w,fpr:B,tpr:N}),console.log("ROC thresh="+w+": fpr="+B.toFixed(4)+", tpr="+N.toFixed(4)),b>0&&(a+=Math.abs(o[b-1].fpr-o[b].fpr)*(o[b-1].tpr+o[b].tpr)/2)}return{rocCurve:o,auc:a}})]})})},t.prototype.createTransferModelFromBaseModel=function(){var e=this;Q(this.words!=null,function(){return"No word example is available for tranfer-learning model of name "+e.name});for(var s=this.baseModel.layers,r=s.length-2;r>=0&&s[r].getClassName().toLowerCase()!=="dense";)r--;if(r<0)throw new Error("Cannot find a hidden dense layer in the base model.");this.secondLastBaseDenseLayer=s[r];var i=this.secondLastBaseDenseLayer.output;this.transferHead=EDt(),this.transferHead.add(BDt({units:this.words.length,activation:"softmax",inputShape:i.shape.slice(1),name:"NewHeadDense"}));var o=this.transferHead.apply(i);this.model=Hq({inputs:this.baseModel.inputs,outputs:o})},t.prototype.modelInputShape=function(){return this.baseModel.inputs[0].shape},t.prototype.getMetadata=function(){return{tfjsSpeechCommandsVersion:b8,modelName:this.name,timeStamp:new Date().toISOString(),wordLabels:this.wordLabels()}},t.prototype.save=function(e){return as(this,void 0,void 0,function(){var s,r,i;return ls(this,function(o){return s=e!=null,e=e||mz(this.name),s||(r=gE.localStorage.getItem(mE),(i=r==null?{}:JSON.parse(r))[this.name]=this.getMetadata(),gE.localStorage.setItem(mE,JSON.stringify(i))),console.log("Saving model to "+e),[2,this.model.save(e)]})})},t.prototype.load=function(e){return as(this,void 0,void 0,function(){var s,r,i;return ls(this,function(o){switch(o.label){case 0:if(s=e!=null,e=e||mz(this.name),!s){if((r=JSON.parse(gE.localStorage.getItem(mE)))==null||r[this.name]==null)throw new Error("Cannot find metadata for transfer model named "+this.name+'"');this.words=r[this.name].wordLabels,console.log("Loaded word list for model named "+this.name+": "+this.words)}return i=this,[4,B$(e)];case 1:return i.model=o.sent(),console.log("Loaded model from "+e+":"),this.model.summary(),[2]}})})},t.prototype.createTransfer=function(e){throw new Error("Creating transfer-learned recognizer from a transfer-learned recognizer is not supported.")},t})(x8);function mz(n){return""+oOt+n}function uOt(n,t,e,s){if(Q(s==null,function(){return"customModelURL and customMetadataURL must be both provided or both not provided."}),n==="BROWSER_FFT")return new x8(t,e,s)}class cOt{constructor(){this.recognizer=null,this.audioContext=null,this.analyser=null,this.microphone=null,this.isListening=!1,this.threatHistory=[],this.HISTORY_LENGTH=100,this.threatPatterns={glassBreak:{freqRange:[2e3,15e3],sharpness:.8,duration:[.1,.5]},scream:{freqRange:[800,3e3],intensity:.7,duration:[.5,3]},gunshot:{freqRange:[500,8e3],sharpness:.95,duration:[.05,.2]},alarm:{freqRange:[1e3,4e3],repetitive:!0,duration:[1,10]},aggressiveVoice:{freqRange:[100,500],intensity:.6,duration:[1,5]},explosion:{freqRange:[20,1e4],intensity:.9,duration:[.1,1]},carCrash:{freqRange:[100,5e3],intensity:.8,duration:[.5,2]},dogBark:{freqRange:[500,1800],repetitive:!0,duration:[.2,1]}}}async initialize(){try{return await FY(),this.recognizer=uOt("BROWSER_FFT"),await this.recognizer.ensureModelLoaded(),this.audioContext=new(window.AudioContext||window.webkitAudioContext),this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2048,this.analyser.smoothingTimeConstant=.8,console.log("SonicGuard initialized successfully"),!0}catch(t){return console.error("Failed to initialize SonicGuard:",t),!1}}async startListening(t){if(!this.isListening)try{const e=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:!0,noiseSuppression:!1,autoGainControl:!1}});this.microphone=this.audioContext.createMediaStreamSource(e),this.microphone.connect(this.analyser),this.isListening=!0,this.analyzeAudio(t),console.log("SonicGuard listening...")}catch(e){throw console.error("Microphone access denied:",e),e}}analyzeAudio(t){if(!this.isListening)return;const e=this.analyser.frequencyBinCount,s=new Uint8Array(e),r=new Uint8Array(e),i=()=>{if(!this.isListening)return;this.analyser.getByteFrequencyData(s),this.analyser.getByteTimeDomainData(r);const o=this.detectThreat(s,r);if(o){const a=this.estimateSoundDirection(s);o.direction=a.direction,o.distance=a.distance,this.threatHistory.push({...o,timestamp:Date.now()}),this.threatHistory.length>this.HISTORY_LENGTH&&this.threatHistory.shift(),t(o)}requestAnimationFrame(i)};i()}detectThreat(t,e){const s=this.extractFeatures(t,e);let r=0,i=null;for(const[o,a]of Object.entries(this.threatPatterns)){const l=this.matchPattern(s,a);l>r&&l>.6&&(r=l,i={type:o,confidence:l*100,severity:this.calculateSeverity(o,l),features:s})}return i}extractFeatures(t,e){return{dominantFrequency:this.getDominantFrequency(t),spectralCentroid:this.getSpectralCentroid(t),spectralRolloff:this.getSpectralRolloff(t),spectralFlux:this.getSpectralFlux(t),rms:this.getRMS(e),zeroCrossingRate:this.getZeroCrossingRate(e),totalEnergy:this.getTotalEnergy(t),lowFreqEnergy:this.getFrequencyBandEnergy(t,0,500),midFreqEnergy:this.getFrequencyBandEnergy(t,500,2e3),highFreqEnergy:this.getFrequencyBandEnergy(t,2e3,2e4)}}matchPattern(t,e){let s=0,r=0;if(e.freqRange){const[o,a]=e.freqRange;t.dominantFrequency>=o&&t.dominantFrequency<=a&&(s+=.3),r++}return e.sharpness&&(t.spectralFlux/100>=e.sharpness*.8&&(s+=.3),r++),e.intensity&&(t.rms/128>=e.intensity*.7&&(s+=.2),r++),t.highFreqEnergy/(t.totalEnergy+1)>.3&&(s+=.2),r++,s/r}calculateSeverity(t,e){const r={gunshot:"critical",explosion:"critical",scream:"high",glassBreak:"high",carCrash:"high",aggressiveVoice:"medium",alarm:"medium",dogBark:"low"}[t]||"low";return e>90||e>75&&r==="high"?"critical":r}estimateSoundDirection(t){const e=this.getFrequencyBandEnergy(t,0,t.length/2),s=this.getFrequencyBandEnergy(t,t.length/2,t.length),i=((s-e)/(s+e+1)+1)/2*360,o=e+s,a=Math.max(1,Math.min(50,50/(o/1e3+1)));return{direction:Math.round(i),distance:Math.round(a)}}getDominantFrequency(t){let e=0,s=0;for(let r=0;r<t.length;r++)t[r]>e&&(e=t[r],s=r);return s*44100/(2*t.length)}getSpectralCentroid(t){let e=0,s=0;for(let r=0;r<t.length;r++)e+=r*t[r],s+=t[r];return s===0?0:e/s}getSpectralRolloff(t,e=.85){const r=t.reduce((o,a)=>o+a,0)*e;let i=0;for(let o=0;o<t.length;o++)if(i+=t[o],i>=r)return o;return t.length-1}getSpectralFlux(t){if(!this.previousSpectrum)return this.previousSpectrum=new Uint8Array(t),0;let e=0;for(let s=0;s<t.length;s++){const r=t[s]-this.previousSpectrum[s];e+=r*r}return this.previousSpectrum=new Uint8Array(t),Math.sqrt(e)}getRMS(t){let e=0;for(let s=0;s<t.length;s++){const r=(t[s]-128)/128;e+=r*r}return Math.sqrt(e/t.length)*128}getZeroCrossingRate(t){let e=0;for(let s=1;s<t.length;s++)(t[s]>=128&&t[s-1]<128||t[s]<128&&t[s-1]>=128)&&e++;return e/t.length}getTotalEnergy(t){return t.reduce((e,s)=>e+s,0)}getFrequencyBandEnergy(t,e,s){const r=Math.floor(e*2*t.length/44100),i=Math.floor(s*2*t.length/44100);let o=0;for(let a=r;a<Math.min(i,t.length);a++)o+=t[a];return o}getThreatHistory(){return this.threatHistory}getAudioLevel(){if(!this.analyser)return 0;const t=new Uint8Array(this.analyser.frequencyBinCount);return this.analyser.getByteFrequencyData(t),t.reduce((s,r)=>s+r,0)/t.length/255*100}stopListening(){this.isListening=!1,this.microphone&&(this.microphone.disconnect(),this.microphone.mediaStream.getTracks().forEach(t=>t.stop()),this.microphone=null),console.log("SonicGuard stopped listening")}dispose(){this.stopListening(),this.audioContext&&(this.audioContext.close(),this.audioContext=null),this.recognizer&&(this.recognizer=null),this.threatHistory=[]}}const hOt="modulepreload",fOt=function(n){return"/"+n},gz={},dOt=function(t,e,s){let r=Promise.resolve();if(e&&e.length>0){let c=function(f){return Promise.all(f.map(d=>Promise.resolve(d).then(m=>({status:"fulfilled",value:m}),m=>({status:"rejected",reason:m}))))};var o=c;document.getElementsByTagName("link");const a=document.querySelector("meta[property=csp-nonce]"),l=a?.nonce||a?.getAttribute("nonce");r=c(e.map(f=>{if(f=fOt(f),f in gz)return;gz[f]=!0;const d=f.endsWith(".css"),m=d?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${f}"]${m}`))return;const y=document.createElement("link");if(y.rel=d?"stylesheet":hOt,d||(y.as="script"),y.crossOrigin="",y.href=f,l&&y.setAttribute("nonce",l),document.head.appendChild(y),d)return new Promise((b,w)=>{y.addEventListener("load",b),y.addEventListener("error",()=>w(new Error(`Unable to preload CSS for ${f}`)))})}))}function i(a){const l=new Event("vite:preloadError",{cancelable:!0});if(l.payload=a,window.dispatchEvent(l),!l.defaultPrevented)throw a}return r.then(a=>{for(const l of a||[])l.status==="rejected"&&i(l.reason);return t().catch(i)})},pOt=()=>{};var yz={};const w8=function(n){const t=[];let e=0;for(let s=0;s<n.length;s++){let r=n.charCodeAt(s);r<128?t[e++]=r:r<2048?(t[e++]=r>>6|192,t[e++]=r&63|128):(r&64512)===55296&&s+1<n.length&&(n.charCodeAt(s+1)&64512)===56320?(r=65536+((r&1023)<<10)+(n.charCodeAt(++s)&1023),t[e++]=r>>18|240,t[e++]=r>>12&63|128,t[e++]=r>>6&63|128,t[e++]=r&63|128):(t[e++]=r>>12|224,t[e++]=r>>6&63|128,t[e++]=r&63|128)}return t},mOt=function(n){const t=[];let e=0,s=0;for(;e<n.length;){const r=n[e++];if(r<128)t[s++]=String.fromCharCode(r);else if(r>191&&r<224){const i=n[e++];t[s++]=String.fromCharCode((r&31)<<6|i&63)}else if(r>239&&r<365){const i=n[e++],o=n[e++],a=n[e++],l=((r&7)<<18|(i&63)<<12|(o&63)<<6|a&63)-65536;t[s++]=String.fromCharCode(55296+(l>>10)),t[s++]=String.fromCharCode(56320+(l&1023))}else{const i=n[e++],o=n[e++];t[s++]=String.fromCharCode((r&15)<<12|(i&63)<<6|o&63)}}return t.join("")},v8={byteToCharMap_:null,charToByteMap_:null,byteToCharMapWebSafe_:null,charToByteMapWebSafe_:null,ENCODED_VALS_BASE:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",get ENCODED_VALS(){return this.ENCODED_VALS_BASE+"+/="},get ENCODED_VALS_WEBSAFE(){return this.ENCODED_VALS_BASE+"-_."},HAS_NATIVE_SUPPORT:typeof atob=="function",encodeByteArray(n,t){if(!Array.isArray(n))throw Error("encodeByteArray takes an array as a parameter");this.init_();const e=t?this.byteToCharMapWebSafe_:this.byteToCharMap_,s=[];for(let r=0;r<n.length;r+=3){const i=n[r],o=r+1<n.length,a=o?n[r+1]:0,l=r+2<n.length,c=l?n[r+2]:0,f=i>>2,d=(i&3)<<4|a>>4;let m=(a&15)<<2|c>>6,y=c&63;l||(y=64,o||(m=64)),s.push(e[f],e[d],e[m],e[y])}return s.join("")},encodeString(n,t){return this.HAS_NATIVE_SUPPORT&&!t?btoa(n):this.encodeByteArray(w8(n),t)},decodeString(n,t){return this.HAS_NATIVE_SUPPORT&&!t?atob(n):mOt(this.decodeStringToByteArray(n,t))},decodeStringToByteArray(n,t){this.init_();const e=t?this.charToByteMapWebSafe_:this.charToByteMap_,s=[];for(let r=0;r<n.length;){const i=e[n.charAt(r++)],a=r<n.length?e[n.charAt(r)]:0;++r;const c=r<n.length?e[n.charAt(r)]:64;++r;const d=r<n.length?e[n.charAt(r)]:64;if(++r,i==null||a==null||c==null||d==null)throw new gOt;const m=i<<2|a>>4;if(s.push(m),c!==64){const y=a<<4&240|c>>2;if(s.push(y),d!==64){const b=c<<6&192|d;s.push(b)}}}return s},init_(){if(!this.byteToCharMap_){this.byteToCharMap_={},this.charToByteMap_={},this.byteToCharMapWebSafe_={},this.charToByteMapWebSafe_={};for(let n=0;n<this.ENCODED_VALS.length;n++)this.byteToCharMap_[n]=this.ENCODED_VALS.charAt(n),this.charToByteMap_[this.byteToCharMap_[n]]=n,this.byteToCharMapWebSafe_[n]=this.ENCODED_VALS_WEBSAFE.charAt(n),this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[n]]=n,n>=this.ENCODED_VALS_BASE.length&&(this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(n)]=n,this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(n)]=n)}}};class gOt extends Error{constructor(){super(...arguments),this.name="DecodeBase64StringError"}}const yOt=function(n){const t=w8(n);return v8.encodeByteArray(t,!0)},Xx=function(n){return yOt(n).replace(/\./g,"")},bOt=function(n){try{return v8.decodeString(n,!0)}catch(t){console.error("base64Decode failed: ",t)}return null};function xOt(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof oa<"u")return oa;throw new Error("Unable to locate global object.")}const wOt=()=>xOt().__FIREBASE_DEFAULTS__,vOt=()=>{if(typeof Un>"u"||typeof yz>"u")return;const n=yz.__FIREBASE_DEFAULTS__;if(n)return JSON.parse(n)},SOt=()=>{if(typeof document>"u")return;let n;try{n=document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)}catch{return}const t=n&&bOt(n[1]);return t&&JSON.parse(t)},rN=()=>{try{return pOt()||wOt()||vOt()||SOt()}catch(n){console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${n}`);return}},IOt=n=>rN()?.emulatorHosts?.[n],S8=n=>{const t=IOt(n);if(!t)return;const e=t.lastIndexOf(":");if(e<=0||e+1===t.length)throw new Error(`Invalid host ${t} with no separate hostname and port!`);const s=parseInt(t.substring(e+1),10);return t[0]==="["?[t.substring(1,e-1),s]:[t.substring(0,e),s]},I8=()=>rN()?.config;class TOt{constructor(){this.reject=()=>{},this.resolve=()=>{},this.promise=new Promise((t,e)=>{this.resolve=t,this.reject=e})}wrapCallback(t){return(e,s)=>{e?this.reject(e):this.resolve(s),typeof t=="function"&&(this.promise.catch(()=>{}),t.length===1?t(e):t(e,s))}}}function Db(n){try{return(n.startsWith("http://")||n.startsWith("https://")?new URL(n).hostname:n).endsWith(".cloudworkstations.dev")}catch{return!1}}async function T8(n){return(await fetch(n,{credentials:"include"})).ok}function COt(n,t){if(n.uid)throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');const e={alg:"none",type:"JWT"},s=t||"demo-project",r=n.iat||0,i=n.sub||n.user_id;if(!i)throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");const o={iss:`https://securetoken.google.com/${s}`,aud:s,iat:r,exp:r+3600,auth_time:r,sub:i,user_id:i,firebase:{sign_in_provider:"custom",identities:{}},...n};return[Xx(JSON.stringify(e)),Xx(JSON.stringify(o)),""].join(".")}const xg={};function EOt(){const n={prod:[],emulator:[]};for(const t of Object.keys(xg))xg[t]?n.emulator.push(t):n.prod.push(t);return n}function $Ot(n){let t=document.getElementById(n),e=!1;return t||(t=document.createElement("div"),t.setAttribute("id",n),e=!0),{created:e,element:t}}let bz=!1;function C8(n,t){if(typeof window>"u"||typeof document>"u"||!Db(window.location.host)||xg[n]===t||xg[n]||bz)return;xg[n]=t;function e(m){return`__firebase__banner__${m}`}const s="__firebase__banner",i=EOt().prod.length>0;function o(){const m=document.getElementById(s);m&&m.remove()}function a(m){m.style.display="flex",m.style.background="#7faaf0",m.style.position="fixed",m.style.bottom="5px",m.style.left="5px",m.style.padding=".5em",m.style.borderRadius="5px",m.style.alignItems="center"}function l(m,y){m.setAttribute("width","24"),m.setAttribute("id",y),m.setAttribute("height","24"),m.setAttribute("viewBox","0 0 24 24"),m.setAttribute("fill","none"),m.style.marginLeft="-6px"}function c(){const m=document.createElement("span");return m.style.cursor="pointer",m.style.marginLeft="16px",m.style.fontSize="24px",m.innerHTML=" &times;",m.onclick=()=>{bz=!0,o()},m}function f(m,y){m.setAttribute("id",y),m.innerText="Learn more",m.href="https://firebase.google.com/docs/studio/preview-apps#preview-backend",m.setAttribute("target","__blank"),m.style.paddingLeft="5px",m.style.textDecoration="underline"}function d(){const m=$Ot(s),y=e("text"),b=document.getElementById(y)||document.createElement("span"),w=e("learnmore"),x=document.getElementById(w)||document.createElement("a"),S=e("preprendIcon"),T=document.getElementById(S)||document.createElementNS("http://www.w3.org/2000/svg","svg");if(m.created){const $=m.element;a($),f(x,w);const E=c();l(T,S),$.append(T,b,x,E),document.body.appendChild($)}i?(b.innerText="Preview backend disconnected.",T.innerHTML=`<g clip-path="url(#clip0_6013_33858)">
<path d="M4.8 17.6L12 5.6L19.2 17.6H4.8ZM6.91667 16.4H17.0833L12 7.93333L6.91667 16.4ZM12 15.6C12.1667 15.6 12.3056 15.5444 12.4167 15.4333C12.5389 15.3111 12.6 15.1667 12.6 15C12.6 14.8333 12.5389 14.6944 12.4167 14.5833C12.3056 14.4611 12.1667 14.4 12 14.4C11.8333 14.4 11.6889 14.4611 11.5667 14.5833C11.4556 14.6944 11.4 14.8333 11.4 15C11.4 15.1667 11.4556 15.3111 11.5667 15.4333C11.6889 15.5444 11.8333 15.6 12 15.6ZM11.4 13.6H12.6V10.4H11.4V13.6Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6013_33858">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`):(T.innerHTML=`<g clip-path="url(#clip0_6083_34804)">
<path d="M11.4 15.2H12.6V11.2H11.4V15.2ZM12 10C12.1667 10 12.3056 9.94444 12.4167 9.83333C12.5389 9.71111 12.6 9.56667 12.6 9.4C12.6 9.23333 12.5389 9.09444 12.4167 8.98333C12.3056 8.86111 12.1667 8.8 12 8.8C11.8333 8.8 11.6889 8.86111 11.5667 8.98333C11.4556 9.09444 11.4 9.23333 11.4 9.4C11.4 9.56667 11.4556 9.71111 11.5667 9.83333C11.6889 9.94444 11.8333 10 12 10ZM12 18.4C11.1222 18.4 10.2944 18.2333 9.51667 17.9C8.73889 17.5667 8.05556 17.1111 7.46667 16.5333C6.88889 15.9444 6.43333 15.2611 6.1 14.4833C5.76667 13.7056 5.6 12.8778 5.6 12C5.6 11.1111 5.76667 10.2833 6.1 9.51667C6.43333 8.73889 6.88889 8.06111 7.46667 7.48333C8.05556 6.89444 8.73889 6.43333 9.51667 6.1C10.2944 5.76667 11.1222 5.6 12 5.6C12.8889 5.6 13.7167 5.76667 14.4833 6.1C15.2611 6.43333 15.9389 6.89444 16.5167 7.48333C17.1056 8.06111 17.5667 8.73889 17.9 9.51667C18.2333 10.2833 18.4 11.1111 18.4 12C18.4 12.8778 18.2333 13.7056 17.9 14.4833C17.5667 15.2611 17.1056 15.9444 16.5167 16.5333C15.9389 17.1111 15.2611 17.5667 14.4833 17.9C13.7167 18.2333 12.8889 18.4 12 18.4ZM12 17.2C13.4444 17.2 14.6722 16.6944 15.6833 15.6833C16.6944 14.6722 17.2 13.4444 17.2 12C17.2 10.5556 16.6944 9.32778 15.6833 8.31667C14.6722 7.30555 13.4444 6.8 12 6.8C10.5556 6.8 9.32778 7.30555 8.31667 8.31667C7.30556 9.32778 6.8 10.5556 6.8 12C6.8 13.4444 7.30556 14.6722 8.31667 15.6833C9.32778 16.6944 10.5556 17.2 12 17.2Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6083_34804">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`,b.innerText="Preview backend running in this workspace."),b.setAttribute("id",y)}document.readyState==="loading"?window.addEventListener("DOMContentLoaded",d):d()}function AOt(){return typeof navigator<"u"&&typeof navigator.userAgent=="string"?navigator.userAgent:""}function kOt(){const n=rN()?.forceEnvironment;if(n==="node")return!0;if(n==="browser")return!1;try{return Object.prototype.toString.call(oa.process)==="[object process]"}catch{return!1}}function _Ot(){const n=typeof chrome=="object"?chrome.runtime:typeof browser=="object"?browser.runtime:void 0;return typeof n=="object"&&n.id!==void 0}function NOt(){return!kOt()&&!!navigator.userAgent&&navigator.userAgent.includes("Safari")&&!navigator.userAgent.includes("Chrome")}function E8(){try{return typeof indexedDB=="object"}catch{return!1}}function $8(){return new Promise((n,t)=>{try{let e=!0;const s="validate-browser-context-for-indexeddb-analytics-module",r=self.indexedDB.open(s);r.onsuccess=()=>{r.result.close(),e||self.indexedDB.deleteDatabase(s),n(!0)},r.onupgradeneeded=()=>{e=!1},r.onerror=()=>{t(r.error?.message||"")}}catch(e){t(e)}})}function ROt(){return!(typeof navigator>"u"||!navigator.cookieEnabled)}const DOt="FirebaseError";class cu extends Error{constructor(t,e,s){super(e),this.code=t,this.customData=s,this.name=DOt,Object.setPrototypeOf(this,cu.prototype),Error.captureStackTrace&&Error.captureStackTrace(this,uS.prototype.create)}}class uS{constructor(t,e,s){this.service=t,this.serviceName=e,this.errors=s}create(t,...e){const s=e[0]||{},r=`${this.service}/${t}`,i=this.errors[t],o=i?OOt(i,s):"Error",a=`${this.serviceName}: ${o} (${r}).`;return new cu(r,a,s)}}function OOt(n,t){return n.replace(FOt,(e,s)=>{const r=t[s];return r!=null?String(r):`<${s}?>`})}const FOt=/\{\$([^}]+)}/g;function Wg(n,t){if(n===t)return!0;const e=Object.keys(n),s=Object.keys(t);for(const r of e){if(!s.includes(r))return!1;const i=n[r],o=t[r];if(xz(i)&&xz(o)){if(!Wg(i,o))return!1}else if(i!==o)return!1}for(const r of s)if(!e.includes(r))return!1;return!0}function xz(n){return n!==null&&typeof n=="object"}const MOt=1e3,LOt=2,zOt=14400*1e3,BOt=.5;function wz(n,t=MOt,e=LOt){const s=t*Math.pow(e,n),r=Math.round(BOt*s*(Math.random()-.5)*2);return Math.min(zOt,s+r)}function Eo(n){return n&&n._delegate?n._delegate:n}class yl{constructor(t,e,s){this.name=t,this.instanceFactory=e,this.type=s,this.multipleInstances=!1,this.serviceProps={},this.instantiationMode="LAZY",this.onInstanceCreated=null}setInstantiationMode(t){return this.instantiationMode=t,this}setMultipleInstances(t){return this.multipleInstances=t,this}setServiceProps(t){return this.serviceProps=t,this}setInstanceCreatedCallback(t){return this.onInstanceCreated=t,this}}const yh="[DEFAULT]";class POt{constructor(t,e){this.name=t,this.container=e,this.component=null,this.instances=new Map,this.instancesDeferred=new Map,this.instancesOptions=new Map,this.onInitCallbacks=new Map}get(t){const e=this.normalizeInstanceIdentifier(t);if(!this.instancesDeferred.has(e)){const s=new TOt;if(this.instancesDeferred.set(e,s),this.isInitialized(e)||this.shouldAutoInitialize())try{const r=this.getOrInitializeService({instanceIdentifier:e});r&&s.resolve(r)}catch{}}return this.instancesDeferred.get(e).promise}getImmediate(t){const e=this.normalizeInstanceIdentifier(t?.identifier),s=t?.optional??!1;if(this.isInitialized(e)||this.shouldAutoInitialize())try{return this.getOrInitializeService({instanceIdentifier:e})}catch(r){if(s)return null;throw r}else{if(s)return null;throw Error(`Service ${this.name} is not available`)}}getComponent(){return this.component}setComponent(t){if(t.name!==this.name)throw Error(`Mismatching Component ${t.name} for Provider ${this.name}.`);if(this.component)throw Error(`Component for ${this.name} has already been provided`);if(this.component=t,!!this.shouldAutoInitialize()){if(UOt(t))try{this.getOrInitializeService({instanceIdentifier:yh})}catch{}for(const[e,s]of this.instancesDeferred.entries()){const r=this.normalizeInstanceIdentifier(e);try{const i=this.getOrInitializeService({instanceIdentifier:r});s.resolve(i)}catch{}}}}clearInstance(t=yh){this.instancesDeferred.delete(t),this.instancesOptions.delete(t),this.instances.delete(t)}async delete(){const t=Array.from(this.instances.values());await Promise.all([...t.filter(e=>"INTERNAL"in e).map(e=>e.INTERNAL.delete()),...t.filter(e=>"_delete"in e).map(e=>e._delete())])}isComponentSet(){return this.component!=null}isInitialized(t=yh){return this.instances.has(t)}getOptions(t=yh){return this.instancesOptions.get(t)||{}}initialize(t={}){const{options:e={}}=t,s=this.normalizeInstanceIdentifier(t.instanceIdentifier);if(this.isInitialized(s))throw Error(`${this.name}(${s}) has already been initialized`);if(!this.isComponentSet())throw Error(`Component ${this.name} has not been registered yet`);const r=this.getOrInitializeService({instanceIdentifier:s,options:e});for(const[i,o]of this.instancesDeferred.entries()){const a=this.normalizeInstanceIdentifier(i);s===a&&o.resolve(r)}return r}onInit(t,e){const s=this.normalizeInstanceIdentifier(e),r=this.onInitCallbacks.get(s)??new Set;r.add(t),this.onInitCallbacks.set(s,r);const i=this.instances.get(s);return i&&t(i,s),()=>{r.delete(t)}}invokeOnInitCallbacks(t,e){const s=this.onInitCallbacks.get(e);if(s)for(const r of s)try{r(t,e)}catch{}}getOrInitializeService({instanceIdentifier:t,options:e={}}){let s=this.instances.get(t);if(!s&&this.component&&(s=this.component.instanceFactory(this.container,{instanceIdentifier:VOt(t),options:e}),this.instances.set(t,s),this.instancesOptions.set(t,e),this.invokeOnInitCallbacks(s,t),this.component.onInstanceCreated))try{this.component.onInstanceCreated(this.container,t,s)}catch{}return s||null}normalizeInstanceIdentifier(t=yh){return this.component?this.component.multipleInstances?t:yh:t}shouldAutoInitialize(){return!!this.component&&this.component.instantiationMode!=="EXPLICIT"}}function VOt(n){return n===yh?void 0:n}function UOt(n){return n.instantiationMode==="EAGER"}class GOt{constructor(t){this.name=t,this.providers=new Map}addComponent(t){const e=this.getProvider(t.name);if(e.isComponentSet())throw new Error(`Component ${t.name} has already been registered with ${this.name}`);e.setComponent(t)}addOrOverwriteComponent(t){this.getProvider(t.name).isComponentSet()&&this.providers.delete(t.name),this.addComponent(t)}getProvider(t){if(this.providers.has(t))return this.providers.get(t);const e=new POt(t,this);return this.providers.set(t,e),e}getProviders(){return Array.from(this.providers.values())}}var an;(function(n){n[n.DEBUG=0]="DEBUG",n[n.VERBOSE=1]="VERBOSE",n[n.INFO=2]="INFO",n[n.WARN=3]="WARN",n[n.ERROR=4]="ERROR",n[n.SILENT=5]="SILENT"})(an||(an={}));const WOt={debug:an.DEBUG,verbose:an.VERBOSE,info:an.INFO,warn:an.WARN,error:an.ERROR,silent:an.SILENT},jOt=an.INFO,qOt={[an.DEBUG]:"log",[an.VERBOSE]:"log",[an.INFO]:"info",[an.WARN]:"warn",[an.ERROR]:"error"},HOt=(n,t,...e)=>{if(t<n.logLevel)return;const s=new Date().toISOString(),r=qOt[t];if(r)console[r](`[${s}]  ${n.name}:`,...e);else throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`)};class iN{constructor(t){this.name=t,this._logLevel=jOt,this._logHandler=HOt,this._userLogHandler=null}get logLevel(){return this._logLevel}set logLevel(t){if(!(t in an))throw new TypeError(`Invalid value "${t}" assigned to \`logLevel\``);this._logLevel=t}setLogLevel(t){this._logLevel=typeof t=="string"?WOt[t]:t}get logHandler(){return this._logHandler}set logHandler(t){if(typeof t!="function")throw new TypeError("Value assigned to `logHandler` must be a function");this._logHandler=t}get userLogHandler(){return this._userLogHandler}set userLogHandler(t){this._userLogHandler=t}debug(...t){this._userLogHandler&&this._userLogHandler(this,an.DEBUG,...t),this._logHandler(this,an.DEBUG,...t)}log(...t){this._userLogHandler&&this._userLogHandler(this,an.VERBOSE,...t),this._logHandler(this,an.VERBOSE,...t)}info(...t){this._userLogHandler&&this._userLogHandler(this,an.INFO,...t),this._logHandler(this,an.INFO,...t)}warn(...t){this._userLogHandler&&this._userLogHandler(this,an.WARN,...t),this._logHandler(this,an.WARN,...t)}error(...t){this._userLogHandler&&this._userLogHandler(this,an.ERROR,...t),this._logHandler(this,an.ERROR,...t)}}const KOt=(n,t)=>t.some(e=>n instanceof e);let vz,Sz;function XOt(){return vz||(vz=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function YOt(){return Sz||(Sz=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const A8=new WeakMap,U$=new WeakMap,k8=new WeakMap,yE=new WeakMap,oN=new WeakMap;function QOt(n){const t=new Promise((e,s)=>{const r=()=>{n.removeEventListener("success",i),n.removeEventListener("error",o)},i=()=>{e(rc(n.result)),r()},o=()=>{s(n.error),r()};n.addEventListener("success",i),n.addEventListener("error",o)});return t.then(e=>{e instanceof IDBCursor&&A8.set(e,n)}).catch(()=>{}),oN.set(t,n),t}function ZOt(n){if(U$.has(n))return;const t=new Promise((e,s)=>{const r=()=>{n.removeEventListener("complete",i),n.removeEventListener("error",o),n.removeEventListener("abort",o)},i=()=>{e(),r()},o=()=>{s(n.error||new DOMException("AbortError","AbortError")),r()};n.addEventListener("complete",i),n.addEventListener("error",o),n.addEventListener("abort",o)});U$.set(n,t)}let G$={get(n,t,e){if(n instanceof IDBTransaction){if(t==="done")return U$.get(n);if(t==="objectStoreNames")return n.objectStoreNames||k8.get(n);if(t==="store")return e.objectStoreNames[1]?void 0:e.objectStore(e.objectStoreNames[0])}return rc(n[t])},set(n,t,e){return n[t]=e,!0},has(n,t){return n instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in n}};function JOt(n){G$=n(G$)}function tFt(n){return n===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(t,...e){const s=n.call(bE(this),t,...e);return k8.set(s,t.sort?t.sort():[t]),rc(s)}:YOt().includes(n)?function(...t){return n.apply(bE(this),t),rc(A8.get(this))}:function(...t){return rc(n.apply(bE(this),t))}}function eFt(n){return typeof n=="function"?tFt(n):(n instanceof IDBTransaction&&ZOt(n),KOt(n,XOt())?new Proxy(n,G$):n)}function rc(n){if(n instanceof IDBRequest)return QOt(n);if(yE.has(n))return yE.get(n);const t=eFt(n);return t!==n&&(yE.set(n,t),oN.set(t,n)),t}const bE=n=>oN.get(n);function _8(n,t,{blocked:e,upgrade:s,blocking:r,terminated:i}={}){const o=indexedDB.open(n,t),a=rc(o);return s&&o.addEventListener("upgradeneeded",l=>{s(rc(o.result),l.oldVersion,l.newVersion,rc(o.transaction),l)}),e&&o.addEventListener("blocked",l=>e(l.oldVersion,l.newVersion,l)),a.then(l=>{i&&l.addEventListener("close",()=>i()),r&&l.addEventListener("versionchange",c=>r(c.oldVersion,c.newVersion,c))}).catch(()=>{}),a}const nFt=["get","getKey","getAll","getAllKeys","count"],sFt=["put","add","delete","clear"],xE=new Map;function Iz(n,t){if(!(n instanceof IDBDatabase&&!(t in n)&&typeof t=="string"))return;if(xE.get(t))return xE.get(t);const e=t.replace(/FromIndex$/,""),s=t!==e,r=sFt.includes(e);if(!(e in(s?IDBIndex:IDBObjectStore).prototype)||!(r||nFt.includes(e)))return;const i=async function(o,...a){const l=this.transaction(o,r?"readwrite":"readonly");let c=l.store;return s&&(c=c.index(a.shift())),(await Promise.all([c[e](...a),r&&l.done]))[0]};return xE.set(t,i),i}JOt(n=>({...n,get:(t,e,s)=>Iz(t,e)||n.get(t,e,s),has:(t,e)=>!!Iz(t,e)||n.has(t,e)}));class rFt{constructor(t){this.container=t}getPlatformInfoString(){return this.container.getProviders().map(e=>{if(iFt(e)){const s=e.getImmediate();return`${s.library}/${s.version}`}else return null}).filter(e=>e).join(" ")}}function iFt(n){return n.getComponent()?.type==="VERSION"}const W$="@firebase/app",Tz="0.14.6";const tu=new iN("@firebase/app"),oFt="@firebase/app-compat",aFt="@firebase/analytics-compat",lFt="@firebase/analytics",uFt="@firebase/app-check-compat",cFt="@firebase/app-check",hFt="@firebase/auth",fFt="@firebase/auth-compat",dFt="@firebase/database",pFt="@firebase/data-connect",mFt="@firebase/database-compat",gFt="@firebase/functions",yFt="@firebase/functions-compat",bFt="@firebase/installations",xFt="@firebase/installations-compat",wFt="@firebase/messaging",vFt="@firebase/messaging-compat",SFt="@firebase/performance",IFt="@firebase/performance-compat",TFt="@firebase/remote-config",CFt="@firebase/remote-config-compat",EFt="@firebase/storage",$Ft="@firebase/storage-compat",AFt="@firebase/firestore",kFt="@firebase/ai",_Ft="@firebase/firestore-compat",NFt="firebase",RFt="12.6.0";const j$="[DEFAULT]",DFt={[W$]:"fire-core",[oFt]:"fire-core-compat",[lFt]:"fire-analytics",[aFt]:"fire-analytics-compat",[cFt]:"fire-app-check",[uFt]:"fire-app-check-compat",[hFt]:"fire-auth",[fFt]:"fire-auth-compat",[dFt]:"fire-rtdb",[pFt]:"fire-data-connect",[mFt]:"fire-rtdb-compat",[gFt]:"fire-fn",[yFt]:"fire-fn-compat",[bFt]:"fire-iid",[xFt]:"fire-iid-compat",[wFt]:"fire-fcm",[vFt]:"fire-fcm-compat",[SFt]:"fire-perf",[IFt]:"fire-perf-compat",[TFt]:"fire-rc",[CFt]:"fire-rc-compat",[EFt]:"fire-gcs",[$Ft]:"fire-gcs-compat",[AFt]:"fire-fst",[_Ft]:"fire-fst-compat",[kFt]:"fire-vertex","fire-js":"fire-js",[NFt]:"fire-js-all"};const Yx=new Map,OFt=new Map,q$=new Map;function Cz(n,t){try{n.container.addComponent(t)}catch(e){tu.debug(`Component ${t.name} failed to register with FirebaseApp ${n.name}`,e)}}function eu(n){const t=n.name;if(q$.has(t))return tu.debug(`There were multiple attempts to register component ${t}.`),!1;q$.set(t,n);for(const e of Yx.values())Cz(e,n);for(const e of OFt.values())Cz(e,n);return!0}function Up(n,t){const e=n.container.getProvider("heartbeat").getImmediate({optional:!0});return e&&e.triggerHeartbeat(),n.container.getProvider(t)}function N8(n){return n==null?!1:n.settings!==void 0}const FFt={"no-app":"No Firebase App '{$appName}' has been created - call initializeApp() first","bad-app-name":"Illegal App name: '{$appName}'","duplicate-app":"Firebase App named '{$appName}' already exists with different options or config","app-deleted":"Firebase App named '{$appName}' already deleted","server-app-deleted":"Firebase Server App has been deleted","no-options":"Need to provide options, when not being deployed to hosting via source.","invalid-app-argument":"firebase.{$appName}() takes either no argument or a Firebase App instance.","invalid-log-argument":"First argument to `onLog` must be null or a function.","idb-open":"Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.","idb-get":"Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.","idb-set":"Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.","idb-delete":"Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.","finalization-registry-not-supported":"FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.","invalid-server-app-environment":"FirebaseServerApp is not for use in browser environments."},ic=new uS("app","Firebase",FFt);class MFt{constructor(t,e,s){this._isDeleted=!1,this._options={...t},this._config={...e},this._name=e.name,this._automaticDataCollectionEnabled=e.automaticDataCollectionEnabled,this._container=s,this.container.addComponent(new yl("app",()=>this,"PUBLIC"))}get automaticDataCollectionEnabled(){return this.checkDestroyed(),this._automaticDataCollectionEnabled}set automaticDataCollectionEnabled(t){this.checkDestroyed(),this._automaticDataCollectionEnabled=t}get name(){return this.checkDestroyed(),this._name}get options(){return this.checkDestroyed(),this._options}get config(){return this.checkDestroyed(),this._config}get container(){return this._container}get isDeleted(){return this._isDeleted}set isDeleted(t){this._isDeleted=t}checkDestroyed(){if(this.isDeleted)throw ic.create("app-deleted",{appName:this._name})}}const LFt=RFt;function R8(n,t={}){let e=n;typeof t!="object"&&(t={name:t});const s={name:j$,automaticDataCollectionEnabled:!0,...t},r=s.name;if(typeof r!="string"||!r)throw ic.create("bad-app-name",{appName:String(r)});if(e||(e=I8()),!e)throw ic.create("no-options");const i=Yx.get(r);if(i){if(Wg(e,i.options)&&Wg(s,i.config))return i;throw ic.create("duplicate-app",{appName:r})}const o=new GOt(r);for(const l of q$.values())o.addComponent(l);const a=new MFt(e,s,o);return Yx.set(r,a),a}function aN(n=j$){const t=Yx.get(n);if(!t&&n===j$&&I8())return R8();if(!t)throw ic.create("no-app",{appName:n});return t}function vo(n,t,e){let s=DFt[n]??n;e&&(s+=`-${e}`);const r=s.match(/\s|\//),i=t.match(/\s|\//);if(r||i){const o=[`Unable to register library "${s}" with version "${t}":`];r&&o.push(`library name "${s}" contains illegal characters (whitespace or "/")`),r&&i&&o.push("and"),i&&o.push(`version name "${t}" contains illegal characters (whitespace or "/")`),tu.warn(o.join(" "));return}eu(new yl(`${s}-version`,()=>({library:s,version:t}),"VERSION"))}const zFt="firebase-heartbeat-database",BFt=1,jg="firebase-heartbeat-store";let wE=null;function D8(){return wE||(wE=_8(zFt,BFt,{upgrade:(n,t)=>{switch(t){case 0:try{n.createObjectStore(jg)}catch(e){console.warn(e)}}}}).catch(n=>{throw ic.create("idb-open",{originalErrorMessage:n.message})})),wE}async function PFt(n){try{const e=(await D8()).transaction(jg),s=await e.objectStore(jg).get(O8(n));return await e.done,s}catch(t){if(t instanceof cu)tu.warn(t.message);else{const e=ic.create("idb-get",{originalErrorMessage:t?.message});tu.warn(e.message)}}}async function Ez(n,t){try{const s=(await D8()).transaction(jg,"readwrite");await s.objectStore(jg).put(t,O8(n)),await s.done}catch(e){if(e instanceof cu)tu.warn(e.message);else{const s=ic.create("idb-set",{originalErrorMessage:e?.message});tu.warn(s.message)}}}function O8(n){return`${n.name}!${n.options.appId}`}const VFt=1024,UFt=30;class GFt{constructor(t){this.container=t,this._heartbeatsCache=null;const e=this.container.getProvider("app").getImmediate();this._storage=new jFt(e),this._heartbeatsCachePromise=this._storage.read().then(s=>(this._heartbeatsCache=s,s))}async triggerHeartbeat(){try{const e=this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(),s=$z();if(this._heartbeatsCache?.heartbeats==null&&(this._heartbeatsCache=await this._heartbeatsCachePromise,this._heartbeatsCache?.heartbeats==null)||this._heartbeatsCache.lastSentHeartbeatDate===s||this._heartbeatsCache.heartbeats.some(r=>r.date===s))return;if(this._heartbeatsCache.heartbeats.push({date:s,agent:e}),this._heartbeatsCache.heartbeats.length>UFt){const r=qFt(this._heartbeatsCache.heartbeats);this._heartbeatsCache.heartbeats.splice(r,1)}return this._storage.overwrite(this._heartbeatsCache)}catch(t){tu.warn(t)}}async getHeartbeatsHeader(){try{if(this._heartbeatsCache===null&&await this._heartbeatsCachePromise,this._heartbeatsCache?.heartbeats==null||this._heartbeatsCache.heartbeats.length===0)return"";const t=$z(),{heartbeatsToSend:e,unsentEntries:s}=WFt(this._heartbeatsCache.heartbeats),r=Xx(JSON.stringify({version:2,heartbeats:e}));return this._heartbeatsCache.lastSentHeartbeatDate=t,s.length>0?(this._heartbeatsCache.heartbeats=s,await this._storage.overwrite(this._heartbeatsCache)):(this._heartbeatsCache.heartbeats=[],this._storage.overwrite(this._heartbeatsCache)),r}catch(t){return tu.warn(t),""}}}function $z(){return new Date().toISOString().substring(0,10)}function WFt(n,t=VFt){const e=[];let s=n.slice();for(const r of n){const i=e.find(o=>o.agent===r.agent);if(i){if(i.dates.push(r.date),Az(e)>t){i.dates.pop();break}}else if(e.push({agent:r.agent,dates:[r.date]}),Az(e)>t){e.pop();break}s=s.slice(1)}return{heartbeatsToSend:e,unsentEntries:s}}class jFt{constructor(t){this.app=t,this._canUseIndexedDBPromise=this.runIndexedDBEnvironmentCheck()}async runIndexedDBEnvironmentCheck(){return E8()?$8().then(()=>!0).catch(()=>!1):!1}async read(){if(await this._canUseIndexedDBPromise){const e=await PFt(this.app);return e?.heartbeats?e:{heartbeats:[]}}else return{heartbeats:[]}}async overwrite(t){if(await this._canUseIndexedDBPromise){const s=await this.read();return Ez(this.app,{lastSentHeartbeatDate:t.lastSentHeartbeatDate??s.lastSentHeartbeatDate,heartbeats:t.heartbeats})}else return}async add(t){if(await this._canUseIndexedDBPromise){const s=await this.read();return Ez(this.app,{lastSentHeartbeatDate:t.lastSentHeartbeatDate??s.lastSentHeartbeatDate,heartbeats:[...s.heartbeats,...t.heartbeats]})}else return}}function Az(n){return Xx(JSON.stringify({version:2,heartbeats:n})).length}function qFt(n){if(n.length===0)return-1;let t=0,e=n[0].date;for(let s=1;s<n.length;s++)n[s].date<e&&(e=n[s].date,t=s);return t}function HFt(n){eu(new yl("platform-logger",t=>new rFt(t),"PRIVATE")),eu(new yl("heartbeat",t=>new GFt(t),"PRIVATE")),vo(W$,Tz,n),vo(W$,Tz,"esm2020"),vo("fire-js","")}HFt("");var KFt="firebase",XFt="12.7.0";vo(KFt,XFt,"app");var kz=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof oa<"u"?oa:typeof self<"u"?self:{};var oc,F8;(function(){var n;function t(N,k){function _(){}_.prototype=k.prototype,N.F=k.prototype,N.prototype=new _,N.prototype.constructor=N,N.D=function(F,A,P){for(var L=Array(arguments.length-2),tt=2;tt<arguments.length;tt++)L[tt-2]=arguments[tt];return k.prototype[A].apply(F,L)}}function e(){this.blockSize=-1}function s(){this.blockSize=-1,this.blockSize=64,this.g=Array(4),this.C=Array(this.blockSize),this.o=this.h=0,this.u()}t(s,e),s.prototype.u=function(){this.g[0]=1732584193,this.g[1]=4023233417,this.g[2]=2562383102,this.g[3]=271733878,this.o=this.h=0};function r(N,k,_){_||(_=0);const F=Array(16);if(typeof k=="string")for(var A=0;A<16;++A)F[A]=k.charCodeAt(_++)|k.charCodeAt(_++)<<8|k.charCodeAt(_++)<<16|k.charCodeAt(_++)<<24;else for(A=0;A<16;++A)F[A]=k[_++]|k[_++]<<8|k[_++]<<16|k[_++]<<24;k=N.g[0],_=N.g[1],A=N.g[2];let P=N.g[3],L;L=k+(P^_&(A^P))+F[0]+3614090360&4294967295,k=_+(L<<7&4294967295|L>>>25),L=P+(A^k&(_^A))+F[1]+3905402710&4294967295,P=k+(L<<12&4294967295|L>>>20),L=A+(_^P&(k^_))+F[2]+606105819&4294967295,A=P+(L<<17&4294967295|L>>>15),L=_+(k^A&(P^k))+F[3]+3250441966&4294967295,_=A+(L<<22&4294967295|L>>>10),L=k+(P^_&(A^P))+F[4]+4118548399&4294967295,k=_+(L<<7&4294967295|L>>>25),L=P+(A^k&(_^A))+F[5]+1200080426&4294967295,P=k+(L<<12&4294967295|L>>>20),L=A+(_^P&(k^_))+F[6]+2821735955&4294967295,A=P+(L<<17&4294967295|L>>>15),L=_+(k^A&(P^k))+F[7]+4249261313&4294967295,_=A+(L<<22&4294967295|L>>>10),L=k+(P^_&(A^P))+F[8]+1770035416&4294967295,k=_+(L<<7&4294967295|L>>>25),L=P+(A^k&(_^A))+F[9]+2336552879&4294967295,P=k+(L<<12&4294967295|L>>>20),L=A+(_^P&(k^_))+F[10]+4294925233&4294967295,A=P+(L<<17&4294967295|L>>>15),L=_+(k^A&(P^k))+F[11]+2304563134&4294967295,_=A+(L<<22&4294967295|L>>>10),L=k+(P^_&(A^P))+F[12]+1804603682&4294967295,k=_+(L<<7&4294967295|L>>>25),L=P+(A^k&(_^A))+F[13]+4254626195&4294967295,P=k+(L<<12&4294967295|L>>>20),L=A+(_^P&(k^_))+F[14]+2792965006&4294967295,A=P+(L<<17&4294967295|L>>>15),L=_+(k^A&(P^k))+F[15]+1236535329&4294967295,_=A+(L<<22&4294967295|L>>>10),L=k+(A^P&(_^A))+F[1]+4129170786&4294967295,k=_+(L<<5&4294967295|L>>>27),L=P+(_^A&(k^_))+F[6]+3225465664&4294967295,P=k+(L<<9&4294967295|L>>>23),L=A+(k^_&(P^k))+F[11]+643717713&4294967295,A=P+(L<<14&4294967295|L>>>18),L=_+(P^k&(A^P))+F[0]+3921069994&4294967295,_=A+(L<<20&4294967295|L>>>12),L=k+(A^P&(_^A))+F[5]+3593408605&4294967295,k=_+(L<<5&4294967295|L>>>27),L=P+(_^A&(k^_))+F[10]+38016083&4294967295,P=k+(L<<9&4294967295|L>>>23),L=A+(k^_&(P^k))+F[15]+3634488961&4294967295,A=P+(L<<14&4294967295|L>>>18),L=_+(P^k&(A^P))+F[4]+3889429448&4294967295,_=A+(L<<20&4294967295|L>>>12),L=k+(A^P&(_^A))+F[9]+568446438&4294967295,k=_+(L<<5&4294967295|L>>>27),L=P+(_^A&(k^_))+F[14]+3275163606&4294967295,P=k+(L<<9&4294967295|L>>>23),L=A+(k^_&(P^k))+F[3]+4107603335&4294967295,A=P+(L<<14&4294967295|L>>>18),L=_+(P^k&(A^P))+F[8]+1163531501&4294967295,_=A+(L<<20&4294967295|L>>>12),L=k+(A^P&(_^A))+F[13]+2850285829&4294967295,k=_+(L<<5&4294967295|L>>>27),L=P+(_^A&(k^_))+F[2]+4243563512&4294967295,P=k+(L<<9&4294967295|L>>>23),L=A+(k^_&(P^k))+F[7]+1735328473&4294967295,A=P+(L<<14&4294967295|L>>>18),L=_+(P^k&(A^P))+F[12]+2368359562&4294967295,_=A+(L<<20&4294967295|L>>>12),L=k+(_^A^P)+F[5]+4294588738&4294967295,k=_+(L<<4&4294967295|L>>>28),L=P+(k^_^A)+F[8]+2272392833&4294967295,P=k+(L<<11&4294967295|L>>>21),L=A+(P^k^_)+F[11]+1839030562&4294967295,A=P+(L<<16&4294967295|L>>>16),L=_+(A^P^k)+F[14]+4259657740&4294967295,_=A+(L<<23&4294967295|L>>>9),L=k+(_^A^P)+F[1]+2763975236&4294967295,k=_+(L<<4&4294967295|L>>>28),L=P+(k^_^A)+F[4]+1272893353&4294967295,P=k+(L<<11&4294967295|L>>>21),L=A+(P^k^_)+F[7]+4139469664&4294967295,A=P+(L<<16&4294967295|L>>>16),L=_+(A^P^k)+F[10]+3200236656&4294967295,_=A+(L<<23&4294967295|L>>>9),L=k+(_^A^P)+F[13]+681279174&4294967295,k=_+(L<<4&4294967295|L>>>28),L=P+(k^_^A)+F[0]+3936430074&4294967295,P=k+(L<<11&4294967295|L>>>21),L=A+(P^k^_)+F[3]+3572445317&4294967295,A=P+(L<<16&4294967295|L>>>16),L=_+(A^P^k)+F[6]+76029189&4294967295,_=A+(L<<23&4294967295|L>>>9),L=k+(_^A^P)+F[9]+3654602809&4294967295,k=_+(L<<4&4294967295|L>>>28),L=P+(k^_^A)+F[12]+3873151461&4294967295,P=k+(L<<11&4294967295|L>>>21),L=A+(P^k^_)+F[15]+530742520&4294967295,A=P+(L<<16&4294967295|L>>>16),L=_+(A^P^k)+F[2]+3299628645&4294967295,_=A+(L<<23&4294967295|L>>>9),L=k+(A^(_|~P))+F[0]+4096336452&4294967295,k=_+(L<<6&4294967295|L>>>26),L=P+(_^(k|~A))+F[7]+1126891415&4294967295,P=k+(L<<10&4294967295|L>>>22),L=A+(k^(P|~_))+F[14]+2878612391&4294967295,A=P+(L<<15&4294967295|L>>>17),L=_+(P^(A|~k))+F[5]+4237533241&4294967295,_=A+(L<<21&4294967295|L>>>11),L=k+(A^(_|~P))+F[12]+1700485571&4294967295,k=_+(L<<6&4294967295|L>>>26),L=P+(_^(k|~A))+F[3]+2399980690&4294967295,P=k+(L<<10&4294967295|L>>>22),L=A+(k^(P|~_))+F[10]+4293915773&4294967295,A=P+(L<<15&4294967295|L>>>17),L=_+(P^(A|~k))+F[1]+2240044497&4294967295,_=A+(L<<21&4294967295|L>>>11),L=k+(A^(_|~P))+F[8]+1873313359&4294967295,k=_+(L<<6&4294967295|L>>>26),L=P+(_^(k|~A))+F[15]+4264355552&4294967295,P=k+(L<<10&4294967295|L>>>22),L=A+(k^(P|~_))+F[6]+2734768916&4294967295,A=P+(L<<15&4294967295|L>>>17),L=_+(P^(A|~k))+F[13]+1309151649&4294967295,_=A+(L<<21&4294967295|L>>>11),L=k+(A^(_|~P))+F[4]+4149444226&4294967295,k=_+(L<<6&4294967295|L>>>26),L=P+(_^(k|~A))+F[11]+3174756917&4294967295,P=k+(L<<10&4294967295|L>>>22),L=A+(k^(P|~_))+F[2]+718787259&4294967295,A=P+(L<<15&4294967295|L>>>17),L=_+(P^(A|~k))+F[9]+3951481745&4294967295,N.g[0]=N.g[0]+k&4294967295,N.g[1]=N.g[1]+(A+(L<<21&4294967295|L>>>11))&4294967295,N.g[2]=N.g[2]+A&4294967295,N.g[3]=N.g[3]+P&4294967295}s.prototype.v=function(N,k){k===void 0&&(k=N.length);const _=k-this.blockSize,F=this.C;let A=this.h,P=0;for(;P<k;){if(A==0)for(;P<=_;)r(this,N,P),P+=this.blockSize;if(typeof N=="string"){for(;P<k;)if(F[A++]=N.charCodeAt(P++),A==this.blockSize){r(this,F),A=0;break}}else for(;P<k;)if(F[A++]=N[P++],A==this.blockSize){r(this,F),A=0;break}}this.h=A,this.o+=k},s.prototype.A=function(){var N=Array((this.h<56?this.blockSize:this.blockSize*2)-this.h);N[0]=128;for(var k=1;k<N.length-8;++k)N[k]=0;k=this.o*8;for(var _=N.length-8;_<N.length;++_)N[_]=k&255,k/=256;for(this.v(N),N=Array(16),k=0,_=0;_<4;++_)for(let F=0;F<32;F+=8)N[k++]=this.g[_]>>>F&255;return N};function i(N,k){var _=a;return Object.prototype.hasOwnProperty.call(_,N)?_[N]:_[N]=k(N)}function o(N,k){this.h=k;const _=[];let F=!0;for(let A=N.length-1;A>=0;A--){const P=N[A]|0;F&&P==k||(_[A]=P,F=!1)}this.g=_}var a={};function l(N){return-128<=N&&N<128?i(N,function(k){return new o([k|0],k<0?-1:0)}):new o([N|0],N<0?-1:0)}function c(N){if(isNaN(N)||!isFinite(N))return d;if(N<0)return x(c(-N));const k=[];let _=1;for(let F=0;N>=_;F++)k[F]=N/_|0,_*=4294967296;return new o(k,0)}function f(N,k){if(N.length==0)throw Error("number format error: empty string");if(k=k||10,k<2||36<k)throw Error("radix out of range: "+k);if(N.charAt(0)=="-")return x(f(N.substring(1),k));if(N.indexOf("-")>=0)throw Error('number format error: interior "-" character');const _=c(Math.pow(k,8));let F=d;for(let P=0;P<N.length;P+=8){var A=Math.min(8,N.length-P);const L=parseInt(N.substring(P,P+A),k);A<8?(A=c(Math.pow(k,A)),F=F.j(A).add(c(L))):(F=F.j(_),F=F.add(c(L)))}return F}var d=l(0),m=l(1),y=l(16777216);n=o.prototype,n.m=function(){if(w(this))return-x(this).m();let N=0,k=1;for(let _=0;_<this.g.length;_++){const F=this.i(_);N+=(F>=0?F:4294967296+F)*k,k*=4294967296}return N},n.toString=function(N){if(N=N||10,N<2||36<N)throw Error("radix out of range: "+N);if(b(this))return"0";if(w(this))return"-"+x(this).toString(N);const k=c(Math.pow(N,6));var _=this;let F="";for(;;){const A=E(_,k).g;_=S(_,A.j(k));let P=((_.g.length>0?_.g[0]:_.h)>>>0).toString(N);if(_=A,b(_))return P+F;for(;P.length<6;)P="0"+P;F=P+F}},n.i=function(N){return N<0?0:N<this.g.length?this.g[N]:this.h};function b(N){if(N.h!=0)return!1;for(let k=0;k<N.g.length;k++)if(N.g[k]!=0)return!1;return!0}function w(N){return N.h==-1}n.l=function(N){return N=S(this,N),w(N)?-1:b(N)?0:1};function x(N){const k=N.g.length,_=[];for(let F=0;F<k;F++)_[F]=~N.g[F];return new o(_,~N.h).add(m)}n.abs=function(){return w(this)?x(this):this},n.add=function(N){const k=Math.max(this.g.length,N.g.length),_=[];let F=0;for(let A=0;A<=k;A++){let P=F+(this.i(A)&65535)+(N.i(A)&65535),L=(P>>>16)+(this.i(A)>>>16)+(N.i(A)>>>16);F=L>>>16,P&=65535,L&=65535,_[A]=L<<16|P}return new o(_,_[_.length-1]&-2147483648?-1:0)};function S(N,k){return N.add(x(k))}n.j=function(N){if(b(this)||b(N))return d;if(w(this))return w(N)?x(this).j(x(N)):x(x(this).j(N));if(w(N))return x(this.j(x(N)));if(this.l(y)<0&&N.l(y)<0)return c(this.m()*N.m());const k=this.g.length+N.g.length,_=[];for(var F=0;F<2*k;F++)_[F]=0;for(F=0;F<this.g.length;F++)for(let A=0;A<N.g.length;A++){const P=this.i(F)>>>16,L=this.i(F)&65535,tt=N.i(A)>>>16,st=N.i(A)&65535;_[2*F+2*A]+=L*st,T(_,2*F+2*A),_[2*F+2*A+1]+=P*st,T(_,2*F+2*A+1),_[2*F+2*A+1]+=L*tt,T(_,2*F+2*A+1),_[2*F+2*A+2]+=P*tt,T(_,2*F+2*A+2)}for(N=0;N<k;N++)_[N]=_[2*N+1]<<16|_[2*N];for(N=k;N<2*k;N++)_[N]=0;return new o(_,0)};function T(N,k){for(;(N[k]&65535)!=N[k];)N[k+1]+=N[k]>>>16,N[k]&=65535,k++}function $(N,k){this.g=N,this.h=k}function E(N,k){if(b(k))throw Error("division by zero");if(b(N))return new $(d,d);if(w(N))return k=E(x(N),k),new $(x(k.g),x(k.h));if(w(k))return k=E(N,x(k)),new $(x(k.g),k.h);if(N.g.length>30){if(w(N)||w(k))throw Error("slowDivide_ only works with positive integers.");for(var _=m,F=k;F.l(N)<=0;)_=R(_),F=R(F);var A=B(_,1),P=B(F,1);for(F=B(F,2),_=B(_,2);!b(F);){var L=P.add(F);L.l(N)<=0&&(A=A.add(_),P=L),F=B(F,1),_=B(_,1)}return k=S(N,A.j(k)),new $(A,k)}for(A=d;N.l(k)>=0;){for(_=Math.max(1,Math.floor(N.m()/k.m())),F=Math.ceil(Math.log(_)/Math.LN2),F=F<=48?1:Math.pow(2,F-48),P=c(_),L=P.j(k);w(L)||L.l(N)>0;)_-=F,P=c(_),L=P.j(k);b(P)&&(P=m),A=A.add(P),N=S(N,L)}return new $(A,N)}n.B=function(N){return E(this,N).h},n.and=function(N){const k=Math.max(this.g.length,N.g.length),_=[];for(let F=0;F<k;F++)_[F]=this.i(F)&N.i(F);return new o(_,this.h&N.h)},n.or=function(N){const k=Math.max(this.g.length,N.g.length),_=[];for(let F=0;F<k;F++)_[F]=this.i(F)|N.i(F);return new o(_,this.h|N.h)},n.xor=function(N){const k=Math.max(this.g.length,N.g.length),_=[];for(let F=0;F<k;F++)_[F]=this.i(F)^N.i(F);return new o(_,this.h^N.h)};function R(N){const k=N.g.length+1,_=[];for(let F=0;F<k;F++)_[F]=N.i(F)<<1|N.i(F-1)>>>31;return new o(_,N.h)}function B(N,k){const _=k>>5;k%=32;const F=N.g.length-_,A=[];for(let P=0;P<F;P++)A[P]=k>0?N.i(P+_)>>>k|N.i(P+_+1)<<32-k:N.i(P+_);return new o(A,N.h)}s.prototype.digest=s.prototype.A,s.prototype.reset=s.prototype.u,s.prototype.update=s.prototype.v,F8=s,o.prototype.add=o.prototype.add,o.prototype.multiply=o.prototype.j,o.prototype.modulo=o.prototype.B,o.prototype.compare=o.prototype.l,o.prototype.toNumber=o.prototype.m,o.prototype.toString=o.prototype.toString,o.prototype.getBits=o.prototype.i,o.fromNumber=c,o.fromString=f,oc=o}).apply(typeof kz<"u"?kz:typeof self<"u"?self:typeof window<"u"?window:{});var k1=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof oa<"u"?oa:typeof self<"u"?self:{};var M8,hg,L8,Y1,H$,z8,B8,P8;(function(){var n,t=Object.defineProperty;function e(v){v=[typeof globalThis=="object"&&globalThis,v,typeof window=="object"&&window,typeof self=="object"&&self,typeof k1=="object"&&k1];for(var D=0;D<v.length;++D){var V=v[D];if(V&&V.Math==Math)return V}throw Error("Cannot find global object")}var s=e(this);function r(v,D){if(D)t:{var V=s;v=v.split(".");for(var K=0;K<v.length-1;K++){var wt=v[K];if(!(wt in V))break t;V=V[wt]}v=v[v.length-1],K=V[v],D=D(K),D!=K&&D!=null&&t(V,v,{configurable:!0,writable:!0,value:D})}}r("Symbol.dispose",function(v){return v||Symbol("Symbol.dispose")}),r("Array.prototype.values",function(v){return v||function(){return this[Symbol.iterator]()}}),r("Object.entries",function(v){return v||function(D){var V=[],K;for(K in D)Object.prototype.hasOwnProperty.call(D,K)&&V.push([K,D[K]]);return V}});var i=i||{},o=this||self;function a(v){var D=typeof v;return D=="object"&&v!=null||D=="function"}function l(v,D,V){return v.call.apply(v.bind,arguments)}function c(v,D,V){return c=l,c.apply(null,arguments)}function f(v,D){var V=Array.prototype.slice.call(arguments,1);return function(){var K=V.slice();return K.push.apply(K,arguments),v.apply(this,K)}}function d(v,D){function V(){}V.prototype=D.prototype,v.Z=D.prototype,v.prototype=new V,v.prototype.constructor=v,v.Ob=function(K,wt,_t){for(var Zt=Array(arguments.length-2),Fe=2;Fe<arguments.length;Fe++)Zt[Fe-2]=arguments[Fe];return D.prototype[wt].apply(K,Zt)}}var m=typeof AsyncContext<"u"&&typeof AsyncContext.Snapshot=="function"?v=>v&&AsyncContext.Snapshot.wrap(v):v=>v;function y(v){const D=v.length;if(D>0){const V=Array(D);for(let K=0;K<D;K++)V[K]=v[K];return V}return[]}function b(v,D){for(let K=1;K<arguments.length;K++){const wt=arguments[K];var V=typeof wt;if(V=V!="object"?V:wt?Array.isArray(wt)?"array":V:"null",V=="array"||V=="object"&&typeof wt.length=="number"){V=v.length||0;const _t=wt.length||0;v.length=V+_t;for(let Zt=0;Zt<_t;Zt++)v[V+Zt]=wt[Zt]}else v.push(wt)}}class w{constructor(D,V){this.i=D,this.j=V,this.h=0,this.g=null}get(){let D;return this.h>0?(this.h--,D=this.g,this.g=D.next,D.next=null):D=this.i(),D}}function x(v){o.setTimeout(()=>{throw v},0)}function S(){var v=N;let D=null;return v.g&&(D=v.g,v.g=v.g.next,v.g||(v.h=null),D.next=null),D}class T{constructor(){this.h=this.g=null}add(D,V){const K=$.get();K.set(D,V),this.h?this.h.next=K:this.g=K,this.h=K}}var $=new w(()=>new E,v=>v.reset());class E{constructor(){this.next=this.g=this.h=null}set(D,V){this.h=D,this.g=V,this.next=null}reset(){this.next=this.g=this.h=null}}let R,B=!1,N=new T,k=()=>{const v=Promise.resolve(void 0);R=()=>{v.then(_)}};function _(){for(var v;v=S();){try{v.h.call(v.g)}catch(V){x(V)}var D=$;D.j(v),D.h<100&&(D.h++,v.next=D.g,D.g=v)}B=!1}function F(){this.u=this.u,this.C=this.C}F.prototype.u=!1,F.prototype.dispose=function(){this.u||(this.u=!0,this.N())},F.prototype[Symbol.dispose]=function(){this.dispose()},F.prototype.N=function(){if(this.C)for(;this.C.length;)this.C.shift()()};function A(v,D){this.type=v,this.g=this.target=D,this.defaultPrevented=!1}A.prototype.h=function(){this.defaultPrevented=!0};var P=(function(){if(!o.addEventListener||!Object.defineProperty)return!1;var v=!1,D=Object.defineProperty({},"passive",{get:function(){v=!0}});try{const V=()=>{};o.addEventListener("test",V,D),o.removeEventListener("test",V,D)}catch{}return v})();function L(v){return/^[\s\xa0]*$/.test(v)}function tt(v,D){A.call(this,v?v.type:""),this.relatedTarget=this.g=this.target=null,this.button=this.screenY=this.screenX=this.clientY=this.clientX=0,this.key="",this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1,this.state=null,this.pointerId=0,this.pointerType="",this.i=null,v&&this.init(v,D)}d(tt,A),tt.prototype.init=function(v,D){const V=this.type=v.type,K=v.changedTouches&&v.changedTouches.length?v.changedTouches[0]:null;this.target=v.target||v.srcElement,this.g=D,D=v.relatedTarget,D||(V=="mouseover"?D=v.fromElement:V=="mouseout"&&(D=v.toElement)),this.relatedTarget=D,K?(this.clientX=K.clientX!==void 0?K.clientX:K.pageX,this.clientY=K.clientY!==void 0?K.clientY:K.pageY,this.screenX=K.screenX||0,this.screenY=K.screenY||0):(this.clientX=v.clientX!==void 0?v.clientX:v.pageX,this.clientY=v.clientY!==void 0?v.clientY:v.pageY,this.screenX=v.screenX||0,this.screenY=v.screenY||0),this.button=v.button,this.key=v.key||"",this.ctrlKey=v.ctrlKey,this.altKey=v.altKey,this.shiftKey=v.shiftKey,this.metaKey=v.metaKey,this.pointerId=v.pointerId||0,this.pointerType=v.pointerType,this.state=v.state,this.i=v,v.defaultPrevented&&tt.Z.h.call(this)},tt.prototype.h=function(){tt.Z.h.call(this);const v=this.i;v.preventDefault?v.preventDefault():v.returnValue=!1};var st="closure_listenable_"+(Math.random()*1e6|0),j=0;function Z(v,D,V,K,wt){this.listener=v,this.proxy=null,this.src=D,this.type=V,this.capture=!!K,this.ha=wt,this.key=++j,this.da=this.fa=!1}function J(v){v.da=!0,v.listener=null,v.proxy=null,v.src=null,v.ha=null}function ot(v,D,V){for(const K in v)D.call(V,v[K],K,v)}function pt(v,D){for(const V in v)D.call(void 0,v[V],V,v)}function q(v){const D={};for(const V in v)D[V]=v[V];return D}const et="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");function U(v,D){let V,K;for(let wt=1;wt<arguments.length;wt++){K=arguments[wt];for(V in K)v[V]=K[V];for(let _t=0;_t<et.length;_t++)V=et[_t],Object.prototype.hasOwnProperty.call(K,V)&&(v[V]=K[V])}}function X(v){this.src=v,this.g={},this.h=0}X.prototype.add=function(v,D,V,K,wt){const _t=v.toString();v=this.g[_t],v||(v=this.g[_t]=[],this.h++);const Zt=xt(v,D,K,wt);return Zt>-1?(D=v[Zt],V||(D.fa=!1)):(D=new Z(D,this.src,_t,!!K,wt),D.fa=V,v.push(D)),D};function nt(v,D){const V=D.type;if(V in v.g){var K=v.g[V],wt=Array.prototype.indexOf.call(K,D,void 0),_t;(_t=wt>=0)&&Array.prototype.splice.call(K,wt,1),_t&&(J(D),v.g[V].length==0&&(delete v.g[V],v.h--))}}function xt(v,D,V,K){for(let wt=0;wt<v.length;++wt){const _t=v[wt];if(!_t.da&&_t.listener==D&&_t.capture==!!V&&_t.ha==K)return wt}return-1}var Ot="closure_lm_"+(Math.random()*1e6|0),qt={};function zt(v,D,V,K,wt){if(Array.isArray(D)){for(let _t=0;_t<D.length;_t++)zt(v,D[_t],V,K,wt);return null}return V=Ge(V),v&&v[st]?v.J(D,V,a(K)?!!K.capture:!1,wt):Wt(v,D,V,!1,K,wt)}function Wt(v,D,V,K,wt,_t){if(!D)throw Error("Invalid event type");const Zt=a(wt)?!!wt.capture:!!wt;let Fe=ie(v);if(Fe||(v[Ot]=Fe=new X(v)),V=Fe.add(D,V,K,Zt,_t),V.proxy)return V;if(K=Xt(),V.proxy=K,K.src=v,K.listener=V,v.addEventListener)P||(wt=Zt),wt===void 0&&(wt=!1),v.addEventListener(D.toString(),K,wt);else if(v.attachEvent)v.attachEvent(fe(D.toString()),K);else if(v.addListener&&v.removeListener)v.addListener(K);else throw Error("addEventListener and attachEvent are unavailable.");return V}function Xt(){function v(V){return D.call(v.src,v.listener,V)}const D=pe;return v}function te(v,D,V,K,wt){if(Array.isArray(D))for(var _t=0;_t<D.length;_t++)te(v,D[_t],V,K,wt);else K=a(K)?!!K.capture:!!K,V=Ge(V),v&&v[st]?(v=v.i,_t=String(D).toString(),_t in v.g&&(D=v.g[_t],V=xt(D,V,K,wt),V>-1&&(J(D[V]),Array.prototype.splice.call(D,V,1),D.length==0&&(delete v.g[_t],v.h--)))):v&&(v=ie(v))&&(D=v.g[D.toString()],v=-1,D&&(v=xt(D,V,K,wt)),(V=v>-1?D[v]:null)&&oe(V))}function oe(v){if(typeof v!="number"&&v&&!v.da){var D=v.src;if(D&&D[st])nt(D.i,v);else{var V=v.type,K=v.proxy;D.removeEventListener?D.removeEventListener(V,K,v.capture):D.detachEvent?D.detachEvent(fe(V),K):D.addListener&&D.removeListener&&D.removeListener(K),(V=ie(D))?(nt(V,v),V.h==0&&(V.src=null,D[Ot]=null)):J(v)}}}function fe(v){return v in qt?qt[v]:qt[v]="on"+v}function pe(v,D){if(v.da)v=!0;else{D=new tt(D,this);const V=v.listener,K=v.ha||v.src;v.fa&&oe(v),v=V.call(K,D)}return v}function ie(v){return v=v[Ot],v instanceof X?v:null}var Ae="__closure_events_fn_"+(Math.random()*1e9>>>0);function Ge(v){return typeof v=="function"?v:(v[Ae]||(v[Ae]=function(D){return v.handleEvent(D)}),v[Ae])}function Nt(){F.call(this),this.i=new X(this),this.M=this,this.G=null}d(Nt,F),Nt.prototype[st]=!0,Nt.prototype.removeEventListener=function(v,D,V,K){te(this,v,D,V,K)};function Ie(v,D){var V,K=v.G;if(K)for(V=[];K;K=K.G)V.push(K);if(v=v.M,K=D.type||D,typeof D=="string")D=new A(D,v);else if(D instanceof A)D.target=D.target||v;else{var wt=D;D=new A(K,v),U(D,wt)}wt=!0;let _t,Zt;if(V)for(Zt=V.length-1;Zt>=0;Zt--)_t=D.g=V[Zt],wt=wn(_t,K,!0,D)&&wt;if(_t=D.g=v,wt=wn(_t,K,!0,D)&&wt,wt=wn(_t,K,!1,D)&&wt,V)for(Zt=0;Zt<V.length;Zt++)_t=D.g=V[Zt],wt=wn(_t,K,!1,D)&&wt}Nt.prototype.N=function(){if(Nt.Z.N.call(this),this.i){var v=this.i;for(const D in v.g){const V=v.g[D];for(let K=0;K<V.length;K++)J(V[K]);delete v.g[D],v.h--}}this.G=null},Nt.prototype.J=function(v,D,V,K){return this.i.add(String(v),D,!1,V,K)},Nt.prototype.K=function(v,D,V,K){return this.i.add(String(v),D,!0,V,K)};function wn(v,D,V,K){if(D=v.i.g[String(D)],!D)return!0;D=D.concat();let wt=!0;for(let _t=0;_t<D.length;++_t){const Zt=D[_t];if(Zt&&!Zt.da&&Zt.capture==V){const Fe=Zt.listener,Is=Zt.ha||Zt.src;Zt.fa&&nt(v.i,Zt),wt=Fe.call(Is,K)!==!1&&wt}}return wt&&!K.defaultPrevented}function rs(v,D){if(typeof v!="function")if(v&&typeof v.handleEvent=="function")v=c(v.handleEvent,v);else throw Error("Invalid listener argument");return Number(D)>2147483647?-1:o.setTimeout(v,D||0)}function Ns(v){v.g=rs(()=>{v.g=null,v.i&&(v.i=!1,Ns(v))},v.l);const D=v.h;v.h=null,v.m.apply(null,D)}class je extends F{constructor(D,V){super(),this.m=D,this.l=V,this.h=null,this.i=!1,this.g=null}j(D){this.h=arguments,this.g?this.i=!0:Ns(this)}N(){super.N(),this.g&&(o.clearTimeout(this.g),this.g=null,this.i=!1,this.h=null)}}function Nn(v){F.call(this),this.h=v,this.g={}}d(Nn,F);var cr=[];function zr(v){ot(v.g,function(D,V){this.g.hasOwnProperty(V)&&oe(D)},v),v.g={}}Nn.prototype.N=function(){Nn.Z.N.call(this),zr(this)},Nn.prototype.handleEvent=function(){throw Error("EventHandler.handleEvent not implemented")};var Wn=o.JSON.stringify,No=o.JSON.parse,G=class{stringify(v){return o.JSON.stringify(v,void 0)}parse(v){return o.JSON.parse(v,void 0)}};function O(){}function M(){}var Y={OPEN:"a",hb:"b",ERROR:"c",tb:"d"};function at(){A.call(this,"d")}d(at,A);function Ct(){A.call(this,"c")}d(Ct,A);var Mt={},Oe=null;function Cn(){return Oe=Oe||new Nt}Mt.Ia="serverreachability";function En(v){A.call(this,Mt.Ia,v)}d(En,A);function un(v){const D=Cn();Ie(D,new En(D))}Mt.STAT_EVENT="statevent";function Je(v,D){A.call(this,Mt.STAT_EVENT,v),this.stat=D}d(Je,A);function Rs(v){const D=Cn();Ie(D,new Je(D,v))}Mt.Ja="timingevent";function ba(v,D){A.call(this,Mt.Ja,v),this.size=D}d(ba,A);function xa(v,D){if(typeof v!="function")throw Error("Fn must not be null and must be a function");return o.setTimeout(function(){v()},D)}function Ro(){this.g=!0}Ro.prototype.ua=function(){this.g=!1};function OS(v,D,V,K,wt,_t){v.info(function(){if(v.g)if(_t){var Zt="",Fe=_t.split("&");for(let gn=0;gn<Fe.length;gn++){var Is=Fe[gn].split("=");if(Is.length>1){const is=Is[0];Is=Is[1];const to=is.split("_");Zt=to.length>=2&&to[1]=="type"?Zt+(is+"="+Is+"&"):Zt+(is+"=redacted&")}}}else Zt=null;else Zt=_t;return"XMLHTTP REQ ("+K+") [attempt "+wt+"]: "+D+`
`+V+`
`+Zt})}function Bb(v,D,V,K,wt,_t,Zt){v.info(function(){return"XMLHTTP RESP ("+K+") [ attempt "+wt+"]: "+D+`
`+V+`
`+_t+" "+Zt})}function wa(v,D,V,K){v.info(function(){return"XMLHTTP TEXT ("+D+"): "+FS(v,V)+(K?" "+K:"")})}function Bc(v,D){v.info(function(){return"TIMEOUT: "+D})}Ro.prototype.info=function(){};function FS(v,D){if(!v.g)return D;if(!D)return null;try{const _t=JSON.parse(D);if(_t){for(v=0;v<_t.length;v++)if(Array.isArray(_t[v])){var V=_t[v];if(!(V.length<2)){var K=V[1];if(Array.isArray(K)&&!(K.length<1)){var wt=K[0];if(wt!="noop"&&wt!="stop"&&wt!="close")for(let Zt=1;Zt<K.length;Zt++)K[Zt]=""}}}}return Wn(_t)}catch{return D}}var Pc={NO_ERROR:0,cb:1,qb:2,pb:3,kb:4,ob:5,rb:6,Ga:7,TIMEOUT:8,ub:9},Kp={ib:"complete",Fb:"success",ERROR:"error",Ga:"abort",xb:"ready",yb:"readystatechange",TIMEOUT:"timeout",sb:"incrementaldata",wb:"progress",lb:"downloadprogress",Nb:"uploadprogress"},Xp;function Vc(){}d(Vc,O),Vc.prototype.g=function(){return new XMLHttpRequest},Xp=new Vc;function vl(v){return encodeURIComponent(String(v))}function Pb(v){var D=1;v=v.split(":");const V=[];for(;D>0&&v.length;)V.push(v.shift()),D--;return v.length&&V.push(v.join(":")),V}function Do(v,D,V,K){this.j=v,this.i=D,this.l=V,this.S=K||1,this.V=new Nn(this),this.H=45e3,this.J=null,this.o=!1,this.u=this.B=this.A=this.M=this.F=this.T=this.D=null,this.G=[],this.g=null,this.C=0,this.m=this.v=null,this.X=-1,this.K=!1,this.P=0,this.O=null,this.W=this.L=this.U=this.R=!1,this.h=new Oo}function Oo(){this.i=null,this.g="",this.h=!1}var Ds={},hr={};function va(v,D,V){v.M=1,v.A=Uc(Fs(D)),v.u=V,v.R=!0,$f(v,null)}function $f(v,D){v.F=Date.now(),Sa(v),v.B=Fs(v.A);var V=v.B,K=v.S;Array.isArray(K)||(K=[String(K)]),Nf(V.i,"t",K),v.C=0,V=v.j.L,v.h=new Oo,v.g=e0(v.j,V?D:null,!v.u),v.P>0&&(v.O=new je(c(v.Y,v,v.g),v.P)),D=v.V,V=v.g,K=v.ba;var wt="readystatechange";Array.isArray(wt)||(wt&&(cr[0]=wt.toString()),wt=cr);for(let _t=0;_t<wt.length;_t++){const Zt=zt(V,wt[_t],K||D.handleEvent,!1,D.h||D);if(!Zt)break;D.g[Zt.key]=Zt}D=v.J?q(v.J):{},v.u?(v.v||(v.v="POST"),D["Content-Type"]="application/x-www-form-urlencoded",v.g.ea(v.B,v.v,v.u,D)):(v.v="GET",v.g.ea(v.B,v.v,null,D)),un(),OS(v.i,v.v,v.B,v.l,v.S,v.u)}Do.prototype.ba=function(v){v=v.target;const D=this.O;D&&Lo(v)==3?D.j():this.Y(v)},Do.prototype.Y=function(v){try{if(v==this.g)t:{const Fe=Lo(this.g),Is=this.g.ya(),gn=this.g.ca();if(!(Fe<3)&&(Fe!=3||this.g&&(this.h.h||this.g.la()||Tr(this.g)))){this.K||Fe!=4||Is==7||(Is==8||gn<=0?un(3):un(2)),Ia(this);var D=this.g.ca();this.X=D;var V=MS(this);if(this.o=D==200,Bb(this.i,this.v,this.B,this.l,this.S,Fe,D),this.o){if(this.U&&!this.L){e:{if(this.g){var K,wt=this.g;if((K=wt.g?wt.g.getResponseHeader("X-HTTP-Initial-Response"):null)&&!L(K)){var _t=K;break e}}_t=null}if(v=_t)wa(this.i,this.l,v,"Initial handshake response via X-HTTP-Initial-Response"),this.L=!0,Ta(this,v);else{this.o=!1,this.m=3,Rs(12),Ri(this),Qi(this);break t}}if(this.R){v=!0;let is;for(;!this.K&&this.C<V.length;)if(is=Ub(this,V),is==hr){Fe==4&&(this.m=4,Rs(14),v=!1),wa(this.i,this.l,null,"[Incomplete Response]");break}else if(is==Ds){this.m=4,Rs(15),wa(this.i,this.l,V,"[Invalid Chunk]"),v=!1;break}else wa(this.i,this.l,is,null),Ta(this,is);if(Vb(this)&&this.C!=0&&(this.h.g=this.h.g.slice(this.C),this.C=0),Fe!=4||V.length!=0||this.h.h||(this.m=1,Rs(16),v=!1),this.o=this.o&&v,!v)wa(this.i,this.l,V,"[Invalid Chunked Response]"),Ri(this),Qi(this);else if(V.length>0&&!this.W){this.W=!0;var Zt=this.j;Zt.g==this&&Zt.aa&&!Zt.P&&(Zt.j.info("Great, no buffering proxy detected. Bytes received: "+V.length),cm(Zt),Zt.P=!0,Rs(11))}}else wa(this.i,this.l,V,null),Ta(this,V);Fe==4&&Ri(this),this.o&&!this.K&&(Fe==4?Qb(this.j,this):(this.o=!1,Sa(this)))}else Il(this.g),D==400&&V.indexOf("Unknown SID")>0?(this.m=3,Rs(12)):(this.m=0,Rs(13)),Ri(this),Qi(this)}}}catch{}};function MS(v){if(!Vb(v))return v.g.la();const D=Tr(v.g);if(D==="")return"";let V="";const K=D.length,wt=Lo(v.g)==4;if(!v.h.i){if(typeof TextDecoder>"u")return Ri(v),Qi(v),"";v.h.i=new o.TextDecoder}for(let _t=0;_t<K;_t++)v.h.h=!0,V+=v.h.i.decode(D[_t],{stream:!(wt&&_t==K-1)});return D.length=0,v.h.g+=V,v.C=0,v.h.g}function Vb(v){return v.g?v.v=="GET"&&v.M!=2&&v.j.Aa:!1}function Ub(v,D){var V=v.C,K=D.indexOf(`
`,V);return K==-1?hr:(V=Number(D.substring(V,K)),isNaN(V)?Ds:(K+=1,K+V>D.length?hr:(D=D.slice(K,K+V),v.C=K+V,D)))}Do.prototype.cancel=function(){this.K=!0,Ri(this)};function Sa(v){v.T=Date.now()+v.H,Af(v,v.H)}function Af(v,D){if(v.D!=null)throw Error("WatchDog timer not null");v.D=xa(c(v.aa,v),D)}function Ia(v){v.D&&(o.clearTimeout(v.D),v.D=null)}Do.prototype.aa=function(){this.D=null;const v=Date.now();v-this.T>=0?(Bc(this.i,this.B),this.M!=2&&(un(),Rs(17)),Ri(this),this.m=2,Qi(this)):Af(this,this.T-v)};function Qi(v){v.j.I==0||v.K||Qb(v.j,v)}function Ri(v){Ia(v);var D=v.O;D&&typeof D.dispose=="function"&&D.dispose(),v.O=null,zr(v.V),v.g&&(D=v.g,v.g=null,D.abort(),D.dispose())}function Ta(v,D){try{var V=v.j;if(V.I!=0&&(V.g==v||Ea(V.h,v))){if(!v.L&&Ea(V.h,v)&&V.I==3){try{var K=V.Ba.g.parse(D)}catch{K=null}if(Array.isArray(K)&&K.length==3){var wt=K;if(wt[0]==0){t:if(!V.v){if(V.g)if(V.g.F+3e3<v.F)Mf(V),xu(V);else break t;Xc(V),Rs(18)}}else V.xa=wt[1],0<V.xa-V.K&&wt[2]<37500&&V.F&&V.A==0&&!V.C&&(V.C=xa(c(V.Va,V),6e3));Ca(V.h)<=1&&V.ta&&(V.ta=void 0)}else Ra(V,11)}else if((v.L||V.g==v)&&Mf(V),!L(D))for(wt=V.Ba.g.parse(D),D=0;D<wt.length;D++){let gn=wt[D];const is=gn[0];if(!(is<=V.K))if(V.K=is,gn=gn[1],V.I==2)if(gn[0]=="c"){V.M=gn[1],V.ba=gn[2];const to=gn[3];to!=null&&(V.ka=to,V.j.info("VER="+V.ka));const Da=gn[4];Da!=null&&(V.za=Da,V.j.info("SVER="+V.za));const zo=gn[5];zo!=null&&typeof zo=="number"&&zo>0&&(K=1.5*zo,V.O=K,V.j.info("backChannelRequestTimeoutMs_="+K)),K=V;const Bo=v.g;if(Bo){const Yc=Bo.g?Bo.g.getResponseHeader("X-Client-Wire-Protocol"):null;if(Yc){var _t=K.h;_t.g||Yc.indexOf("spdy")==-1&&Yc.indexOf("quic")==-1&&Yc.indexOf("h2")==-1||(_t.j=_t.l,_t.g=new Set,_t.h&&(Zp(_t,_t.h),_t.h=null))}if(K.G){const Lf=Bo.g?Bo.g.getResponseHeader("X-HTTP-Session-Id"):null;Lf&&(K.wa=Lf,$n(K.J,K.G,Lf))}}V.I=3,V.l&&V.l.ra(),V.aa&&(V.T=Date.now()-v.F,V.j.info("Handshake RTT: "+V.T+"ms")),K=V;var Zt=v;if(K.na=t0(K,K.L?K.ba:null,K.W),Zt.L){Jp(K.h,Zt);var Fe=Zt,Is=K.O;Is&&(Fe.H=Is),Fe.D&&(Ia(Fe),Sa(Fe)),K.g=Zt}else Xb(K);V.i.length>0&&Na(V)}else gn[0]!="stop"&&gn[0]!="close"||Ra(V,7);else V.I==3&&(gn[0]=="stop"||gn[0]=="close"?gn[0]=="stop"?Ra(V,7):lm(V):gn[0]!="noop"&&V.l&&V.l.qa(gn),V.A=0)}}un(4)}catch{}}var Os=class{constructor(v,D){this.g=v,this.map=D}};function Yp(v){this.l=v||10,o.PerformanceNavigationTiming?(v=o.performance.getEntriesByType("navigation"),v=v.length>0&&(v[0].nextHopProtocol=="hq"||v[0].nextHopProtocol=="h2")):v=!!(o.chrome&&o.chrome.loadTimes&&o.chrome.loadTimes()&&o.chrome.loadTimes().wasFetchedViaSpdy),this.j=v?this.l:1,this.g=null,this.j>1&&(this.g=new Set),this.h=null,this.i=[]}function Qp(v){return v.h?!0:v.g?v.g.size>=v.j:!1}function Ca(v){return v.h?1:v.g?v.g.size:0}function Ea(v,D){return v.h?v.h==D:v.g?v.g.has(D):!1}function Zp(v,D){v.g?v.g.add(D):v.h=D}function Jp(v,D){v.h&&v.h==D?v.h=null:v.g&&v.g.has(D)&&v.g.delete(D)}Yp.prototype.cancel=function(){if(this.i=tm(this),this.h)this.h.cancel(),this.h=null;else if(this.g&&this.g.size!==0){for(const v of this.g.values())v.cancel();this.g.clear()}};function tm(v){if(v.h!=null)return v.i.concat(v.h.G);if(v.g!=null&&v.g.size!==0){let D=v.i;for(const V of v.g.values())D=D.concat(V.G);return D}return y(v.i)}var Gb=RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");function kf(v,D){if(v){v=v.split("&");for(let V=0;V<v.length;V++){const K=v[V].indexOf("=");let wt,_t=null;K>=0?(wt=v[V].substring(0,K),_t=v[V].substring(K+1)):wt=v[V],D(wt,_t?decodeURIComponent(_t.replace(/\+/g," ")):"")}}}function Di(v){this.g=this.o=this.j="",this.u=null,this.m=this.h="",this.l=!1;let D;v instanceof Di?(this.l=v.l,fr(this,v.j),this.o=v.o,this.g=v.g,fu(this,v.u),this.h=v.h,em(this,Hb(v.i)),this.m=v.m):v&&(D=String(v).match(Gb))?(this.l=!1,fr(this,D[1]||"",!0),this.o=$a(D[2]||""),this.g=$a(D[3]||"",!0),fu(this,D[4]),this.h=$a(D[5]||"",!0),em(this,D[6]||"",!0),this.m=$a(D[7]||"")):(this.l=!1,this.i=new pu(null,this.l))}Di.prototype.toString=function(){const v=[];var D=this.j;D&&v.push(Gc(D,_f,!0),":");var V=this.g;return(V||D=="file")&&(v.push("//"),(D=this.o)&&v.push(Gc(D,_f,!0),"@"),v.push(vl(V).replace(/%25([0-9a-fA-F]{2})/g,"%$1")),V=this.u,V!=null&&v.push(":",String(V))),(V=this.h)&&(this.g&&V.charAt(0)!="/"&&v.push("/"),v.push(Gc(V,V.charAt(0)=="/"?nm:Wb,!0))),(V=this.i.toString())&&v.push("?",V),(V=this.m)&&v.push("#",Gc(V,jb)),v.join("")},Di.prototype.resolve=function(v){const D=Fs(this);let V=!!v.j;V?fr(D,v.j):V=!!v.o,V?D.o=v.o:V=!!v.g,V?D.g=v.g:V=v.u!=null;var K=v.h;if(V)fu(D,v.u);else if(V=!!v.h){if(K.charAt(0)!="/")if(this.g&&!this.h)K="/"+K;else{var wt=D.h.lastIndexOf("/");wt!=-1&&(K=D.h.slice(0,wt+1)+K)}if(wt=K,wt==".."||wt==".")K="";else if(wt.indexOf("./")!=-1||wt.indexOf("/.")!=-1){K=wt.lastIndexOf("/",0)==0,wt=wt.split("/");const _t=[];for(let Zt=0;Zt<wt.length;){const Fe=wt[Zt++];Fe=="."?K&&Zt==wt.length&&_t.push(""):Fe==".."?((_t.length>1||_t.length==1&&_t[0]!="")&&_t.pop(),K&&Zt==wt.length&&_t.push("")):(_t.push(Fe),K=!0)}K=_t.join("/")}else K=wt}return V?D.h=K:V=v.i.toString()!=="",V?em(D,Hb(v.i)):V=!!v.m,V&&(D.m=v.m),D};function Fs(v){return new Di(v)}function fr(v,D,V){v.j=V?$a(D,!0):D,v.j&&(v.j=v.j.replace(/:$/,""))}function fu(v,D){if(D){if(D=Number(D),isNaN(D)||D<0)throw Error("Bad port number "+D);v.u=D}else v.u=null}function em(v,D,V){D instanceof pu?(v.i=D,Rf(v.i,v.l)):(V||(D=Gc(D,du)),v.i=new pu(D,v.l))}function $n(v,D,V){v.i.set(D,V)}function Uc(v){return $n(v,"zx",Math.floor(Math.random()*2147483648).toString(36)+Math.abs(Math.floor(Math.random()*2147483648)^Date.now()).toString(36)),v}function $a(v,D){return v?D?decodeURI(v.replace(/%25/g,"%2525")):decodeURIComponent(v):""}function Gc(v,D,V){return typeof v=="string"?(v=encodeURI(v).replace(D,pi),V&&(v=v.replace(/%25([0-9a-fA-F]{2})/g,"%$1")),v):null}function pi(v){return v=v.charCodeAt(0),"%"+(v>>4&15).toString(16)+(v&15).toString(16)}var _f=/[#\/\?@]/g,Wb=/[#\?:]/g,nm=/[#\?]/g,du=/[#\?@]/g,jb=/#/g;function pu(v,D){this.h=this.g=null,this.i=v||null,this.j=!!D}function mi(v){v.g||(v.g=new Map,v.h=0,v.i&&kf(v.i,function(D,V){v.add(decodeURIComponent(D.replace(/\+/g," ")),V)}))}n=pu.prototype,n.add=function(v,D){mi(this),this.i=null,v=mu(this,v);let V=this.g.get(v);return V||this.g.set(v,V=[]),V.push(D),this.h+=1,this};function qb(v,D){mi(v),D=mu(v,D),v.g.has(D)&&(v.i=null,v.h-=v.g.get(D).length,v.g.delete(D))}function sm(v,D){return mi(v),D=mu(v,D),v.g.has(D)}n.forEach=function(v,D){mi(this),this.g.forEach(function(V,K){V.forEach(function(wt){v.call(D,wt,K,this)},this)},this)};function rm(v,D){mi(v);let V=[];if(typeof D=="string")sm(v,D)&&(V=V.concat(v.g.get(mu(v,D))));else for(v=Array.from(v.g.values()),D=0;D<v.length;D++)V=V.concat(v[D]);return V}n.set=function(v,D){return mi(this),this.i=null,v=mu(this,v),sm(this,v)&&(this.h-=this.g.get(v).length),this.g.set(v,[D]),this.h+=1,this},n.get=function(v,D){return v?(v=rm(this,v),v.length>0?String(v[0]):D):D};function Nf(v,D,V){qb(v,D),V.length>0&&(v.i=null,v.g.set(mu(v,D),y(V)),v.h+=V.length)}n.toString=function(){if(this.i)return this.i;if(!this.g)return"";const v=[],D=Array.from(this.g.keys());for(let K=0;K<D.length;K++){var V=D[K];const wt=vl(V);V=rm(this,V);for(let _t=0;_t<V.length;_t++){let Zt=wt;V[_t]!==""&&(Zt+="="+vl(V[_t])),v.push(Zt)}}return this.i=v.join("&")};function Hb(v){const D=new pu;return D.i=v.i,v.g&&(D.g=new Map(v.g),D.h=v.h),D}function mu(v,D){return D=String(D),v.j&&(D=D.toLowerCase()),D}function Rf(v,D){D&&!v.j&&(mi(v),v.i=null,v.g.forEach(function(V,K){const wt=K.toLowerCase();K!=wt&&(qb(this,K),Nf(this,wt,V))},v)),v.j=D}function Fo(v,D){const V=new Ro;if(o.Image){const K=new Image;K.onload=f(Zi,V,"TestLoadImage: loaded",!0,D,K),K.onerror=f(Zi,V,"TestLoadImage: error",!1,D,K),K.onabort=f(Zi,V,"TestLoadImage: abort",!1,D,K),K.ontimeout=f(Zi,V,"TestLoadImage: timeout",!1,D,K),o.setTimeout(function(){K.ontimeout&&K.ontimeout()},1e4),K.src=v}else D(!1)}function im(v,D){const V=new Ro,K=new AbortController,wt=setTimeout(()=>{K.abort(),Zi(V,"TestPingServer: timeout",!1,D)},1e4);fetch(v,{signal:K.signal}).then(_t=>{clearTimeout(wt),_t.ok?Zi(V,"TestPingServer: ok",!0,D):Zi(V,"TestPingServer: server error",!1,D)}).catch(()=>{clearTimeout(wt),Zi(V,"TestPingServer: error",!1,D)})}function Zi(v,D,V,K,wt){try{wt&&(wt.onload=null,wt.onerror=null,wt.onabort=null,wt.ontimeout=null),K(V)}catch{}}function gu(){this.g=new G}function Aa(v){this.i=v.Sb||null,this.h=v.ab||!1}d(Aa,O),Aa.prototype.g=function(){return new Wc(this.i,this.h)};function Wc(v,D){Nt.call(this),this.H=v,this.o=D,this.m=void 0,this.status=this.readyState=0,this.responseType=this.responseText=this.response=this.statusText="",this.onreadystatechange=null,this.A=new Headers,this.h=null,this.F="GET",this.D="",this.g=!1,this.B=this.j=this.l=null,this.v=new AbortController}d(Wc,Nt),n=Wc.prototype,n.open=function(v,D){if(this.readyState!=0)throw this.abort(),Error("Error reopening a connection");this.F=v,this.D=D,this.readyState=1,Mo(this)},n.send=function(v){if(this.readyState!=1)throw this.abort(),Error("need to call open() first. ");if(this.v.signal.aborted)throw this.abort(),Error("Request was aborted.");this.g=!0;const D={headers:this.A,method:this.F,credentials:this.m,cache:void 0,signal:this.v.signal};v&&(D.body=v),(this.H||o).fetch(new Request(this.D,D)).then(this.Pa.bind(this),this.ga.bind(this))},n.abort=function(){this.response=this.responseText="",this.A=new Headers,this.status=0,this.v.abort(),this.j&&this.j.cancel("Request was aborted.").catch(()=>{}),this.readyState>=1&&this.g&&this.readyState!=4&&(this.g=!1,yu(this)),this.readyState=0},n.Pa=function(v){if(this.g&&(this.l=v,this.h||(this.status=this.l.status,this.statusText=this.l.statusText,this.h=v.headers,this.readyState=2,Mo(this)),this.g&&(this.readyState=3,Mo(this),this.g)))if(this.responseType==="arraybuffer")v.arrayBuffer().then(this.Na.bind(this),this.ga.bind(this));else if(typeof o.ReadableStream<"u"&&"body"in v){if(this.j=v.body.getReader(),this.o){if(this.responseType)throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');this.response=[]}else this.response=this.responseText="",this.B=new TextDecoder;Df(this)}else v.text().then(this.Oa.bind(this),this.ga.bind(this))};function Df(v){v.j.read().then(v.Ma.bind(v)).catch(v.ga.bind(v))}n.Ma=function(v){if(this.g){if(this.o&&v.value)this.response.push(v.value);else if(!this.o){var D=v.value?v.value:new Uint8Array(0);(D=this.B.decode(D,{stream:!v.done}))&&(this.response=this.responseText+=D)}v.done?yu(this):Mo(this),this.readyState==3&&Df(this)}},n.Oa=function(v){this.g&&(this.response=this.responseText=v,yu(this))},n.Na=function(v){this.g&&(this.response=v,yu(this))},n.ga=function(){this.g&&yu(this)};function yu(v){v.readyState=4,v.l=null,v.j=null,v.B=null,Mo(v)}n.setRequestHeader=function(v,D){this.A.append(v,D)},n.getResponseHeader=function(v){return this.h&&this.h.get(v.toLowerCase())||""},n.getAllResponseHeaders=function(){if(!this.h)return"";const v=[],D=this.h.entries();for(var V=D.next();!V.done;)V=V.value,v.push(V[0]+": "+V[1]),V=D.next();return v.join(`\r
`)};function Mo(v){v.onreadystatechange&&v.onreadystatechange.call(v)}Object.defineProperty(Wc.prototype,"withCredentials",{get:function(){return this.m==="include"},set:function(v){this.m=v?"include":"same-origin"}});function Ji(v){let D="";return ot(v,function(V,K){D+=K,D+=":",D+=V,D+=`\r
`}),D}function jc(v,D,V){t:{for(K in V){var K=!1;break t}K=!0}K||(V=Ji(V),typeof v=="string"?V!=null&&vl(V):$n(v,D,V))}function Rn(v){Nt.call(this),this.headers=new Map,this.L=v||null,this.h=!1,this.g=null,this.D="",this.o=0,this.l="",this.j=this.B=this.v=this.A=!1,this.m=null,this.F="",this.H=!1}d(Rn,Nt);var ka=/^https?$/i,om=["POST","PUT"];n=Rn.prototype,n.Fa=function(v){this.H=v},n.ea=function(v,D,V,K){if(this.g)throw Error("[goog.net.XhrIo] Object is active with another request="+this.D+"; newUri="+v);D=D?D.toUpperCase():"GET",this.D=v,this.l="",this.o=0,this.A=!1,this.h=!0,this.g=this.L?this.L.g():Xp.g(),this.g.onreadystatechange=m(c(this.Ca,this));try{this.B=!0,this.g.open(D,String(v),!0),this.B=!1}catch(_t){qc(this,_t);return}if(v=V||"",V=new Map(this.headers),K)if(Object.getPrototypeOf(K)===Object.prototype)for(var wt in K)V.set(wt,K[wt]);else if(typeof K.keys=="function"&&typeof K.get=="function")for(const _t of K.keys())V.set(_t,K.get(_t));else throw Error("Unknown input type for opt_headers: "+String(K));K=Array.from(V.keys()).find(_t=>_t.toLowerCase()=="content-type"),wt=o.FormData&&v instanceof o.FormData,!(Array.prototype.indexOf.call(om,D,void 0)>=0)||K||wt||V.set("Content-Type","application/x-www-form-urlencoded;charset=utf-8");for(const[_t,Zt]of V)this.g.setRequestHeader(_t,Zt);this.F&&(this.g.responseType=this.F),"withCredentials"in this.g&&this.g.withCredentials!==this.H&&(this.g.withCredentials=this.H);try{this.m&&(clearTimeout(this.m),this.m=null),this.v=!0,this.g.send(v),this.v=!1}catch(_t){qc(this,_t)}};function qc(v,D){v.h=!1,v.g&&(v.j=!0,v.g.abort(),v.j=!1),v.l=D,v.o=5,am(v),Sl(v)}function am(v){v.A||(v.A=!0,Ie(v,"complete"),Ie(v,"error"))}n.abort=function(v){this.g&&this.h&&(this.h=!1,this.j=!0,this.g.abort(),this.j=!1,this.o=v||7,Ie(this,"complete"),Ie(this,"abort"),Sl(this))},n.N=function(){this.g&&(this.h&&(this.h=!1,this.j=!0,this.g.abort(),this.j=!1),Sl(this,!0)),Rn.Z.N.call(this)},n.Ca=function(){this.u||(this.B||this.v||this.j?Hc(this):this.Xa())},n.Xa=function(){Hc(this)};function Hc(v){if(v.h&&typeof i<"u"){if(v.v&&Lo(v)==4)setTimeout(v.Ca.bind(v),0);else if(Ie(v,"readystatechange"),Lo(v)==4){v.h=!1;try{const _t=v.ca();t:switch(_t){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:var D=!0;break t;default:D=!1}var V;if(!(V=D)){var K;if(K=_t===0){let Zt=String(v.D).match(Gb)[1]||null;!Zt&&o.self&&o.self.location&&(Zt=o.self.location.protocol.slice(0,-1)),K=!ka.test(Zt?Zt.toLowerCase():"")}V=K}if(V)Ie(v,"complete"),Ie(v,"success");else{v.o=6;try{var wt=Lo(v)>2?v.g.statusText:""}catch{wt=""}v.l=wt+" ["+v.ca()+"]",am(v)}}finally{Sl(v)}}}}function Sl(v,D){if(v.g){v.m&&(clearTimeout(v.m),v.m=null);const V=v.g;v.g=null,D||Ie(v,"ready");try{V.onreadystatechange=null}catch{}}}n.isActive=function(){return!!this.g};function Lo(v){return v.g?v.g.readyState:0}n.ca=function(){try{return Lo(this)>2?this.g.status:-1}catch{return-1}},n.la=function(){try{return this.g?this.g.responseText:""}catch{return""}},n.La=function(v){if(this.g){var D=this.g.responseText;return v&&D.indexOf(v)==0&&(D=D.substring(v.length)),No(D)}};function Tr(v){try{if(!v.g)return null;if("response"in v.g)return v.g.response;switch(v.F){case"":case"text":return v.g.responseText;case"arraybuffer":if("mozResponseArrayBuffer"in v.g)return v.g.mozResponseArrayBuffer}return null}catch{return null}}function Il(v){const D={};v=(v.g&&Lo(v)>=2&&v.g.getAllResponseHeaders()||"").split(`\r
`);for(let K=0;K<v.length;K++){if(L(v[K]))continue;var V=Pb(v[K]);const wt=V[0];if(V=V[1],typeof V!="string")continue;V=V.trim();const _t=D[wt]||[];D[wt]=_t,_t.push(V)}pt(D,function(K){return K.join(", ")})}n.ya=function(){return this.o},n.Ha=function(){return typeof this.l=="string"?this.l:String(this.l)};function _a(v,D,V){return V&&V.internalChannelParams&&V.internalChannelParams[v]||D}function bu(v){this.za=0,this.i=[],this.j=new Ro,this.ba=this.na=this.J=this.W=this.g=this.wa=this.G=this.H=this.u=this.U=this.o=null,this.Ya=this.V=0,this.Sa=_a("failFast",!1,v),this.F=this.C=this.v=this.m=this.l=null,this.X=!0,this.xa=this.K=-1,this.Y=this.A=this.D=0,this.Qa=_a("baseRetryDelayMs",5e3,v),this.Za=_a("retryDelaySeedMs",1e4,v),this.Ta=_a("forwardChannelMaxRetries",2,v),this.va=_a("forwardChannelRequestTimeoutMs",2e4,v),this.ma=v&&v.xmlHttpFactory||void 0,this.Ua=v&&v.Rb||void 0,this.Aa=v&&v.useFetchStreams||!1,this.O=void 0,this.L=v&&v.supportsCrossDomainXhr||!1,this.M="",this.h=new Yp(v&&v.concurrentRequestLimit),this.Ba=new gu,this.S=v&&v.fastHandshake||!1,this.R=v&&v.encodeInitMessageHeaders||!1,this.S&&this.R&&(this.R=!1),this.Ra=v&&v.Pb||!1,v&&v.ua&&this.j.ua(),v&&v.forceLongPolling&&(this.X=!1),this.aa=!this.S&&this.X&&v&&v.detectBufferingProxy||!1,this.ia=void 0,v&&v.longPollingTimeout&&v.longPollingTimeout>0&&(this.ia=v.longPollingTimeout),this.ta=void 0,this.T=0,this.P=!1,this.ja=this.B=null}n=bu.prototype,n.ka=8,n.I=1,n.connect=function(v,D,V,K){Rs(0),this.W=v,this.H=D||{},V&&K!==void 0&&(this.H.OSID=V,this.H.OAID=K),this.F=this.X,this.J=t0(this,null,this.W),Na(this)};function lm(v){if(Of(v),v.I==3){var D=v.V++,V=Fs(v.J);if($n(V,"SID",v.M),$n(V,"RID",D),$n(V,"TYPE","terminate"),Kc(v,V),D=new Do(v,v.j,D),D.M=2,D.A=Uc(Fs(V)),V=!1,o.navigator&&o.navigator.sendBeacon)try{V=o.navigator.sendBeacon(D.A.toString(),"")}catch{}!V&&o.Image&&(new Image().src=D.A,V=!0),V||(D.g=e0(D.j,null),D.g.ea(D.A)),D.F=Date.now(),Sa(D)}Jb(v)}function xu(v){v.g&&(cm(v),v.g.cancel(),v.g=null)}function Of(v){xu(v),v.v&&(o.clearTimeout(v.v),v.v=null),Mf(v),v.h.cancel(),v.m&&(typeof v.m=="number"&&o.clearTimeout(v.m),v.m=null)}function Na(v){if(!Qp(v.h)&&!v.m){v.m=!0;var D=v.Ea;R||k(),B||(R(),B=!0),N.add(D,v),v.D=0}}function Ff(v,D){return Ca(v.h)>=v.h.j-(v.m?1:0)?!1:v.m?(v.i=D.G.concat(v.i),!0):v.I==1||v.I==2||v.D>=(v.Sa?0:v.Ta)?!1:(v.m=xa(c(v.Ea,v,D),Zb(v,v.D)),v.D++,!0)}n.Ea=function(v){if(this.m)if(this.m=null,this.I==1){if(!v){this.V=Math.floor(Math.random()*1e5),v=this.V++;const wt=new Do(this,this.j,v);let _t=this.o;if(this.U&&(_t?(_t=q(_t),U(_t,this.U)):_t=this.U),this.u!==null||this.R||(wt.J=_t,_t=null),this.S)t:{for(var D=0,V=0;V<this.i.length;V++){e:{var K=this.i[V];if("__data__"in K.map&&(K=K.map.__data__,typeof K=="string")){K=K.length;break e}K=void 0}if(K===void 0)break;if(D+=K,D>4096){D=V;break t}if(D===4096||V===this.i.length-1){D=V+1;break t}}D=1e3}else D=1e3;D=Kb(this,wt,D),V=Fs(this.J),$n(V,"RID",v),$n(V,"CVER",22),this.G&&$n(V,"X-HTTP-Session-Id",this.G),Kc(this,V),_t&&(this.R?D="headers="+vl(Ji(_t))+"&"+D:this.u&&jc(V,this.u,_t)),Zp(this.h,wt),this.Ra&&$n(V,"TYPE","init"),this.S?($n(V,"$req",D),$n(V,"SID","null"),wt.U=!0,va(wt,V,null)):va(wt,V,D),this.I=2}}else this.I==3&&(v?um(this,v):this.i.length==0||Qp(this.h)||um(this))};function um(v,D){var V;D?V=D.l:V=v.V++;const K=Fs(v.J);$n(K,"SID",v.M),$n(K,"RID",V),$n(K,"AID",v.K),Kc(v,K),v.u&&v.o&&jc(K,v.u,v.o),V=new Do(v,v.j,V,v.D+1),v.u===null&&(V.J=v.o),D&&(v.i=D.G.concat(v.i)),D=Kb(v,V,1e3),V.H=Math.round(v.va*.5)+Math.round(v.va*.5*Math.random()),Zp(v.h,V),va(V,K,D)}function Kc(v,D){v.H&&ot(v.H,function(V,K){$n(D,K,V)}),v.l&&ot({},function(V,K){$n(D,K,V)})}function Kb(v,D,V){V=Math.min(v.i.length,V);const K=v.l?c(v.l.Ka,v.l,v):null;t:{var wt=v.i;let Fe=-1;for(;;){const Is=["count="+V];Fe==-1?V>0?(Fe=wt[0].g,Is.push("ofs="+Fe)):Fe=0:Is.push("ofs="+Fe);let gn=!0;for(let is=0;is<V;is++){var _t=wt[is].g;const to=wt[is].map;if(_t-=Fe,_t<0)Fe=Math.max(0,wt[is].g-100),gn=!1;else try{_t="req"+_t+"_"||"";try{var Zt=to instanceof Map?to:Object.entries(to);for(const[Da,zo]of Zt){let Bo=zo;a(zo)&&(Bo=Wn(zo)),Is.push(_t+Da+"="+encodeURIComponent(Bo))}}catch(Da){throw Is.push(_t+"type="+encodeURIComponent("_badmap")),Da}}catch{K&&K(to)}}if(gn){Zt=Is.join("&");break t}}Zt=void 0}return v=v.i.splice(0,V),D.G=v,Zt}function Xb(v){if(!v.g&&!v.v){v.Y=1;var D=v.Da;R||k(),B||(R(),B=!0),N.add(D,v),v.A=0}}function Xc(v){return v.g||v.v||v.A>=3?!1:(v.Y++,v.v=xa(c(v.Da,v),Zb(v,v.A)),v.A++,!0)}n.Da=function(){if(this.v=null,Yb(this),this.aa&&!(this.P||this.g==null||this.T<=0)){var v=4*this.T;this.j.info("BP detection timer enabled: "+v),this.B=xa(c(this.Wa,this),v)}},n.Wa=function(){this.B&&(this.B=null,this.j.info("BP detection timeout reached."),this.j.info("Buffering proxy detected and switch to long-polling!"),this.F=!1,this.P=!0,Rs(10),xu(this),Yb(this))};function cm(v){v.B!=null&&(o.clearTimeout(v.B),v.B=null)}function Yb(v){v.g=new Do(v,v.j,"rpc",v.Y),v.u===null&&(v.g.J=v.o),v.g.P=0;var D=Fs(v.na);$n(D,"RID","rpc"),$n(D,"SID",v.M),$n(D,"AID",v.K),$n(D,"CI",v.F?"0":"1"),!v.F&&v.ia&&$n(D,"TO",v.ia),$n(D,"TYPE","xmlhttp"),Kc(v,D),v.u&&v.o&&jc(D,v.u,v.o),v.O&&(v.g.H=v.O);var V=v.g;v=v.ba,V.M=1,V.A=Uc(Fs(D)),V.u=null,V.R=!0,$f(V,v)}n.Va=function(){this.C!=null&&(this.C=null,xu(this),Xc(this),Rs(19))};function Mf(v){v.C!=null&&(o.clearTimeout(v.C),v.C=null)}function Qb(v,D){var V=null;if(v.g==D){Mf(v),cm(v),v.g=null;var K=2}else if(Ea(v.h,D))V=D.G,Jp(v.h,D),K=1;else return;if(v.I!=0){if(D.o)if(K==1){V=D.u?D.u.length:0,D=Date.now()-D.F;var wt=v.D;K=Cn(),Ie(K,new ba(K,V)),Na(v)}else Xb(v);else if(wt=D.m,wt==3||wt==0&&D.X>0||!(K==1&&Ff(v,D)||K==2&&Xc(v)))switch(V&&V.length>0&&(D=v.h,D.i=D.i.concat(V)),wt){case 1:Ra(v,5);break;case 4:Ra(v,10);break;case 3:Ra(v,6);break;default:Ra(v,2)}}}function Zb(v,D){let V=v.Qa+Math.floor(Math.random()*v.Za);return v.isActive()||(V*=2),V*D}function Ra(v,D){if(v.j.info("Error code "+D),D==2){var V=c(v.bb,v),K=v.Ua;const wt=!K;K=new Di(K||"//www.google.com/images/cleardot.gif"),o.location&&o.location.protocol=="http"||fr(K,"https"),Uc(K),wt?Fo(K.toString(),V):im(K.toString(),V)}else Rs(2);v.I=0,v.l&&v.l.pa(D),Jb(v),Of(v)}n.bb=function(v){v?(this.j.info("Successfully pinged google.com"),Rs(2)):(this.j.info("Failed to ping google.com"),Rs(1))};function Jb(v){if(v.I=0,v.ja=[],v.l){const D=tm(v.h);(D.length!=0||v.i.length!=0)&&(b(v.ja,D),b(v.ja,v.i),v.h.i.length=0,y(v.i),v.i.length=0),v.l.oa()}}function t0(v,D,V){var K=V instanceof Di?Fs(V):new Di(V);if(K.g!="")D&&(K.g=D+"."+K.g),fu(K,K.u);else{var wt=o.location;K=wt.protocol,D=D?D+"."+wt.hostname:wt.hostname,wt=+wt.port;const _t=new Di(null);K&&fr(_t,K),D&&(_t.g=D),wt&&fu(_t,wt),V&&(_t.h=V),K=_t}return V=v.G,D=v.wa,V&&D&&$n(K,V,D),$n(K,"VER",v.ka),Kc(v,K),K}function e0(v,D,V){if(D&&!v.L)throw Error("Can't create secondary domain capable XhrIo object.");return D=v.Aa&&!v.ma?new Rn(new Aa({ab:V})):new Rn(v.ma),D.Fa(v.L),D}n.isActive=function(){return!!this.l&&this.l.isActive(this)};function n0(){}n=n0.prototype,n.ra=function(){},n.qa=function(){},n.pa=function(){},n.oa=function(){},n.isActive=function(){return!0},n.Ka=function(){};function wu(){}wu.prototype.g=function(v,D){return new Qr(v,D)};function Qr(v,D){Nt.call(this),this.g=new bu(D),this.l=v,this.h=D&&D.messageUrlParams||null,v=D&&D.messageHeaders||null,D&&D.clientProtocolHeaderRequired&&(v?v["X-Client-Protocol"]="webchannel":v={"X-Client-Protocol":"webchannel"}),this.g.o=v,v=D&&D.initMessageHeaders||null,D&&D.messageContentType&&(v?v["X-WebChannel-Content-Type"]=D.messageContentType:v={"X-WebChannel-Content-Type":D.messageContentType}),D&&D.sa&&(v?v["X-WebChannel-Client-Profile"]=D.sa:v={"X-WebChannel-Client-Profile":D.sa}),this.g.U=v,(v=D&&D.Qb)&&!L(v)&&(this.g.u=v),this.A=D&&D.supportsCrossDomainXhr||!1,this.v=D&&D.sendRawJson||!1,(D=D&&D.httpSessionIdParam)&&!L(D)&&(this.g.G=D,v=this.h,v!==null&&D in v&&(v=this.h,D in v&&delete v[D])),this.j=new Tl(this)}d(Qr,Nt),Qr.prototype.m=function(){this.g.l=this.j,this.A&&(this.g.L=!0),this.g.connect(this.l,this.h||void 0)},Qr.prototype.close=function(){lm(this.g)},Qr.prototype.o=function(v){var D=this.g;if(typeof v=="string"){var V={};V.__data__=v,v=V}else this.v&&(V={},V.__data__=Wn(v),v=V);D.i.push(new Os(D.Ya++,v)),D.I==3&&Na(D)},Qr.prototype.N=function(){this.g.l=null,delete this.j,lm(this.g),delete this.g,Qr.Z.N.call(this)};function s0(v){at.call(this),v.__headers__&&(this.headers=v.__headers__,this.statusCode=v.__status__,delete v.__headers__,delete v.__status__);var D=v.__sm__;if(D){t:{for(const V in D){v=V;break t}v=void 0}(this.i=v)&&(v=this.i,D=D!==null&&v in D?D[v]:void 0),this.data=D}else this.data=v}d(s0,at);function r0(){Ct.call(this),this.status=1}d(r0,Ct);function Tl(v){this.g=v}d(Tl,n0),Tl.prototype.ra=function(){Ie(this.g,"a")},Tl.prototype.qa=function(v){Ie(this.g,new s0(v))},Tl.prototype.pa=function(v){Ie(this.g,new r0)},Tl.prototype.oa=function(){Ie(this.g,"b")},wu.prototype.createWebChannel=wu.prototype.g,Qr.prototype.send=Qr.prototype.o,Qr.prototype.open=Qr.prototype.m,Qr.prototype.close=Qr.prototype.close,P8=function(){return new wu},B8=function(){return Cn()},z8=Mt,H$={jb:0,mb:1,nb:2,Hb:3,Mb:4,Jb:5,Kb:6,Ib:7,Gb:8,Lb:9,PROXY:10,NOPROXY:11,Eb:12,Ab:13,Bb:14,zb:15,Cb:16,Db:17,fb:18,eb:19,gb:20},Pc.NO_ERROR=0,Pc.TIMEOUT=8,Pc.HTTP_ERROR=6,Y1=Pc,Kp.COMPLETE="complete",L8=Kp,M.EventType=Y,Y.OPEN="a",Y.CLOSE="b",Y.ERROR="c",Y.MESSAGE="d",Nt.prototype.listen=Nt.prototype.J,hg=M,Rn.prototype.listenOnce=Rn.prototype.K,Rn.prototype.getLastError=Rn.prototype.Ha,Rn.prototype.getLastErrorCode=Rn.prototype.ya,Rn.prototype.getStatus=Rn.prototype.ca,Rn.prototype.getResponseJson=Rn.prototype.La,Rn.prototype.getResponseText=Rn.prototype.la,Rn.prototype.send=Rn.prototype.ea,Rn.prototype.setWithCredentials=Rn.prototype.Fa,M8=Rn}).apply(typeof k1<"u"?k1:typeof self<"u"?self:typeof window<"u"?window:{});const _z="@firebase/firestore",Nz="4.9.3";class Gr{constructor(t){this.uid=t}isAuthenticated(){return this.uid!=null}toKey(){return this.isAuthenticated()?"uid:"+this.uid:"anonymous-user"}isEqual(t){return t.uid===this.uid}}Gr.UNAUTHENTICATED=new Gr(null),Gr.GOOGLE_CREDENTIALS=new Gr("google-credentials-uid"),Gr.FIRST_PARTY=new Gr("first-party-uid"),Gr.MOCK_USER=new Gr("mock-user");let Gp="12.7.0";const ef=new iN("@firebase/firestore");function Ed(){return ef.logLevel}function re(n,...t){if(ef.logLevel<=an.DEBUG){const e=t.map(lN);ef.debug(`Firestore (${Gp}): ${n}`,...e)}}function nu(n,...t){if(ef.logLevel<=an.ERROR){const e=t.map(lN);ef.error(`Firestore (${Gp}): ${n}`,...e)}}function nf(n,...t){if(ef.logLevel<=an.WARN){const e=t.map(lN);ef.warn(`Firestore (${Gp}): ${n}`,...e)}}function lN(n){if(typeof n=="string")return n;try{return(function(e){return JSON.stringify(e)})(n)}catch{return n}}function Ce(n,t,e){let s="Unexpected state";typeof t=="string"?s=t:e=t,V8(n,s,e)}function V8(n,t,e){let s=`FIRESTORE (${Gp}) INTERNAL ASSERTION FAILED: ${t} (ID: ${n.toString(16)})`;if(e!==void 0)try{s+=" CONTEXT: "+JSON.stringify(e)}catch{s+=" CONTEXT: "+e}throw nu(s),new Error(s)}function Sn(n,t,e,s){let r="Unexpected state";typeof e=="string"?r=e:s=e,n||V8(t,r,s)}function De(n,t){return n}const Gt={OK:"ok",CANCELLED:"cancelled",UNKNOWN:"unknown",INVALID_ARGUMENT:"invalid-argument",DEADLINE_EXCEEDED:"deadline-exceeded",NOT_FOUND:"not-found",ALREADY_EXISTS:"already-exists",PERMISSION_DENIED:"permission-denied",UNAUTHENTICATED:"unauthenticated",RESOURCE_EXHAUSTED:"resource-exhausted",FAILED_PRECONDITION:"failed-precondition",ABORTED:"aborted",OUT_OF_RANGE:"out-of-range",UNIMPLEMENTED:"unimplemented",INTERNAL:"internal",UNAVAILABLE:"unavailable",DATA_LOSS:"data-loss"};class se extends cu{constructor(t,e){super(t,e),this.code=t,this.message=e,this.toString=()=>`${this.name}: [code=${this.code}]: ${this.message}`}}class ac{constructor(){this.promise=new Promise(((t,e)=>{this.resolve=t,this.reject=e}))}}class U8{constructor(t,e){this.user=e,this.type="OAuth",this.headers=new Map,this.headers.set("Authorization",`Bearer ${t}`)}}class G8{getToken(){return Promise.resolve(null)}invalidateToken(){}start(t,e){t.enqueueRetryable((()=>e(Gr.UNAUTHENTICATED)))}shutdown(){}}class YFt{constructor(t){this.token=t,this.changeListener=null}getToken(){return Promise.resolve(this.token)}invalidateToken(){}start(t,e){this.changeListener=e,t.enqueueRetryable((()=>e(this.token.user)))}shutdown(){this.changeListener=null}}class QFt{constructor(t){this.t=t,this.currentUser=Gr.UNAUTHENTICATED,this.i=0,this.forceRefresh=!1,this.auth=null}start(t,e){Sn(this.o===void 0,42304);let s=this.i;const r=l=>this.i!==s?(s=this.i,e(l)):Promise.resolve();let i=new ac;this.o=()=>{this.i++,this.currentUser=this.u(),i.resolve(),i=new ac,t.enqueueRetryable((()=>r(this.currentUser)))};const o=()=>{const l=i;t.enqueueRetryable((async()=>{await l.promise,await r(this.currentUser)}))},a=l=>{re("FirebaseAuthCredentialsProvider","Auth detected"),this.auth=l,this.o&&(this.auth.addAuthTokenListener(this.o),o())};this.t.onInit((l=>a(l))),setTimeout((()=>{if(!this.auth){const l=this.t.getImmediate({optional:!0});l?a(l):(re("FirebaseAuthCredentialsProvider","Auth not yet detected"),i.resolve(),i=new ac)}}),0),o()}getToken(){const t=this.i,e=this.forceRefresh;return this.forceRefresh=!1,this.auth?this.auth.getToken(e).then((s=>this.i!==t?(re("FirebaseAuthCredentialsProvider","getToken aborted due to token change."),this.getToken()):s?(Sn(typeof s.accessToken=="string",31837,{l:s}),new U8(s.accessToken,this.currentUser)):null)):Promise.resolve(null)}invalidateToken(){this.forceRefresh=!0}shutdown(){this.auth&&this.o&&this.auth.removeAuthTokenListener(this.o),this.o=void 0}u(){const t=this.auth&&this.auth.getUid();return Sn(t===null||typeof t=="string",2055,{h:t}),new Gr(t)}}class ZFt{constructor(t,e,s){this.P=t,this.T=e,this.I=s,this.type="FirstParty",this.user=Gr.FIRST_PARTY,this.A=new Map}R(){return this.I?this.I():null}get headers(){this.A.set("X-Goog-AuthUser",this.P);const t=this.R();return t&&this.A.set("Authorization",t),this.T&&this.A.set("X-Goog-Iam-Authorization-Token",this.T),this.A}}class JFt{constructor(t,e,s){this.P=t,this.T=e,this.I=s}getToken(){return Promise.resolve(new ZFt(this.P,this.T,this.I))}start(t,e){t.enqueueRetryable((()=>e(Gr.FIRST_PARTY)))}shutdown(){}invalidateToken(){}}class Rz{constructor(t){this.value=t,this.type="AppCheck",this.headers=new Map,t&&t.length>0&&this.headers.set("x-firebase-appcheck",this.value)}}class tMt{constructor(t,e){this.V=e,this.forceRefresh=!1,this.appCheck=null,this.m=null,this.p=null,N8(t)&&t.settings.appCheckToken&&(this.p=t.settings.appCheckToken)}start(t,e){Sn(this.o===void 0,3512);const s=i=>{i.error!=null&&re("FirebaseAppCheckTokenProvider",`Error getting App Check token; using placeholder token instead. Error: ${i.error.message}`);const o=i.token!==this.m;return this.m=i.token,re("FirebaseAppCheckTokenProvider",`Received ${o?"new":"existing"} token.`),o?e(i.token):Promise.resolve()};this.o=i=>{t.enqueueRetryable((()=>s(i)))};const r=i=>{re("FirebaseAppCheckTokenProvider","AppCheck detected"),this.appCheck=i,this.o&&this.appCheck.addTokenListener(this.o)};this.V.onInit((i=>r(i))),setTimeout((()=>{if(!this.appCheck){const i=this.V.getImmediate({optional:!0});i?r(i):re("FirebaseAppCheckTokenProvider","AppCheck not yet detected")}}),0)}getToken(){if(this.p)return Promise.resolve(new Rz(this.p));const t=this.forceRefresh;return this.forceRefresh=!1,this.appCheck?this.appCheck.getToken(t).then((e=>e?(Sn(typeof e.token=="string",44558,{tokenResult:e}),this.m=e.token,new Rz(e.token)):null)):Promise.resolve(null)}invalidateToken(){this.forceRefresh=!0}shutdown(){this.appCheck&&this.o&&this.appCheck.removeTokenListener(this.o),this.o=void 0}}function eMt(n){const t=typeof self<"u"&&(self.crypto||self.msCrypto),e=new Uint8Array(n);if(t&&typeof t.getRandomValues=="function")t.getRandomValues(e);else for(let s=0;s<n;s++)e[s]=Math.floor(256*Math.random());return e}class cS{static newId(){const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",e=62*Math.floor(4.129032258064516);let s="";for(;s.length<20;){const r=eMt(40);for(let i=0;i<r.length;++i)s.length<20&&r[i]<e&&(s+=t.charAt(r[i]%62))}return s}}function Ye(n,t){return n<t?-1:n>t?1:0}function K$(n,t){const e=Math.min(n.length,t.length);for(let s=0;s<e;s++){const r=n.charAt(s),i=t.charAt(s);if(r!==i)return vE(r)===vE(i)?Ye(r,i):vE(r)?1:-1}return Ye(n.length,t.length)}const nMt=55296,sMt=57343;function vE(n){const t=n.charCodeAt(0);return t>=nMt&&t<=sMt}function up(n,t,e){return n.length===t.length&&n.every(((s,r)=>e(s,t[r])))}const Dz="__name__";class Wa{constructor(t,e,s){e===void 0?e=0:e>t.length&&Ce(637,{offset:e,range:t.length}),s===void 0?s=t.length-e:s>t.length-e&&Ce(1746,{length:s,range:t.length-e}),this.segments=t,this.offset=e,this.len=s}get length(){return this.len}isEqual(t){return Wa.comparator(this,t)===0}child(t){const e=this.segments.slice(this.offset,this.limit());return t instanceof Wa?t.forEach((s=>{e.push(s)})):e.push(t),this.construct(e)}limit(){return this.offset+this.length}popFirst(t){return t=t===void 0?1:t,this.construct(this.segments,this.offset+t,this.length-t)}popLast(){return this.construct(this.segments,this.offset,this.length-1)}firstSegment(){return this.segments[this.offset]}lastSegment(){return this.get(this.length-1)}get(t){return this.segments[this.offset+t]}isEmpty(){return this.length===0}isPrefixOf(t){if(t.length<this.length)return!1;for(let e=0;e<this.length;e++)if(this.get(e)!==t.get(e))return!1;return!0}isImmediateParentOf(t){if(this.length+1!==t.length)return!1;for(let e=0;e<this.length;e++)if(this.get(e)!==t.get(e))return!1;return!0}forEach(t){for(let e=this.offset,s=this.limit();e<s;e++)t(this.segments[e])}toArray(){return this.segments.slice(this.offset,this.limit())}static comparator(t,e){const s=Math.min(t.length,e.length);for(let r=0;r<s;r++){const i=Wa.compareSegments(t.get(r),e.get(r));if(i!==0)return i}return Ye(t.length,e.length)}static compareSegments(t,e){const s=Wa.isNumericId(t),r=Wa.isNumericId(e);return s&&!r?-1:!s&&r?1:s&&r?Wa.extractNumericId(t).compare(Wa.extractNumericId(e)):K$(t,e)}static isNumericId(t){return t.startsWith("__id")&&t.endsWith("__")}static extractNumericId(t){return oc.fromString(t.substring(4,t.length-2))}}class qn extends Wa{construct(t,e,s){return new qn(t,e,s)}canonicalString(){return this.toArray().join("/")}toString(){return this.canonicalString()}toUriEncodedString(){return this.toArray().map(encodeURIComponent).join("/")}static fromString(...t){const e=[];for(const s of t){if(s.indexOf("//")>=0)throw new se(Gt.INVALID_ARGUMENT,`Invalid segment (${s}). Paths must not contain // in them.`);e.push(...s.split("/").filter((r=>r.length>0)))}return new qn(e)}static emptyPath(){return new qn([])}}const rMt=/^[_a-zA-Z][_a-zA-Z0-9]*$/;class yr extends Wa{construct(t,e,s){return new yr(t,e,s)}static isValidIdentifier(t){return rMt.test(t)}canonicalString(){return this.toArray().map((t=>(t=t.replace(/\\/g,"\\\\").replace(/`/g,"\\`"),yr.isValidIdentifier(t)||(t="`"+t+"`"),t))).join(".")}toString(){return this.canonicalString()}isKeyField(){return this.length===1&&this.get(0)===Dz}static keyField(){return new yr([Dz])}static fromServerFormat(t){const e=[];let s="",r=0;const i=()=>{if(s.length===0)throw new se(Gt.INVALID_ARGUMENT,`Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);e.push(s),s=""};let o=!1;for(;r<t.length;){const a=t[r];if(a==="\\"){if(r+1===t.length)throw new se(Gt.INVALID_ARGUMENT,"Path has trailing escape character: "+t);const l=t[r+1];if(l!=="\\"&&l!=="."&&l!=="`")throw new se(Gt.INVALID_ARGUMENT,"Path has invalid escape sequence: "+t);s+=l,r+=2}else a==="`"?(o=!o,r++):a!=="."||o?(s+=a,r++):(i(),r++)}if(i(),o)throw new se(Gt.INVALID_ARGUMENT,"Unterminated ` in path: "+t);return new yr(e)}static emptyPath(){return new yr([])}}class ge{constructor(t){this.path=t}static fromPath(t){return new ge(qn.fromString(t))}static fromName(t){return new ge(qn.fromString(t).popFirst(5))}static empty(){return new ge(qn.emptyPath())}get collectionGroup(){return this.path.popLast().lastSegment()}hasCollectionId(t){return this.path.length>=2&&this.path.get(this.path.length-2)===t}getCollectionGroup(){return this.path.get(this.path.length-2)}getCollectionPath(){return this.path.popLast()}isEqual(t){return t!==null&&qn.comparator(this.path,t.path)===0}toString(){return this.path.toString()}static comparator(t,e){return qn.comparator(t.path,e.path)}static isDocumentKey(t){return t.length%2==0}static fromSegments(t){return new ge(new qn(t.slice()))}}function W8(n,t,e){if(!e)throw new se(Gt.INVALID_ARGUMENT,`Function ${n}() cannot be called with an empty ${t}.`)}function j8(n,t,e,s){if(t===!0&&s===!0)throw new se(Gt.INVALID_ARGUMENT,`${n} and ${e} cannot be used together.`)}function Oz(n){if(!ge.isDocumentKey(n))throw new se(Gt.INVALID_ARGUMENT,`Invalid document reference. Document references must have an even number of segments, but ${n} has ${n.length}.`)}function Fz(n){if(ge.isDocumentKey(n))throw new se(Gt.INVALID_ARGUMENT,`Invalid collection reference. Collection references must have an odd number of segments, but ${n} has ${n.length}.`)}function q8(n){return typeof n=="object"&&n!==null&&(Object.getPrototypeOf(n)===Object.prototype||Object.getPrototypeOf(n)===null)}function hS(n){if(n===void 0)return"undefined";if(n===null)return"null";if(typeof n=="string")return n.length>20&&(n=`${n.substring(0,20)}...`),JSON.stringify(n);if(typeof n=="number"||typeof n=="boolean")return""+n;if(typeof n=="object"){if(n instanceof Array)return"an array";{const t=(function(s){return s.constructor?s.constructor.name:null})(n);return t?`a custom ${t} object`:"an object"}}return typeof n=="function"?"a function":Ce(12329,{type:typeof n})}function qg(n,t){if("_delegate"in n&&(n=n._delegate),!(n instanceof t)){if(t.name===n.constructor.name)throw new se(Gt.INVALID_ARGUMENT,"Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");{const e=hS(n);throw new se(Gt.INVALID_ARGUMENT,`Expected type '${t.name}', but it was: ${e}`)}}return n}function iMt(n,t){if(t<=0)throw new se(Gt.INVALID_ARGUMENT,`Function ${n}() requires a positive number, but it was: ${t}.`)}function Hs(n,t){const e={typeString:n};return t&&(e.value=t),e}function Ob(n,t){if(!q8(n))throw new se(Gt.INVALID_ARGUMENT,"JSON must be an object");let e;for(const s in t)if(t[s]){const r=t[s].typeString,i="value"in t[s]?{value:t[s].value}:void 0;if(!(s in n)){e=`JSON missing required field: '${s}'`;break}const o=n[s];if(r&&typeof o!==r){e=`JSON field '${s}' must be a ${r}.`;break}if(i!==void 0&&o!==i.value){e=`Expected '${s}' field to equal '${i.value}'`;break}}if(e)throw new se(Gt.INVALID_ARGUMENT,e);return!0}const Mz=-62135596800,Lz=1e6;class Hn{static now(){return Hn.fromMillis(Date.now())}static fromDate(t){return Hn.fromMillis(t.getTime())}static fromMillis(t){const e=Math.floor(t/1e3),s=Math.floor((t-1e3*e)*Lz);return new Hn(e,s)}constructor(t,e){if(this.seconds=t,this.nanoseconds=e,e<0)throw new se(Gt.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: "+e);if(e>=1e9)throw new se(Gt.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: "+e);if(t<Mz)throw new se(Gt.INVALID_ARGUMENT,"Timestamp seconds out of range: "+t);if(t>=253402300800)throw new se(Gt.INVALID_ARGUMENT,"Timestamp seconds out of range: "+t)}toDate(){return new Date(this.toMillis())}toMillis(){return 1e3*this.seconds+this.nanoseconds/Lz}_compareTo(t){return this.seconds===t.seconds?Ye(this.nanoseconds,t.nanoseconds):Ye(this.seconds,t.seconds)}isEqual(t){return t.seconds===this.seconds&&t.nanoseconds===this.nanoseconds}toString(){return"Timestamp(seconds="+this.seconds+", nanoseconds="+this.nanoseconds+")"}toJSON(){return{type:Hn._jsonSchemaVersion,seconds:this.seconds,nanoseconds:this.nanoseconds}}static fromJSON(t){if(Ob(t,Hn._jsonSchema))return new Hn(t.seconds,t.nanoseconds)}valueOf(){const t=this.seconds-Mz;return String(t).padStart(12,"0")+"."+String(this.nanoseconds).padStart(9,"0")}}Hn._jsonSchemaVersion="firestore/timestamp/1.0",Hn._jsonSchema={type:Hs("string",Hn._jsonSchemaVersion),seconds:Hs("number"),nanoseconds:Hs("number")};class ke{static fromTimestamp(t){return new ke(t)}static min(){return new ke(new Hn(0,0))}static max(){return new ke(new Hn(253402300799,999999999))}constructor(t){this.timestamp=t}compareTo(t){return this.timestamp._compareTo(t.timestamp)}isEqual(t){return this.timestamp.isEqual(t.timestamp)}toMicroseconds(){return 1e6*this.timestamp.seconds+this.timestamp.nanoseconds/1e3}toString(){return"SnapshotVersion("+this.timestamp.toString()+")"}toTimestamp(){return this.timestamp}}const Hg=-1;function oMt(n,t){const e=n.toTimestamp().seconds,s=n.toTimestamp().nanoseconds+1,r=ke.fromTimestamp(s===1e9?new Hn(e+1,0):new Hn(e,s));return new Sc(r,ge.empty(),t)}function aMt(n){return new Sc(n.readTime,n.key,Hg)}class Sc{constructor(t,e,s){this.readTime=t,this.documentKey=e,this.largestBatchId=s}static min(){return new Sc(ke.min(),ge.empty(),Hg)}static max(){return new Sc(ke.max(),ge.empty(),Hg)}}function lMt(n,t){let e=n.readTime.compareTo(t.readTime);return e!==0?e:(e=ge.comparator(n.documentKey,t.documentKey),e!==0?e:Ye(n.largestBatchId,t.largestBatchId))}const uMt="The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";class cMt{constructor(){this.onCommittedListeners=[]}addOnCommittedListener(t){this.onCommittedListeners.push(t)}raiseOnCommittedEvent(){this.onCommittedListeners.forEach((t=>t()))}}async function Wp(n){if(n.code!==Gt.FAILED_PRECONDITION||n.message!==uMt)throw n;re("LocalStore","Unexpectedly lost primary lease")}class jt{constructor(t){this.nextCallback=null,this.catchCallback=null,this.result=void 0,this.error=void 0,this.isDone=!1,this.callbackAttached=!1,t((e=>{this.isDone=!0,this.result=e,this.nextCallback&&this.nextCallback(e)}),(e=>{this.isDone=!0,this.error=e,this.catchCallback&&this.catchCallback(e)}))}catch(t){return this.next(void 0,t)}next(t,e){return this.callbackAttached&&Ce(59440),this.callbackAttached=!0,this.isDone?this.error?this.wrapFailure(e,this.error):this.wrapSuccess(t,this.result):new jt(((s,r)=>{this.nextCallback=i=>{this.wrapSuccess(t,i).next(s,r)},this.catchCallback=i=>{this.wrapFailure(e,i).next(s,r)}}))}toPromise(){return new Promise(((t,e)=>{this.next(t,e)}))}wrapUserFunction(t){try{const e=t();return e instanceof jt?e:jt.resolve(e)}catch(e){return jt.reject(e)}}wrapSuccess(t,e){return t?this.wrapUserFunction((()=>t(e))):jt.resolve(e)}wrapFailure(t,e){return t?this.wrapUserFunction((()=>t(e))):jt.reject(e)}static resolve(t){return new jt(((e,s)=>{e(t)}))}static reject(t){return new jt(((e,s)=>{s(t)}))}static waitFor(t){return new jt(((e,s)=>{let r=0,i=0,o=!1;t.forEach((a=>{++r,a.next((()=>{++i,o&&i===r&&e()}),(l=>s(l)))})),o=!0,i===r&&e()}))}static or(t){let e=jt.resolve(!1);for(const s of t)e=e.next((r=>r?jt.resolve(r):s()));return e}static forEach(t,e){const s=[];return t.forEach(((r,i)=>{s.push(e.call(this,r,i))})),this.waitFor(s)}static mapArray(t,e){return new jt(((s,r)=>{const i=t.length,o=new Array(i);let a=0;for(let l=0;l<i;l++){const c=l;e(t[c]).next((f=>{o[c]=f,++a,a===i&&s(o)}),(f=>r(f)))}}))}static doWhile(t,e){return new jt(((s,r)=>{const i=()=>{t()===!0?e().next((()=>{i()}),r):s()};i()}))}}function hMt(n){const t=n.match(/Android ([\d.]+)/i),e=t?t[1].split(".").slice(0,2).join("."):"-1";return Number(e)}function jp(n){return n.name==="IndexedDbTransactionError"}class fS{constructor(t,e){this.previousValue=t,e&&(e.sequenceNumberHandler=s=>this.ae(s),this.ue=s=>e.writeSequenceNumber(s))}ae(t){return this.previousValue=Math.max(t,this.previousValue),this.previousValue}next(){const t=++this.previousValue;return this.ue&&this.ue(t),t}}fS.ce=-1;const uN=-1;function dS(n){return n==null}function Qx(n){return n===0&&1/n==-1/0}function fMt(n){return typeof n=="number"&&Number.isInteger(n)&&!Qx(n)&&n<=Number.MAX_SAFE_INTEGER&&n>=Number.MIN_SAFE_INTEGER}const H8="";function dMt(n){let t="";for(let e=0;e<n.length;e++)t.length>0&&(t=zz(t)),t=pMt(n.get(e),t);return zz(t)}function pMt(n,t){let e=t;const s=n.length;for(let r=0;r<s;r++){const i=n.charAt(r);switch(i){case"\0":e+="";break;case H8:e+="";break;default:e+=i}}return e}function zz(n){return n+H8+""}function Bz(n){let t=0;for(const e in n)Object.prototype.hasOwnProperty.call(n,e)&&t++;return t}function If(n,t){for(const e in n)Object.prototype.hasOwnProperty.call(n,e)&&t(e,n[e])}function K8(n){for(const t in n)if(Object.prototype.hasOwnProperty.call(n,t))return!1;return!0}class ds{constructor(t,e){this.comparator=t,this.root=e||kr.EMPTY}insert(t,e){return new ds(this.comparator,this.root.insert(t,e,this.comparator).copy(null,null,kr.BLACK,null,null))}remove(t){return new ds(this.comparator,this.root.remove(t,this.comparator).copy(null,null,kr.BLACK,null,null))}get(t){let e=this.root;for(;!e.isEmpty();){const s=this.comparator(t,e.key);if(s===0)return e.value;s<0?e=e.left:s>0&&(e=e.right)}return null}indexOf(t){let e=0,s=this.root;for(;!s.isEmpty();){const r=this.comparator(t,s.key);if(r===0)return e+s.left.size;r<0?s=s.left:(e+=s.left.size+1,s=s.right)}return-1}isEmpty(){return this.root.isEmpty()}get size(){return this.root.size}minKey(){return this.root.minKey()}maxKey(){return this.root.maxKey()}inorderTraversal(t){return this.root.inorderTraversal(t)}forEach(t){this.inorderTraversal(((e,s)=>(t(e,s),!1)))}toString(){const t=[];return this.inorderTraversal(((e,s)=>(t.push(`${e}:${s}`),!1))),`{${t.join(", ")}}`}reverseTraversal(t){return this.root.reverseTraversal(t)}getIterator(){return new _1(this.root,null,this.comparator,!1)}getIteratorFrom(t){return new _1(this.root,t,this.comparator,!1)}getReverseIterator(){return new _1(this.root,null,this.comparator,!0)}getReverseIteratorFrom(t){return new _1(this.root,t,this.comparator,!0)}}class _1{constructor(t,e,s,r){this.isReverse=r,this.nodeStack=[];let i=1;for(;!t.isEmpty();)if(i=e?s(t.key,e):1,e&&r&&(i*=-1),i<0)t=this.isReverse?t.left:t.right;else{if(i===0){this.nodeStack.push(t);break}this.nodeStack.push(t),t=this.isReverse?t.right:t.left}}getNext(){let t=this.nodeStack.pop();const e={key:t.key,value:t.value};if(this.isReverse)for(t=t.left;!t.isEmpty();)this.nodeStack.push(t),t=t.right;else for(t=t.right;!t.isEmpty();)this.nodeStack.push(t),t=t.left;return e}hasNext(){return this.nodeStack.length>0}peek(){if(this.nodeStack.length===0)return null;const t=this.nodeStack[this.nodeStack.length-1];return{key:t.key,value:t.value}}}class kr{constructor(t,e,s,r,i){this.key=t,this.value=e,this.color=s??kr.RED,this.left=r??kr.EMPTY,this.right=i??kr.EMPTY,this.size=this.left.size+1+this.right.size}copy(t,e,s,r,i){return new kr(t??this.key,e??this.value,s??this.color,r??this.left,i??this.right)}isEmpty(){return!1}inorderTraversal(t){return this.left.inorderTraversal(t)||t(this.key,this.value)||this.right.inorderTraversal(t)}reverseTraversal(t){return this.right.reverseTraversal(t)||t(this.key,this.value)||this.left.reverseTraversal(t)}min(){return this.left.isEmpty()?this:this.left.min()}minKey(){return this.min().key}maxKey(){return this.right.isEmpty()?this.key:this.right.maxKey()}insert(t,e,s){let r=this;const i=s(t,r.key);return r=i<0?r.copy(null,null,null,r.left.insert(t,e,s),null):i===0?r.copy(null,e,null,null,null):r.copy(null,null,null,null,r.right.insert(t,e,s)),r.fixUp()}removeMin(){if(this.left.isEmpty())return kr.EMPTY;let t=this;return t.left.isRed()||t.left.left.isRed()||(t=t.moveRedLeft()),t=t.copy(null,null,null,t.left.removeMin(),null),t.fixUp()}remove(t,e){let s,r=this;if(e(t,r.key)<0)r.left.isEmpty()||r.left.isRed()||r.left.left.isRed()||(r=r.moveRedLeft()),r=r.copy(null,null,null,r.left.remove(t,e),null);else{if(r.left.isRed()&&(r=r.rotateRight()),r.right.isEmpty()||r.right.isRed()||r.right.left.isRed()||(r=r.moveRedRight()),e(t,r.key)===0){if(r.right.isEmpty())return kr.EMPTY;s=r.right.min(),r=r.copy(s.key,s.value,null,null,r.right.removeMin())}r=r.copy(null,null,null,null,r.right.remove(t,e))}return r.fixUp()}isRed(){return this.color}fixUp(){let t=this;return t.right.isRed()&&!t.left.isRed()&&(t=t.rotateLeft()),t.left.isRed()&&t.left.left.isRed()&&(t=t.rotateRight()),t.left.isRed()&&t.right.isRed()&&(t=t.colorFlip()),t}moveRedLeft(){let t=this.colorFlip();return t.right.left.isRed()&&(t=t.copy(null,null,null,null,t.right.rotateRight()),t=t.rotateLeft(),t=t.colorFlip()),t}moveRedRight(){let t=this.colorFlip();return t.left.left.isRed()&&(t=t.rotateRight(),t=t.colorFlip()),t}rotateLeft(){const t=this.copy(null,null,kr.RED,null,this.right.left);return this.right.copy(null,null,this.color,t,null)}rotateRight(){const t=this.copy(null,null,kr.RED,this.left.right,null);return this.left.copy(null,null,this.color,null,t)}colorFlip(){const t=this.left.copy(null,null,!this.left.color,null,null),e=this.right.copy(null,null,!this.right.color,null,null);return this.copy(null,null,!this.color,t,e)}checkMaxDepth(){const t=this.check();return Math.pow(2,t)<=this.size+1}check(){if(this.isRed()&&this.left.isRed())throw Ce(43730,{key:this.key,value:this.value});if(this.right.isRed())throw Ce(14113,{key:this.key,value:this.value});const t=this.left.check();if(t!==this.right.check())throw Ce(27949);return t+(this.isRed()?0:1)}}kr.EMPTY=null,kr.RED=!0,kr.BLACK=!1;kr.EMPTY=new class{constructor(){this.size=0}get key(){throw Ce(57766)}get value(){throw Ce(16141)}get color(){throw Ce(16727)}get left(){throw Ce(29726)}get right(){throw Ce(36894)}copy(t,e,s,r,i){return this}insert(t,e,s){return new kr(t,e)}remove(t,e){return this}isEmpty(){return!0}inorderTraversal(t){return!1}reverseTraversal(t){return!1}minKey(){return null}maxKey(){return null}isRed(){return!1}checkMaxDepth(){return!0}check(){return 0}};class ar{constructor(t){this.comparator=t,this.data=new ds(this.comparator)}has(t){return this.data.get(t)!==null}first(){return this.data.minKey()}last(){return this.data.maxKey()}get size(){return this.data.size}indexOf(t){return this.data.indexOf(t)}forEach(t){this.data.inorderTraversal(((e,s)=>(t(e),!1)))}forEachInRange(t,e){const s=this.data.getIteratorFrom(t[0]);for(;s.hasNext();){const r=s.getNext();if(this.comparator(r.key,t[1])>=0)return;e(r.key)}}forEachWhile(t,e){let s;for(s=e!==void 0?this.data.getIteratorFrom(e):this.data.getIterator();s.hasNext();)if(!t(s.getNext().key))return}firstAfterOrEqual(t){const e=this.data.getIteratorFrom(t);return e.hasNext()?e.getNext().key:null}getIterator(){return new Pz(this.data.getIterator())}getIteratorFrom(t){return new Pz(this.data.getIteratorFrom(t))}add(t){return this.copy(this.data.remove(t).insert(t,!0))}delete(t){return this.has(t)?this.copy(this.data.remove(t)):this}isEmpty(){return this.data.isEmpty()}unionWith(t){let e=this;return e.size<t.size&&(e=t,t=this),t.forEach((s=>{e=e.add(s)})),e}isEqual(t){if(!(t instanceof ar)||this.size!==t.size)return!1;const e=this.data.getIterator(),s=t.data.getIterator();for(;e.hasNext();){const r=e.getNext().key,i=s.getNext().key;if(this.comparator(r,i)!==0)return!1}return!0}toArray(){const t=[];return this.forEach((e=>{t.push(e)})),t}toString(){const t=[];return this.forEach((e=>t.push(e))),"SortedSet("+t.toString()+")"}copy(t){const e=new ar(this.comparator);return e.data=t,e}}class Pz{constructor(t){this.iter=t}getNext(){return this.iter.getNext().key}hasNext(){return this.iter.hasNext()}}class Zo{constructor(t){this.fields=t,t.sort(yr.comparator)}static empty(){return new Zo([])}unionWith(t){let e=new ar(yr.comparator);for(const s of this.fields)e=e.add(s);for(const s of t)e=e.add(s);return new Zo(e.toArray())}covers(t){for(const e of this.fields)if(e.isPrefixOf(t))return!0;return!1}isEqual(t){return up(this.fields,t.fields,((e,s)=>e.isEqual(s)))}}class X8 extends Error{constructor(){super(...arguments),this.name="Base64DecodeError"}}class wr{constructor(t){this.binaryString=t}static fromBase64String(t){const e=(function(r){try{return atob(r)}catch(i){throw typeof DOMException<"u"&&i instanceof DOMException?new X8("Invalid base64 string: "+i):i}})(t);return new wr(e)}static fromUint8Array(t){const e=(function(r){let i="";for(let o=0;o<r.length;++o)i+=String.fromCharCode(r[o]);return i})(t);return new wr(e)}[Symbol.iterator](){let t=0;return{next:()=>t<this.binaryString.length?{value:this.binaryString.charCodeAt(t++),done:!1}:{value:void 0,done:!0}}}toBase64(){return(function(e){return btoa(e)})(this.binaryString)}toUint8Array(){return(function(e){const s=new Uint8Array(e.length);for(let r=0;r<e.length;r++)s[r]=e.charCodeAt(r);return s})(this.binaryString)}approximateByteSize(){return 2*this.binaryString.length}compareTo(t){return Ye(this.binaryString,t.binaryString)}isEqual(t){return this.binaryString===t.binaryString}}wr.EMPTY_BYTE_STRING=new wr("");const mMt=new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);function Ic(n){if(Sn(!!n,39018),typeof n=="string"){let t=0;const e=mMt.exec(n);if(Sn(!!e,46558,{timestamp:n}),e[1]){let r=e[1];r=(r+"000000000").substr(0,9),t=Number(r)}const s=new Date(n);return{seconds:Math.floor(s.getTime()/1e3),nanos:t}}return{seconds:Es(n.seconds),nanos:Es(n.nanos)}}function Es(n){return typeof n=="number"?n:typeof n=="string"?Number(n):0}function Tc(n){return typeof n=="string"?wr.fromBase64String(n):wr.fromUint8Array(n)}const Y8="server_timestamp",Q8="__type__",Z8="__previous_value__",J8="__local_write_time__";function cN(n){return(n?.mapValue?.fields||{})[Q8]?.stringValue===Y8}function pS(n){const t=n.mapValue.fields[Z8];return cN(t)?pS(t):t}function Kg(n){const t=Ic(n.mapValue.fields[J8].timestampValue);return new Hn(t.seconds,t.nanos)}class gMt{constructor(t,e,s,r,i,o,a,l,c,f){this.databaseId=t,this.appId=e,this.persistenceKey=s,this.host=r,this.ssl=i,this.forceLongPolling=o,this.autoDetectLongPolling=a,this.longPollingOptions=l,this.useFetchStreams=c,this.isUsingEmulator=f}}const Zx="(default)";class cp{constructor(t,e){this.projectId=t,this.database=e||Zx}static empty(){return new cp("","")}get isDefaultDatabase(){return this.database===Zx}isEqual(t){return t instanceof cp&&t.projectId===this.projectId&&t.database===this.database}}const t9="__type__",yMt="__max__",N1={mapValue:{}},e9="__vector__",Jx="value";function Cc(n){return"nullValue"in n?0:"booleanValue"in n?1:"integerValue"in n||"doubleValue"in n?2:"timestampValue"in n?3:"stringValue"in n?5:"bytesValue"in n?6:"referenceValue"in n?7:"geoPointValue"in n?8:"arrayValue"in n?9:"mapValue"in n?cN(n)?4:xMt(n)?9007199254740991:bMt(n)?10:11:Ce(28295,{value:n})}function bl(n,t){if(n===t)return!0;const e=Cc(n);if(e!==Cc(t))return!1;switch(e){case 0:case 9007199254740991:return!0;case 1:return n.booleanValue===t.booleanValue;case 4:return Kg(n).isEqual(Kg(t));case 3:return(function(r,i){if(typeof r.timestampValue=="string"&&typeof i.timestampValue=="string"&&r.timestampValue.length===i.timestampValue.length)return r.timestampValue===i.timestampValue;const o=Ic(r.timestampValue),a=Ic(i.timestampValue);return o.seconds===a.seconds&&o.nanos===a.nanos})(n,t);case 5:return n.stringValue===t.stringValue;case 6:return(function(r,i){return Tc(r.bytesValue).isEqual(Tc(i.bytesValue))})(n,t);case 7:return n.referenceValue===t.referenceValue;case 8:return(function(r,i){return Es(r.geoPointValue.latitude)===Es(i.geoPointValue.latitude)&&Es(r.geoPointValue.longitude)===Es(i.geoPointValue.longitude)})(n,t);case 2:return(function(r,i){if("integerValue"in r&&"integerValue"in i)return Es(r.integerValue)===Es(i.integerValue);if("doubleValue"in r&&"doubleValue"in i){const o=Es(r.doubleValue),a=Es(i.doubleValue);return o===a?Qx(o)===Qx(a):isNaN(o)&&isNaN(a)}return!1})(n,t);case 9:return up(n.arrayValue.values||[],t.arrayValue.values||[],bl);case 10:case 11:return(function(r,i){const o=r.mapValue.fields||{},a=i.mapValue.fields||{};if(Bz(o)!==Bz(a))return!1;for(const l in o)if(o.hasOwnProperty(l)&&(a[l]===void 0||!bl(o[l],a[l])))return!1;return!0})(n,t);default:return Ce(52216,{left:n})}}function Xg(n,t){return(n.values||[]).find((e=>bl(e,t)))!==void 0}function hp(n,t){if(n===t)return 0;const e=Cc(n),s=Cc(t);if(e!==s)return Ye(e,s);switch(e){case 0:case 9007199254740991:return 0;case 1:return Ye(n.booleanValue,t.booleanValue);case 2:return(function(i,o){const a=Es(i.integerValue||i.doubleValue),l=Es(o.integerValue||o.doubleValue);return a<l?-1:a>l?1:a===l?0:isNaN(a)?isNaN(l)?0:-1:1})(n,t);case 3:return Vz(n.timestampValue,t.timestampValue);case 4:return Vz(Kg(n),Kg(t));case 5:return K$(n.stringValue,t.stringValue);case 6:return(function(i,o){const a=Tc(i),l=Tc(o);return a.compareTo(l)})(n.bytesValue,t.bytesValue);case 7:return(function(i,o){const a=i.split("/"),l=o.split("/");for(let c=0;c<a.length&&c<l.length;c++){const f=Ye(a[c],l[c]);if(f!==0)return f}return Ye(a.length,l.length)})(n.referenceValue,t.referenceValue);case 8:return(function(i,o){const a=Ye(Es(i.latitude),Es(o.latitude));return a!==0?a:Ye(Es(i.longitude),Es(o.longitude))})(n.geoPointValue,t.geoPointValue);case 9:return Uz(n.arrayValue,t.arrayValue);case 10:return(function(i,o){const a=i.fields||{},l=o.fields||{},c=a[Jx]?.arrayValue,f=l[Jx]?.arrayValue,d=Ye(c?.values?.length||0,f?.values?.length||0);return d!==0?d:Uz(c,f)})(n.mapValue,t.mapValue);case 11:return(function(i,o){if(i===N1.mapValue&&o===N1.mapValue)return 0;if(i===N1.mapValue)return 1;if(o===N1.mapValue)return-1;const a=i.fields||{},l=Object.keys(a),c=o.fields||{},f=Object.keys(c);l.sort(),f.sort();for(let d=0;d<l.length&&d<f.length;++d){const m=K$(l[d],f[d]);if(m!==0)return m;const y=hp(a[l[d]],c[f[d]]);if(y!==0)return y}return Ye(l.length,f.length)})(n.mapValue,t.mapValue);default:throw Ce(23264,{he:e})}}function Vz(n,t){if(typeof n=="string"&&typeof t=="string"&&n.length===t.length)return Ye(n,t);const e=Ic(n),s=Ic(t),r=Ye(e.seconds,s.seconds);return r!==0?r:Ye(e.nanos,s.nanos)}function Uz(n,t){const e=n.values||[],s=t.values||[];for(let r=0;r<e.length&&r<s.length;++r){const i=hp(e[r],s[r]);if(i)return i}return Ye(e.length,s.length)}function fp(n){return X$(n)}function X$(n){return"nullValue"in n?"null":"booleanValue"in n?""+n.booleanValue:"integerValue"in n?""+n.integerValue:"doubleValue"in n?""+n.doubleValue:"timestampValue"in n?(function(e){const s=Ic(e);return`time(${s.seconds},${s.nanos})`})(n.timestampValue):"stringValue"in n?n.stringValue:"bytesValue"in n?(function(e){return Tc(e).toBase64()})(n.bytesValue):"referenceValue"in n?(function(e){return ge.fromName(e).toString()})(n.referenceValue):"geoPointValue"in n?(function(e){return`geo(${e.latitude},${e.longitude})`})(n.geoPointValue):"arrayValue"in n?(function(e){let s="[",r=!0;for(const i of e.values||[])r?r=!1:s+=",",s+=X$(i);return s+"]"})(n.arrayValue):"mapValue"in n?(function(e){const s=Object.keys(e.fields||{}).sort();let r="{",i=!0;for(const o of s)i?i=!1:r+=",",r+=`${o}:${X$(e.fields[o])}`;return r+"}"})(n.mapValue):Ce(61005,{value:n})}function Q1(n){switch(Cc(n)){case 0:case 1:return 4;case 2:return 8;case 3:case 8:return 16;case 4:const t=pS(n);return t?16+Q1(t):16;case 5:return 2*n.stringValue.length;case 6:return Tc(n.bytesValue).approximateByteSize();case 7:return n.referenceValue.length;case 9:return(function(s){return(s.values||[]).reduce(((r,i)=>r+Q1(i)),0)})(n.arrayValue);case 10:case 11:return(function(s){let r=0;return If(s.fields,((i,o)=>{r+=i.length+Q1(o)})),r})(n.mapValue);default:throw Ce(13486,{value:n})}}function Gz(n,t){return{referenceValue:`projects/${n.projectId}/databases/${n.database}/documents/${t.path.canonicalString()}`}}function Y$(n){return!!n&&"integerValue"in n}function hN(n){return!!n&&"arrayValue"in n}function Wz(n){return!!n&&"nullValue"in n}function jz(n){return!!n&&"doubleValue"in n&&isNaN(Number(n.doubleValue))}function Z1(n){return!!n&&"mapValue"in n}function bMt(n){return(n?.mapValue?.fields||{})[t9]?.stringValue===e9}function wg(n){if(n.geoPointValue)return{geoPointValue:{...n.geoPointValue}};if(n.timestampValue&&typeof n.timestampValue=="object")return{timestampValue:{...n.timestampValue}};if(n.mapValue){const t={mapValue:{fields:{}}};return If(n.mapValue.fields,((e,s)=>t.mapValue.fields[e]=wg(s))),t}if(n.arrayValue){const t={arrayValue:{values:[]}};for(let e=0;e<(n.arrayValue.values||[]).length;++e)t.arrayValue.values[e]=wg(n.arrayValue.values[e]);return t}return{...n}}function xMt(n){return(((n.mapValue||{}).fields||{}).__type__||{}).stringValue===yMt}class yo{constructor(t){this.value=t}static empty(){return new yo({mapValue:{}})}field(t){if(t.isEmpty())return this.value;{let e=this.value;for(let s=0;s<t.length-1;++s)if(e=(e.mapValue.fields||{})[t.get(s)],!Z1(e))return null;return e=(e.mapValue.fields||{})[t.lastSegment()],e||null}}set(t,e){this.getFieldsMap(t.popLast())[t.lastSegment()]=wg(e)}setAll(t){let e=yr.emptyPath(),s={},r=[];t.forEach(((o,a)=>{if(!e.isImmediateParentOf(a)){const l=this.getFieldsMap(e);this.applyChanges(l,s,r),s={},r=[],e=a.popLast()}o?s[a.lastSegment()]=wg(o):r.push(a.lastSegment())}));const i=this.getFieldsMap(e);this.applyChanges(i,s,r)}delete(t){const e=this.field(t.popLast());Z1(e)&&e.mapValue.fields&&delete e.mapValue.fields[t.lastSegment()]}isEqual(t){return bl(this.value,t.value)}getFieldsMap(t){let e=this.value;e.mapValue.fields||(e.mapValue={fields:{}});for(let s=0;s<t.length;++s){let r=e.mapValue.fields[t.get(s)];Z1(r)&&r.mapValue.fields||(r={mapValue:{fields:{}}},e.mapValue.fields[t.get(s)]=r),e=r}return e.mapValue.fields}applyChanges(t,e,s){If(e,((r,i)=>t[r]=i));for(const r of s)delete t[r]}clone(){return new yo(wg(this.value))}}function n9(n){const t=[];return If(n.fields,((e,s)=>{const r=new yr([e]);if(Z1(s)){const i=n9(s.mapValue).fields;if(i.length===0)t.push(r);else for(const o of i)t.push(r.child(o))}else t.push(r)})),new Zo(t)}class jr{constructor(t,e,s,r,i,o,a){this.key=t,this.documentType=e,this.version=s,this.readTime=r,this.createTime=i,this.data=o,this.documentState=a}static newInvalidDocument(t){return new jr(t,0,ke.min(),ke.min(),ke.min(),yo.empty(),0)}static newFoundDocument(t,e,s,r){return new jr(t,1,e,ke.min(),s,r,0)}static newNoDocument(t,e){return new jr(t,2,e,ke.min(),ke.min(),yo.empty(),0)}static newUnknownDocument(t,e){return new jr(t,3,e,ke.min(),ke.min(),yo.empty(),2)}convertToFoundDocument(t,e){return!this.createTime.isEqual(ke.min())||this.documentType!==2&&this.documentType!==0||(this.createTime=t),this.version=t,this.documentType=1,this.data=e,this.documentState=0,this}convertToNoDocument(t){return this.version=t,this.documentType=2,this.data=yo.empty(),this.documentState=0,this}convertToUnknownDocument(t){return this.version=t,this.documentType=3,this.data=yo.empty(),this.documentState=2,this}setHasCommittedMutations(){return this.documentState=2,this}setHasLocalMutations(){return this.documentState=1,this.version=ke.min(),this}setReadTime(t){return this.readTime=t,this}get hasLocalMutations(){return this.documentState===1}get hasCommittedMutations(){return this.documentState===2}get hasPendingWrites(){return this.hasLocalMutations||this.hasCommittedMutations}isValidDocument(){return this.documentType!==0}isFoundDocument(){return this.documentType===1}isNoDocument(){return this.documentType===2}isUnknownDocument(){return this.documentType===3}isEqual(t){return t instanceof jr&&this.key.isEqual(t.key)&&this.version.isEqual(t.version)&&this.documentType===t.documentType&&this.documentState===t.documentState&&this.data.isEqual(t.data)}mutableCopy(){return new jr(this.key,this.documentType,this.version,this.readTime,this.createTime,this.data.clone(),this.documentState)}toString(){return`Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`}}class tw{constructor(t,e){this.position=t,this.inclusive=e}}function qz(n,t,e){let s=0;for(let r=0;r<n.position.length;r++){const i=t[r],o=n.position[r];if(i.field.isKeyField()?s=ge.comparator(ge.fromName(o.referenceValue),e.key):s=hp(o,e.data.field(i.field)),i.dir==="desc"&&(s*=-1),s!==0)break}return s}function Hz(n,t){if(n===null)return t===null;if(t===null||n.inclusive!==t.inclusive||n.position.length!==t.position.length)return!1;for(let e=0;e<n.position.length;e++)if(!bl(n.position[e],t.position[e]))return!1;return!0}class Yg{constructor(t,e="asc"){this.field=t,this.dir=e}}function wMt(n,t){return n.dir===t.dir&&n.field.isEqual(t.field)}class s9{}class Us extends s9{constructor(t,e,s){super(),this.field=t,this.op=e,this.value=s}static create(t,e,s){return t.isKeyField()?e==="in"||e==="not-in"?this.createKeyFieldInFilter(t,e,s):new SMt(t,e,s):e==="array-contains"?new CMt(t,s):e==="in"?new EMt(t,s):e==="not-in"?new $Mt(t,s):e==="array-contains-any"?new AMt(t,s):new Us(t,e,s)}static createKeyFieldInFilter(t,e,s){return e==="in"?new IMt(t,s):new TMt(t,s)}matches(t){const e=t.data.field(this.field);return this.op==="!="?e!==null&&e.nullValue===void 0&&this.matchesComparison(hp(e,this.value)):e!==null&&Cc(this.value)===Cc(e)&&this.matchesComparison(hp(e,this.value))}matchesComparison(t){switch(this.op){case"<":return t<0;case"<=":return t<=0;case"==":return t===0;case"!=":return t!==0;case">":return t>0;case">=":return t>=0;default:return Ce(47266,{operator:this.op})}}isInequality(){return["<","<=",">",">=","!=","not-in"].indexOf(this.op)>=0}getFlattenedFilters(){return[this]}getFilters(){return[this]}}class pa extends s9{constructor(t,e){super(),this.filters=t,this.op=e,this.Pe=null}static create(t,e){return new pa(t,e)}matches(t){return r9(this)?this.filters.find((e=>!e.matches(t)))===void 0:this.filters.find((e=>e.matches(t)))!==void 0}getFlattenedFilters(){return this.Pe!==null||(this.Pe=this.filters.reduce(((t,e)=>t.concat(e.getFlattenedFilters())),[])),this.Pe}getFilters(){return Object.assign([],this.filters)}}function r9(n){return n.op==="and"}function i9(n){return vMt(n)&&r9(n)}function vMt(n){for(const t of n.filters)if(t instanceof pa)return!1;return!0}function Q$(n){if(n instanceof Us)return n.field.canonicalString()+n.op.toString()+fp(n.value);if(i9(n))return n.filters.map((t=>Q$(t))).join(",");{const t=n.filters.map((e=>Q$(e))).join(",");return`${n.op}(${t})`}}function o9(n,t){return n instanceof Us?(function(s,r){return r instanceof Us&&s.op===r.op&&s.field.isEqual(r.field)&&bl(s.value,r.value)})(n,t):n instanceof pa?(function(s,r){return r instanceof pa&&s.op===r.op&&s.filters.length===r.filters.length?s.filters.reduce(((i,o,a)=>i&&o9(o,r.filters[a])),!0):!1})(n,t):void Ce(19439)}function a9(n){return n instanceof Us?(function(e){return`${e.field.canonicalString()} ${e.op} ${fp(e.value)}`})(n):n instanceof pa?(function(e){return e.op.toString()+" {"+e.getFilters().map(a9).join(" ,")+"}"})(n):"Filter"}class SMt extends Us{constructor(t,e,s){super(t,e,s),this.key=ge.fromName(s.referenceValue)}matches(t){const e=ge.comparator(t.key,this.key);return this.matchesComparison(e)}}class IMt extends Us{constructor(t,e){super(t,"in",e),this.keys=l9("in",e)}matches(t){return this.keys.some((e=>e.isEqual(t.key)))}}class TMt extends Us{constructor(t,e){super(t,"not-in",e),this.keys=l9("not-in",e)}matches(t){return!this.keys.some((e=>e.isEqual(t.key)))}}function l9(n,t){return(t.arrayValue?.values||[]).map((e=>ge.fromName(e.referenceValue)))}class CMt extends Us{constructor(t,e){super(t,"array-contains",e)}matches(t){const e=t.data.field(this.field);return hN(e)&&Xg(e.arrayValue,this.value)}}class EMt extends Us{constructor(t,e){super(t,"in",e)}matches(t){const e=t.data.field(this.field);return e!==null&&Xg(this.value.arrayValue,e)}}class $Mt extends Us{constructor(t,e){super(t,"not-in",e)}matches(t){if(Xg(this.value.arrayValue,{nullValue:"NULL_VALUE"}))return!1;const e=t.data.field(this.field);return e!==null&&e.nullValue===void 0&&!Xg(this.value.arrayValue,e)}}class AMt extends Us{constructor(t,e){super(t,"array-contains-any",e)}matches(t){const e=t.data.field(this.field);return!(!hN(e)||!e.arrayValue.values)&&e.arrayValue.values.some((s=>Xg(this.value.arrayValue,s)))}}class kMt{constructor(t,e=null,s=[],r=[],i=null,o=null,a=null){this.path=t,this.collectionGroup=e,this.orderBy=s,this.filters=r,this.limit=i,this.startAt=o,this.endAt=a,this.Te=null}}function Kz(n,t=null,e=[],s=[],r=null,i=null,o=null){return new kMt(n,t,e,s,r,i,o)}function fN(n){const t=De(n);if(t.Te===null){let e=t.path.canonicalString();t.collectionGroup!==null&&(e+="|cg:"+t.collectionGroup),e+="|f:",e+=t.filters.map((s=>Q$(s))).join(","),e+="|ob:",e+=t.orderBy.map((s=>(function(i){return i.field.canonicalString()+i.dir})(s))).join(","),dS(t.limit)||(e+="|l:",e+=t.limit),t.startAt&&(e+="|lb:",e+=t.startAt.inclusive?"b:":"a:",e+=t.startAt.position.map((s=>fp(s))).join(",")),t.endAt&&(e+="|ub:",e+=t.endAt.inclusive?"a:":"b:",e+=t.endAt.position.map((s=>fp(s))).join(",")),t.Te=e}return t.Te}function dN(n,t){if(n.limit!==t.limit||n.orderBy.length!==t.orderBy.length)return!1;for(let e=0;e<n.orderBy.length;e++)if(!wMt(n.orderBy[e],t.orderBy[e]))return!1;if(n.filters.length!==t.filters.length)return!1;for(let e=0;e<n.filters.length;e++)if(!o9(n.filters[e],t.filters[e]))return!1;return n.collectionGroup===t.collectionGroup&&!!n.path.isEqual(t.path)&&!!Hz(n.startAt,t.startAt)&&Hz(n.endAt,t.endAt)}function Z$(n){return ge.isDocumentKey(n.path)&&n.collectionGroup===null&&n.filters.length===0}class qp{constructor(t,e=null,s=[],r=[],i=null,o="F",a=null,l=null){this.path=t,this.collectionGroup=e,this.explicitOrderBy=s,this.filters=r,this.limit=i,this.limitType=o,this.startAt=a,this.endAt=l,this.Ie=null,this.Ee=null,this.de=null,this.startAt,this.endAt}}function _Mt(n,t,e,s,r,i,o,a){return new qp(n,t,e,s,r,i,o,a)}function u9(n){return new qp(n)}function Xz(n){return n.filters.length===0&&n.limit===null&&n.startAt==null&&n.endAt==null&&(n.explicitOrderBy.length===0||n.explicitOrderBy.length===1&&n.explicitOrderBy[0].field.isKeyField())}function c9(n){return n.collectionGroup!==null}function vg(n){const t=De(n);if(t.Ie===null){t.Ie=[];const e=new Set;for(const i of t.explicitOrderBy)t.Ie.push(i),e.add(i.field.canonicalString());const s=t.explicitOrderBy.length>0?t.explicitOrderBy[t.explicitOrderBy.length-1].dir:"asc";(function(o){let a=new ar(yr.comparator);return o.filters.forEach((l=>{l.getFlattenedFilters().forEach((c=>{c.isInequality()&&(a=a.add(c.field))}))})),a})(t).forEach((i=>{e.has(i.canonicalString())||i.isKeyField()||t.Ie.push(new Yg(i,s))})),e.has(yr.keyField().canonicalString())||t.Ie.push(new Yg(yr.keyField(),s))}return t.Ie}function ul(n){const t=De(n);return t.Ee||(t.Ee=NMt(t,vg(n))),t.Ee}function NMt(n,t){if(n.limitType==="F")return Kz(n.path,n.collectionGroup,t,n.filters,n.limit,n.startAt,n.endAt);{t=t.map((r=>{const i=r.dir==="desc"?"asc":"desc";return new Yg(r.field,i)}));const e=n.endAt?new tw(n.endAt.position,n.endAt.inclusive):null,s=n.startAt?new tw(n.startAt.position,n.startAt.inclusive):null;return Kz(n.path,n.collectionGroup,t,n.filters,n.limit,e,s)}}function J$(n,t){const e=n.filters.concat([t]);return new qp(n.path,n.collectionGroup,n.explicitOrderBy.slice(),e,n.limit,n.limitType,n.startAt,n.endAt)}function ew(n,t,e){return new qp(n.path,n.collectionGroup,n.explicitOrderBy.slice(),n.filters.slice(),t,e,n.startAt,n.endAt)}function mS(n,t){return dN(ul(n),ul(t))&&n.limitType===t.limitType}function h9(n){return`${fN(ul(n))}|lt:${n.limitType}`}function $d(n){return`Query(target=${(function(e){let s=e.path.canonicalString();return e.collectionGroup!==null&&(s+=" collectionGroup="+e.collectionGroup),e.filters.length>0&&(s+=`, filters: [${e.filters.map((r=>a9(r))).join(", ")}]`),dS(e.limit)||(s+=", limit: "+e.limit),e.orderBy.length>0&&(s+=`, orderBy: [${e.orderBy.map((r=>(function(o){return`${o.field.canonicalString()} (${o.dir})`})(r))).join(", ")}]`),e.startAt&&(s+=", startAt: ",s+=e.startAt.inclusive?"b:":"a:",s+=e.startAt.position.map((r=>fp(r))).join(",")),e.endAt&&(s+=", endAt: ",s+=e.endAt.inclusive?"a:":"b:",s+=e.endAt.position.map((r=>fp(r))).join(",")),`Target(${s})`})(ul(n))}; limitType=${n.limitType})`}function gS(n,t){return t.isFoundDocument()&&(function(s,r){const i=r.key.path;return s.collectionGroup!==null?r.key.hasCollectionId(s.collectionGroup)&&s.path.isPrefixOf(i):ge.isDocumentKey(s.path)?s.path.isEqual(i):s.path.isImmediateParentOf(i)})(n,t)&&(function(s,r){for(const i of vg(s))if(!i.field.isKeyField()&&r.data.field(i.field)===null)return!1;return!0})(n,t)&&(function(s,r){for(const i of s.filters)if(!i.matches(r))return!1;return!0})(n,t)&&(function(s,r){return!(s.startAt&&!(function(o,a,l){const c=qz(o,a,l);return o.inclusive?c<=0:c<0})(s.startAt,vg(s),r)||s.endAt&&!(function(o,a,l){const c=qz(o,a,l);return o.inclusive?c>=0:c>0})(s.endAt,vg(s),r))})(n,t)}function RMt(n){return n.collectionGroup||(n.path.length%2==1?n.path.lastSegment():n.path.get(n.path.length-2))}function f9(n){return(t,e)=>{let s=!1;for(const r of vg(n)){const i=DMt(r,t,e);if(i!==0)return i;s=s||r.field.isKeyField()}return 0}}function DMt(n,t,e){const s=n.field.isKeyField()?ge.comparator(t.key,e.key):(function(i,o,a){const l=o.data.field(i),c=a.data.field(i);return l!==null&&c!==null?hp(l,c):Ce(42886)})(n.field,t,e);switch(n.dir){case"asc":return s;case"desc":return-1*s;default:return Ce(19790,{direction:n.dir})}}class Tf{constructor(t,e){this.mapKeyFn=t,this.equalsFn=e,this.inner={},this.innerSize=0}get(t){const e=this.mapKeyFn(t),s=this.inner[e];if(s!==void 0){for(const[r,i]of s)if(this.equalsFn(r,t))return i}}has(t){return this.get(t)!==void 0}set(t,e){const s=this.mapKeyFn(t),r=this.inner[s];if(r===void 0)return this.inner[s]=[[t,e]],void this.innerSize++;for(let i=0;i<r.length;i++)if(this.equalsFn(r[i][0],t))return void(r[i]=[t,e]);r.push([t,e]),this.innerSize++}delete(t){const e=this.mapKeyFn(t),s=this.inner[e];if(s===void 0)return!1;for(let r=0;r<s.length;r++)if(this.equalsFn(s[r][0],t))return s.length===1?delete this.inner[e]:s.splice(r,1),this.innerSize--,!0;return!1}forEach(t){If(this.inner,((e,s)=>{for(const[r,i]of s)t(r,i)}))}isEmpty(){return K8(this.inner)}size(){return this.innerSize}}const OMt=new ds(ge.comparator);function su(){return OMt}const d9=new ds(ge.comparator);function fg(...n){let t=d9;for(const e of n)t=t.insert(e.key,e);return t}function p9(n){let t=d9;return n.forEach(((e,s)=>t=t.insert(e,s.overlayedDocument))),t}function Eh(){return Sg()}function m9(){return Sg()}function Sg(){return new Tf((n=>n.toString()),((n,t)=>n.isEqual(t)))}const FMt=new ds(ge.comparator),MMt=new ar(ge.comparator);function Qe(...n){let t=MMt;for(const e of n)t=t.add(e);return t}const LMt=new ar(Ye);function zMt(){return LMt}function pN(n,t){if(n.useProto3Json){if(isNaN(t))return{doubleValue:"NaN"};if(t===1/0)return{doubleValue:"Infinity"};if(t===-1/0)return{doubleValue:"-Infinity"}}return{doubleValue:Qx(t)?"-0":t}}function g9(n){return{integerValue:""+n}}function BMt(n,t){return fMt(t)?g9(t):pN(n,t)}class yS{constructor(){this._=void 0}}function PMt(n,t,e){return n instanceof Qg?(function(r,i){const o={fields:{[Q8]:{stringValue:Y8},[J8]:{timestampValue:{seconds:r.seconds,nanos:r.nanoseconds}}}};return i&&cN(i)&&(i=pS(i)),i&&(o.fields[Z8]=i),{mapValue:o}})(e,t):n instanceof Zg?b9(n,t):n instanceof Jg?x9(n,t):(function(r,i){const o=y9(r,i),a=Yz(o)+Yz(r.Ae);return Y$(o)&&Y$(r.Ae)?g9(a):pN(r.serializer,a)})(n,t)}function VMt(n,t,e){return n instanceof Zg?b9(n,t):n instanceof Jg?x9(n,t):e}function y9(n,t){return n instanceof nw?(function(s){return Y$(s)||(function(i){return!!i&&"doubleValue"in i})(s)})(t)?t:{integerValue:0}:null}class Qg extends yS{}class Zg extends yS{constructor(t){super(),this.elements=t}}function b9(n,t){const e=w9(t);for(const s of n.elements)e.some((r=>bl(r,s)))||e.push(s);return{arrayValue:{values:e}}}class Jg extends yS{constructor(t){super(),this.elements=t}}function x9(n,t){let e=w9(t);for(const s of n.elements)e=e.filter((r=>!bl(r,s)));return{arrayValue:{values:e}}}class nw extends yS{constructor(t,e){super(),this.serializer=t,this.Ae=e}}function Yz(n){return Es(n.integerValue||n.doubleValue)}function w9(n){return hN(n)&&n.arrayValue.values?n.arrayValue.values.slice():[]}class UMt{constructor(t,e){this.field=t,this.transform=e}}function GMt(n,t){return n.field.isEqual(t.field)&&(function(s,r){return s instanceof Zg&&r instanceof Zg||s instanceof Jg&&r instanceof Jg?up(s.elements,r.elements,bl):s instanceof nw&&r instanceof nw?bl(s.Ae,r.Ae):s instanceof Qg&&r instanceof Qg})(n.transform,t.transform)}class WMt{constructor(t,e){this.version=t,this.transformResults=e}}class Kl{constructor(t,e){this.updateTime=t,this.exists=e}static none(){return new Kl}static exists(t){return new Kl(void 0,t)}static updateTime(t){return new Kl(t)}get isNone(){return this.updateTime===void 0&&this.exists===void 0}isEqual(t){return this.exists===t.exists&&(this.updateTime?!!t.updateTime&&this.updateTime.isEqual(t.updateTime):!t.updateTime)}}function J1(n,t){return n.updateTime!==void 0?t.isFoundDocument()&&t.version.isEqual(n.updateTime):n.exists===void 0||n.exists===t.isFoundDocument()}class bS{}function v9(n,t){if(!n.hasLocalMutations||t&&t.fields.length===0)return null;if(t===null)return n.isNoDocument()?new I9(n.key,Kl.none()):new Fb(n.key,n.data,Kl.none());{const e=n.data,s=yo.empty();let r=new ar(yr.comparator);for(let i of t.fields)if(!r.has(i)){let o=e.field(i);o===null&&i.length>1&&(i=i.popLast(),o=e.field(i)),o===null?s.delete(i):s.set(i,o),r=r.add(i)}return new Cf(n.key,s,new Zo(r.toArray()),Kl.none())}}function jMt(n,t,e){n instanceof Fb?(function(r,i,o){const a=r.value.clone(),l=Zz(r.fieldTransforms,i,o.transformResults);a.setAll(l),i.convertToFoundDocument(o.version,a).setHasCommittedMutations()})(n,t,e):n instanceof Cf?(function(r,i,o){if(!J1(r.precondition,i))return void i.convertToUnknownDocument(o.version);const a=Zz(r.fieldTransforms,i,o.transformResults),l=i.data;l.setAll(S9(r)),l.setAll(a),i.convertToFoundDocument(o.version,l).setHasCommittedMutations()})(n,t,e):(function(r,i,o){i.convertToNoDocument(o.version).setHasCommittedMutations()})(0,t,e)}function Ig(n,t,e,s){return n instanceof Fb?(function(i,o,a,l){if(!J1(i.precondition,o))return a;const c=i.value.clone(),f=Jz(i.fieldTransforms,l,o);return c.setAll(f),o.convertToFoundDocument(o.version,c).setHasLocalMutations(),null})(n,t,e,s):n instanceof Cf?(function(i,o,a,l){if(!J1(i.precondition,o))return a;const c=Jz(i.fieldTransforms,l,o),f=o.data;return f.setAll(S9(i)),f.setAll(c),o.convertToFoundDocument(o.version,f).setHasLocalMutations(),a===null?null:a.unionWith(i.fieldMask.fields).unionWith(i.fieldTransforms.map((d=>d.field)))})(n,t,e,s):(function(i,o,a){return J1(i.precondition,o)?(o.convertToNoDocument(o.version).setHasLocalMutations(),null):a})(n,t,e)}function qMt(n,t){let e=null;for(const s of n.fieldTransforms){const r=t.data.field(s.field),i=y9(s.transform,r||null);i!=null&&(e===null&&(e=yo.empty()),e.set(s.field,i))}return e||null}function Qz(n,t){return n.type===t.type&&!!n.key.isEqual(t.key)&&!!n.precondition.isEqual(t.precondition)&&!!(function(s,r){return s===void 0&&r===void 0||!(!s||!r)&&up(s,r,((i,o)=>GMt(i,o)))})(n.fieldTransforms,t.fieldTransforms)&&(n.type===0?n.value.isEqual(t.value):n.type!==1||n.data.isEqual(t.data)&&n.fieldMask.isEqual(t.fieldMask))}class Fb extends bS{constructor(t,e,s,r=[]){super(),this.key=t,this.value=e,this.precondition=s,this.fieldTransforms=r,this.type=0}getFieldMask(){return null}}class Cf extends bS{constructor(t,e,s,r,i=[]){super(),this.key=t,this.data=e,this.fieldMask=s,this.precondition=r,this.fieldTransforms=i,this.type=1}getFieldMask(){return this.fieldMask}}function S9(n){const t=new Map;return n.fieldMask.fields.forEach((e=>{if(!e.isEmpty()){const s=n.data.field(e);t.set(e,s)}})),t}function Zz(n,t,e){const s=new Map;Sn(n.length===e.length,32656,{Re:e.length,Ve:n.length});for(let r=0;r<e.length;r++){const i=n[r],o=i.transform,a=t.data.field(i.field);s.set(i.field,VMt(o,a,e[r]))}return s}function Jz(n,t,e){const s=new Map;for(const r of n){const i=r.transform,o=e.data.field(r.field);s.set(r.field,PMt(i,o,t))}return s}class I9 extends bS{constructor(t,e){super(),this.key=t,this.precondition=e,this.type=2,this.fieldTransforms=[]}getFieldMask(){return null}}class HMt extends bS{constructor(t,e){super(),this.key=t,this.precondition=e,this.type=3,this.fieldTransforms=[]}getFieldMask(){return null}}class KMt{constructor(t,e,s,r){this.batchId=t,this.localWriteTime=e,this.baseMutations=s,this.mutations=r}applyToRemoteDocument(t,e){const s=e.mutationResults;for(let r=0;r<this.mutations.length;r++){const i=this.mutations[r];i.key.isEqual(t.key)&&jMt(i,t,s[r])}}applyToLocalView(t,e){for(const s of this.baseMutations)s.key.isEqual(t.key)&&(e=Ig(s,t,e,this.localWriteTime));for(const s of this.mutations)s.key.isEqual(t.key)&&(e=Ig(s,t,e,this.localWriteTime));return e}applyToLocalDocumentSet(t,e){const s=m9();return this.mutations.forEach((r=>{const i=t.get(r.key),o=i.overlayedDocument;let a=this.applyToLocalView(o,i.mutatedFields);a=e.has(r.key)?null:a;const l=v9(o,a);l!==null&&s.set(r.key,l),o.isValidDocument()||o.convertToNoDocument(ke.min())})),s}keys(){return this.mutations.reduce(((t,e)=>t.add(e.key)),Qe())}isEqual(t){return this.batchId===t.batchId&&up(this.mutations,t.mutations,((e,s)=>Qz(e,s)))&&up(this.baseMutations,t.baseMutations,((e,s)=>Qz(e,s)))}}class mN{constructor(t,e,s,r){this.batch=t,this.commitVersion=e,this.mutationResults=s,this.docVersions=r}static from(t,e,s){Sn(t.mutations.length===s.length,58842,{me:t.mutations.length,fe:s.length});let r=(function(){return FMt})();const i=t.mutations;for(let o=0;o<i.length;o++)r=r.insert(i[o].key,s[o].version);return new mN(t,e,s,r)}}class XMt{constructor(t,e){this.largestBatchId=t,this.mutation=e}getKey(){return this.mutation.key}isEqual(t){return t!==null&&this.mutation===t.mutation}toString(){return`Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`}}class YMt{constructor(t,e){this.count=t,this.unchangedNames=e}}var Ps,on;function QMt(n){switch(n){case Gt.OK:return Ce(64938);case Gt.CANCELLED:case Gt.UNKNOWN:case Gt.DEADLINE_EXCEEDED:case Gt.RESOURCE_EXHAUSTED:case Gt.INTERNAL:case Gt.UNAVAILABLE:case Gt.UNAUTHENTICATED:return!1;case Gt.INVALID_ARGUMENT:case Gt.NOT_FOUND:case Gt.ALREADY_EXISTS:case Gt.PERMISSION_DENIED:case Gt.FAILED_PRECONDITION:case Gt.ABORTED:case Gt.OUT_OF_RANGE:case Gt.UNIMPLEMENTED:case Gt.DATA_LOSS:return!0;default:return Ce(15467,{code:n})}}function T9(n){if(n===void 0)return nu("GRPC error has no .code"),Gt.UNKNOWN;switch(n){case Ps.OK:return Gt.OK;case Ps.CANCELLED:return Gt.CANCELLED;case Ps.UNKNOWN:return Gt.UNKNOWN;case Ps.DEADLINE_EXCEEDED:return Gt.DEADLINE_EXCEEDED;case Ps.RESOURCE_EXHAUSTED:return Gt.RESOURCE_EXHAUSTED;case Ps.INTERNAL:return Gt.INTERNAL;case Ps.UNAVAILABLE:return Gt.UNAVAILABLE;case Ps.UNAUTHENTICATED:return Gt.UNAUTHENTICATED;case Ps.INVALID_ARGUMENT:return Gt.INVALID_ARGUMENT;case Ps.NOT_FOUND:return Gt.NOT_FOUND;case Ps.ALREADY_EXISTS:return Gt.ALREADY_EXISTS;case Ps.PERMISSION_DENIED:return Gt.PERMISSION_DENIED;case Ps.FAILED_PRECONDITION:return Gt.FAILED_PRECONDITION;case Ps.ABORTED:return Gt.ABORTED;case Ps.OUT_OF_RANGE:return Gt.OUT_OF_RANGE;case Ps.UNIMPLEMENTED:return Gt.UNIMPLEMENTED;case Ps.DATA_LOSS:return Gt.DATA_LOSS;default:return Ce(39323,{code:n})}}(on=Ps||(Ps={}))[on.OK=0]="OK",on[on.CANCELLED=1]="CANCELLED",on[on.UNKNOWN=2]="UNKNOWN",on[on.INVALID_ARGUMENT=3]="INVALID_ARGUMENT",on[on.DEADLINE_EXCEEDED=4]="DEADLINE_EXCEEDED",on[on.NOT_FOUND=5]="NOT_FOUND",on[on.ALREADY_EXISTS=6]="ALREADY_EXISTS",on[on.PERMISSION_DENIED=7]="PERMISSION_DENIED",on[on.UNAUTHENTICATED=16]="UNAUTHENTICATED",on[on.RESOURCE_EXHAUSTED=8]="RESOURCE_EXHAUSTED",on[on.FAILED_PRECONDITION=9]="FAILED_PRECONDITION",on[on.ABORTED=10]="ABORTED",on[on.OUT_OF_RANGE=11]="OUT_OF_RANGE",on[on.UNIMPLEMENTED=12]="UNIMPLEMENTED",on[on.INTERNAL=13]="INTERNAL",on[on.UNAVAILABLE=14]="UNAVAILABLE",on[on.DATA_LOSS=15]="DATA_LOSS";function ZMt(){return new TextEncoder}const JMt=new oc([4294967295,4294967295],0);function tB(n){const t=ZMt().encode(n),e=new F8;return e.update(t),new Uint8Array(e.digest())}function eB(n){const t=new DataView(n.buffer),e=t.getUint32(0,!0),s=t.getUint32(4,!0),r=t.getUint32(8,!0),i=t.getUint32(12,!0);return[new oc([e,s],0),new oc([r,i],0)]}class gN{constructor(t,e,s){if(this.bitmap=t,this.padding=e,this.hashCount=s,e<0||e>=8)throw new dg(`Invalid padding: ${e}`);if(s<0)throw new dg(`Invalid hash count: ${s}`);if(t.length>0&&this.hashCount===0)throw new dg(`Invalid hash count: ${s}`);if(t.length===0&&e!==0)throw new dg(`Invalid padding when bitmap length is 0: ${e}`);this.ge=8*t.length-e,this.pe=oc.fromNumber(this.ge)}ye(t,e,s){let r=t.add(e.multiply(oc.fromNumber(s)));return r.compare(JMt)===1&&(r=new oc([r.getBits(0),r.getBits(1)],0)),r.modulo(this.pe).toNumber()}we(t){return!!(this.bitmap[Math.floor(t/8)]&1<<t%8)}mightContain(t){if(this.ge===0)return!1;const e=tB(t),[s,r]=eB(e);for(let i=0;i<this.hashCount;i++){const o=this.ye(s,r,i);if(!this.we(o))return!1}return!0}static create(t,e,s){const r=t%8==0?0:8-t%8,i=new Uint8Array(Math.ceil(t/8)),o=new gN(i,r,e);return s.forEach((a=>o.insert(a))),o}insert(t){if(this.ge===0)return;const e=tB(t),[s,r]=eB(e);for(let i=0;i<this.hashCount;i++){const o=this.ye(s,r,i);this.Se(o)}}Se(t){const e=Math.floor(t/8),s=t%8;this.bitmap[e]|=1<<s}}class dg extends Error{constructor(){super(...arguments),this.name="BloomFilterError"}}class xS{constructor(t,e,s,r,i){this.snapshotVersion=t,this.targetChanges=e,this.targetMismatches=s,this.documentUpdates=r,this.resolvedLimboDocuments=i}static createSynthesizedRemoteEventForCurrentChange(t,e,s){const r=new Map;return r.set(t,Mb.createSynthesizedTargetChangeForCurrentChange(t,e,s)),new xS(ke.min(),r,new ds(Ye),su(),Qe())}}class Mb{constructor(t,e,s,r,i){this.resumeToken=t,this.current=e,this.addedDocuments=s,this.modifiedDocuments=r,this.removedDocuments=i}static createSynthesizedTargetChangeForCurrentChange(t,e,s){return new Mb(s,e,Qe(),Qe(),Qe())}}class tx{constructor(t,e,s,r){this.be=t,this.removedTargetIds=e,this.key=s,this.De=r}}class C9{constructor(t,e){this.targetId=t,this.Ce=e}}class E9{constructor(t,e,s=wr.EMPTY_BYTE_STRING,r=null){this.state=t,this.targetIds=e,this.resumeToken=s,this.cause=r}}class nB{constructor(){this.ve=0,this.Fe=sB(),this.Me=wr.EMPTY_BYTE_STRING,this.xe=!1,this.Oe=!0}get current(){return this.xe}get resumeToken(){return this.Me}get Ne(){return this.ve!==0}get Be(){return this.Oe}Le(t){t.approximateByteSize()>0&&(this.Oe=!0,this.Me=t)}ke(){let t=Qe(),e=Qe(),s=Qe();return this.Fe.forEach(((r,i)=>{switch(i){case 0:t=t.add(r);break;case 2:e=e.add(r);break;case 1:s=s.add(r);break;default:Ce(38017,{changeType:i})}})),new Mb(this.Me,this.xe,t,e,s)}qe(){this.Oe=!1,this.Fe=sB()}Qe(t,e){this.Oe=!0,this.Fe=this.Fe.insert(t,e)}$e(t){this.Oe=!0,this.Fe=this.Fe.remove(t)}Ue(){this.ve+=1}Ke(){this.ve-=1,Sn(this.ve>=0,3241,{ve:this.ve})}We(){this.Oe=!0,this.xe=!0}}class t3t{constructor(t){this.Ge=t,this.ze=new Map,this.je=su(),this.Je=R1(),this.He=R1(),this.Ye=new ds(Ye)}Ze(t){for(const e of t.be)t.De&&t.De.isFoundDocument()?this.Xe(e,t.De):this.et(e,t.key,t.De);for(const e of t.removedTargetIds)this.et(e,t.key,t.De)}tt(t){this.forEachTarget(t,(e=>{const s=this.nt(e);switch(t.state){case 0:this.rt(e)&&s.Le(t.resumeToken);break;case 1:s.Ke(),s.Ne||s.qe(),s.Le(t.resumeToken);break;case 2:s.Ke(),s.Ne||this.removeTarget(e);break;case 3:this.rt(e)&&(s.We(),s.Le(t.resumeToken));break;case 4:this.rt(e)&&(this.it(e),s.Le(t.resumeToken));break;default:Ce(56790,{state:t.state})}}))}forEachTarget(t,e){t.targetIds.length>0?t.targetIds.forEach(e):this.ze.forEach(((s,r)=>{this.rt(r)&&e(r)}))}st(t){const e=t.targetId,s=t.Ce.count,r=this.ot(e);if(r){const i=r.target;if(Z$(i))if(s===0){const o=new ge(i.path);this.et(e,o,jr.newNoDocument(o,ke.min()))}else Sn(s===1,20013,{expectedCount:s});else{const o=this._t(e);if(o!==s){const a=this.ut(t),l=a?this.ct(a,t,o):1;if(l!==0){this.it(e);const c=l===2?"TargetPurposeExistenceFilterMismatchBloom":"TargetPurposeExistenceFilterMismatch";this.Ye=this.Ye.insert(e,c)}}}}}ut(t){const e=t.Ce.unchangedNames;if(!e||!e.bits)return null;const{bits:{bitmap:s="",padding:r=0},hashCount:i=0}=e;let o,a;try{o=Tc(s).toUint8Array()}catch(l){if(l instanceof X8)return nf("Decoding the base64 bloom filter in existence filter failed ("+l.message+"); ignoring the bloom filter and falling back to full re-query."),null;throw l}try{a=new gN(o,r,i)}catch(l){return nf(l instanceof dg?"BloomFilter error: ":"Applying bloom filter failed: ",l),null}return a.ge===0?null:a}ct(t,e,s){return e.Ce.count===s-this.Pt(t,e.targetId)?0:2}Pt(t,e){const s=this.Ge.getRemoteKeysForTarget(e);let r=0;return s.forEach((i=>{const o=this.Ge.ht(),a=`projects/${o.projectId}/databases/${o.database}/documents/${i.path.canonicalString()}`;t.mightContain(a)||(this.et(e,i,null),r++)})),r}Tt(t){const e=new Map;this.ze.forEach(((i,o)=>{const a=this.ot(o);if(a){if(i.current&&Z$(a.target)){const l=new ge(a.target.path);this.It(l).has(o)||this.Et(o,l)||this.et(o,l,jr.newNoDocument(l,t))}i.Be&&(e.set(o,i.ke()),i.qe())}}));let s=Qe();this.He.forEach(((i,o)=>{let a=!0;o.forEachWhile((l=>{const c=this.ot(l);return!c||c.purpose==="TargetPurposeLimboResolution"||(a=!1,!1)})),a&&(s=s.add(i))})),this.je.forEach(((i,o)=>o.setReadTime(t)));const r=new xS(t,e,this.Ye,this.je,s);return this.je=su(),this.Je=R1(),this.He=R1(),this.Ye=new ds(Ye),r}Xe(t,e){if(!this.rt(t))return;const s=this.Et(t,e.key)?2:0;this.nt(t).Qe(e.key,s),this.je=this.je.insert(e.key,e),this.Je=this.Je.insert(e.key,this.It(e.key).add(t)),this.He=this.He.insert(e.key,this.dt(e.key).add(t))}et(t,e,s){if(!this.rt(t))return;const r=this.nt(t);this.Et(t,e)?r.Qe(e,1):r.$e(e),this.He=this.He.insert(e,this.dt(e).delete(t)),this.He=this.He.insert(e,this.dt(e).add(t)),s&&(this.je=this.je.insert(e,s))}removeTarget(t){this.ze.delete(t)}_t(t){const e=this.nt(t).ke();return this.Ge.getRemoteKeysForTarget(t).size+e.addedDocuments.size-e.removedDocuments.size}Ue(t){this.nt(t).Ue()}nt(t){let e=this.ze.get(t);return e||(e=new nB,this.ze.set(t,e)),e}dt(t){let e=this.He.get(t);return e||(e=new ar(Ye),this.He=this.He.insert(t,e)),e}It(t){let e=this.Je.get(t);return e||(e=new ar(Ye),this.Je=this.Je.insert(t,e)),e}rt(t){const e=this.ot(t)!==null;return e||re("WatchChangeAggregator","Detected inactive target",t),e}ot(t){const e=this.ze.get(t);return e&&e.Ne?null:this.Ge.At(t)}it(t){this.ze.set(t,new nB),this.Ge.getRemoteKeysForTarget(t).forEach((e=>{this.et(t,e,null)}))}Et(t,e){return this.Ge.getRemoteKeysForTarget(t).has(e)}}function R1(){return new ds(ge.comparator)}function sB(){return new ds(ge.comparator)}const e3t={asc:"ASCENDING",desc:"DESCENDING"},n3t={"<":"LESS_THAN","<=":"LESS_THAN_OR_EQUAL",">":"GREATER_THAN",">=":"GREATER_THAN_OR_EQUAL","==":"EQUAL","!=":"NOT_EQUAL","array-contains":"ARRAY_CONTAINS",in:"IN","not-in":"NOT_IN","array-contains-any":"ARRAY_CONTAINS_ANY"},s3t={and:"AND",or:"OR"};class r3t{constructor(t,e){this.databaseId=t,this.useProto3Json=e}}function t2(n,t){return n.useProto3Json||dS(t)?t:{value:t}}function sw(n,t){return n.useProto3Json?`${new Date(1e3*t.seconds).toISOString().replace(/\.\d*/,"").replace("Z","")}.${("000000000"+t.nanoseconds).slice(-9)}Z`:{seconds:""+t.seconds,nanos:t.nanoseconds}}function $9(n,t){return n.useProto3Json?t.toBase64():t.toUint8Array()}function i3t(n,t){return sw(n,t.toTimestamp())}function cl(n){return Sn(!!n,49232),ke.fromTimestamp((function(e){const s=Ic(e);return new Hn(s.seconds,s.nanos)})(n))}function yN(n,t){return e2(n,t).canonicalString()}function e2(n,t){const e=(function(r){return new qn(["projects",r.projectId,"databases",r.database])})(n).child("documents");return t===void 0?e:e.child(t)}function A9(n){const t=qn.fromString(n);return Sn(D9(t),10190,{key:t.toString()}),t}function n2(n,t){return yN(n.databaseId,t.path)}function SE(n,t){const e=A9(t);if(e.get(1)!==n.databaseId.projectId)throw new se(Gt.INVALID_ARGUMENT,"Tried to deserialize key from different project: "+e.get(1)+" vs "+n.databaseId.projectId);if(e.get(3)!==n.databaseId.database)throw new se(Gt.INVALID_ARGUMENT,"Tried to deserialize key from different database: "+e.get(3)+" vs "+n.databaseId.database);return new ge(_9(e))}function k9(n,t){return yN(n.databaseId,t)}function o3t(n){const t=A9(n);return t.length===4?qn.emptyPath():_9(t)}function s2(n){return new qn(["projects",n.databaseId.projectId,"databases",n.databaseId.database]).canonicalString()}function _9(n){return Sn(n.length>4&&n.get(4)==="documents",29091,{key:n.toString()}),n.popFirst(5)}function rB(n,t,e){return{name:n2(n,t),fields:e.value.mapValue.fields}}function a3t(n,t){let e;if("targetChange"in t){t.targetChange;const s=(function(c){return c==="NO_CHANGE"?0:c==="ADD"?1:c==="REMOVE"?2:c==="CURRENT"?3:c==="RESET"?4:Ce(39313,{state:c})})(t.targetChange.targetChangeType||"NO_CHANGE"),r=t.targetChange.targetIds||[],i=(function(c,f){return c.useProto3Json?(Sn(f===void 0||typeof f=="string",58123),wr.fromBase64String(f||"")):(Sn(f===void 0||f instanceof ou||f instanceof Uint8Array,16193),wr.fromUint8Array(f||new Uint8Array))})(n,t.targetChange.resumeToken),o=t.targetChange.cause,a=o&&(function(c){const f=c.code===void 0?Gt.UNKNOWN:T9(c.code);return new se(f,c.message||"")})(o);e=new E9(s,r,i,a||null)}else if("documentChange"in t){t.documentChange;const s=t.documentChange;s.document,s.document.name,s.document.updateTime;const r=SE(n,s.document.name),i=cl(s.document.updateTime),o=s.document.createTime?cl(s.document.createTime):ke.min(),a=new yo({mapValue:{fields:s.document.fields}}),l=jr.newFoundDocument(r,i,o,a),c=s.targetIds||[],f=s.removedTargetIds||[];e=new tx(c,f,l.key,l)}else if("documentDelete"in t){t.documentDelete;const s=t.documentDelete;s.document;const r=SE(n,s.document),i=s.readTime?cl(s.readTime):ke.min(),o=jr.newNoDocument(r,i),a=s.removedTargetIds||[];e=new tx([],a,o.key,o)}else if("documentRemove"in t){t.documentRemove;const s=t.documentRemove;s.document;const r=SE(n,s.document),i=s.removedTargetIds||[];e=new tx([],i,r,null)}else{if(!("filter"in t))return Ce(11601,{Rt:t});{t.filter;const s=t.filter;s.targetId;const{count:r=0,unchangedNames:i}=s,o=new YMt(r,i),a=s.targetId;e=new C9(a,o)}}return e}function l3t(n,t){let e;if(t instanceof Fb)e={update:rB(n,t.key,t.value)};else if(t instanceof I9)e={delete:n2(n,t.key)};else if(t instanceof Cf)e={update:rB(n,t.key,t.data),updateMask:y3t(t.fieldMask)};else{if(!(t instanceof HMt))return Ce(16599,{Vt:t.type});e={verify:n2(n,t.key)}}return t.fieldTransforms.length>0&&(e.updateTransforms=t.fieldTransforms.map((s=>(function(i,o){const a=o.transform;if(a instanceof Qg)return{fieldPath:o.field.canonicalString(),setToServerValue:"REQUEST_TIME"};if(a instanceof Zg)return{fieldPath:o.field.canonicalString(),appendMissingElements:{values:a.elements}};if(a instanceof Jg)return{fieldPath:o.field.canonicalString(),removeAllFromArray:{values:a.elements}};if(a instanceof nw)return{fieldPath:o.field.canonicalString(),increment:a.Ae};throw Ce(20930,{transform:o.transform})})(0,s)))),t.precondition.isNone||(e.currentDocument=(function(r,i){return i.updateTime!==void 0?{updateTime:i3t(r,i.updateTime)}:i.exists!==void 0?{exists:i.exists}:Ce(27497)})(n,t.precondition)),e}function u3t(n,t){return n&&n.length>0?(Sn(t!==void 0,14353),n.map((e=>(function(r,i){let o=r.updateTime?cl(r.updateTime):cl(i);return o.isEqual(ke.min())&&(o=cl(i)),new WMt(o,r.transformResults||[])})(e,t)))):[]}function c3t(n,t){return{documents:[k9(n,t.path)]}}function h3t(n,t){const e={structuredQuery:{}},s=t.path;let r;t.collectionGroup!==null?(r=s,e.structuredQuery.from=[{collectionId:t.collectionGroup,allDescendants:!0}]):(r=s.popLast(),e.structuredQuery.from=[{collectionId:s.lastSegment()}]),e.parent=k9(n,r);const i=(function(c){if(c.length!==0)return R9(pa.create(c,"and"))})(t.filters);i&&(e.structuredQuery.where=i);const o=(function(c){if(c.length!==0)return c.map((f=>(function(m){return{field:Ad(m.field),direction:p3t(m.dir)}})(f)))})(t.orderBy);o&&(e.structuredQuery.orderBy=o);const a=t2(n,t.limit);return a!==null&&(e.structuredQuery.limit=a),t.startAt&&(e.structuredQuery.startAt=(function(c){return{before:c.inclusive,values:c.position}})(t.startAt)),t.endAt&&(e.structuredQuery.endAt=(function(c){return{before:!c.inclusive,values:c.position}})(t.endAt)),{ft:e,parent:r}}function f3t(n){let t=o3t(n.parent);const e=n.structuredQuery,s=e.from?e.from.length:0;let r=null;if(s>0){Sn(s===1,65062);const f=e.from[0];f.allDescendants?r=f.collectionId:t=t.child(f.collectionId)}let i=[];e.where&&(i=(function(d){const m=N9(d);return m instanceof pa&&i9(m)?m.getFilters():[m]})(e.where));let o=[];e.orderBy&&(o=(function(d){return d.map((m=>(function(b){return new Yg(kd(b.field),(function(x){switch(x){case"ASCENDING":return"asc";case"DESCENDING":return"desc";default:return}})(b.direction))})(m)))})(e.orderBy));let a=null;e.limit&&(a=(function(d){let m;return m=typeof d=="object"?d.value:d,dS(m)?null:m})(e.limit));let l=null;e.startAt&&(l=(function(d){const m=!!d.before,y=d.values||[];return new tw(y,m)})(e.startAt));let c=null;return e.endAt&&(c=(function(d){const m=!d.before,y=d.values||[];return new tw(y,m)})(e.endAt)),_Mt(t,r,o,i,a,"F",l,c)}function d3t(n,t){const e=(function(r){switch(r){case"TargetPurposeListen":return null;case"TargetPurposeExistenceFilterMismatch":return"existence-filter-mismatch";case"TargetPurposeExistenceFilterMismatchBloom":return"existence-filter-mismatch-bloom";case"TargetPurposeLimboResolution":return"limbo-document";default:return Ce(28987,{purpose:r})}})(t.purpose);return e==null?null:{"goog-listen-tags":e}}function N9(n){return n.unaryFilter!==void 0?(function(e){switch(e.unaryFilter.op){case"IS_NAN":const s=kd(e.unaryFilter.field);return Us.create(s,"==",{doubleValue:NaN});case"IS_NULL":const r=kd(e.unaryFilter.field);return Us.create(r,"==",{nullValue:"NULL_VALUE"});case"IS_NOT_NAN":const i=kd(e.unaryFilter.field);return Us.create(i,"!=",{doubleValue:NaN});case"IS_NOT_NULL":const o=kd(e.unaryFilter.field);return Us.create(o,"!=",{nullValue:"NULL_VALUE"});case"OPERATOR_UNSPECIFIED":return Ce(61313);default:return Ce(60726)}})(n):n.fieldFilter!==void 0?(function(e){return Us.create(kd(e.fieldFilter.field),(function(r){switch(r){case"EQUAL":return"==";case"NOT_EQUAL":return"!=";case"GREATER_THAN":return">";case"GREATER_THAN_OR_EQUAL":return">=";case"LESS_THAN":return"<";case"LESS_THAN_OR_EQUAL":return"<=";case"ARRAY_CONTAINS":return"array-contains";case"IN":return"in";case"NOT_IN":return"not-in";case"ARRAY_CONTAINS_ANY":return"array-contains-any";case"OPERATOR_UNSPECIFIED":return Ce(58110);default:return Ce(50506)}})(e.fieldFilter.op),e.fieldFilter.value)})(n):n.compositeFilter!==void 0?(function(e){return pa.create(e.compositeFilter.filters.map((s=>N9(s))),(function(r){switch(r){case"AND":return"and";case"OR":return"or";default:return Ce(1026)}})(e.compositeFilter.op))})(n):Ce(30097,{filter:n})}function p3t(n){return e3t[n]}function m3t(n){return n3t[n]}function g3t(n){return s3t[n]}function Ad(n){return{fieldPath:n.canonicalString()}}function kd(n){return yr.fromServerFormat(n.fieldPath)}function R9(n){return n instanceof Us?(function(e){if(e.op==="=="){if(jz(e.value))return{unaryFilter:{field:Ad(e.field),op:"IS_NAN"}};if(Wz(e.value))return{unaryFilter:{field:Ad(e.field),op:"IS_NULL"}}}else if(e.op==="!="){if(jz(e.value))return{unaryFilter:{field:Ad(e.field),op:"IS_NOT_NAN"}};if(Wz(e.value))return{unaryFilter:{field:Ad(e.field),op:"IS_NOT_NULL"}}}return{fieldFilter:{field:Ad(e.field),op:m3t(e.op),value:e.value}}})(n):n instanceof pa?(function(e){const s=e.getFilters().map((r=>R9(r)));return s.length===1?s[0]:{compositeFilter:{op:g3t(e.op),filters:s}}})(n):Ce(54877,{filter:n})}function y3t(n){const t=[];return n.fields.forEach((e=>t.push(e.canonicalString()))),{fieldPaths:t}}function D9(n){return n.length>=4&&n.get(0)==="projects"&&n.get(2)==="databases"}class Qu{constructor(t,e,s,r,i=ke.min(),o=ke.min(),a=wr.EMPTY_BYTE_STRING,l=null){this.target=t,this.targetId=e,this.purpose=s,this.sequenceNumber=r,this.snapshotVersion=i,this.lastLimboFreeSnapshotVersion=o,this.resumeToken=a,this.expectedCount=l}withSequenceNumber(t){return new Qu(this.target,this.targetId,this.purpose,t,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,this.expectedCount)}withResumeToken(t,e){return new Qu(this.target,this.targetId,this.purpose,this.sequenceNumber,e,this.lastLimboFreeSnapshotVersion,t,null)}withExpectedCount(t){return new Qu(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,t)}withLastLimboFreeSnapshotVersion(t){return new Qu(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,t,this.resumeToken,this.expectedCount)}}class b3t{constructor(t){this.yt=t}}function x3t(n){const t=f3t({parent:n.parent,structuredQuery:n.structuredQuery});return n.limitType==="LAST"?ew(t,t.limit,"L"):t}class w3t{constructor(){this.Cn=new v3t}addToCollectionParentIndex(t,e){return this.Cn.add(e),jt.resolve()}getCollectionParents(t,e){return jt.resolve(this.Cn.getEntries(e))}addFieldIndex(t,e){return jt.resolve()}deleteFieldIndex(t,e){return jt.resolve()}deleteAllFieldIndexes(t){return jt.resolve()}createTargetIndexes(t,e){return jt.resolve()}getDocumentsMatchingTarget(t,e){return jt.resolve(null)}getIndexType(t,e){return jt.resolve(0)}getFieldIndexes(t,e){return jt.resolve([])}getNextCollectionGroupToUpdate(t){return jt.resolve(null)}getMinOffset(t,e){return jt.resolve(Sc.min())}getMinOffsetFromCollectionGroup(t,e){return jt.resolve(Sc.min())}updateCollectionGroup(t,e,s){return jt.resolve()}updateIndexEntries(t,e){return jt.resolve()}}class v3t{constructor(){this.index={}}add(t){const e=t.lastSegment(),s=t.popLast(),r=this.index[e]||new ar(qn.comparator),i=!r.has(s);return this.index[e]=r.add(s),i}has(t){const e=t.lastSegment(),s=t.popLast(),r=this.index[e];return r&&r.has(s)}getEntries(t){return(this.index[t]||new ar(qn.comparator)).toArray()}}const iB={didRun:!1,sequenceNumbersCollected:0,targetsRemoved:0,documentsRemoved:0},O9=41943040;class Si{static withCacheSize(t){return new Si(t,Si.DEFAULT_COLLECTION_PERCENTILE,Si.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT)}constructor(t,e,s){this.cacheSizeCollectionThreshold=t,this.percentileToCollect=e,this.maximumSequenceNumbersToCollect=s}}Si.DEFAULT_COLLECTION_PERCENTILE=10,Si.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT=1e3,Si.DEFAULT=new Si(O9,Si.DEFAULT_COLLECTION_PERCENTILE,Si.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT),Si.DISABLED=new Si(-1,0,0);class dp{constructor(t){this.ar=t}next(){return this.ar+=2,this.ar}static ur(){return new dp(0)}static cr(){return new dp(-1)}}const oB="LruGarbageCollector",S3t=1048576;function aB([n,t],[e,s]){const r=Ye(n,e);return r===0?Ye(t,s):r}class I3t{constructor(t){this.Ir=t,this.buffer=new ar(aB),this.Er=0}dr(){return++this.Er}Ar(t){const e=[t,this.dr()];if(this.buffer.size<this.Ir)this.buffer=this.buffer.add(e);else{const s=this.buffer.last();aB(e,s)<0&&(this.buffer=this.buffer.delete(s).add(e))}}get maxValue(){return this.buffer.last()[0]}}class T3t{constructor(t,e,s){this.garbageCollector=t,this.asyncQueue=e,this.localStore=s,this.Rr=null}start(){this.garbageCollector.params.cacheSizeCollectionThreshold!==-1&&this.Vr(6e4)}stop(){this.Rr&&(this.Rr.cancel(),this.Rr=null)}get started(){return this.Rr!==null}Vr(t){re(oB,`Garbage collection scheduled in ${t}ms`),this.Rr=this.asyncQueue.enqueueAfterDelay("lru_garbage_collection",t,(async()=>{this.Rr=null;try{await this.localStore.collectGarbage(this.garbageCollector)}catch(e){jp(e)?re(oB,"Ignoring IndexedDB error during garbage collection: ",e):await Wp(e)}await this.Vr(3e5)}))}}class C3t{constructor(t,e){this.mr=t,this.params=e}calculateTargetCount(t,e){return this.mr.gr(t).next((s=>Math.floor(e/100*s)))}nthSequenceNumber(t,e){if(e===0)return jt.resolve(fS.ce);const s=new I3t(e);return this.mr.forEachTarget(t,(r=>s.Ar(r.sequenceNumber))).next((()=>this.mr.pr(t,(r=>s.Ar(r))))).next((()=>s.maxValue))}removeTargets(t,e,s){return this.mr.removeTargets(t,e,s)}removeOrphanedDocuments(t,e){return this.mr.removeOrphanedDocuments(t,e)}collect(t,e){return this.params.cacheSizeCollectionThreshold===-1?(re("LruGarbageCollector","Garbage collection skipped; disabled"),jt.resolve(iB)):this.getCacheSize(t).next((s=>s<this.params.cacheSizeCollectionThreshold?(re("LruGarbageCollector",`Garbage collection skipped; Cache size ${s} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`),iB):this.yr(t,e)))}getCacheSize(t){return this.mr.getCacheSize(t)}yr(t,e){let s,r,i,o,a,l,c;const f=Date.now();return this.calculateTargetCount(t,this.params.percentileToCollect).next((d=>(d>this.params.maximumSequenceNumbersToCollect?(re("LruGarbageCollector",`Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${d}`),r=this.params.maximumSequenceNumbersToCollect):r=d,o=Date.now(),this.nthSequenceNumber(t,r)))).next((d=>(s=d,a=Date.now(),this.removeTargets(t,s,e)))).next((d=>(i=d,l=Date.now(),this.removeOrphanedDocuments(t,s)))).next((d=>(c=Date.now(),Ed()<=an.DEBUG&&re("LruGarbageCollector",`LRU Garbage Collection
	Counted targets in ${o-f}ms
	Determined least recently used ${r} in `+(a-o)+`ms
	Removed ${i} targets in `+(l-a)+`ms
	Removed ${d} documents in `+(c-l)+`ms
Total Duration: ${c-f}ms`),jt.resolve({didRun:!0,sequenceNumbersCollected:r,targetsRemoved:i,documentsRemoved:d}))))}}function E3t(n,t){return new C3t(n,t)}class $3t{constructor(){this.changes=new Tf((t=>t.toString()),((t,e)=>t.isEqual(e))),this.changesApplied=!1}addEntry(t){this.assertNotApplied(),this.changes.set(t.key,t)}removeEntry(t,e){this.assertNotApplied(),this.changes.set(t,jr.newInvalidDocument(t).setReadTime(e))}getEntry(t,e){this.assertNotApplied();const s=this.changes.get(e);return s!==void 0?jt.resolve(s):this.getFromCache(t,e)}getEntries(t,e){return this.getAllFromCache(t,e)}apply(t){return this.assertNotApplied(),this.changesApplied=!0,this.applyChanges(t)}assertNotApplied(){}}class A3t{constructor(t,e){this.overlayedDocument=t,this.mutatedFields=e}}class k3t{constructor(t,e,s,r){this.remoteDocumentCache=t,this.mutationQueue=e,this.documentOverlayCache=s,this.indexManager=r}getDocument(t,e){let s=null;return this.documentOverlayCache.getOverlay(t,e).next((r=>(s=r,this.remoteDocumentCache.getEntry(t,e)))).next((r=>(s!==null&&Ig(s.mutation,r,Zo.empty(),Hn.now()),r)))}getDocuments(t,e){return this.remoteDocumentCache.getEntries(t,e).next((s=>this.getLocalViewOfDocuments(t,s,Qe()).next((()=>s))))}getLocalViewOfDocuments(t,e,s=Qe()){const r=Eh();return this.populateOverlays(t,r,e).next((()=>this.computeViews(t,e,r,s).next((i=>{let o=fg();return i.forEach(((a,l)=>{o=o.insert(a,l.overlayedDocument)})),o}))))}getOverlayedDocuments(t,e){const s=Eh();return this.populateOverlays(t,s,e).next((()=>this.computeViews(t,e,s,Qe())))}populateOverlays(t,e,s){const r=[];return s.forEach((i=>{e.has(i)||r.push(i)})),this.documentOverlayCache.getOverlays(t,r).next((i=>{i.forEach(((o,a)=>{e.set(o,a)}))}))}computeViews(t,e,s,r){let i=su();const o=Sg(),a=(function(){return Sg()})();return e.forEach(((l,c)=>{const f=s.get(c.key);r.has(c.key)&&(f===void 0||f.mutation instanceof Cf)?i=i.insert(c.key,c):f!==void 0?(o.set(c.key,f.mutation.getFieldMask()),Ig(f.mutation,c,f.mutation.getFieldMask(),Hn.now())):o.set(c.key,Zo.empty())})),this.recalculateAndSaveOverlays(t,i).next((l=>(l.forEach(((c,f)=>o.set(c,f))),e.forEach(((c,f)=>a.set(c,new A3t(f,o.get(c)??null)))),a)))}recalculateAndSaveOverlays(t,e){const s=Sg();let r=new ds(((o,a)=>o-a)),i=Qe();return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(t,e).next((o=>{for(const a of o)a.keys().forEach((l=>{const c=e.get(l);if(c===null)return;let f=s.get(l)||Zo.empty();f=a.applyToLocalView(c,f),s.set(l,f);const d=(r.get(a.batchId)||Qe()).add(l);r=r.insert(a.batchId,d)}))})).next((()=>{const o=[],a=r.getReverseIterator();for(;a.hasNext();){const l=a.getNext(),c=l.key,f=l.value,d=m9();f.forEach((m=>{if(!i.has(m)){const y=v9(e.get(m),s.get(m));y!==null&&d.set(m,y),i=i.add(m)}})),o.push(this.documentOverlayCache.saveOverlays(t,c,d))}return jt.waitFor(o)})).next((()=>s))}recalculateAndSaveOverlaysForDocumentKeys(t,e){return this.remoteDocumentCache.getEntries(t,e).next((s=>this.recalculateAndSaveOverlays(t,s)))}getDocumentsMatchingQuery(t,e,s,r){return(function(o){return ge.isDocumentKey(o.path)&&o.collectionGroup===null&&o.filters.length===0})(e)?this.getDocumentsMatchingDocumentQuery(t,e.path):c9(e)?this.getDocumentsMatchingCollectionGroupQuery(t,e,s,r):this.getDocumentsMatchingCollectionQuery(t,e,s,r)}getNextDocuments(t,e,s,r){return this.remoteDocumentCache.getAllFromCollectionGroup(t,e,s,r).next((i=>{const o=r-i.size>0?this.documentOverlayCache.getOverlaysForCollectionGroup(t,e,s.largestBatchId,r-i.size):jt.resolve(Eh());let a=Hg,l=i;return o.next((c=>jt.forEach(c,((f,d)=>(a<d.largestBatchId&&(a=d.largestBatchId),i.get(f)?jt.resolve():this.remoteDocumentCache.getEntry(t,f).next((m=>{l=l.insert(f,m)}))))).next((()=>this.populateOverlays(t,c,i))).next((()=>this.computeViews(t,l,c,Qe()))).next((f=>({batchId:a,changes:p9(f)})))))}))}getDocumentsMatchingDocumentQuery(t,e){return this.getDocument(t,new ge(e)).next((s=>{let r=fg();return s.isFoundDocument()&&(r=r.insert(s.key,s)),r}))}getDocumentsMatchingCollectionGroupQuery(t,e,s,r){const i=e.collectionGroup;let o=fg();return this.indexManager.getCollectionParents(t,i).next((a=>jt.forEach(a,(l=>{const c=(function(d,m){return new qp(m,null,d.explicitOrderBy.slice(),d.filters.slice(),d.limit,d.limitType,d.startAt,d.endAt)})(e,l.child(i));return this.getDocumentsMatchingCollectionQuery(t,c,s,r).next((f=>{f.forEach(((d,m)=>{o=o.insert(d,m)}))}))})).next((()=>o))))}getDocumentsMatchingCollectionQuery(t,e,s,r){let i;return this.documentOverlayCache.getOverlaysForCollection(t,e.path,s.largestBatchId).next((o=>(i=o,this.remoteDocumentCache.getDocumentsMatchingQuery(t,e,s,i,r)))).next((o=>{i.forEach(((l,c)=>{const f=c.getKey();o.get(f)===null&&(o=o.insert(f,jr.newInvalidDocument(f)))}));let a=fg();return o.forEach(((l,c)=>{const f=i.get(l);f!==void 0&&Ig(f.mutation,c,Zo.empty(),Hn.now()),gS(e,c)&&(a=a.insert(l,c))})),a}))}}class _3t{constructor(t){this.serializer=t,this.Lr=new Map,this.kr=new Map}getBundleMetadata(t,e){return jt.resolve(this.Lr.get(e))}saveBundleMetadata(t,e){return this.Lr.set(e.id,(function(r){return{id:r.id,version:r.version,createTime:cl(r.createTime)}})(e)),jt.resolve()}getNamedQuery(t,e){return jt.resolve(this.kr.get(e))}saveNamedQuery(t,e){return this.kr.set(e.name,(function(r){return{name:r.name,query:x3t(r.bundledQuery),readTime:cl(r.readTime)}})(e)),jt.resolve()}}class N3t{constructor(){this.overlays=new ds(ge.comparator),this.qr=new Map}getOverlay(t,e){return jt.resolve(this.overlays.get(e))}getOverlays(t,e){const s=Eh();return jt.forEach(e,(r=>this.getOverlay(t,r).next((i=>{i!==null&&s.set(r,i)})))).next((()=>s))}saveOverlays(t,e,s){return s.forEach(((r,i)=>{this.St(t,e,i)})),jt.resolve()}removeOverlaysForBatchId(t,e,s){const r=this.qr.get(s);return r!==void 0&&(r.forEach((i=>this.overlays=this.overlays.remove(i))),this.qr.delete(s)),jt.resolve()}getOverlaysForCollection(t,e,s){const r=Eh(),i=e.length+1,o=new ge(e.child("")),a=this.overlays.getIteratorFrom(o);for(;a.hasNext();){const l=a.getNext().value,c=l.getKey();if(!e.isPrefixOf(c.path))break;c.path.length===i&&l.largestBatchId>s&&r.set(l.getKey(),l)}return jt.resolve(r)}getOverlaysForCollectionGroup(t,e,s,r){let i=new ds(((c,f)=>c-f));const o=this.overlays.getIterator();for(;o.hasNext();){const c=o.getNext().value;if(c.getKey().getCollectionGroup()===e&&c.largestBatchId>s){let f=i.get(c.largestBatchId);f===null&&(f=Eh(),i=i.insert(c.largestBatchId,f)),f.set(c.getKey(),c)}}const a=Eh(),l=i.getIterator();for(;l.hasNext()&&(l.getNext().value.forEach(((c,f)=>a.set(c,f))),!(a.size()>=r)););return jt.resolve(a)}St(t,e,s){const r=this.overlays.get(s.key);if(r!==null){const o=this.qr.get(r.largestBatchId).delete(s.key);this.qr.set(r.largestBatchId,o)}this.overlays=this.overlays.insert(s.key,new XMt(e,s));let i=this.qr.get(e);i===void 0&&(i=Qe(),this.qr.set(e,i)),this.qr.set(e,i.add(s.key))}}class R3t{constructor(){this.sessionToken=wr.EMPTY_BYTE_STRING}getSessionToken(t){return jt.resolve(this.sessionToken)}setSessionToken(t,e){return this.sessionToken=e,jt.resolve()}}class bN{constructor(){this.Qr=new ar(pr.$r),this.Ur=new ar(pr.Kr)}isEmpty(){return this.Qr.isEmpty()}addReference(t,e){const s=new pr(t,e);this.Qr=this.Qr.add(s),this.Ur=this.Ur.add(s)}Wr(t,e){t.forEach((s=>this.addReference(s,e)))}removeReference(t,e){this.Gr(new pr(t,e))}zr(t,e){t.forEach((s=>this.removeReference(s,e)))}jr(t){const e=new ge(new qn([])),s=new pr(e,t),r=new pr(e,t+1),i=[];return this.Ur.forEachInRange([s,r],(o=>{this.Gr(o),i.push(o.key)})),i}Jr(){this.Qr.forEach((t=>this.Gr(t)))}Gr(t){this.Qr=this.Qr.delete(t),this.Ur=this.Ur.delete(t)}Hr(t){const e=new ge(new qn([])),s=new pr(e,t),r=new pr(e,t+1);let i=Qe();return this.Ur.forEachInRange([s,r],(o=>{i=i.add(o.key)})),i}containsKey(t){const e=new pr(t,0),s=this.Qr.firstAfterOrEqual(e);return s!==null&&t.isEqual(s.key)}}class pr{constructor(t,e){this.key=t,this.Yr=e}static $r(t,e){return ge.comparator(t.key,e.key)||Ye(t.Yr,e.Yr)}static Kr(t,e){return Ye(t.Yr,e.Yr)||ge.comparator(t.key,e.key)}}class D3t{constructor(t,e){this.indexManager=t,this.referenceDelegate=e,this.mutationQueue=[],this.tr=1,this.Zr=new ar(pr.$r)}checkEmpty(t){return jt.resolve(this.mutationQueue.length===0)}addMutationBatch(t,e,s,r){const i=this.tr;this.tr++,this.mutationQueue.length>0&&this.mutationQueue[this.mutationQueue.length-1];const o=new KMt(i,e,s,r);this.mutationQueue.push(o);for(const a of r)this.Zr=this.Zr.add(new pr(a.key,i)),this.indexManager.addToCollectionParentIndex(t,a.key.path.popLast());return jt.resolve(o)}lookupMutationBatch(t,e){return jt.resolve(this.Xr(e))}getNextMutationBatchAfterBatchId(t,e){const s=e+1,r=this.ei(s),i=r<0?0:r;return jt.resolve(this.mutationQueue.length>i?this.mutationQueue[i]:null)}getHighestUnacknowledgedBatchId(){return jt.resolve(this.mutationQueue.length===0?uN:this.tr-1)}getAllMutationBatches(t){return jt.resolve(this.mutationQueue.slice())}getAllMutationBatchesAffectingDocumentKey(t,e){const s=new pr(e,0),r=new pr(e,Number.POSITIVE_INFINITY),i=[];return this.Zr.forEachInRange([s,r],(o=>{const a=this.Xr(o.Yr);i.push(a)})),jt.resolve(i)}getAllMutationBatchesAffectingDocumentKeys(t,e){let s=new ar(Ye);return e.forEach((r=>{const i=new pr(r,0),o=new pr(r,Number.POSITIVE_INFINITY);this.Zr.forEachInRange([i,o],(a=>{s=s.add(a.Yr)}))})),jt.resolve(this.ti(s))}getAllMutationBatchesAffectingQuery(t,e){const s=e.path,r=s.length+1;let i=s;ge.isDocumentKey(i)||(i=i.child(""));const o=new pr(new ge(i),0);let a=new ar(Ye);return this.Zr.forEachWhile((l=>{const c=l.key.path;return!!s.isPrefixOf(c)&&(c.length===r&&(a=a.add(l.Yr)),!0)}),o),jt.resolve(this.ti(a))}ti(t){const e=[];return t.forEach((s=>{const r=this.Xr(s);r!==null&&e.push(r)})),e}removeMutationBatch(t,e){Sn(this.ni(e.batchId,"removed")===0,55003),this.mutationQueue.shift();let s=this.Zr;return jt.forEach(e.mutations,(r=>{const i=new pr(r.key,e.batchId);return s=s.delete(i),this.referenceDelegate.markPotentiallyOrphaned(t,r.key)})).next((()=>{this.Zr=s}))}ir(t){}containsKey(t,e){const s=new pr(e,0),r=this.Zr.firstAfterOrEqual(s);return jt.resolve(e.isEqual(r&&r.key))}performConsistencyCheck(t){return this.mutationQueue.length,jt.resolve()}ni(t,e){return this.ei(t)}ei(t){return this.mutationQueue.length===0?0:t-this.mutationQueue[0].batchId}Xr(t){const e=this.ei(t);return e<0||e>=this.mutationQueue.length?null:this.mutationQueue[e]}}class O3t{constructor(t){this.ri=t,this.docs=(function(){return new ds(ge.comparator)})(),this.size=0}setIndexManager(t){this.indexManager=t}addEntry(t,e){const s=e.key,r=this.docs.get(s),i=r?r.size:0,o=this.ri(e);return this.docs=this.docs.insert(s,{document:e.mutableCopy(),size:o}),this.size+=o-i,this.indexManager.addToCollectionParentIndex(t,s.path.popLast())}removeEntry(t){const e=this.docs.get(t);e&&(this.docs=this.docs.remove(t),this.size-=e.size)}getEntry(t,e){const s=this.docs.get(e);return jt.resolve(s?s.document.mutableCopy():jr.newInvalidDocument(e))}getEntries(t,e){let s=su();return e.forEach((r=>{const i=this.docs.get(r);s=s.insert(r,i?i.document.mutableCopy():jr.newInvalidDocument(r))})),jt.resolve(s)}getDocumentsMatchingQuery(t,e,s,r){let i=su();const o=e.path,a=new ge(o.child("__id-9223372036854775808__")),l=this.docs.getIteratorFrom(a);for(;l.hasNext();){const{key:c,value:{document:f}}=l.getNext();if(!o.isPrefixOf(c.path))break;c.path.length>o.length+1||lMt(aMt(f),s)<=0||(r.has(f.key)||gS(e,f))&&(i=i.insert(f.key,f.mutableCopy()))}return jt.resolve(i)}getAllFromCollectionGroup(t,e,s,r){Ce(9500)}ii(t,e){return jt.forEach(this.docs,(s=>e(s)))}newChangeBuffer(t){return new F3t(this)}getSize(t){return jt.resolve(this.size)}}class F3t extends $3t{constructor(t){super(),this.Nr=t}applyChanges(t){const e=[];return this.changes.forEach(((s,r)=>{r.isValidDocument()?e.push(this.Nr.addEntry(t,r)):this.Nr.removeEntry(s)})),jt.waitFor(e)}getFromCache(t,e){return this.Nr.getEntry(t,e)}getAllFromCache(t,e){return this.Nr.getEntries(t,e)}}class M3t{constructor(t){this.persistence=t,this.si=new Tf((e=>fN(e)),dN),this.lastRemoteSnapshotVersion=ke.min(),this.highestTargetId=0,this.oi=0,this._i=new bN,this.targetCount=0,this.ai=dp.ur()}forEachTarget(t,e){return this.si.forEach(((s,r)=>e(r))),jt.resolve()}getLastRemoteSnapshotVersion(t){return jt.resolve(this.lastRemoteSnapshotVersion)}getHighestSequenceNumber(t){return jt.resolve(this.oi)}allocateTargetId(t){return this.highestTargetId=this.ai.next(),jt.resolve(this.highestTargetId)}setTargetsMetadata(t,e,s){return s&&(this.lastRemoteSnapshotVersion=s),e>this.oi&&(this.oi=e),jt.resolve()}Pr(t){this.si.set(t.target,t);const e=t.targetId;e>this.highestTargetId&&(this.ai=new dp(e),this.highestTargetId=e),t.sequenceNumber>this.oi&&(this.oi=t.sequenceNumber)}addTargetData(t,e){return this.Pr(e),this.targetCount+=1,jt.resolve()}updateTargetData(t,e){return this.Pr(e),jt.resolve()}removeTargetData(t,e){return this.si.delete(e.target),this._i.jr(e.targetId),this.targetCount-=1,jt.resolve()}removeTargets(t,e,s){let r=0;const i=[];return this.si.forEach(((o,a)=>{a.sequenceNumber<=e&&s.get(a.targetId)===null&&(this.si.delete(o),i.push(this.removeMatchingKeysForTargetId(t,a.targetId)),r++)})),jt.waitFor(i).next((()=>r))}getTargetCount(t){return jt.resolve(this.targetCount)}getTargetData(t,e){const s=this.si.get(e)||null;return jt.resolve(s)}addMatchingKeys(t,e,s){return this._i.Wr(e,s),jt.resolve()}removeMatchingKeys(t,e,s){this._i.zr(e,s);const r=this.persistence.referenceDelegate,i=[];return r&&e.forEach((o=>{i.push(r.markPotentiallyOrphaned(t,o))})),jt.waitFor(i)}removeMatchingKeysForTargetId(t,e){return this._i.jr(e),jt.resolve()}getMatchingKeysForTargetId(t,e){const s=this._i.Hr(e);return jt.resolve(s)}containsKey(t,e){return jt.resolve(this._i.containsKey(e))}}class F9{constructor(t,e){this.ui={},this.overlays={},this.ci=new fS(0),this.li=!1,this.li=!0,this.hi=new R3t,this.referenceDelegate=t(this),this.Pi=new M3t(this),this.indexManager=new w3t,this.remoteDocumentCache=(function(r){return new O3t(r)})((s=>this.referenceDelegate.Ti(s))),this.serializer=new b3t(e),this.Ii=new _3t(this.serializer)}start(){return Promise.resolve()}shutdown(){return this.li=!1,Promise.resolve()}get started(){return this.li}setDatabaseDeletedListener(){}setNetworkEnabled(){}getIndexManager(t){return this.indexManager}getDocumentOverlayCache(t){let e=this.overlays[t.toKey()];return e||(e=new N3t,this.overlays[t.toKey()]=e),e}getMutationQueue(t,e){let s=this.ui[t.toKey()];return s||(s=new D3t(e,this.referenceDelegate),this.ui[t.toKey()]=s),s}getGlobalsCache(){return this.hi}getTargetCache(){return this.Pi}getRemoteDocumentCache(){return this.remoteDocumentCache}getBundleCache(){return this.Ii}runTransaction(t,e,s){re("MemoryPersistence","Starting transaction:",t);const r=new L3t(this.ci.next());return this.referenceDelegate.Ei(),s(r).next((i=>this.referenceDelegate.di(r).next((()=>i)))).toPromise().then((i=>(r.raiseOnCommittedEvent(),i)))}Ai(t,e){return jt.or(Object.values(this.ui).map((s=>()=>s.containsKey(t,e))))}}class L3t extends cMt{constructor(t){super(),this.currentSequenceNumber=t}}class xN{constructor(t){this.persistence=t,this.Ri=new bN,this.Vi=null}static mi(t){return new xN(t)}get fi(){if(this.Vi)return this.Vi;throw Ce(60996)}addReference(t,e,s){return this.Ri.addReference(s,e),this.fi.delete(s.toString()),jt.resolve()}removeReference(t,e,s){return this.Ri.removeReference(s,e),this.fi.add(s.toString()),jt.resolve()}markPotentiallyOrphaned(t,e){return this.fi.add(e.toString()),jt.resolve()}removeTarget(t,e){this.Ri.jr(e.targetId).forEach((r=>this.fi.add(r.toString())));const s=this.persistence.getTargetCache();return s.getMatchingKeysForTargetId(t,e.targetId).next((r=>{r.forEach((i=>this.fi.add(i.toString())))})).next((()=>s.removeTargetData(t,e)))}Ei(){this.Vi=new Set}di(t){const e=this.persistence.getRemoteDocumentCache().newChangeBuffer();return jt.forEach(this.fi,(s=>{const r=ge.fromPath(s);return this.gi(t,r).next((i=>{i||e.removeEntry(r,ke.min())}))})).next((()=>(this.Vi=null,e.apply(t))))}updateLimboDocument(t,e){return this.gi(t,e).next((s=>{s?this.fi.delete(e.toString()):this.fi.add(e.toString())}))}Ti(t){return 0}gi(t,e){return jt.or([()=>jt.resolve(this.Ri.containsKey(e)),()=>this.persistence.getTargetCache().containsKey(t,e),()=>this.persistence.Ai(t,e)])}}class rw{constructor(t,e){this.persistence=t,this.pi=new Tf((s=>dMt(s.path)),((s,r)=>s.isEqual(r))),this.garbageCollector=E3t(this,e)}static mi(t,e){return new rw(t,e)}Ei(){}di(t){return jt.resolve()}forEachTarget(t,e){return this.persistence.getTargetCache().forEachTarget(t,e)}gr(t){const e=this.wr(t);return this.persistence.getTargetCache().getTargetCount(t).next((s=>e.next((r=>s+r))))}wr(t){let e=0;return this.pr(t,(s=>{e++})).next((()=>e))}pr(t,e){return jt.forEach(this.pi,((s,r)=>this.br(t,s,r).next((i=>i?jt.resolve():e(r)))))}removeTargets(t,e,s){return this.persistence.getTargetCache().removeTargets(t,e,s)}removeOrphanedDocuments(t,e){let s=0;const r=this.persistence.getRemoteDocumentCache(),i=r.newChangeBuffer();return r.ii(t,(o=>this.br(t,o,e).next((a=>{a||(s++,i.removeEntry(o,ke.min()))})))).next((()=>i.apply(t))).next((()=>s))}markPotentiallyOrphaned(t,e){return this.pi.set(e,t.currentSequenceNumber),jt.resolve()}removeTarget(t,e){const s=e.withSequenceNumber(t.currentSequenceNumber);return this.persistence.getTargetCache().updateTargetData(t,s)}addReference(t,e,s){return this.pi.set(s,t.currentSequenceNumber),jt.resolve()}removeReference(t,e,s){return this.pi.set(s,t.currentSequenceNumber),jt.resolve()}updateLimboDocument(t,e){return this.pi.set(e,t.currentSequenceNumber),jt.resolve()}Ti(t){let e=t.key.toString().length;return t.isFoundDocument()&&(e+=Q1(t.data.value)),e}br(t,e,s){return jt.or([()=>this.persistence.Ai(t,e),()=>this.persistence.getTargetCache().containsKey(t,e),()=>{const r=this.pi.get(e);return jt.resolve(r!==void 0&&r>s)}])}getCacheSize(t){return this.persistence.getRemoteDocumentCache().getSize(t)}}class wN{constructor(t,e,s,r){this.targetId=t,this.fromCache=e,this.Es=s,this.ds=r}static As(t,e){let s=Qe(),r=Qe();for(const i of e.docChanges)switch(i.type){case 0:s=s.add(i.doc.key);break;case 1:r=r.add(i.doc.key)}return new wN(t,e.fromCache,s,r)}}class z3t{constructor(){this._documentReadCount=0}get documentReadCount(){return this._documentReadCount}incrementDocumentReadCount(t){this._documentReadCount+=t}}class B3t{constructor(){this.Rs=!1,this.Vs=!1,this.fs=100,this.gs=(function(){return NOt()?8:hMt(AOt())>0?6:4})()}initialize(t,e){this.ps=t,this.indexManager=e,this.Rs=!0}getDocumentsMatchingQuery(t,e,s,r){const i={result:null};return this.ys(t,e).next((o=>{i.result=o})).next((()=>{if(!i.result)return this.ws(t,e,r,s).next((o=>{i.result=o}))})).next((()=>{if(i.result)return;const o=new z3t;return this.Ss(t,e,o).next((a=>{if(i.result=a,this.Vs)return this.bs(t,e,o,a.size)}))})).next((()=>i.result))}bs(t,e,s,r){return s.documentReadCount<this.fs?(Ed()<=an.DEBUG&&re("QueryEngine","SDK will not create cache indexes for query:",$d(e),"since it only creates cache indexes for collection contains","more than or equal to",this.fs,"documents"),jt.resolve()):(Ed()<=an.DEBUG&&re("QueryEngine","Query:",$d(e),"scans",s.documentReadCount,"local documents and returns",r,"documents as results."),s.documentReadCount>this.gs*r?(Ed()<=an.DEBUG&&re("QueryEngine","The SDK decides to create cache indexes for query:",$d(e),"as using cache indexes may help improve performance."),this.indexManager.createTargetIndexes(t,ul(e))):jt.resolve())}ys(t,e){if(Xz(e))return jt.resolve(null);let s=ul(e);return this.indexManager.getIndexType(t,s).next((r=>r===0?null:(e.limit!==null&&r===1&&(e=ew(e,null,"F"),s=ul(e)),this.indexManager.getDocumentsMatchingTarget(t,s).next((i=>{const o=Qe(...i);return this.ps.getDocuments(t,o).next((a=>this.indexManager.getMinOffset(t,s).next((l=>{const c=this.Ds(e,a);return this.Cs(e,c,o,l.readTime)?this.ys(t,ew(e,null,"F")):this.vs(t,c,e,l)}))))})))))}ws(t,e,s,r){return Xz(e)||r.isEqual(ke.min())?jt.resolve(null):this.ps.getDocuments(t,s).next((i=>{const o=this.Ds(e,i);return this.Cs(e,o,s,r)?jt.resolve(null):(Ed()<=an.DEBUG&&re("QueryEngine","Re-using previous result from %s to execute query: %s",r.toString(),$d(e)),this.vs(t,o,e,oMt(r,Hg)).next((a=>a)))}))}Ds(t,e){let s=new ar(f9(t));return e.forEach(((r,i)=>{gS(t,i)&&(s=s.add(i))})),s}Cs(t,e,s,r){if(t.limit===null)return!1;if(s.size!==e.size)return!0;const i=t.limitType==="F"?e.last():e.first();return!!i&&(i.hasPendingWrites||i.version.compareTo(r)>0)}Ss(t,e,s){return Ed()<=an.DEBUG&&re("QueryEngine","Using full collection scan to execute query:",$d(e)),this.ps.getDocumentsMatchingQuery(t,e,Sc.min(),s)}vs(t,e,s,r){return this.ps.getDocumentsMatchingQuery(t,s,r).next((i=>(e.forEach((o=>{i=i.insert(o.key,o)})),i)))}}const vN="LocalStore",P3t=3e8;class V3t{constructor(t,e,s,r){this.persistence=t,this.Fs=e,this.serializer=r,this.Ms=new ds(Ye),this.xs=new Tf((i=>fN(i)),dN),this.Os=new Map,this.Ns=t.getRemoteDocumentCache(),this.Pi=t.getTargetCache(),this.Ii=t.getBundleCache(),this.Bs(s)}Bs(t){this.documentOverlayCache=this.persistence.getDocumentOverlayCache(t),this.indexManager=this.persistence.getIndexManager(t),this.mutationQueue=this.persistence.getMutationQueue(t,this.indexManager),this.localDocuments=new k3t(this.Ns,this.mutationQueue,this.documentOverlayCache,this.indexManager),this.Ns.setIndexManager(this.indexManager),this.Fs.initialize(this.localDocuments,this.indexManager)}collectGarbage(t){return this.persistence.runTransaction("Collect garbage","readwrite-primary",(e=>t.collect(e,this.Ms)))}}function U3t(n,t,e,s){return new V3t(n,t,e,s)}async function M9(n,t){const e=De(n);return await e.persistence.runTransaction("Handle user change","readonly",(s=>{let r;return e.mutationQueue.getAllMutationBatches(s).next((i=>(r=i,e.Bs(t),e.mutationQueue.getAllMutationBatches(s)))).next((i=>{const o=[],a=[];let l=Qe();for(const c of r){o.push(c.batchId);for(const f of c.mutations)l=l.add(f.key)}for(const c of i){a.push(c.batchId);for(const f of c.mutations)l=l.add(f.key)}return e.localDocuments.getDocuments(s,l).next((c=>({Ls:c,removedBatchIds:o,addedBatchIds:a})))}))}))}function G3t(n,t){const e=De(n);return e.persistence.runTransaction("Acknowledge batch","readwrite-primary",(s=>{const r=t.batch.keys(),i=e.Ns.newChangeBuffer({trackRemovals:!0});return(function(a,l,c,f){const d=c.batch,m=d.keys();let y=jt.resolve();return m.forEach((b=>{y=y.next((()=>f.getEntry(l,b))).next((w=>{const x=c.docVersions.get(b);Sn(x!==null,48541),w.version.compareTo(x)<0&&(d.applyToRemoteDocument(w,c),w.isValidDocument()&&(w.setReadTime(c.commitVersion),f.addEntry(w)))}))})),y.next((()=>a.mutationQueue.removeMutationBatch(l,d)))})(e,s,t,i).next((()=>i.apply(s))).next((()=>e.mutationQueue.performConsistencyCheck(s))).next((()=>e.documentOverlayCache.removeOverlaysForBatchId(s,r,t.batch.batchId))).next((()=>e.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(s,(function(a){let l=Qe();for(let c=0;c<a.mutationResults.length;++c)a.mutationResults[c].transformResults.length>0&&(l=l.add(a.batch.mutations[c].key));return l})(t)))).next((()=>e.localDocuments.getDocuments(s,r)))}))}function L9(n){const t=De(n);return t.persistence.runTransaction("Get last remote snapshot version","readonly",(e=>t.Pi.getLastRemoteSnapshotVersion(e)))}function W3t(n,t){const e=De(n),s=t.snapshotVersion;let r=e.Ms;return e.persistence.runTransaction("Apply remote event","readwrite-primary",(i=>{const o=e.Ns.newChangeBuffer({trackRemovals:!0});r=e.Ms;const a=[];t.targetChanges.forEach(((f,d)=>{const m=r.get(d);if(!m)return;a.push(e.Pi.removeMatchingKeys(i,f.removedDocuments,d).next((()=>e.Pi.addMatchingKeys(i,f.addedDocuments,d))));let y=m.withSequenceNumber(i.currentSequenceNumber);t.targetMismatches.get(d)!==null?y=y.withResumeToken(wr.EMPTY_BYTE_STRING,ke.min()).withLastLimboFreeSnapshotVersion(ke.min()):f.resumeToken.approximateByteSize()>0&&(y=y.withResumeToken(f.resumeToken,s)),r=r.insert(d,y),(function(w,x,S){return w.resumeToken.approximateByteSize()===0||x.snapshotVersion.toMicroseconds()-w.snapshotVersion.toMicroseconds()>=P3t?!0:S.addedDocuments.size+S.modifiedDocuments.size+S.removedDocuments.size>0})(m,y,f)&&a.push(e.Pi.updateTargetData(i,y))}));let l=su(),c=Qe();if(t.documentUpdates.forEach((f=>{t.resolvedLimboDocuments.has(f)&&a.push(e.persistence.referenceDelegate.updateLimboDocument(i,f))})),a.push(j3t(i,o,t.documentUpdates).next((f=>{l=f.ks,c=f.qs}))),!s.isEqual(ke.min())){const f=e.Pi.getLastRemoteSnapshotVersion(i).next((d=>e.Pi.setTargetsMetadata(i,i.currentSequenceNumber,s)));a.push(f)}return jt.waitFor(a).next((()=>o.apply(i))).next((()=>e.localDocuments.getLocalViewOfDocuments(i,l,c))).next((()=>l))})).then((i=>(e.Ms=r,i)))}function j3t(n,t,e){let s=Qe(),r=Qe();return e.forEach((i=>s=s.add(i))),t.getEntries(n,s).next((i=>{let o=su();return e.forEach(((a,l)=>{const c=i.get(a);l.isFoundDocument()!==c.isFoundDocument()&&(r=r.add(a)),l.isNoDocument()&&l.version.isEqual(ke.min())?(t.removeEntry(a,l.readTime),o=o.insert(a,l)):!c.isValidDocument()||l.version.compareTo(c.version)>0||l.version.compareTo(c.version)===0&&c.hasPendingWrites?(t.addEntry(l),o=o.insert(a,l)):re(vN,"Ignoring outdated watch update for ",a,". Current version:",c.version," Watch version:",l.version)})),{ks:o,qs:r}}))}function q3t(n,t){const e=De(n);return e.persistence.runTransaction("Get next mutation batch","readonly",(s=>(t===void 0&&(t=uN),e.mutationQueue.getNextMutationBatchAfterBatchId(s,t))))}function H3t(n,t){const e=De(n);return e.persistence.runTransaction("Allocate target","readwrite",(s=>{let r;return e.Pi.getTargetData(s,t).next((i=>i?(r=i,jt.resolve(r)):e.Pi.allocateTargetId(s).next((o=>(r=new Qu(t,o,"TargetPurposeListen",s.currentSequenceNumber),e.Pi.addTargetData(s,r).next((()=>r)))))))})).then((s=>{const r=e.Ms.get(s.targetId);return(r===null||s.snapshotVersion.compareTo(r.snapshotVersion)>0)&&(e.Ms=e.Ms.insert(s.targetId,s),e.xs.set(t,s.targetId)),s}))}async function r2(n,t,e){const s=De(n),r=s.Ms.get(t),i=e?"readwrite":"readwrite-primary";try{e||await s.persistence.runTransaction("Release target",i,(o=>s.persistence.referenceDelegate.removeTarget(o,r)))}catch(o){if(!jp(o))throw o;re(vN,`Failed to update sequence numbers for target ${t}: ${o}`)}s.Ms=s.Ms.remove(t),s.xs.delete(r.target)}function lB(n,t,e){const s=De(n);let r=ke.min(),i=Qe();return s.persistence.runTransaction("Execute query","readwrite",(o=>(function(l,c,f){const d=De(l),m=d.xs.get(f);return m!==void 0?jt.resolve(d.Ms.get(m)):d.Pi.getTargetData(c,f)})(s,o,ul(t)).next((a=>{if(a)return r=a.lastLimboFreeSnapshotVersion,s.Pi.getMatchingKeysForTargetId(o,a.targetId).next((l=>{i=l}))})).next((()=>s.Fs.getDocumentsMatchingQuery(o,t,e?r:ke.min(),e?i:Qe()))).next((a=>(K3t(s,RMt(t),a),{documents:a,Qs:i})))))}function K3t(n,t,e){let s=n.Os.get(t)||ke.min();e.forEach(((r,i)=>{i.readTime.compareTo(s)>0&&(s=i.readTime)})),n.Os.set(t,s)}class uB{constructor(){this.activeTargetIds=zMt()}zs(t){this.activeTargetIds=this.activeTargetIds.add(t)}js(t){this.activeTargetIds=this.activeTargetIds.delete(t)}Gs(){const t={activeTargetIds:this.activeTargetIds.toArray(),updateTimeMs:Date.now()};return JSON.stringify(t)}}class X3t{constructor(){this.Mo=new uB,this.xo={},this.onlineStateHandler=null,this.sequenceNumberHandler=null}addPendingMutation(t){}updateMutationState(t,e,s){}addLocalQueryTarget(t,e=!0){return e&&this.Mo.zs(t),this.xo[t]||"not-current"}updateQueryState(t,e,s){this.xo[t]=e}removeLocalQueryTarget(t){this.Mo.js(t)}isLocalQueryTarget(t){return this.Mo.activeTargetIds.has(t)}clearQueryState(t){delete this.xo[t]}getAllActiveQueryTargets(){return this.Mo.activeTargetIds}isActiveQueryTarget(t){return this.Mo.activeTargetIds.has(t)}start(){return this.Mo=new uB,Promise.resolve()}handleUserChange(t,e,s){}setOnlineState(t){}shutdown(){}writeSequenceNumber(t){}notifyBundleLoaded(t){}}class Y3t{Oo(t){}shutdown(){}}const cB="ConnectivityMonitor";class hB{constructor(){this.No=()=>this.Bo(),this.Lo=()=>this.ko(),this.qo=[],this.Qo()}Oo(t){this.qo.push(t)}shutdown(){window.removeEventListener("online",this.No),window.removeEventListener("offline",this.Lo)}Qo(){window.addEventListener("online",this.No),window.addEventListener("offline",this.Lo)}Bo(){re(cB,"Network connectivity changed: AVAILABLE");for(const t of this.qo)t(0)}ko(){re(cB,"Network connectivity changed: UNAVAILABLE");for(const t of this.qo)t(1)}static v(){return typeof window<"u"&&window.addEventListener!==void 0&&window.removeEventListener!==void 0}}let D1=null;function i2(){return D1===null?D1=(function(){return 268435456+Math.round(2147483648*Math.random())})():D1++,"0x"+D1.toString(16)}const IE="RestConnection",Q3t={BatchGetDocuments:"batchGet",Commit:"commit",RunQuery:"runQuery",RunAggregationQuery:"runAggregationQuery"};class Z3t{get $o(){return!1}constructor(t){this.databaseInfo=t,this.databaseId=t.databaseId;const e=t.ssl?"https":"http",s=encodeURIComponent(this.databaseId.projectId),r=encodeURIComponent(this.databaseId.database);this.Uo=e+"://"+t.host,this.Ko=`projects/${s}/databases/${r}`,this.Wo=this.databaseId.database===Zx?`project_id=${s}`:`project_id=${s}&database_id=${r}`}Go(t,e,s,r,i){const o=i2(),a=this.zo(t,e.toUriEncodedString());re(IE,`Sending RPC '${t}' ${o}:`,a,s);const l={"google-cloud-resource-prefix":this.Ko,"x-goog-request-params":this.Wo};this.jo(l,r,i);const{host:c}=new URL(a),f=Db(c);return this.Jo(t,a,l,s,f).then((d=>(re(IE,`Received RPC '${t}' ${o}: `,d),d)),(d=>{throw nf(IE,`RPC '${t}' ${o} failed with error: `,d,"url: ",a,"request:",s),d}))}Ho(t,e,s,r,i,o){return this.Go(t,e,s,r,i)}jo(t,e,s){t["X-Goog-Api-Client"]=(function(){return"gl-js/ fire/"+Gp})(),t["Content-Type"]="text/plain",this.databaseInfo.appId&&(t["X-Firebase-GMPID"]=this.databaseInfo.appId),e&&e.headers.forEach(((r,i)=>t[i]=r)),s&&s.headers.forEach(((r,i)=>t[i]=r))}zo(t,e){const s=Q3t[t];return`${this.Uo}/v1/${e}:${s}`}terminate(){}}class J3t{constructor(t){this.Yo=t.Yo,this.Zo=t.Zo}Xo(t){this.e_=t}t_(t){this.n_=t}r_(t){this.i_=t}onMessage(t){this.s_=t}close(){this.Zo()}send(t){this.Yo(t)}o_(){this.e_()}__(){this.n_()}a_(t){this.i_(t)}u_(t){this.s_(t)}}const Pr="WebChannelConnection";class tLt extends Z3t{constructor(t){super(t),this.c_=[],this.forceLongPolling=t.forceLongPolling,this.autoDetectLongPolling=t.autoDetectLongPolling,this.useFetchStreams=t.useFetchStreams,this.longPollingOptions=t.longPollingOptions}Jo(t,e,s,r,i){const o=i2();return new Promise(((a,l)=>{const c=new M8;c.setWithCredentials(!0),c.listenOnce(L8.COMPLETE,(()=>{try{switch(c.getLastErrorCode()){case Y1.NO_ERROR:const d=c.getResponseJson();re(Pr,`XHR for RPC '${t}' ${o} received:`,JSON.stringify(d)),a(d);break;case Y1.TIMEOUT:re(Pr,`RPC '${t}' ${o} timed out`),l(new se(Gt.DEADLINE_EXCEEDED,"Request time out"));break;case Y1.HTTP_ERROR:const m=c.getStatus();if(re(Pr,`RPC '${t}' ${o} failed with status:`,m,"response text:",c.getResponseText()),m>0){let y=c.getResponseJson();Array.isArray(y)&&(y=y[0]);const b=y?.error;if(b&&b.status&&b.message){const w=(function(S){const T=S.toLowerCase().replace(/_/g,"-");return Object.values(Gt).indexOf(T)>=0?T:Gt.UNKNOWN})(b.status);l(new se(w,b.message))}else l(new se(Gt.UNKNOWN,"Server responded with status "+c.getStatus()))}else l(new se(Gt.UNAVAILABLE,"Connection failed."));break;default:Ce(9055,{l_:t,streamId:o,h_:c.getLastErrorCode(),P_:c.getLastError()})}}finally{re(Pr,`RPC '${t}' ${o} completed.`)}}));const f=JSON.stringify(r);re(Pr,`RPC '${t}' ${o} sending request:`,r),c.send(e,"POST",f,s,15)}))}T_(t,e,s){const r=i2(),i=[this.Uo,"/","google.firestore.v1.Firestore","/",t,"/channel"],o=P8(),a=B8(),l={httpSessionIdParam:"gsessionid",initMessageHeaders:{},messageUrlParams:{database:`projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`},sendRawJson:!0,supportsCrossDomainXhr:!0,internalChannelParams:{forwardChannelRequestTimeoutMs:6e5},forceLongPolling:this.forceLongPolling,detectBufferingProxy:this.autoDetectLongPolling},c=this.longPollingOptions.timeoutSeconds;c!==void 0&&(l.longPollingTimeout=Math.round(1e3*c)),this.useFetchStreams&&(l.useFetchStreams=!0),this.jo(l.initMessageHeaders,e,s),l.encodeInitMessageHeaders=!0;const f=i.join("");re(Pr,`Creating RPC '${t}' stream ${r}: ${f}`,l);const d=o.createWebChannel(f,l);this.I_(d);let m=!1,y=!1;const b=new J3t({Yo:x=>{y?re(Pr,`Not sending because RPC '${t}' stream ${r} is closed:`,x):(m||(re(Pr,`Opening RPC '${t}' stream ${r} transport.`),d.open(),m=!0),re(Pr,`RPC '${t}' stream ${r} sending:`,x),d.send(x))},Zo:()=>d.close()}),w=(x,S,T)=>{x.listen(S,($=>{try{T($)}catch(E){setTimeout((()=>{throw E}),0)}}))};return w(d,hg.EventType.OPEN,(()=>{y||(re(Pr,`RPC '${t}' stream ${r} transport opened.`),b.o_())})),w(d,hg.EventType.CLOSE,(()=>{y||(y=!0,re(Pr,`RPC '${t}' stream ${r} transport closed`),b.a_(),this.E_(d))})),w(d,hg.EventType.ERROR,(x=>{y||(y=!0,nf(Pr,`RPC '${t}' stream ${r} transport errored. Name:`,x.name,"Message:",x.message),b.a_(new se(Gt.UNAVAILABLE,"The operation could not be completed")))})),w(d,hg.EventType.MESSAGE,(x=>{if(!y){const S=x.data[0];Sn(!!S,16349);const T=S,$=T?.error||T[0]?.error;if($){re(Pr,`RPC '${t}' stream ${r} received error:`,$);const E=$.status;let R=(function(k){const _=Ps[k];if(_!==void 0)return T9(_)})(E),B=$.message;R===void 0&&(R=Gt.INTERNAL,B="Unknown error status: "+E+" with message "+$.message),y=!0,b.a_(new se(R,B)),d.close()}else re(Pr,`RPC '${t}' stream ${r} received:`,S),b.u_(S)}})),w(a,z8.STAT_EVENT,(x=>{x.stat===H$.PROXY?re(Pr,`RPC '${t}' stream ${r} detected buffering proxy`):x.stat===H$.NOPROXY&&re(Pr,`RPC '${t}' stream ${r} detected no buffering proxy`)})),setTimeout((()=>{b.__()}),0),b}terminate(){this.c_.forEach((t=>t.close())),this.c_=[]}I_(t){this.c_.push(t)}E_(t){this.c_=this.c_.filter((e=>e===t))}}function TE(){return typeof document<"u"?document:null}function wS(n){return new r3t(n,!0)}class z9{constructor(t,e,s=1e3,r=1.5,i=6e4){this.Mi=t,this.timerId=e,this.d_=s,this.A_=r,this.R_=i,this.V_=0,this.m_=null,this.f_=Date.now(),this.reset()}reset(){this.V_=0}g_(){this.V_=this.R_}p_(t){this.cancel();const e=Math.floor(this.V_+this.y_()),s=Math.max(0,Date.now()-this.f_),r=Math.max(0,e-s);r>0&&re("ExponentialBackoff",`Backing off for ${r} ms (base delay: ${this.V_} ms, delay with jitter: ${e} ms, last attempt: ${s} ms ago)`),this.m_=this.Mi.enqueueAfterDelay(this.timerId,r,(()=>(this.f_=Date.now(),t()))),this.V_*=this.A_,this.V_<this.d_&&(this.V_=this.d_),this.V_>this.R_&&(this.V_=this.R_)}w_(){this.m_!==null&&(this.m_.skipDelay(),this.m_=null)}cancel(){this.m_!==null&&(this.m_.cancel(),this.m_=null)}y_(){return(Math.random()-.5)*this.V_}}const fB="PersistentStream";class B9{constructor(t,e,s,r,i,o,a,l){this.Mi=t,this.S_=s,this.b_=r,this.connection=i,this.authCredentialsProvider=o,this.appCheckCredentialsProvider=a,this.listener=l,this.state=0,this.D_=0,this.C_=null,this.v_=null,this.stream=null,this.F_=0,this.M_=new z9(t,e)}x_(){return this.state===1||this.state===5||this.O_()}O_(){return this.state===2||this.state===3}start(){this.F_=0,this.state!==4?this.auth():this.N_()}async stop(){this.x_()&&await this.close(0)}B_(){this.state=0,this.M_.reset()}L_(){this.O_()&&this.C_===null&&(this.C_=this.Mi.enqueueAfterDelay(this.S_,6e4,(()=>this.k_())))}q_(t){this.Q_(),this.stream.send(t)}async k_(){if(this.O_())return this.close(0)}Q_(){this.C_&&(this.C_.cancel(),this.C_=null)}U_(){this.v_&&(this.v_.cancel(),this.v_=null)}async close(t,e){this.Q_(),this.U_(),this.M_.cancel(),this.D_++,t!==4?this.M_.reset():e&&e.code===Gt.RESOURCE_EXHAUSTED?(nu(e.toString()),nu("Using maximum backoff delay to prevent overloading the backend."),this.M_.g_()):e&&e.code===Gt.UNAUTHENTICATED&&this.state!==3&&(this.authCredentialsProvider.invalidateToken(),this.appCheckCredentialsProvider.invalidateToken()),this.stream!==null&&(this.K_(),this.stream.close(),this.stream=null),this.state=t,await this.listener.r_(e)}K_(){}auth(){this.state=1;const t=this.W_(this.D_),e=this.D_;Promise.all([this.authCredentialsProvider.getToken(),this.appCheckCredentialsProvider.getToken()]).then((([s,r])=>{this.D_===e&&this.G_(s,r)}),(s=>{t((()=>{const r=new se(Gt.UNKNOWN,"Fetching auth token failed: "+s.message);return this.z_(r)}))}))}G_(t,e){const s=this.W_(this.D_);this.stream=this.j_(t,e),this.stream.Xo((()=>{s((()=>this.listener.Xo()))})),this.stream.t_((()=>{s((()=>(this.state=2,this.v_=this.Mi.enqueueAfterDelay(this.b_,1e4,(()=>(this.O_()&&(this.state=3),Promise.resolve()))),this.listener.t_())))})),this.stream.r_((r=>{s((()=>this.z_(r)))})),this.stream.onMessage((r=>{s((()=>++this.F_==1?this.J_(r):this.onNext(r)))}))}N_(){this.state=5,this.M_.p_((async()=>{this.state=0,this.start()}))}z_(t){return re(fB,`close with error: ${t}`),this.stream=null,this.close(4,t)}W_(t){return e=>{this.Mi.enqueueAndForget((()=>this.D_===t?e():(re(fB,"stream callback skipped by getCloseGuardedDispatcher."),Promise.resolve())))}}}class eLt extends B9{constructor(t,e,s,r,i,o){super(t,"listen_stream_connection_backoff","listen_stream_idle","health_check_timeout",e,s,r,o),this.serializer=i}j_(t,e){return this.connection.T_("Listen",t,e)}J_(t){return this.onNext(t)}onNext(t){this.M_.reset();const e=a3t(this.serializer,t),s=(function(i){if(!("targetChange"in i))return ke.min();const o=i.targetChange;return o.targetIds&&o.targetIds.length?ke.min():o.readTime?cl(o.readTime):ke.min()})(t);return this.listener.H_(e,s)}Y_(t){const e={};e.database=s2(this.serializer),e.addTarget=(function(i,o){let a;const l=o.target;if(a=Z$(l)?{documents:c3t(i,l)}:{query:h3t(i,l).ft},a.targetId=o.targetId,o.resumeToken.approximateByteSize()>0){a.resumeToken=$9(i,o.resumeToken);const c=t2(i,o.expectedCount);c!==null&&(a.expectedCount=c)}else if(o.snapshotVersion.compareTo(ke.min())>0){a.readTime=sw(i,o.snapshotVersion.toTimestamp());const c=t2(i,o.expectedCount);c!==null&&(a.expectedCount=c)}return a})(this.serializer,t);const s=d3t(this.serializer,t);s&&(e.labels=s),this.q_(e)}Z_(t){const e={};e.database=s2(this.serializer),e.removeTarget=t,this.q_(e)}}class nLt extends B9{constructor(t,e,s,r,i,o){super(t,"write_stream_connection_backoff","write_stream_idle","health_check_timeout",e,s,r,o),this.serializer=i}get X_(){return this.F_>0}start(){this.lastStreamToken=void 0,super.start()}K_(){this.X_&&this.ea([])}j_(t,e){return this.connection.T_("Write",t,e)}J_(t){return Sn(!!t.streamToken,31322),this.lastStreamToken=t.streamToken,Sn(!t.writeResults||t.writeResults.length===0,55816),this.listener.ta()}onNext(t){Sn(!!t.streamToken,12678),this.lastStreamToken=t.streamToken,this.M_.reset();const e=u3t(t.writeResults,t.commitTime),s=cl(t.commitTime);return this.listener.na(s,e)}ra(){const t={};t.database=s2(this.serializer),this.q_(t)}ea(t){const e={streamToken:this.lastStreamToken,writes:t.map((s=>l3t(this.serializer,s)))};this.q_(e)}}class sLt{}class rLt extends sLt{constructor(t,e,s,r){super(),this.authCredentials=t,this.appCheckCredentials=e,this.connection=s,this.serializer=r,this.ia=!1}sa(){if(this.ia)throw new se(Gt.FAILED_PRECONDITION,"The client has already been terminated.")}Go(t,e,s,r){return this.sa(),Promise.all([this.authCredentials.getToken(),this.appCheckCredentials.getToken()]).then((([i,o])=>this.connection.Go(t,e2(e,s),r,i,o))).catch((i=>{throw i.name==="FirebaseError"?(i.code===Gt.UNAUTHENTICATED&&(this.authCredentials.invalidateToken(),this.appCheckCredentials.invalidateToken()),i):new se(Gt.UNKNOWN,i.toString())}))}Ho(t,e,s,r,i){return this.sa(),Promise.all([this.authCredentials.getToken(),this.appCheckCredentials.getToken()]).then((([o,a])=>this.connection.Ho(t,e2(e,s),r,o,a,i))).catch((o=>{throw o.name==="FirebaseError"?(o.code===Gt.UNAUTHENTICATED&&(this.authCredentials.invalidateToken(),this.appCheckCredentials.invalidateToken()),o):new se(Gt.UNKNOWN,o.toString())}))}terminate(){this.ia=!0,this.connection.terminate()}}class iLt{constructor(t,e){this.asyncQueue=t,this.onlineStateHandler=e,this.state="Unknown",this.oa=0,this._a=null,this.aa=!0}ua(){this.oa===0&&(this.ca("Unknown"),this._a=this.asyncQueue.enqueueAfterDelay("online_state_timeout",1e4,(()=>(this._a=null,this.la("Backend didn't respond within 10 seconds."),this.ca("Offline"),Promise.resolve()))))}ha(t){this.state==="Online"?this.ca("Unknown"):(this.oa++,this.oa>=1&&(this.Pa(),this.la(`Connection failed 1 times. Most recent error: ${t.toString()}`),this.ca("Offline")))}set(t){this.Pa(),this.oa=0,t==="Online"&&(this.aa=!1),this.ca(t)}ca(t){t!==this.state&&(this.state=t,this.onlineStateHandler(t))}la(t){const e=`Could not reach Cloud Firestore backend. ${t}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;this.aa?(nu(e),this.aa=!1):re("OnlineStateTracker",e)}Pa(){this._a!==null&&(this._a.cancel(),this._a=null)}}const sf="RemoteStore";class oLt{constructor(t,e,s,r,i){this.localStore=t,this.datastore=e,this.asyncQueue=s,this.remoteSyncer={},this.Ta=[],this.Ia=new Map,this.Ea=new Set,this.da=[],this.Aa=i,this.Aa.Oo((o=>{s.enqueueAndForget((async()=>{Ef(this)&&(re(sf,"Restarting streams for network reachability change."),await(async function(l){const c=De(l);c.Ea.add(4),await Lb(c),c.Ra.set("Unknown"),c.Ea.delete(4),await vS(c)})(this))}))})),this.Ra=new iLt(s,r)}}async function vS(n){if(Ef(n))for(const t of n.da)await t(!0)}async function Lb(n){for(const t of n.da)await t(!1)}function P9(n,t){const e=De(n);e.Ia.has(t.targetId)||(e.Ia.set(t.targetId,t),CN(e)?TN(e):Hp(e).O_()&&IN(e,t))}function SN(n,t){const e=De(n),s=Hp(e);e.Ia.delete(t),s.O_()&&V9(e,t),e.Ia.size===0&&(s.O_()?s.L_():Ef(e)&&e.Ra.set("Unknown"))}function IN(n,t){if(n.Va.Ue(t.targetId),t.resumeToken.approximateByteSize()>0||t.snapshotVersion.compareTo(ke.min())>0){const e=n.remoteSyncer.getRemoteKeysForTarget(t.targetId).size;t=t.withExpectedCount(e)}Hp(n).Y_(t)}function V9(n,t){n.Va.Ue(t),Hp(n).Z_(t)}function TN(n){n.Va=new t3t({getRemoteKeysForTarget:t=>n.remoteSyncer.getRemoteKeysForTarget(t),At:t=>n.Ia.get(t)||null,ht:()=>n.datastore.serializer.databaseId}),Hp(n).start(),n.Ra.ua()}function CN(n){return Ef(n)&&!Hp(n).x_()&&n.Ia.size>0}function Ef(n){return De(n).Ea.size===0}function U9(n){n.Va=void 0}async function aLt(n){n.Ra.set("Online")}async function lLt(n){n.Ia.forEach(((t,e)=>{IN(n,t)}))}async function uLt(n,t){U9(n),CN(n)?(n.Ra.ha(t),TN(n)):n.Ra.set("Unknown")}async function cLt(n,t,e){if(n.Ra.set("Online"),t instanceof E9&&t.state===2&&t.cause)try{await(async function(r,i){const o=i.cause;for(const a of i.targetIds)r.Ia.has(a)&&(await r.remoteSyncer.rejectListen(a,o),r.Ia.delete(a),r.Va.removeTarget(a))})(n,t)}catch(s){re(sf,"Failed to remove targets %s: %s ",t.targetIds.join(","),s),await iw(n,s)}else if(t instanceof tx?n.Va.Ze(t):t instanceof C9?n.Va.st(t):n.Va.tt(t),!e.isEqual(ke.min()))try{const s=await L9(n.localStore);e.compareTo(s)>=0&&await(function(i,o){const a=i.Va.Tt(o);return a.targetChanges.forEach(((l,c)=>{if(l.resumeToken.approximateByteSize()>0){const f=i.Ia.get(c);f&&i.Ia.set(c,f.withResumeToken(l.resumeToken,o))}})),a.targetMismatches.forEach(((l,c)=>{const f=i.Ia.get(l);if(!f)return;i.Ia.set(l,f.withResumeToken(wr.EMPTY_BYTE_STRING,f.snapshotVersion)),V9(i,l);const d=new Qu(f.target,l,c,f.sequenceNumber);IN(i,d)})),i.remoteSyncer.applyRemoteEvent(a)})(n,e)}catch(s){re(sf,"Failed to raise snapshot:",s),await iw(n,s)}}async function iw(n,t,e){if(!jp(t))throw t;n.Ea.add(1),await Lb(n),n.Ra.set("Offline"),e||(e=()=>L9(n.localStore)),n.asyncQueue.enqueueRetryable((async()=>{re(sf,"Retrying IndexedDB access"),await e(),n.Ea.delete(1),await vS(n)}))}function G9(n,t){return t().catch((e=>iw(n,e,t)))}async function SS(n){const t=De(n),e=Ec(t);let s=t.Ta.length>0?t.Ta[t.Ta.length-1].batchId:uN;for(;hLt(t);)try{const r=await q3t(t.localStore,s);if(r===null){t.Ta.length===0&&e.L_();break}s=r.batchId,fLt(t,r)}catch(r){await iw(t,r)}W9(t)&&j9(t)}function hLt(n){return Ef(n)&&n.Ta.length<10}function fLt(n,t){n.Ta.push(t);const e=Ec(n);e.O_()&&e.X_&&e.ea(t.mutations)}function W9(n){return Ef(n)&&!Ec(n).x_()&&n.Ta.length>0}function j9(n){Ec(n).start()}async function dLt(n){Ec(n).ra()}async function pLt(n){const t=Ec(n);for(const e of n.Ta)t.ea(e.mutations)}async function mLt(n,t,e){const s=n.Ta.shift(),r=mN.from(s,t,e);await G9(n,(()=>n.remoteSyncer.applySuccessfulWrite(r))),await SS(n)}async function gLt(n,t){t&&Ec(n).X_&&await(async function(s,r){if((function(o){return QMt(o)&&o!==Gt.ABORTED})(r.code)){const i=s.Ta.shift();Ec(s).B_(),await G9(s,(()=>s.remoteSyncer.rejectFailedWrite(i.batchId,r))),await SS(s)}})(n,t),W9(n)&&j9(n)}async function dB(n,t){const e=De(n);e.asyncQueue.verifyOperationInProgress(),re(sf,"RemoteStore received new credentials");const s=Ef(e);e.Ea.add(3),await Lb(e),s&&e.Ra.set("Unknown"),await e.remoteSyncer.handleCredentialChange(t),e.Ea.delete(3),await vS(e)}async function yLt(n,t){const e=De(n);t?(e.Ea.delete(2),await vS(e)):t||(e.Ea.add(2),await Lb(e),e.Ra.set("Unknown"))}function Hp(n){return n.ma||(n.ma=(function(e,s,r){const i=De(e);return i.sa(),new eLt(s,i.connection,i.authCredentials,i.appCheckCredentials,i.serializer,r)})(n.datastore,n.asyncQueue,{Xo:aLt.bind(null,n),t_:lLt.bind(null,n),r_:uLt.bind(null,n),H_:cLt.bind(null,n)}),n.da.push((async t=>{t?(n.ma.B_(),CN(n)?TN(n):n.Ra.set("Unknown")):(await n.ma.stop(),U9(n))}))),n.ma}function Ec(n){return n.fa||(n.fa=(function(e,s,r){const i=De(e);return i.sa(),new nLt(s,i.connection,i.authCredentials,i.appCheckCredentials,i.serializer,r)})(n.datastore,n.asyncQueue,{Xo:()=>Promise.resolve(),t_:dLt.bind(null,n),r_:gLt.bind(null,n),ta:pLt.bind(null,n),na:mLt.bind(null,n)}),n.da.push((async t=>{t?(n.fa.B_(),await SS(n)):(await n.fa.stop(),n.Ta.length>0&&(re(sf,`Stopping write stream with ${n.Ta.length} pending writes`),n.Ta=[]))}))),n.fa}class EN{constructor(t,e,s,r,i){this.asyncQueue=t,this.timerId=e,this.targetTimeMs=s,this.op=r,this.removalCallback=i,this.deferred=new ac,this.then=this.deferred.promise.then.bind(this.deferred.promise),this.deferred.promise.catch((o=>{}))}get promise(){return this.deferred.promise}static createAndSchedule(t,e,s,r,i){const o=Date.now()+s,a=new EN(t,e,o,r,i);return a.start(s),a}start(t){this.timerHandle=setTimeout((()=>this.handleDelayElapsed()),t)}skipDelay(){return this.handleDelayElapsed()}cancel(t){this.timerHandle!==null&&(this.clearTimeout(),this.deferred.reject(new se(Gt.CANCELLED,"Operation cancelled"+(t?": "+t:""))))}handleDelayElapsed(){this.asyncQueue.enqueueAndForget((()=>this.timerHandle!==null?(this.clearTimeout(),this.op().then((t=>this.deferred.resolve(t)))):Promise.resolve()))}clearTimeout(){this.timerHandle!==null&&(this.removalCallback(this),clearTimeout(this.timerHandle),this.timerHandle=null)}}function $N(n,t){if(nu("AsyncQueue",`${t}: ${n}`),jp(n))return new se(Gt.UNAVAILABLE,`${t}: ${n}`);throw n}class Ud{static emptySet(t){return new Ud(t.comparator)}constructor(t){this.comparator=t?(e,s)=>t(e,s)||ge.comparator(e.key,s.key):(e,s)=>ge.comparator(e.key,s.key),this.keyedMap=fg(),this.sortedSet=new ds(this.comparator)}has(t){return this.keyedMap.get(t)!=null}get(t){return this.keyedMap.get(t)}first(){return this.sortedSet.minKey()}last(){return this.sortedSet.maxKey()}isEmpty(){return this.sortedSet.isEmpty()}indexOf(t){const e=this.keyedMap.get(t);return e?this.sortedSet.indexOf(e):-1}get size(){return this.sortedSet.size}forEach(t){this.sortedSet.inorderTraversal(((e,s)=>(t(e),!1)))}add(t){const e=this.delete(t.key);return e.copy(e.keyedMap.insert(t.key,t),e.sortedSet.insert(t,null))}delete(t){const e=this.get(t);return e?this.copy(this.keyedMap.remove(t),this.sortedSet.remove(e)):this}isEqual(t){if(!(t instanceof Ud)||this.size!==t.size)return!1;const e=this.sortedSet.getIterator(),s=t.sortedSet.getIterator();for(;e.hasNext();){const r=e.getNext().key,i=s.getNext().key;if(!r.isEqual(i))return!1}return!0}toString(){const t=[];return this.forEach((e=>{t.push(e.toString())})),t.length===0?"DocumentSet ()":`DocumentSet (
  `+t.join(`  
`)+`
)`}copy(t,e){const s=new Ud;return s.comparator=this.comparator,s.keyedMap=t,s.sortedSet=e,s}}class pB{constructor(){this.ga=new ds(ge.comparator)}track(t){const e=t.doc.key,s=this.ga.get(e);s?t.type!==0&&s.type===3?this.ga=this.ga.insert(e,t):t.type===3&&s.type!==1?this.ga=this.ga.insert(e,{type:s.type,doc:t.doc}):t.type===2&&s.type===2?this.ga=this.ga.insert(e,{type:2,doc:t.doc}):t.type===2&&s.type===0?this.ga=this.ga.insert(e,{type:0,doc:t.doc}):t.type===1&&s.type===0?this.ga=this.ga.remove(e):t.type===1&&s.type===2?this.ga=this.ga.insert(e,{type:1,doc:s.doc}):t.type===0&&s.type===1?this.ga=this.ga.insert(e,{type:2,doc:t.doc}):Ce(63341,{Rt:t,pa:s}):this.ga=this.ga.insert(e,t)}ya(){const t=[];return this.ga.inorderTraversal(((e,s)=>{t.push(s)})),t}}class pp{constructor(t,e,s,r,i,o,a,l,c){this.query=t,this.docs=e,this.oldDocs=s,this.docChanges=r,this.mutatedKeys=i,this.fromCache=o,this.syncStateChanged=a,this.excludesMetadataChanges=l,this.hasCachedResults=c}static fromInitialDocuments(t,e,s,r,i){const o=[];return e.forEach((a=>{o.push({type:0,doc:a})})),new pp(t,e,Ud.emptySet(e),o,s,r,!0,!1,i)}get hasPendingWrites(){return!this.mutatedKeys.isEmpty()}isEqual(t){if(!(this.fromCache===t.fromCache&&this.hasCachedResults===t.hasCachedResults&&this.syncStateChanged===t.syncStateChanged&&this.mutatedKeys.isEqual(t.mutatedKeys)&&mS(this.query,t.query)&&this.docs.isEqual(t.docs)&&this.oldDocs.isEqual(t.oldDocs)))return!1;const e=this.docChanges,s=t.docChanges;if(e.length!==s.length)return!1;for(let r=0;r<e.length;r++)if(e[r].type!==s[r].type||!e[r].doc.isEqual(s[r].doc))return!1;return!0}}class bLt{constructor(){this.wa=void 0,this.Sa=[]}ba(){return this.Sa.some((t=>t.Da()))}}class xLt{constructor(){this.queries=mB(),this.onlineState="Unknown",this.Ca=new Set}terminate(){(function(e,s){const r=De(e),i=r.queries;r.queries=mB(),i.forEach(((o,a)=>{for(const l of a.Sa)l.onError(s)}))})(this,new se(Gt.ABORTED,"Firestore shutting down"))}}function mB(){return new Tf((n=>h9(n)),mS)}async function wLt(n,t){const e=De(n);let s=3;const r=t.query;let i=e.queries.get(r);i?!i.ba()&&t.Da()&&(s=2):(i=new bLt,s=t.Da()?0:1);try{switch(s){case 0:i.wa=await e.onListen(r,!0);break;case 1:i.wa=await e.onListen(r,!1);break;case 2:await e.onFirstRemoteStoreListen(r)}}catch(o){const a=$N(o,`Initialization of query '${$d(t.query)}' failed`);return void t.onError(a)}e.queries.set(r,i),i.Sa.push(t),t.va(e.onlineState),i.wa&&t.Fa(i.wa)&&AN(e)}async function vLt(n,t){const e=De(n),s=t.query;let r=3;const i=e.queries.get(s);if(i){const o=i.Sa.indexOf(t);o>=0&&(i.Sa.splice(o,1),i.Sa.length===0?r=t.Da()?0:1:!i.ba()&&t.Da()&&(r=2))}switch(r){case 0:return e.queries.delete(s),e.onUnlisten(s,!0);case 1:return e.queries.delete(s),e.onUnlisten(s,!1);case 2:return e.onLastRemoteStoreUnlisten(s);default:return}}function SLt(n,t){const e=De(n);let s=!1;for(const r of t){const i=r.query,o=e.queries.get(i);if(o){for(const a of o.Sa)a.Fa(r)&&(s=!0);o.wa=r}}s&&AN(e)}function ILt(n,t,e){const s=De(n),r=s.queries.get(t);if(r)for(const i of r.Sa)i.onError(e);s.queries.delete(t)}function AN(n){n.Ca.forEach((t=>{t.next()}))}var o2,gB;(gB=o2||(o2={})).Ma="default",gB.Cache="cache";class TLt{constructor(t,e,s){this.query=t,this.xa=e,this.Oa=!1,this.Na=null,this.onlineState="Unknown",this.options=s||{}}Fa(t){if(!this.options.includeMetadataChanges){const s=[];for(const r of t.docChanges)r.type!==3&&s.push(r);t=new pp(t.query,t.docs,t.oldDocs,s,t.mutatedKeys,t.fromCache,t.syncStateChanged,!0,t.hasCachedResults)}let e=!1;return this.Oa?this.Ba(t)&&(this.xa.next(t),e=!0):this.La(t,this.onlineState)&&(this.ka(t),e=!0),this.Na=t,e}onError(t){this.xa.error(t)}va(t){this.onlineState=t;let e=!1;return this.Na&&!this.Oa&&this.La(this.Na,t)&&(this.ka(this.Na),e=!0),e}La(t,e){if(!t.fromCache||!this.Da())return!0;const s=e!=="Offline";return(!this.options.qa||!s)&&(!t.docs.isEmpty()||t.hasCachedResults||e==="Offline")}Ba(t){if(t.docChanges.length>0)return!0;const e=this.Na&&this.Na.hasPendingWrites!==t.hasPendingWrites;return!(!t.syncStateChanged&&!e)&&this.options.includeMetadataChanges===!0}ka(t){t=pp.fromInitialDocuments(t.query,t.docs,t.mutatedKeys,t.fromCache,t.hasCachedResults),this.Oa=!0,this.xa.next(t)}Da(){return this.options.source!==o2.Cache}}class q9{constructor(t){this.key=t}}class H9{constructor(t){this.key=t}}class CLt{constructor(t,e){this.query=t,this.Ya=e,this.Za=null,this.hasCachedResults=!1,this.current=!1,this.Xa=Qe(),this.mutatedKeys=Qe(),this.eu=f9(t),this.tu=new Ud(this.eu)}get nu(){return this.Ya}ru(t,e){const s=e?e.iu:new pB,r=e?e.tu:this.tu;let i=e?e.mutatedKeys:this.mutatedKeys,o=r,a=!1;const l=this.query.limitType==="F"&&r.size===this.query.limit?r.last():null,c=this.query.limitType==="L"&&r.size===this.query.limit?r.first():null;if(t.inorderTraversal(((f,d)=>{const m=r.get(f),y=gS(this.query,d)?d:null,b=!!m&&this.mutatedKeys.has(m.key),w=!!y&&(y.hasLocalMutations||this.mutatedKeys.has(y.key)&&y.hasCommittedMutations);let x=!1;m&&y?m.data.isEqual(y.data)?b!==w&&(s.track({type:3,doc:y}),x=!0):this.su(m,y)||(s.track({type:2,doc:y}),x=!0,(l&&this.eu(y,l)>0||c&&this.eu(y,c)<0)&&(a=!0)):!m&&y?(s.track({type:0,doc:y}),x=!0):m&&!y&&(s.track({type:1,doc:m}),x=!0,(l||c)&&(a=!0)),x&&(y?(o=o.add(y),i=w?i.add(f):i.delete(f)):(o=o.delete(f),i=i.delete(f)))})),this.query.limit!==null)for(;o.size>this.query.limit;){const f=this.query.limitType==="F"?o.last():o.first();o=o.delete(f.key),i=i.delete(f.key),s.track({type:1,doc:f})}return{tu:o,iu:s,Cs:a,mutatedKeys:i}}su(t,e){return t.hasLocalMutations&&e.hasCommittedMutations&&!e.hasLocalMutations}applyChanges(t,e,s,r){const i=this.tu;this.tu=t.tu,this.mutatedKeys=t.mutatedKeys;const o=t.iu.ya();o.sort(((f,d)=>(function(y,b){const w=x=>{switch(x){case 0:return 1;case 2:case 3:return 2;case 1:return 0;default:return Ce(20277,{Rt:x})}};return w(y)-w(b)})(f.type,d.type)||this.eu(f.doc,d.doc))),this.ou(s),r=r??!1;const a=e&&!r?this._u():[],l=this.Xa.size===0&&this.current&&!r?1:0,c=l!==this.Za;return this.Za=l,o.length!==0||c?{snapshot:new pp(this.query,t.tu,i,o,t.mutatedKeys,l===0,c,!1,!!s&&s.resumeToken.approximateByteSize()>0),au:a}:{au:a}}va(t){return this.current&&t==="Offline"?(this.current=!1,this.applyChanges({tu:this.tu,iu:new pB,mutatedKeys:this.mutatedKeys,Cs:!1},!1)):{au:[]}}uu(t){return!this.Ya.has(t)&&!!this.tu.has(t)&&!this.tu.get(t).hasLocalMutations}ou(t){t&&(t.addedDocuments.forEach((e=>this.Ya=this.Ya.add(e))),t.modifiedDocuments.forEach((e=>{})),t.removedDocuments.forEach((e=>this.Ya=this.Ya.delete(e))),this.current=t.current)}_u(){if(!this.current)return[];const t=this.Xa;this.Xa=Qe(),this.tu.forEach((s=>{this.uu(s.key)&&(this.Xa=this.Xa.add(s.key))}));const e=[];return t.forEach((s=>{this.Xa.has(s)||e.push(new H9(s))})),this.Xa.forEach((s=>{t.has(s)||e.push(new q9(s))})),e}cu(t){this.Ya=t.Qs,this.Xa=Qe();const e=this.ru(t.documents);return this.applyChanges(e,!0)}lu(){return pp.fromInitialDocuments(this.query,this.tu,this.mutatedKeys,this.Za===0,this.hasCachedResults)}}const kN="SyncEngine";class ELt{constructor(t,e,s){this.query=t,this.targetId=e,this.view=s}}class $Lt{constructor(t){this.key=t,this.hu=!1}}class ALt{constructor(t,e,s,r,i,o){this.localStore=t,this.remoteStore=e,this.eventManager=s,this.sharedClientState=r,this.currentUser=i,this.maxConcurrentLimboResolutions=o,this.Pu={},this.Tu=new Tf((a=>h9(a)),mS),this.Iu=new Map,this.Eu=new Set,this.du=new ds(ge.comparator),this.Au=new Map,this.Ru=new bN,this.Vu={},this.mu=new Map,this.fu=dp.cr(),this.onlineState="Unknown",this.gu=void 0}get isPrimaryClient(){return this.gu===!0}}async function kLt(n,t,e=!0){const s=J9(n);let r;const i=s.Tu.get(t);return i?(s.sharedClientState.addLocalQueryTarget(i.targetId),r=i.view.lu()):r=await K9(s,t,e,!0),r}async function _Lt(n,t){const e=J9(n);await K9(e,t,!0,!1)}async function K9(n,t,e,s){const r=await H3t(n.localStore,ul(t)),i=r.targetId,o=n.sharedClientState.addLocalQueryTarget(i,e);let a;return s&&(a=await NLt(n,t,i,o==="current",r.resumeToken)),n.isPrimaryClient&&e&&P9(n.remoteStore,r),a}async function NLt(n,t,e,s,r){n.pu=(d,m,y)=>(async function(w,x,S,T){let $=x.view.ru(S);$.Cs&&($=await lB(w.localStore,x.query,!1).then((({documents:N})=>x.view.ru(N,$))));const E=T&&T.targetChanges.get(x.targetId),R=T&&T.targetMismatches.get(x.targetId)!=null,B=x.view.applyChanges($,w.isPrimaryClient,E,R);return bB(w,x.targetId,B.au),B.snapshot})(n,d,m,y);const i=await lB(n.localStore,t,!0),o=new CLt(t,i.Qs),a=o.ru(i.documents),l=Mb.createSynthesizedTargetChangeForCurrentChange(e,s&&n.onlineState!=="Offline",r),c=o.applyChanges(a,n.isPrimaryClient,l);bB(n,e,c.au);const f=new ELt(t,e,o);return n.Tu.set(t,f),n.Iu.has(e)?n.Iu.get(e).push(t):n.Iu.set(e,[t]),c.snapshot}async function RLt(n,t,e){const s=De(n),r=s.Tu.get(t),i=s.Iu.get(r.targetId);if(i.length>1)return s.Iu.set(r.targetId,i.filter((o=>!mS(o,t)))),void s.Tu.delete(t);s.isPrimaryClient?(s.sharedClientState.removeLocalQueryTarget(r.targetId),s.sharedClientState.isActiveQueryTarget(r.targetId)||await r2(s.localStore,r.targetId,!1).then((()=>{s.sharedClientState.clearQueryState(r.targetId),e&&SN(s.remoteStore,r.targetId),a2(s,r.targetId)})).catch(Wp)):(a2(s,r.targetId),await r2(s.localStore,r.targetId,!0))}async function DLt(n,t){const e=De(n),s=e.Tu.get(t),r=e.Iu.get(s.targetId);e.isPrimaryClient&&r.length===1&&(e.sharedClientState.removeLocalQueryTarget(s.targetId),SN(e.remoteStore,s.targetId))}async function OLt(n,t,e){const s=VLt(n);try{const r=await(function(o,a){const l=De(o),c=Hn.now(),f=a.reduce(((y,b)=>y.add(b.key)),Qe());let d,m;return l.persistence.runTransaction("Locally write mutations","readwrite",(y=>{let b=su(),w=Qe();return l.Ns.getEntries(y,f).next((x=>{b=x,b.forEach(((S,T)=>{T.isValidDocument()||(w=w.add(S))}))})).next((()=>l.localDocuments.getOverlayedDocuments(y,b))).next((x=>{d=x;const S=[];for(const T of a){const $=qMt(T,d.get(T.key).overlayedDocument);$!=null&&S.push(new Cf(T.key,$,n9($.value.mapValue),Kl.exists(!0)))}return l.mutationQueue.addMutationBatch(y,c,S,a)})).next((x=>{m=x;const S=x.applyToLocalDocumentSet(d,w);return l.documentOverlayCache.saveOverlays(y,x.batchId,S)}))})).then((()=>({batchId:m.batchId,changes:p9(d)})))})(s.localStore,t);s.sharedClientState.addPendingMutation(r.batchId),(function(o,a,l){let c=o.Vu[o.currentUser.toKey()];c||(c=new ds(Ye)),c=c.insert(a,l),o.Vu[o.currentUser.toKey()]=c})(s,r.batchId,e),await zb(s,r.changes),await SS(s.remoteStore)}catch(r){const i=$N(r,"Failed to persist write");e.reject(i)}}async function X9(n,t){const e=De(n);try{const s=await W3t(e.localStore,t);t.targetChanges.forEach(((r,i)=>{const o=e.Au.get(i);o&&(Sn(r.addedDocuments.size+r.modifiedDocuments.size+r.removedDocuments.size<=1,22616),r.addedDocuments.size>0?o.hu=!0:r.modifiedDocuments.size>0?Sn(o.hu,14607):r.removedDocuments.size>0&&(Sn(o.hu,42227),o.hu=!1))})),await zb(e,s,t)}catch(s){await Wp(s)}}function yB(n,t,e){const s=De(n);if(s.isPrimaryClient&&e===0||!s.isPrimaryClient&&e===1){const r=[];s.Tu.forEach(((i,o)=>{const a=o.view.va(t);a.snapshot&&r.push(a.snapshot)})),(function(o,a){const l=De(o);l.onlineState=a;let c=!1;l.queries.forEach(((f,d)=>{for(const m of d.Sa)m.va(a)&&(c=!0)})),c&&AN(l)})(s.eventManager,t),r.length&&s.Pu.H_(r),s.onlineState=t,s.isPrimaryClient&&s.sharedClientState.setOnlineState(t)}}async function FLt(n,t,e){const s=De(n);s.sharedClientState.updateQueryState(t,"rejected",e);const r=s.Au.get(t),i=r&&r.key;if(i){let o=new ds(ge.comparator);o=o.insert(i,jr.newNoDocument(i,ke.min()));const a=Qe().add(i),l=new xS(ke.min(),new Map,new ds(Ye),o,a);await X9(s,l),s.du=s.du.remove(i),s.Au.delete(t),_N(s)}else await r2(s.localStore,t,!1).then((()=>a2(s,t,e))).catch(Wp)}async function MLt(n,t){const e=De(n),s=t.batch.batchId;try{const r=await G3t(e.localStore,t);Q9(e,s,null),Y9(e,s),e.sharedClientState.updateMutationState(s,"acknowledged"),await zb(e,r)}catch(r){await Wp(r)}}async function LLt(n,t,e){const s=De(n);try{const r=await(function(o,a){const l=De(o);return l.persistence.runTransaction("Reject batch","readwrite-primary",(c=>{let f;return l.mutationQueue.lookupMutationBatch(c,a).next((d=>(Sn(d!==null,37113),f=d.keys(),l.mutationQueue.removeMutationBatch(c,d)))).next((()=>l.mutationQueue.performConsistencyCheck(c))).next((()=>l.documentOverlayCache.removeOverlaysForBatchId(c,f,a))).next((()=>l.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(c,f))).next((()=>l.localDocuments.getDocuments(c,f)))}))})(s.localStore,t);Q9(s,t,e),Y9(s,t),s.sharedClientState.updateMutationState(t,"rejected",e),await zb(s,r)}catch(r){await Wp(r)}}function Y9(n,t){(n.mu.get(t)||[]).forEach((e=>{e.resolve()})),n.mu.delete(t)}function Q9(n,t,e){const s=De(n);let r=s.Vu[s.currentUser.toKey()];if(r){const i=r.get(t);i&&(e?i.reject(e):i.resolve(),r=r.remove(t)),s.Vu[s.currentUser.toKey()]=r}}function a2(n,t,e=null){n.sharedClientState.removeLocalQueryTarget(t);for(const s of n.Iu.get(t))n.Tu.delete(s),e&&n.Pu.yu(s,e);n.Iu.delete(t),n.isPrimaryClient&&n.Ru.jr(t).forEach((s=>{n.Ru.containsKey(s)||Z9(n,s)}))}function Z9(n,t){n.Eu.delete(t.path.canonicalString());const e=n.du.get(t);e!==null&&(SN(n.remoteStore,e),n.du=n.du.remove(t),n.Au.delete(e),_N(n))}function bB(n,t,e){for(const s of e)s instanceof q9?(n.Ru.addReference(s.key,t),zLt(n,s)):s instanceof H9?(re(kN,"Document no longer in limbo: "+s.key),n.Ru.removeReference(s.key,t),n.Ru.containsKey(s.key)||Z9(n,s.key)):Ce(19791,{wu:s})}function zLt(n,t){const e=t.key,s=e.path.canonicalString();n.du.get(e)||n.Eu.has(s)||(re(kN,"New document in limbo: "+e),n.Eu.add(s),_N(n))}function _N(n){for(;n.Eu.size>0&&n.du.size<n.maxConcurrentLimboResolutions;){const t=n.Eu.values().next().value;n.Eu.delete(t);const e=new ge(qn.fromString(t)),s=n.fu.next();n.Au.set(s,new $Lt(e)),n.du=n.du.insert(e,s),P9(n.remoteStore,new Qu(ul(u9(e.path)),s,"TargetPurposeLimboResolution",fS.ce))}}async function zb(n,t,e){const s=De(n),r=[],i=[],o=[];s.Tu.isEmpty()||(s.Tu.forEach(((a,l)=>{o.push(s.pu(l,t,e).then((c=>{if((c||e)&&s.isPrimaryClient){const f=c?!c.fromCache:e?.targetChanges.get(l.targetId)?.current;s.sharedClientState.updateQueryState(l.targetId,f?"current":"not-current")}if(c){r.push(c);const f=wN.As(l.targetId,c);i.push(f)}})))})),await Promise.all(o),s.Pu.H_(r),await(async function(l,c){const f=De(l);try{await f.persistence.runTransaction("notifyLocalViewChanges","readwrite",(d=>jt.forEach(c,(m=>jt.forEach(m.Es,(y=>f.persistence.referenceDelegate.addReference(d,m.targetId,y))).next((()=>jt.forEach(m.ds,(y=>f.persistence.referenceDelegate.removeReference(d,m.targetId,y)))))))))}catch(d){if(!jp(d))throw d;re(vN,"Failed to update sequence numbers: "+d)}for(const d of c){const m=d.targetId;if(!d.fromCache){const y=f.Ms.get(m),b=y.snapshotVersion,w=y.withLastLimboFreeSnapshotVersion(b);f.Ms=f.Ms.insert(m,w)}}})(s.localStore,i))}async function BLt(n,t){const e=De(n);if(!e.currentUser.isEqual(t)){re(kN,"User change. New user:",t.toKey());const s=await M9(e.localStore,t);e.currentUser=t,(function(i,o){i.mu.forEach((a=>{a.forEach((l=>{l.reject(new se(Gt.CANCELLED,o))}))})),i.mu.clear()})(e,"'waitForPendingWrites' promise is rejected due to a user change."),e.sharedClientState.handleUserChange(t,s.removedBatchIds,s.addedBatchIds),await zb(e,s.Ls)}}function PLt(n,t){const e=De(n),s=e.Au.get(t);if(s&&s.hu)return Qe().add(s.key);{let r=Qe();const i=e.Iu.get(t);if(!i)return r;for(const o of i){const a=e.Tu.get(o);r=r.unionWith(a.view.nu)}return r}}function J9(n){const t=De(n);return t.remoteStore.remoteSyncer.applyRemoteEvent=X9.bind(null,t),t.remoteStore.remoteSyncer.getRemoteKeysForTarget=PLt.bind(null,t),t.remoteStore.remoteSyncer.rejectListen=FLt.bind(null,t),t.Pu.H_=SLt.bind(null,t.eventManager),t.Pu.yu=ILt.bind(null,t.eventManager),t}function VLt(n){const t=De(n);return t.remoteStore.remoteSyncer.applySuccessfulWrite=MLt.bind(null,t),t.remoteStore.remoteSyncer.rejectFailedWrite=LLt.bind(null,t),t}class ow{constructor(){this.kind="memory",this.synchronizeTabs=!1}async initialize(t){this.serializer=wS(t.databaseInfo.databaseId),this.sharedClientState=this.Du(t),this.persistence=this.Cu(t),await this.persistence.start(),this.localStore=this.vu(t),this.gcScheduler=this.Fu(t,this.localStore),this.indexBackfillerScheduler=this.Mu(t,this.localStore)}Fu(t,e){return null}Mu(t,e){return null}vu(t){return U3t(this.persistence,new B3t,t.initialUser,this.serializer)}Cu(t){return new F9(xN.mi,this.serializer)}Du(t){return new X3t}async terminate(){this.gcScheduler?.stop(),this.indexBackfillerScheduler?.stop(),this.sharedClientState.shutdown(),await this.persistence.shutdown()}}ow.provider={build:()=>new ow};class ULt extends ow{constructor(t){super(),this.cacheSizeBytes=t}Fu(t,e){Sn(this.persistence.referenceDelegate instanceof rw,46915);const s=this.persistence.referenceDelegate.garbageCollector;return new T3t(s,t.asyncQueue,e)}Cu(t){const e=this.cacheSizeBytes!==void 0?Si.withCacheSize(this.cacheSizeBytes):Si.DEFAULT;return new F9((s=>rw.mi(s,e)),this.serializer)}}class l2{async initialize(t,e){this.localStore||(this.localStore=t.localStore,this.sharedClientState=t.sharedClientState,this.datastore=this.createDatastore(e),this.remoteStore=this.createRemoteStore(e),this.eventManager=this.createEventManager(e),this.syncEngine=this.createSyncEngine(e,!t.synchronizeTabs),this.sharedClientState.onlineStateHandler=s=>yB(this.syncEngine,s,1),this.remoteStore.remoteSyncer.handleCredentialChange=BLt.bind(null,this.syncEngine),await yLt(this.remoteStore,this.syncEngine.isPrimaryClient))}createEventManager(t){return(function(){return new xLt})()}createDatastore(t){const e=wS(t.databaseInfo.databaseId),s=(function(i){return new tLt(i)})(t.databaseInfo);return(function(i,o,a,l){return new rLt(i,o,a,l)})(t.authCredentials,t.appCheckCredentials,s,e)}createRemoteStore(t){return(function(s,r,i,o,a){return new oLt(s,r,i,o,a)})(this.localStore,this.datastore,t.asyncQueue,(e=>yB(this.syncEngine,e,0)),(function(){return hB.v()?new hB:new Y3t})())}createSyncEngine(t,e){return(function(r,i,o,a,l,c,f){const d=new ALt(r,i,o,a,l,c);return f&&(d.gu=!0),d})(this.localStore,this.remoteStore,this.eventManager,this.sharedClientState,t.initialUser,t.maxConcurrentLimboResolutions,e)}async terminate(){await(async function(e){const s=De(e);re(sf,"RemoteStore shutting down."),s.Ea.add(5),await Lb(s),s.Aa.shutdown(),s.Ra.set("Unknown")})(this.remoteStore),this.datastore?.terminate(),this.eventManager?.terminate()}}l2.provider={build:()=>new l2};class GLt{constructor(t){this.observer=t,this.muted=!1}next(t){this.muted||this.observer.next&&this.Ou(this.observer.next,t)}error(t){this.muted||(this.observer.error?this.Ou(this.observer.error,t):nu("Uncaught Error in snapshot listener:",t.toString()))}Nu(){this.muted=!0}Ou(t,e){setTimeout((()=>{this.muted||t(e)}),0)}}const $c="FirestoreClient";class WLt{constructor(t,e,s,r,i){this.authCredentials=t,this.appCheckCredentials=e,this.asyncQueue=s,this.databaseInfo=r,this.user=Gr.UNAUTHENTICATED,this.clientId=cS.newId(),this.authCredentialListener=()=>Promise.resolve(),this.appCheckCredentialListener=()=>Promise.resolve(),this._uninitializedComponentsProvider=i,this.authCredentials.start(s,(async o=>{re($c,"Received user=",o.uid),await this.authCredentialListener(o),this.user=o})),this.appCheckCredentials.start(s,(o=>(re($c,"Received new app check token=",o),this.appCheckCredentialListener(o,this.user))))}get configuration(){return{asyncQueue:this.asyncQueue,databaseInfo:this.databaseInfo,clientId:this.clientId,authCredentials:this.authCredentials,appCheckCredentials:this.appCheckCredentials,initialUser:this.user,maxConcurrentLimboResolutions:100}}setCredentialChangeListener(t){this.authCredentialListener=t}setAppCheckTokenChangeListener(t){this.appCheckCredentialListener=t}terminate(){this.asyncQueue.enterRestrictedMode();const t=new ac;return this.asyncQueue.enqueueAndForgetEvenWhileRestricted((async()=>{try{this._onlineComponents&&await this._onlineComponents.terminate(),this._offlineComponents&&await this._offlineComponents.terminate(),this.authCredentials.shutdown(),this.appCheckCredentials.shutdown(),t.resolve()}catch(e){const s=$N(e,"Failed to shutdown persistence");t.reject(s)}})),t.promise}}async function CE(n,t){n.asyncQueue.verifyOperationInProgress(),re($c,"Initializing OfflineComponentProvider");const e=n.configuration;await t.initialize(e);let s=e.initialUser;n.setCredentialChangeListener((async r=>{s.isEqual(r)||(await M9(t.localStore,r),s=r)})),t.persistence.setDatabaseDeletedListener((()=>n.terminate())),n._offlineComponents=t}async function xB(n,t){n.asyncQueue.verifyOperationInProgress();const e=await jLt(n);re($c,"Initializing OnlineComponentProvider"),await t.initialize(e,n.configuration),n.setCredentialChangeListener((s=>dB(t.remoteStore,s))),n.setAppCheckTokenChangeListener(((s,r)=>dB(t.remoteStore,r))),n._onlineComponents=t}async function jLt(n){if(!n._offlineComponents)if(n._uninitializedComponentsProvider){re($c,"Using user provided OfflineComponentProvider");try{await CE(n,n._uninitializedComponentsProvider._offline)}catch(t){const e=t;if(!(function(r){return r.name==="FirebaseError"?r.code===Gt.FAILED_PRECONDITION||r.code===Gt.UNIMPLEMENTED:!(typeof DOMException<"u"&&r instanceof DOMException)||r.code===22||r.code===20||r.code===11})(e))throw e;nf("Error using user provided cache. Falling back to memory cache: "+e),await CE(n,new ow)}}else re($c,"Using default OfflineComponentProvider"),await CE(n,new ULt(void 0));return n._offlineComponents}async function tK(n){return n._onlineComponents||(n._uninitializedComponentsProvider?(re($c,"Using user provided OnlineComponentProvider"),await xB(n,n._uninitializedComponentsProvider._online)):(re($c,"Using default OnlineComponentProvider"),await xB(n,new l2))),n._onlineComponents}function qLt(n){return tK(n).then((t=>t.syncEngine))}async function HLt(n){const t=await tK(n),e=t.eventManager;return e.onListen=kLt.bind(null,t.syncEngine),e.onUnlisten=RLt.bind(null,t.syncEngine),e.onFirstRemoteStoreListen=_Lt.bind(null,t.syncEngine),e.onLastRemoteStoreUnlisten=DLt.bind(null,t.syncEngine),e}function KLt(n,t,e={}){const s=new ac;return n.asyncQueue.enqueueAndForget((async()=>(function(i,o,a,l,c){const f=new GLt({next:m=>{f.Nu(),o.enqueueAndForget((()=>vLt(i,d))),m.fromCache&&l.source==="server"?c.reject(new se(Gt.UNAVAILABLE,'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')):c.resolve(m)},error:m=>c.reject(m)}),d=new TLt(a,f,{includeMetadataChanges:!0,qa:!0});return wLt(i,d)})(await HLt(n),n.asyncQueue,t,e,s))),s.promise}function eK(n){const t={};return n.timeoutSeconds!==void 0&&(t.timeoutSeconds=n.timeoutSeconds),t}const wB=new Map;const nK="firestore.googleapis.com",vB=!0;class SB{constructor(t){if(t.host===void 0){if(t.ssl!==void 0)throw new se(Gt.INVALID_ARGUMENT,"Can't provide ssl option if host option is not set");this.host=nK,this.ssl=vB}else this.host=t.host,this.ssl=t.ssl??vB;if(this.isUsingEmulator=t.emulatorOptions!==void 0,this.credentials=t.credentials,this.ignoreUndefinedProperties=!!t.ignoreUndefinedProperties,this.localCache=t.localCache,t.cacheSizeBytes===void 0)this.cacheSizeBytes=O9;else{if(t.cacheSizeBytes!==-1&&t.cacheSizeBytes<S3t)throw new se(Gt.INVALID_ARGUMENT,"cacheSizeBytes must be at least 1048576");this.cacheSizeBytes=t.cacheSizeBytes}j8("experimentalForceLongPolling",t.experimentalForceLongPolling,"experimentalAutoDetectLongPolling",t.experimentalAutoDetectLongPolling),this.experimentalForceLongPolling=!!t.experimentalForceLongPolling,this.experimentalForceLongPolling?this.experimentalAutoDetectLongPolling=!1:t.experimentalAutoDetectLongPolling===void 0?this.experimentalAutoDetectLongPolling=!0:this.experimentalAutoDetectLongPolling=!!t.experimentalAutoDetectLongPolling,this.experimentalLongPollingOptions=eK(t.experimentalLongPollingOptions??{}),(function(s){if(s.timeoutSeconds!==void 0){if(isNaN(s.timeoutSeconds))throw new se(Gt.INVALID_ARGUMENT,`invalid long polling timeout: ${s.timeoutSeconds} (must not be NaN)`);if(s.timeoutSeconds<5)throw new se(Gt.INVALID_ARGUMENT,`invalid long polling timeout: ${s.timeoutSeconds} (minimum allowed value is 5)`);if(s.timeoutSeconds>30)throw new se(Gt.INVALID_ARGUMENT,`invalid long polling timeout: ${s.timeoutSeconds} (maximum allowed value is 30)`)}})(this.experimentalLongPollingOptions),this.useFetchStreams=!!t.useFetchStreams}isEqual(t){return this.host===t.host&&this.ssl===t.ssl&&this.credentials===t.credentials&&this.cacheSizeBytes===t.cacheSizeBytes&&this.experimentalForceLongPolling===t.experimentalForceLongPolling&&this.experimentalAutoDetectLongPolling===t.experimentalAutoDetectLongPolling&&(function(s,r){return s.timeoutSeconds===r.timeoutSeconds})(this.experimentalLongPollingOptions,t.experimentalLongPollingOptions)&&this.ignoreUndefinedProperties===t.ignoreUndefinedProperties&&this.useFetchStreams===t.useFetchStreams}}class IS{constructor(t,e,s,r){this._authCredentials=t,this._appCheckCredentials=e,this._databaseId=s,this._app=r,this.type="firestore-lite",this._persistenceKey="(lite)",this._settings=new SB({}),this._settingsFrozen=!1,this._emulatorOptions={},this._terminateTask="notTerminated"}get app(){if(!this._app)throw new se(Gt.FAILED_PRECONDITION,"Firestore was not initialized using the Firebase SDK. 'app' is not available");return this._app}get _initialized(){return this._settingsFrozen}get _terminated(){return this._terminateTask!=="notTerminated"}_setSettings(t){if(this._settingsFrozen)throw new se(Gt.FAILED_PRECONDITION,"Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");this._settings=new SB(t),this._emulatorOptions=t.emulatorOptions||{},t.credentials!==void 0&&(this._authCredentials=(function(s){if(!s)return new G8;switch(s.type){case"firstParty":return new JFt(s.sessionIndex||"0",s.iamToken||null,s.authTokenFactory||null);case"provider":return s.client;default:throw new se(Gt.INVALID_ARGUMENT,"makeAuthCredentialsProvider failed due to invalid credential type")}})(t.credentials))}_getSettings(){return this._settings}_getEmulatorOptions(){return this._emulatorOptions}_freezeSettings(){return this._settingsFrozen=!0,this._settings}_delete(){return this._terminateTask==="notTerminated"&&(this._terminateTask=this._terminate()),this._terminateTask}async _restart(){this._terminateTask==="notTerminated"?await this._terminate():this._terminateTask="notTerminated"}toJSON(){return{app:this._app,databaseId:this._databaseId,settings:this._settings}}_terminate(){return(function(e){const s=wB.get(e);s&&(re("ComponentProvider","Removing Datastore"),wB.delete(e),s.terminate())})(this),Promise.resolve()}}function sK(n,t,e,s={}){n=qg(n,IS);const r=Db(t),i=n._getSettings(),o={...i,emulatorOptions:n._getEmulatorOptions()},a=`${t}:${e}`;r&&(T8(`https://${a}`),C8("Firestore",!0)),i.host!==nK&&i.host!==a&&nf("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used.");const l={...i,host:a,ssl:r,emulatorOptions:s};if(!Wg(l,o)&&(n._setSettings(l),s.mockUserToken)){let c,f;if(typeof s.mockUserToken=="string")c=s.mockUserToken,f=Gr.MOCK_USER;else{c=COt(s.mockUserToken,n._app?.options.projectId);const d=s.mockUserToken.sub||s.mockUserToken.user_id;if(!d)throw new se(Gt.INVALID_ARGUMENT,"mockUserToken must contain 'sub' or 'user_id' field!");f=new Gr(d)}n._authCredentials=new YFt(new U8(c,f))}}class hu{constructor(t,e,s){this.converter=e,this._query=s,this.type="query",this.firestore=t}withConverter(t){return new hu(this.firestore,t,this._query)}}class or{constructor(t,e,s){this.converter=e,this._key=s,this.type="document",this.firestore=t}get _path(){return this._key.path}get id(){return this._key.path.lastSegment()}get path(){return this._key.path.canonicalString()}get parent(){return new Xl(this.firestore,this.converter,this._key.path.popLast())}withConverter(t){return new or(this.firestore,t,this._key)}toJSON(){return{type:or._jsonSchemaVersion,referencePath:this._key.toString()}}static fromJSON(t,e,s){if(Ob(e,or._jsonSchema))return new or(t,s||null,new ge(qn.fromString(e.referencePath)))}}or._jsonSchemaVersion="firestore/documentReference/1.0",or._jsonSchema={type:Hs("string",or._jsonSchemaVersion),referencePath:Hs("string")};class Xl extends hu{constructor(t,e,s){super(t,e,u9(s)),this._path=s,this.type="collection"}get id(){return this._query.path.lastSegment()}get path(){return this._query.path.canonicalString()}get parent(){const t=this._path.popLast();return t.isEmpty()?null:new or(this.firestore,null,new ge(t))}withConverter(t){return new Xl(this.firestore,t,this._path)}}function u2(n,t,...e){if(n=Eo(n),W8("collection","path",t),n instanceof IS){const s=qn.fromString(t,...e);return Fz(s),new Xl(n,null,s)}{if(!(n instanceof or||n instanceof Xl))throw new se(Gt.INVALID_ARGUMENT,"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");const s=n._path.child(qn.fromString(t,...e));return Fz(s),new Xl(n.firestore,null,s)}}function rK(n,t,...e){if(n=Eo(n),arguments.length===1&&(t=cS.newId()),W8("doc","path",t),n instanceof IS){const s=qn.fromString(t,...e);return Oz(s),new or(n,null,new ge(s))}{if(!(n instanceof or||n instanceof Xl))throw new se(Gt.INVALID_ARGUMENT,"Expected first argument to doc() to be a CollectionReference, a DocumentReference or FirebaseFirestore");const s=n._path.child(qn.fromString(t,...e));return Oz(s),new or(n.firestore,n instanceof Xl?n.converter:null,new ge(s))}}const IB="AsyncQueue";class TB{constructor(t=Promise.resolve()){this.Xu=[],this.ec=!1,this.tc=[],this.nc=null,this.rc=!1,this.sc=!1,this.oc=[],this.M_=new z9(this,"async_queue_retry"),this._c=()=>{const s=TE();s&&re(IB,"Visibility state changed to "+s.visibilityState),this.M_.w_()},this.ac=t;const e=TE();e&&typeof e.addEventListener=="function"&&e.addEventListener("visibilitychange",this._c)}get isShuttingDown(){return this.ec}enqueueAndForget(t){this.enqueue(t)}enqueueAndForgetEvenWhileRestricted(t){this.uc(),this.cc(t)}enterRestrictedMode(t){if(!this.ec){this.ec=!0,this.sc=t||!1;const e=TE();e&&typeof e.removeEventListener=="function"&&e.removeEventListener("visibilitychange",this._c)}}enqueue(t){if(this.uc(),this.ec)return new Promise((()=>{}));const e=new ac;return this.cc((()=>this.ec&&this.sc?Promise.resolve():(t().then(e.resolve,e.reject),e.promise))).then((()=>e.promise))}enqueueRetryable(t){this.enqueueAndForget((()=>(this.Xu.push(t),this.lc())))}async lc(){if(this.Xu.length!==0){try{await this.Xu[0](),this.Xu.shift(),this.M_.reset()}catch(t){if(!jp(t))throw t;re(IB,"Operation failed with retryable error: "+t)}this.Xu.length>0&&this.M_.p_((()=>this.lc()))}}cc(t){const e=this.ac.then((()=>(this.rc=!0,t().catch((s=>{throw this.nc=s,this.rc=!1,nu("INTERNAL UNHANDLED ERROR: ",CB(s)),s})).then((s=>(this.rc=!1,s))))));return this.ac=e,e}enqueueAfterDelay(t,e,s){this.uc(),this.oc.indexOf(t)>-1&&(e=0);const r=EN.createAndSchedule(this,t,e,s,(i=>this.hc(i)));return this.tc.push(r),r}uc(){this.nc&&Ce(47125,{Pc:CB(this.nc)})}verifyOperationInProgress(){}async Tc(){let t;do t=this.ac,await t;while(t!==this.ac)}Ic(t){for(const e of this.tc)if(e.timerId===t)return!0;return!1}Ec(t){return this.Tc().then((()=>{this.tc.sort(((e,s)=>e.targetTimeMs-s.targetTimeMs));for(const e of this.tc)if(e.skipDelay(),t!=="all"&&e.timerId===t)break;return this.Tc()}))}dc(t){this.oc.push(t)}hc(t){const e=this.tc.indexOf(t);this.tc.splice(e,1)}}function CB(n){let t=n.message||"";return n.stack&&(t=n.stack.includes(n.message)?n.stack:n.message+`
`+n.stack),t}class TS extends IS{constructor(t,e,s,r){super(t,e,s,r),this.type="firestore",this._queue=new TB,this._persistenceKey=r?.name||"[DEFAULT]"}async _terminate(){if(this._firestoreClient){const t=this._firestoreClient.terminate();this._queue=new TB(t),this._firestoreClient=void 0,await t}}}function iK(n,t){const e=typeof n=="object"?n:aN(),s=typeof n=="string"?n:Zx,r=Up(e,"firestore").getImmediate({identifier:s});if(!r._initialized){const i=S8("firestore");i&&sK(r,...i)}return r}function NN(n){if(n._terminated)throw new se(Gt.FAILED_PRECONDITION,"The client has already been terminated.");return n._firestoreClient||XLt(n),n._firestoreClient}function XLt(n){const t=n._freezeSettings(),e=(function(r,i,o,a){return new gMt(r,i,o,a.host,a.ssl,a.experimentalForceLongPolling,a.experimentalAutoDetectLongPolling,eK(a.experimentalLongPollingOptions),a.useFetchStreams,a.isUsingEmulator)})(n._databaseId,n._app?.options.appId||"",n._persistenceKey,t);n._componentsProvider||t.localCache?._offlineComponentProvider&&t.localCache?._onlineComponentProvider&&(n._componentsProvider={_offline:t.localCache._offlineComponentProvider,_online:t.localCache._onlineComponentProvider}),n._firestoreClient=new WLt(n._authCredentials,n._appCheckCredentials,n._queue,e,n._componentsProvider&&(function(r){const i=r?._online.build();return{_offline:r?._offline.build(i),_online:i}})(n._componentsProvider))}class Gi{constructor(t){this._byteString=t}static fromBase64String(t){try{return new Gi(wr.fromBase64String(t))}catch(e){throw new se(Gt.INVALID_ARGUMENT,"Failed to construct data from Base64 string: "+e)}}static fromUint8Array(t){return new Gi(wr.fromUint8Array(t))}toBase64(){return this._byteString.toBase64()}toUint8Array(){return this._byteString.toUint8Array()}toString(){return"Bytes(base64: "+this.toBase64()+")"}isEqual(t){return this._byteString.isEqual(t._byteString)}toJSON(){return{type:Gi._jsonSchemaVersion,bytes:this.toBase64()}}static fromJSON(t){if(Ob(t,Gi._jsonSchema))return Gi.fromBase64String(t.bytes)}}Gi._jsonSchemaVersion="firestore/bytes/1.0",Gi._jsonSchema={type:Hs("string",Gi._jsonSchemaVersion),bytes:Hs("string")};class CS{constructor(...t){for(let e=0;e<t.length;++e)if(t[e].length===0)throw new se(Gt.INVALID_ARGUMENT,"Invalid field name at argument $(i + 1). Field names must not be empty.");this._internalPath=new yr(t)}isEqual(t){return this._internalPath.isEqual(t._internalPath)}}class ES{constructor(t){this._methodName=t}}class ra{constructor(t,e){if(!isFinite(t)||t<-90||t>90)throw new se(Gt.INVALID_ARGUMENT,"Latitude must be a number between -90 and 90, but was: "+t);if(!isFinite(e)||e<-180||e>180)throw new se(Gt.INVALID_ARGUMENT,"Longitude must be a number between -180 and 180, but was: "+e);this._lat=t,this._long=e}get latitude(){return this._lat}get longitude(){return this._long}isEqual(t){return this._lat===t._lat&&this._long===t._long}_compareTo(t){return Ye(this._lat,t._lat)||Ye(this._long,t._long)}toJSON(){return{latitude:this._lat,longitude:this._long,type:ra._jsonSchemaVersion}}static fromJSON(t){if(Ob(t,ra._jsonSchema))return new ra(t.latitude,t.longitude)}}ra._jsonSchemaVersion="firestore/geoPoint/1.0",ra._jsonSchema={type:Hs("string",ra._jsonSchemaVersion),latitude:Hs("number"),longitude:Hs("number")};class ia{constructor(t){this._values=(t||[]).map((e=>e))}toArray(){return this._values.map((t=>t))}isEqual(t){return(function(s,r){if(s.length!==r.length)return!1;for(let i=0;i<s.length;++i)if(s[i]!==r[i])return!1;return!0})(this._values,t._values)}toJSON(){return{type:ia._jsonSchemaVersion,vectorValues:this._values}}static fromJSON(t){if(Ob(t,ia._jsonSchema)){if(Array.isArray(t.vectorValues)&&t.vectorValues.every((e=>typeof e=="number")))return new ia(t.vectorValues);throw new se(Gt.INVALID_ARGUMENT,"Expected 'vectorValues' field to be a number array")}}}ia._jsonSchemaVersion="firestore/vectorValue/1.0",ia._jsonSchema={type:Hs("string",ia._jsonSchemaVersion),vectorValues:Hs("object")};const YLt=/^__.*__$/;class QLt{constructor(t,e,s){this.data=t,this.fieldMask=e,this.fieldTransforms=s}toMutation(t,e){return this.fieldMask!==null?new Cf(t,this.data,this.fieldMask,e,this.fieldTransforms):new Fb(t,this.data,e,this.fieldTransforms)}}function oK(n){switch(n){case 0:case 2:case 1:return!0;case 3:case 4:return!1;default:throw Ce(40011,{Ac:n})}}class RN{constructor(t,e,s,r,i,o){this.settings=t,this.databaseId=e,this.serializer=s,this.ignoreUndefinedProperties=r,i===void 0&&this.Rc(),this.fieldTransforms=i||[],this.fieldMask=o||[]}get path(){return this.settings.path}get Ac(){return this.settings.Ac}Vc(t){return new RN({...this.settings,...t},this.databaseId,this.serializer,this.ignoreUndefinedProperties,this.fieldTransforms,this.fieldMask)}mc(t){const e=this.path?.child(t),s=this.Vc({path:e,fc:!1});return s.gc(t),s}yc(t){const e=this.path?.child(t),s=this.Vc({path:e,fc:!1});return s.Rc(),s}wc(t){return this.Vc({path:void 0,fc:!0})}Sc(t){return aw(t,this.settings.methodName,this.settings.bc||!1,this.path,this.settings.Dc)}contains(t){return this.fieldMask.find((e=>t.isPrefixOf(e)))!==void 0||this.fieldTransforms.find((e=>t.isPrefixOf(e.field)))!==void 0}Rc(){if(this.path)for(let t=0;t<this.path.length;t++)this.gc(this.path.get(t))}gc(t){if(t.length===0)throw this.Sc("Document fields must not be empty");if(oK(this.Ac)&&YLt.test(t))throw this.Sc('Document fields cannot begin and end with "__"')}}class ZLt{constructor(t,e,s){this.databaseId=t,this.ignoreUndefinedProperties=e,this.serializer=s||wS(t)}Cc(t,e,s,r=!1){return new RN({Ac:t,methodName:e,Dc:s,path:yr.emptyPath(),fc:!1,bc:r},this.databaseId,this.serializer,this.ignoreUndefinedProperties)}}function aK(n){const t=n._freezeSettings(),e=wS(n._databaseId);return new ZLt(n._databaseId,!!t.ignoreUndefinedProperties,e)}function JLt(n,t,e,s,r,i={}){const o=n.Cc(i.merge||i.mergeFields?2:0,t,e,r);cK("Data must be an object, but it was:",o,s);const a=lK(s,o);let l,c;if(i.merge)l=new Zo(o.fieldMask),c=o.fieldTransforms;else if(i.mergeFields){const f=[];for(const d of i.mergeFields){const m=ezt(t,d,e);if(!o.contains(m))throw new se(Gt.INVALID_ARGUMENT,`Field '${m}' is specified in your field mask but missing from your input data.`);szt(f,m)||f.push(m)}l=new Zo(f),c=o.fieldTransforms.filter((d=>l.covers(d.field)))}else l=null,c=o.fieldTransforms;return new QLt(new yo(a),l,c)}class DN extends ES{_toFieldTransform(t){return new UMt(t.path,new Qg)}isEqual(t){return t instanceof DN}}function tzt(n,t,e,s=!1){return ON(e,n.Cc(s?4:3,t))}function ON(n,t){if(uK(n=Eo(n)))return cK("Unsupported field value:",t,n),lK(n,t);if(n instanceof ES)return(function(s,r){if(!oK(r.Ac))throw r.Sc(`${s._methodName}() can only be used with update() and set()`);if(!r.path)throw r.Sc(`${s._methodName}() is not currently supported inside arrays`);const i=s._toFieldTransform(r);i&&r.fieldTransforms.push(i)})(n,t),null;if(n===void 0&&t.ignoreUndefinedProperties)return null;if(t.path&&t.fieldMask.push(t.path),n instanceof Array){if(t.settings.fc&&t.Ac!==4)throw t.Sc("Nested arrays are not supported");return(function(s,r){const i=[];let o=0;for(const a of s){let l=ON(a,r.wc(o));l==null&&(l={nullValue:"NULL_VALUE"}),i.push(l),o++}return{arrayValue:{values:i}}})(n,t)}return(function(s,r){if((s=Eo(s))===null)return{nullValue:"NULL_VALUE"};if(typeof s=="number")return BMt(r.serializer,s);if(typeof s=="boolean")return{booleanValue:s};if(typeof s=="string")return{stringValue:s};if(s instanceof Date){const i=Hn.fromDate(s);return{timestampValue:sw(r.serializer,i)}}if(s instanceof Hn){const i=new Hn(s.seconds,1e3*Math.floor(s.nanoseconds/1e3));return{timestampValue:sw(r.serializer,i)}}if(s instanceof ra)return{geoPointValue:{latitude:s.latitude,longitude:s.longitude}};if(s instanceof Gi)return{bytesValue:$9(r.serializer,s._byteString)};if(s instanceof or){const i=r.databaseId,o=s.firestore._databaseId;if(!o.isEqual(i))throw r.Sc(`Document reference is for database ${o.projectId}/${o.database} but should be for database ${i.projectId}/${i.database}`);return{referenceValue:yN(s.firestore._databaseId||r.databaseId,s._key.path)}}if(s instanceof ia)return(function(o,a){return{mapValue:{fields:{[t9]:{stringValue:e9},[Jx]:{arrayValue:{values:o.toArray().map((c=>{if(typeof c!="number")throw a.Sc("VectorValues must only contain numeric values.");return pN(a.serializer,c)}))}}}}}})(s,r);throw r.Sc(`Unsupported field value: ${hS(s)}`)})(n,t)}function lK(n,t){const e={};return K8(n)?t.path&&t.path.length>0&&t.fieldMask.push(t.path):If(n,((s,r)=>{const i=ON(r,t.mc(s));i!=null&&(e[s]=i)})),{mapValue:{fields:e}}}function uK(n){return!(typeof n!="object"||n===null||n instanceof Array||n instanceof Date||n instanceof Hn||n instanceof ra||n instanceof Gi||n instanceof or||n instanceof ES||n instanceof ia)}function cK(n,t,e){if(!uK(e)||!q8(e)){const s=hS(e);throw s==="an object"?t.Sc(n+" a custom object"):t.Sc(n+" "+s)}}function ezt(n,t,e){if((t=Eo(t))instanceof CS)return t._internalPath;if(typeof t=="string")return hK(n,t);throw aw("Field path arguments must be of type string or ",n,!1,void 0,e)}const nzt=new RegExp("[~\\*/\\[\\]]");function hK(n,t,e){if(t.search(nzt)>=0)throw aw(`Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`,n,!1,void 0,e);try{return new CS(...t.split("."))._internalPath}catch{throw aw(`Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,n,!1,void 0,e)}}function aw(n,t,e,s,r){const i=s&&!s.isEmpty(),o=r!==void 0;let a=`Function ${t}() called with invalid data`;e&&(a+=" (via `toFirestore()`)"),a+=". ";let l="";return(i||o)&&(l+=" (found",i&&(l+=` in field ${s}`),o&&(l+=` in document ${r}`),l+=")"),new se(Gt.INVALID_ARGUMENT,a+n+l)}function szt(n,t){return n.some((e=>e.isEqual(t)))}class fK{constructor(t,e,s,r,i){this._firestore=t,this._userDataWriter=e,this._key=s,this._document=r,this._converter=i}get id(){return this._key.path.lastSegment()}get ref(){return new or(this._firestore,this._converter,this._key)}exists(){return this._document!==null}data(){if(this._document){if(this._converter){const t=new rzt(this._firestore,this._userDataWriter,this._key,this._document,null);return this._converter.fromFirestore(t)}return this._userDataWriter.convertValue(this._document.data.value)}}get(t){if(this._document){const e=this._document.data.field(FN("DocumentSnapshot.get",t));if(e!==null)return this._userDataWriter.convertValue(e)}}}class rzt extends fK{data(){return super.data()}}function FN(n,t){return typeof t=="string"?hK(n,t):t instanceof CS?t._internalPath:t._delegate._internalPath}function izt(n){if(n.limitType==="L"&&n.explicitOrderBy.length===0)throw new se(Gt.UNIMPLEMENTED,"limitToLast() queries require specifying at least one orderBy() clause")}class MN{}class $S extends MN{}function ozt(n,t,...e){let s=[];t instanceof MN&&s.push(t),s=s.concat(e),(function(i){const o=i.filter((l=>l instanceof kS)).length,a=i.filter((l=>l instanceof AS)).length;if(o>1||o>0&&a>0)throw new se(Gt.INVALID_ARGUMENT,"InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.")})(s);for(const r of s)n=r._apply(n);return n}class AS extends $S{constructor(t,e,s){super(),this._field=t,this._op=e,this._value=s,this.type="where"}static _create(t,e,s){return new AS(t,e,s)}_apply(t){const e=this._parse(t);return dK(t._query,e),new hu(t.firestore,t.converter,J$(t._query,e))}_parse(t){const e=aK(t.firestore);return(function(i,o,a,l,c,f,d){let m;if(c.isKeyField()){if(f==="array-contains"||f==="array-contains-any")throw new se(Gt.INVALID_ARGUMENT,`Invalid Query. You can't perform '${f}' queries on documentId().`);if(f==="in"||f==="not-in"){$B(d,f);const b=[];for(const w of d)b.push(EB(l,i,w));m={arrayValue:{values:b}}}else m=EB(l,i,d)}else f!=="in"&&f!=="not-in"&&f!=="array-contains-any"||$B(d,f),m=tzt(a,o,d,f==="in"||f==="not-in");return Us.create(c,f,m)})(t._query,"where",e,t.firestore._databaseId,this._field,this._op,this._value)}}class kS extends MN{constructor(t,e){super(),this.type=t,this._queryConstraints=e}static _create(t,e){return new kS(t,e)}_parse(t){const e=this._queryConstraints.map((s=>s._parse(t))).filter((s=>s.getFilters().length>0));return e.length===1?e[0]:pa.create(e,this._getOperator())}_apply(t){const e=this._parse(t);return e.getFilters().length===0?t:((function(r,i){let o=r;const a=i.getFlattenedFilters();for(const l of a)dK(o,l),o=J$(o,l)})(t._query,e),new hu(t.firestore,t.converter,J$(t._query,e)))}_getQueryConstraints(){return this._queryConstraints}_getOperator(){return this.type==="and"?"and":"or"}}class _S extends $S{constructor(t,e){super(),this._field=t,this._direction=e,this.type="orderBy"}static _create(t,e){return new _S(t,e)}_apply(t){const e=(function(r,i,o){if(r.startAt!==null)throw new se(Gt.INVALID_ARGUMENT,"Invalid query. You must not call startAt() or startAfter() before calling orderBy().");if(r.endAt!==null)throw new se(Gt.INVALID_ARGUMENT,"Invalid query. You must not call endAt() or endBefore() before calling orderBy().");return new Yg(i,o)})(t._query,this._field,this._direction);return new hu(t.firestore,t.converter,(function(r,i){const o=r.explicitOrderBy.concat([i]);return new qp(r.path,r.collectionGroup,o,r.filters.slice(),r.limit,r.limitType,r.startAt,r.endAt)})(t._query,e))}}function azt(n,t="asc"){const e=t,s=FN("orderBy",n);return _S._create(s,e)}class NS extends $S{constructor(t,e,s){super(),this.type=t,this._limit=e,this._limitType=s}static _create(t,e,s){return new NS(t,e,s)}_apply(t){return new hu(t.firestore,t.converter,ew(t._query,this._limit,this._limitType))}}function lzt(n){return iMt("limitToLast",n),NS._create("limitToLast",n,"L")}function EB(n,t,e){if(typeof(e=Eo(e))=="string"){if(e==="")throw new se(Gt.INVALID_ARGUMENT,"Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");if(!c9(t)&&e.indexOf("/")!==-1)throw new se(Gt.INVALID_ARGUMENT,`Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${e}' contains a '/' character.`);const s=t.path.child(qn.fromString(e));if(!ge.isDocumentKey(s))throw new se(Gt.INVALID_ARGUMENT,`Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${s}' is not because it has an odd number of segments (${s.length}).`);return Gz(n,new ge(s))}if(e instanceof or)return Gz(n,e._key);throw new se(Gt.INVALID_ARGUMENT,`Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${hS(e)}.`)}function $B(n,t){if(!Array.isArray(n)||n.length===0)throw new se(Gt.INVALID_ARGUMENT,`Invalid Query. A non-empty array is required for '${t.toString()}' filters.`)}function dK(n,t){const e=(function(r,i){for(const o of r)for(const a of o.getFlattenedFilters())if(i.indexOf(a.op)>=0)return a.op;return null})(n.filters,(function(r){switch(r){case"!=":return["!=","not-in"];case"array-contains-any":case"in":return["not-in"];case"not-in":return["array-contains-any","in","not-in","!="];default:return[]}})(t.op));if(e!==null)throw e===t.op?new se(Gt.INVALID_ARGUMENT,`Invalid query. You cannot use more than one '${t.op.toString()}' filter.`):new se(Gt.INVALID_ARGUMENT,`Invalid query. You cannot use '${t.op.toString()}' filters with '${e.toString()}' filters.`)}class pK{convertValue(t,e="none"){switch(Cc(t)){case 0:return null;case 1:return t.booleanValue;case 2:return Es(t.integerValue||t.doubleValue);case 3:return this.convertTimestamp(t.timestampValue);case 4:return this.convertServerTimestamp(t,e);case 5:return t.stringValue;case 6:return this.convertBytes(Tc(t.bytesValue));case 7:return this.convertReference(t.referenceValue);case 8:return this.convertGeoPoint(t.geoPointValue);case 9:return this.convertArray(t.arrayValue,e);case 11:return this.convertObject(t.mapValue,e);case 10:return this.convertVectorValue(t.mapValue);default:throw Ce(62114,{value:t})}}convertObject(t,e){return this.convertObjectMap(t.fields,e)}convertObjectMap(t,e="none"){const s={};return If(t,((r,i)=>{s[r]=this.convertValue(i,e)})),s}convertVectorValue(t){const e=t.fields?.[Jx].arrayValue?.values?.map((s=>Es(s.doubleValue)));return new ia(e)}convertGeoPoint(t){return new ra(Es(t.latitude),Es(t.longitude))}convertArray(t,e){return(t.values||[]).map((s=>this.convertValue(s,e)))}convertServerTimestamp(t,e){switch(e){case"previous":const s=pS(t);return s==null?null:this.convertValue(s,e);case"estimate":return this.convertTimestamp(Kg(t));default:return null}}convertTimestamp(t){const e=Ic(t);return new Hn(e.seconds,e.nanos)}convertDocumentKey(t,e){const s=qn.fromString(t);Sn(D9(s),9688,{name:t});const r=new cp(s.get(1),s.get(3)),i=new ge(s.popFirst(5));return r.isEqual(e)||nu(`Document ${i} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`),i}}function uzt(n,t,e){let s;return s=n?n.toFirestore(t):t,s}class pg{constructor(t,e){this.hasPendingWrites=t,this.fromCache=e}isEqual(t){return this.hasPendingWrites===t.hasPendingWrites&&this.fromCache===t.fromCache}}class Fh extends fK{constructor(t,e,s,r,i,o){super(t,e,s,r,o),this._firestore=t,this._firestoreImpl=t,this.metadata=i}exists(){return super.exists()}data(t={}){if(this._document){if(this._converter){const e=new Tg(this._firestore,this._userDataWriter,this._key,this._document,this.metadata,null);return this._converter.fromFirestore(e,t)}return this._userDataWriter.convertValue(this._document.data.value,t.serverTimestamps)}}get(t,e={}){if(this._document){const s=this._document.data.field(FN("DocumentSnapshot.get",t));if(s!==null)return this._userDataWriter.convertValue(s,e.serverTimestamps)}}toJSON(){if(this.metadata.hasPendingWrites)throw new se(Gt.FAILED_PRECONDITION,"DocumentSnapshot.toJSON() attempted to serialize a document with pending writes. Await waitForPendingWrites() before invoking toJSON().");const t=this._document,e={};return e.type=Fh._jsonSchemaVersion,e.bundle="",e.bundleSource="DocumentSnapshot",e.bundleName=this._key.toString(),!t||!t.isValidDocument()||!t.isFoundDocument()?e:(this._userDataWriter.convertObjectMap(t.data.value.mapValue.fields,"previous"),e.bundle=(this._firestore,this.ref.path,"NOT SUPPORTED"),e)}}Fh._jsonSchemaVersion="firestore/documentSnapshot/1.0",Fh._jsonSchema={type:Hs("string",Fh._jsonSchemaVersion),bundleSource:Hs("string","DocumentSnapshot"),bundleName:Hs("string"),bundle:Hs("string")};class Tg extends Fh{data(t={}){return super.data(t)}}class Mh{constructor(t,e,s,r){this._firestore=t,this._userDataWriter=e,this._snapshot=r,this.metadata=new pg(r.hasPendingWrites,r.fromCache),this.query=s}get docs(){const t=[];return this.forEach((e=>t.push(e))),t}get size(){return this._snapshot.docs.size}get empty(){return this.size===0}forEach(t,e){this._snapshot.docs.forEach((s=>{t.call(e,new Tg(this._firestore,this._userDataWriter,s.key,s,new pg(this._snapshot.mutatedKeys.has(s.key),this._snapshot.fromCache),this.query.converter))}))}docChanges(t={}){const e=!!t.includeMetadataChanges;if(e&&this._snapshot.excludesMetadataChanges)throw new se(Gt.INVALID_ARGUMENT,"To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");return this._cachedChanges&&this._cachedChangesIncludeMetadataChanges===e||(this._cachedChanges=(function(r,i){if(r._snapshot.oldDocs.isEmpty()){let o=0;return r._snapshot.docChanges.map((a=>{const l=new Tg(r._firestore,r._userDataWriter,a.doc.key,a.doc,new pg(r._snapshot.mutatedKeys.has(a.doc.key),r._snapshot.fromCache),r.query.converter);return a.doc,{type:"added",doc:l,oldIndex:-1,newIndex:o++}}))}{let o=r._snapshot.oldDocs;return r._snapshot.docChanges.filter((a=>i||a.type!==3)).map((a=>{const l=new Tg(r._firestore,r._userDataWriter,a.doc.key,a.doc,new pg(r._snapshot.mutatedKeys.has(a.doc.key),r._snapshot.fromCache),r.query.converter);let c=-1,f=-1;return a.type!==0&&(c=o.indexOf(a.doc.key),o=o.delete(a.doc.key)),a.type!==1&&(o=o.add(a.doc),f=o.indexOf(a.doc.key)),{type:czt(a.type),doc:l,oldIndex:c,newIndex:f}}))}})(this,e),this._cachedChangesIncludeMetadataChanges=e),this._cachedChanges}toJSON(){if(this.metadata.hasPendingWrites)throw new se(Gt.FAILED_PRECONDITION,"QuerySnapshot.toJSON() attempted to serialize a document with pending writes. Await waitForPendingWrites() before invoking toJSON().");const t={};t.type=Mh._jsonSchemaVersion,t.bundleSource="QuerySnapshot",t.bundleName=cS.newId(),this._firestore._databaseId.database,this._firestore._databaseId.projectId;const e=[],s=[],r=[];return this.docs.forEach((i=>{i._document!==null&&(e.push(i._document),s.push(this._userDataWriter.convertObjectMap(i._document.data.value.mapValue.fields,"previous")),r.push(i.ref.path))})),t.bundle=(this._firestore,this.query._query,t.bundleName,"NOT SUPPORTED"),t}}function czt(n){switch(n){case 0:return"added";case 2:case 3:return"modified";case 1:return"removed";default:return Ce(61501,{type:n})}}Mh._jsonSchemaVersion="firestore/querySnapshot/1.0",Mh._jsonSchema={type:Hs("string",Mh._jsonSchemaVersion),bundleSource:Hs("string","QuerySnapshot"),bundleName:Hs("string"),bundle:Hs("string")};class hzt extends pK{constructor(t){super(),this.firestore=t}convertBytes(t){return new Gi(t)}convertReference(t){const e=this.convertDocumentKey(t,this.firestore._databaseId);return new or(this.firestore,null,e)}}function fzt(n){n=qg(n,hu);const t=qg(n.firestore,TS),e=NN(t),s=new hzt(t);return izt(n._query),KLt(e,n._query).then((r=>new Mh(t,s,n,r)))}function mK(n,t){const e=qg(n.firestore,TS),s=rK(n),r=uzt(n.converter,t);return gK(e,[JLt(aK(n.firestore),"addDoc",s._key,r,n.converter!==null,{}).toMutation(s._key,Kl.exists(!1))]).then((()=>s))}function gK(n,t){return(function(s,r){const i=new ac;return s.asyncQueue.enqueueAndForget((async()=>OLt(await qLt(s),r,i))),i.promise})(NN(n),t)}function yK(){return new DN("serverTimestamp")}(function(t,e=!0){(function(r){Gp=r})(LFt),eu(new yl("firestore",((s,{instanceIdentifier:r,options:i})=>{const o=s.getProvider("app").getImmediate(),a=new TS(new QFt(s.getProvider("auth-internal")),new tMt(o,s.getProvider("app-check-internal")),(function(c,f){if(!Object.prototype.hasOwnProperty.apply(c.options,["projectId"]))throw new se(Gt.INVALID_ARGUMENT,'"projectId" not provided in firebase.initializeApp.');return new cp(c.options.projectId,f)})(o,r),o);return i={useFetchStreams:e,...i},a._setSettings(i),a}),"PUBLIC").setMultipleInstances(!0)),vo(_z,Nz,t),vo(_z,Nz,"esm2020")})();const dzt=Object.freeze(Object.defineProperty({__proto__:null,AbstractUserDataWriter:pK,Bytes:Gi,CollectionReference:Xl,DocumentReference:or,DocumentSnapshot:Fh,FieldPath:CS,FieldValue:ES,Firestore:TS,FirestoreError:se,GeoPoint:ra,Query:hu,QueryCompositeFilterConstraint:kS,QueryConstraint:$S,QueryDocumentSnapshot:Tg,QueryFieldFilterConstraint:AS,QueryLimitConstraint:NS,QueryOrderByConstraint:_S,QuerySnapshot:Mh,SnapshotMetadata:pg,Timestamp:Hn,VectorValue:ia,_AutoId:cS,_ByteString:wr,_DatabaseId:cp,_DocumentKey:ge,_EmptyAuthCredentialsProvider:G8,_FieldPath:yr,_cast:qg,_logWarn:nf,_validateIsNotUsedTogether:j8,addDoc:mK,collection:u2,connectFirestoreEmulator:sK,doc:rK,ensureFirestoreConfigured:NN,executeWrite:gK,getDocs:fzt,getFirestore:iK,limitToLast:lzt,orderBy:azt,query:ozt,serverTimestamp:yK},Symbol.toStringTag,{value:"Module"}));const pzt="type.googleapis.com/google.protobuf.Int64Value",mzt="type.googleapis.com/google.protobuf.UInt64Value";function bK(n,t){const e={};for(const s in n)n.hasOwnProperty(s)&&(e[s]=t(n[s]));return e}function lw(n){if(n==null)return null;if(n instanceof Number&&(n=n.valueOf()),typeof n=="number"&&isFinite(n)||n===!0||n===!1||Object.prototype.toString.call(n)==="[object String]")return n;if(n instanceof Date)return n.toISOString();if(Array.isArray(n))return n.map(t=>lw(t));if(typeof n=="function"||typeof n=="object")return bK(n,t=>lw(t));throw new Error("Data cannot be encoded in JSON: "+n)}function mp(n){if(n==null)return n;if(n["@type"])switch(n["@type"]){case pzt:case mzt:{const t=Number(n.value);if(isNaN(t))throw new Error("Data cannot be decoded from JSON: "+n);return t}default:throw new Error("Data cannot be decoded from JSON: "+n)}return Array.isArray(n)?n.map(t=>mp(t)):typeof n=="function"||typeof n=="object"?bK(n,t=>mp(t)):n}const LN="functions";const AB={OK:"ok",CANCELLED:"cancelled",UNKNOWN:"unknown",INVALID_ARGUMENT:"invalid-argument",DEADLINE_EXCEEDED:"deadline-exceeded",NOT_FOUND:"not-found",ALREADY_EXISTS:"already-exists",PERMISSION_DENIED:"permission-denied",UNAUTHENTICATED:"unauthenticated",RESOURCE_EXHAUSTED:"resource-exhausted",FAILED_PRECONDITION:"failed-precondition",ABORTED:"aborted",OUT_OF_RANGE:"out-of-range",UNIMPLEMENTED:"unimplemented",INTERNAL:"internal",UNAVAILABLE:"unavailable",DATA_LOSS:"data-loss"};class Ci extends cu{constructor(t,e,s){super(`${LN}/${t}`,e||""),this.details=s,Object.setPrototypeOf(this,Ci.prototype)}}function gzt(n){if(n>=200&&n<300)return"ok";switch(n){case 0:return"internal";case 400:return"invalid-argument";case 401:return"unauthenticated";case 403:return"permission-denied";case 404:return"not-found";case 409:return"aborted";case 429:return"resource-exhausted";case 499:return"cancelled";case 500:return"internal";case 501:return"unimplemented";case 503:return"unavailable";case 504:return"deadline-exceeded"}return"unknown"}function uw(n,t){let e=gzt(n),s=e,r;try{const i=t&&t.error;if(i){const o=i.status;if(typeof o=="string"){if(!AB[o])return new Ci("internal","internal");e=AB[o],s=o}const a=i.message;typeof a=="string"&&(s=a),r=i.details,r!==void 0&&(r=mp(r))}}catch{}return e==="ok"?null:new Ci(e,s,r)}class yzt{constructor(t,e,s,r){this.app=t,this.auth=null,this.messaging=null,this.appCheck=null,this.serverAppAppCheckToken=null,N8(t)&&t.settings.appCheckToken&&(this.serverAppAppCheckToken=t.settings.appCheckToken),this.auth=e.getImmediate({optional:!0}),this.messaging=s.getImmediate({optional:!0}),this.auth||e.get().then(i=>this.auth=i,()=>{}),this.messaging||s.get().then(i=>this.messaging=i,()=>{}),this.appCheck||r?.get().then(i=>this.appCheck=i,()=>{})}async getAuthToken(){if(this.auth)try{return(await this.auth.getToken())?.accessToken}catch{return}}async getMessagingToken(){if(!(!this.messaging||!("Notification"in self)||Notification.permission!=="granted"))try{return await this.messaging.getToken()}catch{return}}async getAppCheckToken(t){if(this.serverAppAppCheckToken)return this.serverAppAppCheckToken;if(this.appCheck){const e=t?await this.appCheck.getLimitedUseToken():await this.appCheck.getToken();return e.error?null:e.token}return null}async getContext(t){const e=await this.getAuthToken(),s=await this.getMessagingToken(),r=await this.getAppCheckToken(t);return{authToken:e,messagingToken:s,appCheckToken:r}}}const c2="us-central1",bzt=/^data: (.*?)(?:\n|$)/;function xzt(n){let t=null;return{promise:new Promise((e,s)=>{t=setTimeout(()=>{s(new Ci("deadline-exceeded","deadline-exceeded"))},n)}),cancel:()=>{t&&clearTimeout(t)}}}class wzt{constructor(t,e,s,r,i=c2,o=(...a)=>fetch(...a)){this.app=t,this.fetchImpl=o,this.emulatorOrigin=null,this.contextProvider=new yzt(t,e,s,r),this.cancelAllRequests=new Promise(a=>{this.deleteService=()=>Promise.resolve(a())});try{const a=new URL(i);this.customDomain=a.origin+(a.pathname==="/"?"":a.pathname),this.region=c2}catch{this.customDomain=null,this.region=i}}_delete(){return this.deleteService()}_url(t){const e=this.app.options.projectId;return this.emulatorOrigin!==null?`${this.emulatorOrigin}/${e}/${this.region}/${t}`:this.customDomain!==null?`${this.customDomain}/${t}`:`https://${this.region}-${e}.cloudfunctions.net/${t}`}}function vzt(n,t,e){const s=Db(t);n.emulatorOrigin=`http${s?"s":""}://${t}:${e}`,s&&(T8(n.emulatorOrigin+"/backends"),C8("Functions",!0))}function Szt(n,t,e){const s=r=>Tzt(n,t,r,{});return s.stream=(r,i)=>Ezt(n,t,r,i),s}function xK(n){return n.emulatorOrigin&&Db(n.emulatorOrigin)?"include":void 0}async function Izt(n,t,e,s,r){e["Content-Type"]="application/json";let i;try{i=await s(n,{method:"POST",body:JSON.stringify(t),headers:e,credentials:xK(r)})}catch{return{status:0,json:null}}let o=null;try{o=await i.json()}catch{}return{status:i.status,json:o}}async function wK(n,t){const e={},s=await n.contextProvider.getContext(t.limitedUseAppCheckTokens);return s.authToken&&(e.Authorization="Bearer "+s.authToken),s.messagingToken&&(e["Firebase-Instance-ID-Token"]=s.messagingToken),s.appCheckToken!==null&&(e["X-Firebase-AppCheck"]=s.appCheckToken),e}function Tzt(n,t,e,s){const r=n._url(t);return Czt(n,r,e,s)}async function Czt(n,t,e,s){e=lw(e);const r={data:e},i=await wK(n,s),o=s.timeout||7e4,a=xzt(o),l=await Promise.race([Izt(t,r,i,n.fetchImpl,n),a.promise,n.cancelAllRequests]);if(a.cancel(),!l)throw new Ci("cancelled","Firebase Functions instance was deleted.");const c=uw(l.status,l.json);if(c)throw c;if(!l.json)throw new Ci("internal","Response is not valid JSON object.");let f=l.json.data;if(typeof f>"u"&&(f=l.json.result),typeof f>"u")throw new Ci("internal","Response is missing data field.");return{data:mp(f)}}function Ezt(n,t,e,s){const r=n._url(t);return $zt(n,r,e,s||{})}async function $zt(n,t,e,s){e=lw(e);const r={data:e},i=await wK(n,s);i["Content-Type"]="application/json",i.Accept="text/event-stream";let o;try{o=await n.fetchImpl(t,{method:"POST",body:JSON.stringify(r),headers:i,signal:s?.signal,credentials:xK(n)})}catch(m){if(m instanceof Error&&m.name==="AbortError"){const b=new Ci("cancelled","Request was cancelled.");return{data:Promise.reject(b),stream:{[Symbol.asyncIterator](){return{next(){return Promise.reject(b)}}}}}}const y=uw(0,null);return{data:Promise.reject(y),stream:{[Symbol.asyncIterator](){return{next(){return Promise.reject(y)}}}}}}let a,l;const c=new Promise((m,y)=>{a=m,l=y});s?.signal?.addEventListener("abort",()=>{const m=new Ci("cancelled","Request was cancelled.");l(m)});const f=o.body.getReader(),d=Azt(f,a,l,s?.signal);return{stream:{[Symbol.asyncIterator](){const m=d.getReader();return{async next(){const{value:y,done:b}=await m.read();return{value:y,done:b}},async return(){return await m.cancel(),{done:!0,value:void 0}}}}},data:c}}function Azt(n,t,e,s){const r=(o,a)=>{const l=o.match(bzt);if(!l)return;const c=l[1];try{const f=JSON.parse(c);if("result"in f){t(mp(f.result));return}if("message"in f){a.enqueue(mp(f.message));return}if("error"in f){const d=uw(0,f);a.error(d),e(d);return}}catch(f){if(f instanceof Ci){a.error(f),e(f);return}}},i=new TextDecoder;return new ReadableStream({start(o){let a="";return l();async function l(){if(s?.aborted){const c=new Ci("cancelled","Request was cancelled");return o.error(c),e(c),Promise.resolve()}try{const{value:c,done:f}=await n.read();if(f){a.trim()&&r(a.trim(),o),o.close();return}if(s?.aborted){const m=new Ci("cancelled","Request was cancelled");o.error(m),e(m),await n.cancel();return}a+=i.decode(c,{stream:!0});const d=a.split(`
`);a=d.pop()||"";for(const m of d)m.trim()&&r(m.trim(),o);return l()}catch(c){const f=c instanceof Ci?c:uw(0,null);o.error(f),e(f)}}},cancel(){return n.cancel()}})}const kB="@firebase/functions",_B="0.13.1";const kzt="auth-internal",_zt="app-check-internal",Nzt="messaging-internal";function Rzt(n){const t=(e,{instanceIdentifier:s})=>{const r=e.getProvider("app").getImmediate(),i=e.getProvider(kzt),o=e.getProvider(Nzt),a=e.getProvider(_zt);return new wzt(r,i,o,a,s)};eu(new yl(LN,t,"PUBLIC").setMultipleInstances(!0)),vo(kB,_B,n),vo(kB,_B,"esm2020")}function Dzt(n=aN(),t=c2){const s=Up(Eo(n),LN).getImmediate({identifier:t}),r=S8("functions");return r&&Ozt(s,...r),s}function Ozt(n,t,e){vzt(Eo(n),t,e)}function Fzt(n,t,e){return Szt(Eo(n),t)}Rzt();const vK="@firebase/installations",zN="0.6.19";const SK=1e4,IK=`w:${zN}`,TK="FIS_v2",Mzt="https://firebaseinstallations.googleapis.com/v1",Lzt=3600*1e3,zzt="installations",Bzt="Installations";const Pzt={"missing-app-config-values":'Missing App configuration value: "{$valueName}"',"not-registered":"Firebase Installation is not registered.","installation-not-found":"Firebase Installation not found.","request-failed":'{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',"app-offline":"Could not process request. Application offline.","delete-pending-registration":"Can't delete installation while there is a pending registration request."},rf=new uS(zzt,Bzt,Pzt);function CK(n){return n instanceof cu&&n.code.includes("request-failed")}function EK({projectId:n}){return`${Mzt}/projects/${n}/installations`}function $K(n){return{token:n.token,requestStatus:2,expiresIn:Uzt(n.expiresIn),creationTime:Date.now()}}async function AK(n,t){const s=(await t.json()).error;return rf.create("request-failed",{requestName:n,serverCode:s.code,serverMessage:s.message,serverStatus:s.status})}function kK({apiKey:n}){return new Headers({"Content-Type":"application/json",Accept:"application/json","x-goog-api-key":n})}function Vzt(n,{refreshToken:t}){const e=kK(n);return e.append("Authorization",Gzt(t)),e}async function _K(n){const t=await n();return t.status>=500&&t.status<600?n():t}function Uzt(n){return Number(n.replace("s","000"))}function Gzt(n){return`${TK} ${n}`}async function Wzt({appConfig:n,heartbeatServiceProvider:t},{fid:e}){const s=EK(n),r=kK(n),i=t.getImmediate({optional:!0});if(i){const c=await i.getHeartbeatsHeader();c&&r.append("x-firebase-client",c)}const o={fid:e,authVersion:TK,appId:n.appId,sdkVersion:IK},a={method:"POST",headers:r,body:JSON.stringify(o)},l=await _K(()=>fetch(s,a));if(l.ok){const c=await l.json();return{fid:c.fid||e,registrationStatus:2,refreshToken:c.refreshToken,authToken:$K(c.authToken)}}else throw await AK("Create Installation",l)}function NK(n){return new Promise(t=>{setTimeout(t,n)})}function jzt(n){return btoa(String.fromCharCode(...n)).replace(/\+/g,"-").replace(/\//g,"_")}const qzt=/^[cdef][\w-]{21}$/,h2="";function Hzt(){try{const n=new Uint8Array(17);(self.crypto||self.msCrypto).getRandomValues(n),n[0]=112+n[0]%16;const e=Kzt(n);return qzt.test(e)?e:h2}catch{return h2}}function Kzt(n){return jzt(n).substr(0,22)}function RS(n){return`${n.appName}!${n.appId}`}const RK=new Map;function DK(n,t){const e=RS(n);OK(e,t),Xzt(e,t)}function OK(n,t){const e=RK.get(n);if(e)for(const s of e)s(t)}function Xzt(n,t){const e=Yzt();e&&e.postMessage({key:n,fid:t}),Qzt()}let $h=null;function Yzt(){return!$h&&"BroadcastChannel"in self&&($h=new BroadcastChannel("[Firebase] FID Change"),$h.onmessage=n=>{OK(n.data.key,n.data.fid)}),$h}function Qzt(){RK.size===0&&$h&&($h.close(),$h=null)}const Zzt="firebase-installations-database",Jzt=1,of="firebase-installations-store";let EE=null;function BN(){return EE||(EE=_8(Zzt,Jzt,{upgrade:(n,t)=>{t===0&&n.createObjectStore(of)}})),EE}async function cw(n,t){const e=RS(n),r=(await BN()).transaction(of,"readwrite"),i=r.objectStore(of),o=await i.get(e);return await i.put(t,e),await r.done,(!o||o.fid!==t.fid)&&DK(n,t.fid),t}async function FK(n){const t=RS(n),s=(await BN()).transaction(of,"readwrite");await s.objectStore(of).delete(t),await s.done}async function DS(n,t){const e=RS(n),r=(await BN()).transaction(of,"readwrite"),i=r.objectStore(of),o=await i.get(e),a=t(o);return a===void 0?await i.delete(e):await i.put(a,e),await r.done,a&&(!o||o.fid!==a.fid)&&DK(n,a.fid),a}async function PN(n){let t;const e=await DS(n.appConfig,s=>{const r=tBt(s),i=eBt(n,r);return t=i.registrationPromise,i.installationEntry});return e.fid===h2?{installationEntry:await t}:{installationEntry:e,registrationPromise:t}}function tBt(n){const t=n||{fid:Hzt(),registrationStatus:0};return MK(t)}function eBt(n,t){if(t.registrationStatus===0){if(!navigator.onLine){const r=Promise.reject(rf.create("app-offline"));return{installationEntry:t,registrationPromise:r}}const e={fid:t.fid,registrationStatus:1,registrationTime:Date.now()},s=nBt(n,e);return{installationEntry:e,registrationPromise:s}}else return t.registrationStatus===1?{installationEntry:t,registrationPromise:sBt(n)}:{installationEntry:t}}async function nBt(n,t){try{const e=await Wzt(n,t);return cw(n.appConfig,e)}catch(e){throw CK(e)&&e.customData.serverCode===409?await FK(n.appConfig):await cw(n.appConfig,{fid:t.fid,registrationStatus:0}),e}}async function sBt(n){let t=await NB(n.appConfig);for(;t.registrationStatus===1;)await NK(100),t=await NB(n.appConfig);if(t.registrationStatus===0){const{installationEntry:e,registrationPromise:s}=await PN(n);return s||e}return t}function NB(n){return DS(n,t=>{if(!t)throw rf.create("installation-not-found");return MK(t)})}function MK(n){return rBt(n)?{fid:n.fid,registrationStatus:0}:n}function rBt(n){return n.registrationStatus===1&&n.registrationTime+SK<Date.now()}async function iBt({appConfig:n,heartbeatServiceProvider:t},e){const s=oBt(n,e),r=Vzt(n,e),i=t.getImmediate({optional:!0});if(i){const c=await i.getHeartbeatsHeader();c&&r.append("x-firebase-client",c)}const o={installation:{sdkVersion:IK,appId:n.appId}},a={method:"POST",headers:r,body:JSON.stringify(o)},l=await _K(()=>fetch(s,a));if(l.ok){const c=await l.json();return $K(c)}else throw await AK("Generate Auth Token",l)}function oBt(n,{fid:t}){return`${EK(n)}/${t}/authTokens:generate`}async function VN(n,t=!1){let e;const s=await DS(n.appConfig,i=>{if(!LK(i))throw rf.create("not-registered");const o=i.authToken;if(!t&&uBt(o))return i;if(o.requestStatus===1)return e=aBt(n,t),i;{if(!navigator.onLine)throw rf.create("app-offline");const a=hBt(i);return e=lBt(n,a),a}});return e?await e:s.authToken}async function aBt(n,t){let e=await RB(n.appConfig);for(;e.authToken.requestStatus===1;)await NK(100),e=await RB(n.appConfig);const s=e.authToken;return s.requestStatus===0?VN(n,t):s}function RB(n){return DS(n,t=>{if(!LK(t))throw rf.create("not-registered");const e=t.authToken;return fBt(e)?{...t,authToken:{requestStatus:0}}:t})}async function lBt(n,t){try{const e=await iBt(n,t),s={...t,authToken:e};return await cw(n.appConfig,s),e}catch(e){if(CK(e)&&(e.customData.serverCode===401||e.customData.serverCode===404))await FK(n.appConfig);else{const s={...t,authToken:{requestStatus:0}};await cw(n.appConfig,s)}throw e}}function LK(n){return n!==void 0&&n.registrationStatus===2}function uBt(n){return n.requestStatus===2&&!cBt(n)}function cBt(n){const t=Date.now();return t<n.creationTime||n.creationTime+n.expiresIn<t+Lzt}function hBt(n){const t={requestStatus:1,requestTime:Date.now()};return{...n,authToken:t}}function fBt(n){return n.requestStatus===1&&n.requestTime+SK<Date.now()}async function dBt(n){const t=n,{installationEntry:e,registrationPromise:s}=await PN(t);return s?s.catch(console.error):VN(t).catch(console.error),e.fid}async function pBt(n,t=!1){const e=n;return await mBt(e),(await VN(e,t)).token}async function mBt(n){const{registrationPromise:t}=await PN(n);t&&await t}function gBt(n){if(!n||!n.options)throw $E("App Configuration");if(!n.name)throw $E("App Name");const t=["projectId","apiKey","appId"];for(const e of t)if(!n.options[e])throw $E(e);return{appName:n.name,projectId:n.options.projectId,apiKey:n.options.apiKey,appId:n.options.appId}}function $E(n){return rf.create("missing-app-config-values",{valueName:n})}const zK="installations",yBt="installations-internal",bBt=n=>{const t=n.getProvider("app").getImmediate(),e=gBt(t),s=Up(t,"heartbeat");return{app:t,appConfig:e,heartbeatServiceProvider:s,_delete:()=>Promise.resolve()}},xBt=n=>{const t=n.getProvider("app").getImmediate(),e=Up(t,zK).getImmediate();return{getId:()=>dBt(e),getToken:r=>pBt(e,r)}};function wBt(){eu(new yl(zK,bBt,"PUBLIC")),eu(new yl(yBt,xBt,"PRIVATE"))}wBt();vo(vK,zN);vo(vK,zN,"esm2020");const hw="analytics",vBt="firebase_id",SBt="origin",IBt=60*1e3,TBt="https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig",UN="https://www.googletagmanager.com/gtag/js";const ai=new iN("@firebase/analytics");const CBt={"already-exists":"A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.","already-initialized":"initializeAnalytics() cannot be called again with different options than those it was initially called with. It can be called again with the same options to return the existing instance, or getAnalytics() can be used to get a reference to the already-initialized instance.","already-initialized-settings":"Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.","interop-component-reg-failed":"Firebase Analytics Interop Component failed to instantiate: {$reason}","invalid-analytics-context":"Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}","indexeddb-unavailable":"IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}","fetch-throttle":"The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.","config-fetch-failed":"Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}","no-api-key":'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.',"no-app-id":'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.',"no-client-id":'The "client_id" field is empty.',"invalid-gtag-resource":"Trusted Types detected an invalid gtag resource: {$gtagURL}."},qi=new uS("analytics","Analytics",CBt);function EBt(n){if(!n.startsWith(UN)){const t=qi.create("invalid-gtag-resource",{gtagURL:n});return ai.warn(t.message),""}return n}function BK(n){return Promise.all(n.map(t=>t.catch(e=>e)))}function $Bt(n,t){let e;return window.trustedTypes&&(e=window.trustedTypes.createPolicy(n,t)),e}function ABt(n,t){const e=$Bt("firebase-js-sdk-policy",{createScriptURL:EBt}),s=document.createElement("script"),r=`${UN}?l=${n}&id=${t}`;s.src=e?e?.createScriptURL(r):r,s.async=!0,document.head.appendChild(s)}function kBt(n){let t=[];return Array.isArray(window[n])?t=window[n]:window[n]=t,t}async function _Bt(n,t,e,s,r,i){const o=s[r];try{if(o)await t[o];else{const l=(await BK(e)).find(c=>c.measurementId===r);l&&await t[l.appId]}}catch(a){ai.error(a)}n("config",r,i)}async function NBt(n,t,e,s,r){try{let i=[];if(r&&r.send_to){let o=r.send_to;Array.isArray(o)||(o=[o]);const a=await BK(e);for(const l of o){const c=a.find(d=>d.measurementId===l),f=c&&t[c.appId];if(f)i.push(f);else{i=[];break}}}i.length===0&&(i=Object.values(t)),await Promise.all(i),n("event",s,r||{})}catch(i){ai.error(i)}}function RBt(n,t,e,s){async function r(i,...o){try{if(i==="event"){const[a,l]=o;await NBt(n,t,e,a,l)}else if(i==="config"){const[a,l]=o;await _Bt(n,t,e,s,a,l)}else if(i==="consent"){const[a,l]=o;n("consent",a,l)}else if(i==="get"){const[a,l,c]=o;n("get",a,l,c)}else if(i==="set"){const[a]=o;n("set",a)}else n(i,...o)}catch(a){ai.error(a)}}return r}function DBt(n,t,e,s,r){let i=function(...o){window[s].push(arguments)};return window[r]&&typeof window[r]=="function"&&(i=window[r]),window[r]=RBt(i,n,t,e),{gtagCore:i,wrappedGtag:window[r]}}function OBt(n){const t=window.document.getElementsByTagName("script");for(const e of Object.values(t))if(e.src&&e.src.includes(UN)&&e.src.includes(n))return e;return null}const FBt=30,MBt=1e3;class LBt{constructor(t={},e=MBt){this.throttleMetadata=t,this.intervalMillis=e}getThrottleMetadata(t){return this.throttleMetadata[t]}setThrottleMetadata(t,e){this.throttleMetadata[t]=e}deleteThrottleMetadata(t){delete this.throttleMetadata[t]}}const PK=new LBt;function zBt(n){return new Headers({Accept:"application/json","x-goog-api-key":n})}async function BBt(n){const{appId:t,apiKey:e}=n,s={method:"GET",headers:zBt(e)},r=TBt.replace("{app-id}",t),i=await fetch(r,s);if(i.status!==200&&i.status!==304){let o="";try{const a=await i.json();a.error?.message&&(o=a.error.message)}catch{}throw qi.create("config-fetch-failed",{httpStatus:i.status,responseMessage:o})}return i.json()}async function PBt(n,t=PK,e){const{appId:s,apiKey:r,measurementId:i}=n.options;if(!s)throw qi.create("no-app-id");if(!r){if(i)return{measurementId:i,appId:s};throw qi.create("no-api-key")}const o=t.getThrottleMetadata(s)||{backoffCount:0,throttleEndTimeMillis:Date.now()},a=new GBt;return setTimeout(async()=>{a.abort()},IBt),VK({appId:s,apiKey:r,measurementId:i},o,a,t)}async function VK(n,{throttleEndTimeMillis:t,backoffCount:e},s,r=PK){const{appId:i,measurementId:o}=n;try{await VBt(s,t)}catch(a){if(o)return ai.warn(`Timed out fetching this Firebase app's measurement ID from the server. Falling back to the measurement ID ${o} provided in the "measurementId" field in the local Firebase config. [${a?.message}]`),{appId:i,measurementId:o};throw a}try{const a=await BBt(n);return r.deleteThrottleMetadata(i),a}catch(a){const l=a;if(!UBt(l)){if(r.deleteThrottleMetadata(i),o)return ai.warn(`Failed to fetch this Firebase app's measurement ID from the server. Falling back to the measurement ID ${o} provided in the "measurementId" field in the local Firebase config. [${l?.message}]`),{appId:i,measurementId:o};throw a}const c=Number(l?.customData?.httpStatus)===503?wz(e,r.intervalMillis,FBt):wz(e,r.intervalMillis),f={throttleEndTimeMillis:Date.now()+c,backoffCount:e+1};return r.setThrottleMetadata(i,f),ai.debug(`Calling attemptFetch again in ${c} millis`),VK(n,f,s,r)}}function VBt(n,t){return new Promise((e,s)=>{const r=Math.max(t-Date.now(),0),i=setTimeout(e,r);n.addEventListener(()=>{clearTimeout(i),s(qi.create("fetch-throttle",{throttleEndTimeMillis:t}))})})}function UBt(n){if(!(n instanceof cu)||!n.customData)return!1;const t=Number(n.customData.httpStatus);return t===429||t===500||t===503||t===504}class GBt{constructor(){this.listeners=[]}addEventListener(t){this.listeners.push(t)}abort(){this.listeners.forEach(t=>t())}}async function WBt(n,t,e,s,r){if(r&&r.global){n("event",e,s);return}else{const i=await t,o={...s,send_to:i};n("event",e,o)}}async function jBt(n,t,e,s){if(s&&s.global){const r={};for(const i of Object.keys(e))r[`user_properties.${i}`]=e[i];return n("set",r),Promise.resolve()}else{const r=await t;n("config",r,{update:!0,user_properties:e})}}async function qBt(){if(E8())try{await $8()}catch(n){return ai.warn(qi.create("indexeddb-unavailable",{errorInfo:n?.toString()}).message),!1}else return ai.warn(qi.create("indexeddb-unavailable",{errorInfo:"IndexedDB is not available in this environment."}).message),!1;return!0}async function HBt(n,t,e,s,r,i,o){const a=PBt(n);a.then(m=>{e[m.measurementId]=m.appId,n.options.measurementId&&m.measurementId!==n.options.measurementId&&ai.warn(`The measurement ID in the local Firebase config (${n.options.measurementId}) does not match the measurement ID fetched from the server (${m.measurementId}). To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.`)}).catch(m=>ai.error(m)),t.push(a);const l=qBt().then(m=>{if(m)return s.getId()}),[c,f]=await Promise.all([a,l]);OBt(i)||ABt(i,c.measurementId),r("js",new Date);const d=o?.config??{};return d[SBt]="firebase",d.update=!0,f!=null&&(d[vBt]=f),r("config",c.measurementId,d),c.measurementId}class KBt{constructor(t){this.app=t}_delete(){return delete Gd[this.app.options.appId],Promise.resolve()}}let Gd={},DB=[];const OB={};let AE="dataLayer",XBt="gtag",FB,GN,MB=!1;function YBt(){const n=[];if(_Ot()&&n.push("This is a browser extension environment."),ROt()||n.push("Cookies are not available."),n.length>0){const t=n.map((s,r)=>`(${r+1}) ${s}`).join(" "),e=qi.create("invalid-analytics-context",{errorInfo:t});ai.warn(e.message)}}function QBt(n,t,e){YBt();const s=n.options.appId;if(!s)throw qi.create("no-app-id");if(!n.options.apiKey)if(n.options.measurementId)ai.warn(`The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest measurement ID for this Firebase app. Falling back to the measurement ID ${n.options.measurementId} provided in the "measurementId" field in the local Firebase config.`);else throw qi.create("no-api-key");if(Gd[s]!=null)throw qi.create("already-exists",{id:s});if(!MB){kBt(AE);const{wrappedGtag:i,gtagCore:o}=DBt(Gd,DB,OB,AE,XBt);GN=i,FB=o,MB=!0}return Gd[s]=HBt(n,DB,OB,t,FB,AE,e),new KBt(n)}function ZBt(n=aN()){n=Eo(n);const t=Up(n,hw);return t.isInitialized()?t.getImmediate():JBt(n)}function JBt(n,t={}){const e=Up(n,hw);if(e.isInitialized()){const r=e.getImmediate();if(Wg(t,e.getOptions()))return r;throw qi.create("already-initialized")}return e.initialize({options:t})}function tPt(n,t,e){n=Eo(n),jBt(GN,Gd[n.app.options.appId],t,e).catch(s=>ai.error(s))}function ePt(n,t,e,s){n=Eo(n),WBt(GN,Gd[n.app.options.appId],t,e,s).catch(r=>ai.error(r))}const LB="@firebase/analytics",zB="0.10.19";function nPt(){eu(new yl(hw,(t,{options:e})=>{const s=t.getProvider("app").getImmediate(),r=t.getProvider("installations-internal").getImmediate();return QBt(s,r,e)},"PUBLIC")),eu(new yl("analytics-internal",n,"PRIVATE")),vo(LB,zB),vo(LB,zB,"esm2020");function n(t){try{const e=t.getProvider(hw).getImmediate();return{logEvent:(s,r,i)=>ePt(e,s,r,i),setUserProperties:(s,r)=>tPt(e,s,r)}}catch(e){throw qi.create("interop-component-reg-failed",{reason:e})}}}nPt();const sPt={apiKey:"AIzaSyAOp34gqvNaWAB-VHdBXum3xsqIfMy9daY",authDomain:"orionteamoutliers.firebaseapp.com",projectId:"orionteamoutliers",storageBucket:"orionteamoutliers.firebasestorage.app",messagingSenderId:"661127440342",appId:"1:661127440342:web:284ba13bfc226ee3b82677",measurementId:"G-P1S2Q7VQQG"};class rPt{constructor(){this.app=null,this.db=null,this.functions=null,this.analytics=null,this.isConfigured=!1,this.lastAlertTime=0,this.ALERT_COOLDOWN=3e4,this.recipientEmail="",this.recipientName="Security Team",this.useDefaultConfig=!0}configure(t){try{const e=t.useDefault?sPt:{apiKey:t.apiKey,authDomain:t.authDomain,projectId:t.projectId,storageBucket:t.storageBucket,messagingSenderId:t.messagingSenderId,appId:t.appId};this.app=R8(e),this.db=iK(this.app),this.functions=Dzt(this.app);try{this.analytics=ZBt(this.app)}catch{console.log("Analytics not available (normal for localhost)")}return this.recipientEmail=t.recipientEmail||"",this.recipientName=t.recipientName||"Security Team",this.useDefaultConfig=t.useDefault||!1,this.isConfigured=!0,console.log("Firebase alerts configured successfully"),!0}catch(e){return console.error("Failed to configure Firebase:",e),!1}}async sendThreatAlert(t){if(!this.isConfigured)return console.warn("Firebase alerts not configured"),{success:!1,error:"Not configured"};const e=Date.now();if(e-this.lastAlertTime<this.ALERT_COOLDOWN)return console.log("Alert cooldown active, skipping notification"),{success:!1,error:"Cooldown active"};try{const s={type:t.type,confidence:t.confidence,severity:t.severity,direction:t.direction,distance:t.distance,timestamp:yK(),recipientEmail:this.recipientEmail,recipientName:this.recipientName,notificationSent:!1},r=await mK(u2(this.db,"threats"),s);console.log("Threat stored in Firestore:",r.id);try{const o=await Fzt(this.functions,"sendThreatEmail")({threatId:r.id,...s,timestamp:new Date().toISOString()});return console.log("Email notification sent:",o.data),this.lastAlertTime=e,{success:!0,threatId:r.id,emailSent:!0}}catch(i){return console.warn("Email notification failed, but threat stored:",i),this.lastAlertTime=e,{success:!0,threatId:r.id,emailSent:!1,emailError:i.message}}}catch(s){return console.error("Failed to send threat alert:",s),{success:!1,error:s.message}}}async getRecentThreats(t=10){if(!this.isConfigured||!this.db)return[];try{const{query:e,orderBy:s,getDocs:r,limitToLast:i}=await dOt(async()=>{const{query:f,orderBy:d,getDocs:m,limitToLast:y}=await Promise.resolve().then(()=>dzt);return{query:f,orderBy:d,getDocs:m,limitToLast:y}},void 0),o=u2(this.db,"threats"),a=e(o,s("timestamp","desc"),i(t)),l=await r(a),c=[];return l.forEach(f=>{c.push({id:f.id,...f.data()})}),c}catch(e){return console.error("Failed to fetch recent threats:",e),[]}}formatThreatType(t){return t.replace(/([A-Z])/g," $1").trim().toUpperCase()}isReady(){return this.isConfigured}getConfig(){return{isConfigured:this.isConfigured,recipientEmail:this.recipientEmail,recipientName:this.recipientName,useDefaultConfig:this.useDefaultConfig}}}function iPt(){const[n,t]=Vr.useState(null),[e,s]=Vr.useState(null),[r,i]=Vr.useState(!1),[o,a]=Vr.useState(0),[l,c]=Vr.useState(null),[f,d]=Vr.useState([]),[m,y]=Vr.useState(!1),[b,w]=Vr.useState(!1),[x,S]=Vr.useState({useDefault:!0,apiKey:"",authDomain:"",projectId:"",storageBucket:"",messagingSenderId:"",appId:"",recipientEmail:"",recipientName:"Security Team"}),[T,$]=Vr.useState(!1),E=Vr.useRef(null),R=Vr.useRef(null);Vr.useEffect(()=>{const P=async()=>{const tt=new cOt;await tt.initialize()&&(t(tt),y(!0))},L=new rPt;return s(L),P(),()=>{n&&n.dispose()}},[]),Vr.useEffect(()=>{if(r&&n){const P=setInterval(()=>{const L=n.getAudioLevel();a(L)},50);return()=>clearInterval(P)}},[r,n]),Vr.useEffect(()=>{r?_():R.current&&cancelAnimationFrame(R.current)},[r,l,f]);const B=async()=>{if(n)if(r)n.stopListening(),i(!1),c(null);else try{await n.startListening(async P=>{c(P),d(L=>[P,...L].slice(0,10)),T&&e&&e.isReady()&&(await e.sendThreatAlert(P)).success&&console.log("Email alert sent successfully"),setTimeout(()=>{c(null)},3e3)}),i(!0)}catch{alert("Microphone access is required for SonicGuard to work")}},N=()=>{e&&(e.configure(x),$(!0),w(!1),alert("Email alerts configured successfully!"))},k=(P,L)=>{S(tt=>({...tt,[P]:L}))},_=()=>{const P=E.current;if(!P)return;const L=P.getContext("2d"),tt=P.width,st=P.height,j=tt/2,Z=st/2,J=Math.min(tt,st)/2-20;L.fillStyle="#0a0e1a",L.fillRect(0,0,tt,st),L.strokeStyle="rgba(0, 255, 255, 0.2)",L.lineWidth=1;for(let ot=1;ot<=4;ot++)L.beginPath(),L.arc(j,Z,J/4*ot,0,Math.PI*2),L.stroke();if(L.strokeStyle="rgba(0, 255, 255, 0.3)",L.beginPath(),L.moveTo(j,Z-J),L.lineTo(j,Z+J),L.moveTo(j-J,Z),L.lineTo(j+J,Z),L.stroke(),L.fillStyle="rgba(0, 255, 255, 0.5)",L.font='12px "Courier New"',L.textAlign="center",L.fillText("N",j,Z-J-5),L.fillText("S",j,Z+J+15),L.fillText("E",j+J+15,Z+5),L.fillText("W",j-J-15,Z+5),r){const ot=o/100*J*.3,pt=L.createRadialGradient(j,Z,0,j,Z,ot);pt.addColorStop(0,"rgba(0, 255, 255, 0.3)"),pt.addColorStop(1,"rgba(0, 255, 255, 0)"),L.fillStyle=pt,L.beginPath(),L.arc(j,Z,ot,0,Math.PI*2),L.fill()}if(l){const ot=l.direction*Math.PI/180,pt=(50-l.distance)/50*J,q=j+Math.cos(ot-Math.PI/2)*pt,et=Z+Math.sin(ot-Math.PI/2)*pt,U=F(l.severity);L.fillStyle=U,L.shadowBlur=20,L.shadowColor=U,L.beginPath(),L.arc(q,et,8,0,Math.PI*2),L.fill(),L.shadowBlur=0,L.strokeStyle=U,L.lineWidth=2,L.setLineDash([5,5]),L.beginPath(),L.moveTo(j,Z),L.lineTo(q,et),L.stroke(),L.setLineDash([]),L.fillStyle=U,L.font='bold 11px "Courier New"',L.textAlign="center",L.fillText(A(l.type),q,et-15)}f.slice(1).forEach((ot,pt)=>{const q=pt+1,et=Math.max(0,1-q/10),U=ot.direction*Math.PI/180,X=(50-ot.distance)/50*J,nt=j+Math.cos(U-Math.PI/2)*X,xt=Z+Math.sin(U-Math.PI/2)*X,Ot=F(ot.severity);L.fillStyle=Ot.replace(")",`, ${et})`).replace("rgb","rgba"),L.beginPath(),L.arc(nt,xt,4,0,Math.PI*2),L.fill()}),R.current=requestAnimationFrame(_)},F=P=>{switch(P){case"critical":return"#ff0000";case"high":return"#ff6600";case"medium":return"#ffaa00";case"low":return"#44ff88";default:return"#00ffff"}},A=P=>P.replace(/([A-Z])/g," $1").trim().toUpperCase();return Pt.jsxs("div",{className:"container",children:[Pt.jsxs("div",{className:"header",children:[Pt.jsx("h1",{className:"title",children:"SonicGuard"}),Pt.jsx("p",{className:"subtitle",children:"AI-Powered Audio Threat Intelligence  360 Sound Awareness"})]}),Pt.jsxs("div",{className:"grid",children:[Pt.jsx("div",{children:Pt.jsxs("div",{className:"card",children:[Pt.jsxs("div",{className:"radar-container",children:[Pt.jsx("canvas",{ref:E,width:500,height:500,className:"radar-canvas"}),!r&&Pt.jsx("div",{className:"radar-overlay",children:Pt.jsx("div",{className:"radar-overlay-text",children:"Click START to begin monitoring"})})]}),Pt.jsx("div",{className:"button-container",children:Pt.jsx("button",{onClick:B,disabled:!m,className:`button ${r?"button-stop":"button-start"}`,children:m?r?"STOP MONITORING":"START MONITORING":"INITIALIZING..."})}),r&&Pt.jsxs("div",{className:"audio-level-container",children:[Pt.jsx("div",{className:"stat-label",children:"Audio Level"}),Pt.jsx("div",{className:"audio-level-bar",children:Pt.jsx("div",{className:"audio-level-fill",style:{width:`${o}%`}})})]}),Pt.jsx("div",{className:"email-alert-section",children:Pt.jsx("button",{onClick:()=>w(!0),className:"button button-email",children:T?" Email Alerts Active":" Configure Email Alerts"})})]})}),Pt.jsxs("div",{children:[l&&Pt.jsxs("div",{className:"panel threat-alert",children:[Pt.jsx("h3",{className:"panel-title",style:{color:F(l.severity)},children:" THREAT DETECTED"}),Pt.jsxs("div",{style:{marginBottom:"1.5rem"},children:[Pt.jsx("div",{className:"stat-label",children:"Threat Type"}),Pt.jsx("div",{className:"stat-value-large",style:{color:F(l.severity)},children:A(l.type)})]}),Pt.jsxs("div",{className:"threat-grid",children:[Pt.jsxs("div",{children:[Pt.jsx("div",{className:"stat-label",children:"Confidence"}),Pt.jsxs("div",{className:"stat-value",children:[l.confidence.toFixed(1),"%"]})]}),Pt.jsxs("div",{children:[Pt.jsx("div",{className:"stat-label",children:"Severity"}),Pt.jsx("div",{className:"stat-value",style:{color:F(l.severity)},children:l.severity.toUpperCase()})]})]}),Pt.jsxs("div",{className:"threat-grid",children:[Pt.jsxs("div",{children:[Pt.jsx("div",{className:"stat-label",children:"Direction"}),Pt.jsxs("div",{className:"stat-value",children:[l.direction,""]})]}),Pt.jsxs("div",{children:[Pt.jsx("div",{className:"stat-label",children:"Distance"}),Pt.jsxs("div",{className:"stat-value",children:["~",l.distance,"m"]})]})]})]}),Pt.jsxs("div",{className:"panel",children:[Pt.jsx("h3",{className:"panel-title",children:"Detection Capabilities"}),Pt.jsxs("ul",{className:"info-list",children:[Pt.jsx("li",{children:" Gunshots & Explosions"}),Pt.jsx("li",{children:" Screams & Distress Calls"}),Pt.jsx("li",{children:" Glass Breaking"}),Pt.jsx("li",{children:" Alarm Systems"}),Pt.jsx("li",{children:" Aggressive Voices"}),Pt.jsx("li",{children:" Car Crashes"}),Pt.jsx("li",{children:" Aggressive Dog Barks"}),Pt.jsx("li",{children:" Spatial Audio Mapping"})]})]}),f.length>0&&Pt.jsxs("div",{className:"panel",children:[Pt.jsx("h3",{className:"panel-title",children:"Recent Threats"}),Pt.jsx("div",{className:"threat-history",children:f.slice(0,5).map((P,L)=>Pt.jsxs("div",{className:"threat-history-item",children:[Pt.jsx("div",{className:"threat-history-dot",style:{backgroundColor:F(P.severity)}}),Pt.jsxs("div",{className:"threat-history-content",children:[Pt.jsx("div",{className:"threat-history-type",children:A(P.type)}),Pt.jsxs("div",{className:"threat-history-meta",children:[P.confidence.toFixed(0),"%  ",P.direction,"  ",P.distance,"m"]})]})]},L))})]}),Pt.jsxs("div",{className:"panel",children:[Pt.jsx("h3",{className:"panel-title",children:"How It Works"}),Pt.jsxs("ul",{className:"info-list",children:[Pt.jsx("li",{children:" Real-time audio frequency analysis"}),Pt.jsx("li",{children:" AI-powered sound classification"}),Pt.jsx("li",{children:" Spectral pattern matching"}),Pt.jsx("li",{children:" Spatial audio estimation"}),Pt.jsx("li",{children:" Sub-100ms threat detection"}),Pt.jsx("li",{children:" 100% privacy (local processing)"})]})]})]})]}),b&&Pt.jsx("div",{className:"modal-overlay",onClick:()=>w(!1),children:Pt.jsxs("div",{className:"modal",onClick:P=>P.stopPropagation(),children:[Pt.jsx("h2",{className:"modal-title",children:"Configure Firebase Alerts"}),Pt.jsx("p",{className:"modal-subtitle",children:"Get instant email notifications and cloud storage when threats are detected"}),Pt.jsxs("div",{className:"form-group checkbox-group",children:[Pt.jsxs("label",{className:"checkbox-label",children:[Pt.jsx("input",{type:"checkbox",checked:x.useDefault,onChange:P=>k("useDefault",P.target.checked)}),"Use Default Configuration (OrionTeamOutliers)"]}),Pt.jsx("p",{className:"field-hint",children:"Use the pre-configured Firebase project for immediate testing."})]}),!x.useDefault&&Pt.jsxs(Pt.Fragment,{children:[Pt.jsxs("div",{className:"form-group",children:[Pt.jsx("label",{className:"form-label",children:"Firebase API Key"}),Pt.jsx("input",{type:"text",className:"form-input",value:x.apiKey,onChange:P=>k("apiKey",P.target.value),placeholder:"AIzaSy..."})]}),Pt.jsxs("div",{className:"form-group",children:[Pt.jsx("label",{className:"form-label",children:"Auth Domain"}),Pt.jsx("input",{type:"text",className:"form-input",value:x.authDomain,onChange:P=>k("authDomain",P.target.value),placeholder:"your-project.firebaseapp.com"})]}),Pt.jsxs("div",{className:"form-group",children:[Pt.jsx("label",{className:"form-label",children:"Project ID"}),Pt.jsx("input",{type:"text",className:"form-input",value:x.projectId,onChange:P=>k("projectId",P.target.value),placeholder:"your-project-id"})]}),Pt.jsxs("div",{className:"form-group",children:[Pt.jsx("label",{className:"form-label",children:"Storage Bucket"}),Pt.jsx("input",{type:"text",className:"form-input",value:x.storageBucket,onChange:P=>k("storageBucket",P.target.value),placeholder:"your-project.appspot.com"})]}),Pt.jsxs("div",{className:"form-group",children:[Pt.jsx("label",{className:"form-label",children:"Messaging Sender ID"}),Pt.jsx("input",{type:"text",className:"form-input",value:x.messagingSenderId,onChange:P=>k("messagingSenderId",P.target.value),placeholder:"123456789"})]}),Pt.jsxs("div",{className:"form-group",children:[Pt.jsx("label",{className:"form-label",children:"App ID"}),Pt.jsx("input",{type:"text",className:"form-input",value:x.appId,onChange:P=>k("appId",P.target.value),placeholder:"1:123456789:web:abc123"})]})]}),Pt.jsxs("div",{className:"form-group",children:[Pt.jsx("label",{className:"form-label",children:"Recipient Email"}),Pt.jsx("input",{type:"email",className:"form-input",value:x.recipientEmail,onChange:P=>k("recipientEmail",P.target.value),placeholder:"security@example.com"})]}),Pt.jsxs("div",{className:"form-group",children:[Pt.jsx("label",{className:"form-label",children:"Recipient Name"}),Pt.jsx("input",{type:"text",className:"form-input",value:x.recipientName,onChange:P=>k("recipientName",P.target.value),placeholder:"Security Team"})]}),Pt.jsxs("div",{className:"modal-info",children:[Pt.jsxs("p",{children:[" ",Pt.jsx("strong",{children:"Setup Instructions:"})]}),x.useDefault?Pt.jsxs("ol",{children:[Pt.jsxs("li",{children:["Values are pre-configured for the ",Pt.jsx("strong",{children:"OrionTeamOutliers"})," project."]}),Pt.jsx("li",{children:"Just enter your email address to receive alerts."}),Pt.jsx("li",{children:'Click "Save & Enable Alerts" to start.'})]}):Pt.jsxs("ol",{children:[Pt.jsxs("li",{children:["Create a Firebase project at ",Pt.jsx("a",{href:"https://console.firebase.google.com/",target:"_blank",rel:"noopener noreferrer",children:"Firebase Console"})]}),Pt.jsx("li",{children:"Enable Firestore Database and Cloud Functions"}),Pt.jsx("li",{children:"Go to Project Settings  General  Your apps"}),Pt.jsx("li",{children:"Copy your Firebase configuration values"}),Pt.jsx("li",{children:"Paste them above and click Save"})]})]}),Pt.jsxs("div",{className:"modal-actions",children:[Pt.jsx("button",{onClick:()=>w(!1),className:"button button-secondary",children:"Cancel"}),Pt.jsx("button",{onClick:N,className:"button button-start",disabled:!x.useDefault&&(!x.apiKey||!x.projectId||!x.appId)||!x.recipientEmail,children:"Save & Enable Alerts"})]})]})})]})}OX.createRoot(document.getElementById("root")).render(Pt.jsx(Vr.StrictMode,{children:Pt.jsx(iPt,{})}));
